 /***************************************************************************\
|*                                                                           *|
|*      Copyright 2005-2010 NVIDIA Corporation.  All rights reserved.        *|
|*                                                                           *|     
|*   THE SOFTWARE AND INFORMATION CONTAINED HEREIN IS PROPRIETARY AND        *|
|*   CONFIDENTIAL TO NVIDIA CORPORATION. THIS SOFTWARE IS FOR INTERNAL USE   *|
|*   ONLY AND ANY REPRODUCTION OR DISCLOSURE TO ANY PARTY OUTSIDE OF NVIDIA  *|
|*   IS STRICTLY PROHIBITED.                                                 *|
|*                                                                           *|
 \***************************************************************************/
///////////////////////////////////////////////////////////////////////////////
//
// Date: Jun 17, 2015 
// File: nvapi.h
//
// NvAPI provides an interface to NVIDIA devices. This file contains the 
// interface constants, structure definitions and function prototypes.
//
//   Target Profile: nvsdk
//  Target Platform: windows
//
///////////////////////////////////////////////////////////////////////////////
#ifndef _NVAPI_H
#define _NVAPI_H

#pragma pack(push,8) // Make sure we have consistent structure packings

#ifdef __cplusplus
extern "C" {
#endif
// ====================================================
// Universal NvAPI Definitions
// ====================================================
#ifndef _WIN32
#define __cdecl
#endif

// ====================================================
// SAL related support
// ====================================================

#ifndef __ecount
    #define __nvapi_undef__ecount
    #define __ecount(size)
#endif
#ifndef __bcount
    #define __nvapi_undef__bcount
    #define __bcount(size)
#endif
#ifndef __in
    #define __nvapi_undef__in
    #define __in
#endif
#ifndef __in_ecount
    #define __nvapi_undef__in_ecount
    #define __in_ecount(size)
#endif
#ifndef __in_bcount
    #define __nvapi_undef__in_bcount
    #define __in_bcount(size)
#endif
#ifndef __in_z
    #define __nvapi_undef__in_z
    #define __in_z
#endif
#ifndef __in_ecount_z
    #define __nvapi_undef__in_ecount_z
    #define __in_ecount_z(size)
#endif
#ifndef __in_bcount_z
    #define __nvapi_undef__in_bcount_z
    #define __in_bcount_z(size)
#endif
#ifndef __in_nz
    #define __nvapi_undef__in_nz
    #define __in_nz
#endif
#ifndef __in_ecount_nz
    #define __nvapi_undef__in_ecount_nz
    #define __in_ecount_nz(size)
#endif
#ifndef __in_bcount_nz
    #define __nvapi_undef__in_bcount_nz
    #define __in_bcount_nz(size)
#endif
#ifndef __out
    #define __nvapi_undef__out
    #define __out
#endif
#ifndef __out_ecount
    #define __nvapi_undef__out_ecount
    #define __out_ecount(size)
#endif
#ifndef __out_bcount
    #define __nvapi_undef__out_bcount
    #define __out_bcount(size)
#endif
#ifndef __out_ecount_part
    #define __nvapi_undef__out_ecount_part
    #define __out_ecount_part(size,length)
#endif
#ifndef __out_bcount_part
    #define __nvapi_undef__out_bcount_part
    #define __out_bcount_part(size,length)
#endif
#ifndef __out_ecount_full
    #define __nvapi_undef__out_ecount_full
    #define __out_ecount_full(size)
#endif
#ifndef __out_bcount_full
    #define __nvapi_undef__out_bcount_full
    #define __out_bcount_full(size)
#endif
#ifndef __out_z
    #define __nvapi_undef__out_z
    #define __out_z
#endif
#ifndef __out_z_opt
    #define __nvapi_undef__out_z_opt
    #define __out_z_opt
#endif
#ifndef __out_ecount_z
    #define __nvapi_undef__out_ecount_z
    #define __out_ecount_z(size)
#endif
#ifndef __out_bcount_z
    #define __nvapi_undef__out_bcount_z
    #define __out_bcount_z(size)
#endif
#ifndef __out_ecount_part_z
    #define __nvapi_undef__out_ecount_part_z
    #define __out_ecount_part_z(size,length)
#endif
#ifndef __out_bcount_part_z
    #define __nvapi_undef__out_bcount_part_z
    #define __out_bcount_part_z(size,length)
#endif
#ifndef __out_ecount_full_z
    #define __nvapi_undef__out_ecount_full_z
    #define __out_ecount_full_z(size)
#endif
#ifndef __out_bcount_full_z
    #define __nvapi_undef__out_bcount_full_z
    #define __out_bcount_full_z(size)
#endif
#ifndef __out_nz
    #define __nvapi_undef__out_nz
    #define __out_nz
#endif
#ifndef __out_nz_opt
    #define __nvapi_undef__out_nz_opt
    #define __out_nz_opt
#endif
#ifndef __out_ecount_nz
    #define __nvapi_undef__out_ecount_nz
    #define __out_ecount_nz(size)
#endif
#ifndef __out_bcount_nz
    #define __nvapi_undef__out_bcount_nz
    #define __out_bcount_nz(size)
#endif
#ifndef __inout
    #define __nvapi_undef__inout
    #define __inout
#endif
#ifndef __inout_ecount
    #define __nvapi_undef__inout_ecount
    #define __inout_ecount(size)
#endif
#ifndef __inout_bcount
    #define __nvapi_undef__inout_bcount
    #define __inout_bcount(size)
#endif
#ifndef __inout_ecount_part
    #define __nvapi_undef__inout_ecount_part
    #define __inout_ecount_part(size,length)
#endif
#ifndef __inout_bcount_part
    #define __nvapi_undef__inout_bcount_part
    #define __inout_bcount_part(size,length)
#endif
#ifndef __inout_ecount_full
    #define __nvapi_undef__inout_ecount_full
    #define __inout_ecount_full(size)
#endif
#ifndef __inout_bcount_full
    #define __nvapi_undef__inout_bcount_full
    #define __inout_bcount_full(size)
#endif
#ifndef __inout_z
    #define __nvapi_undef__inout_z
    #define __inout_z
#endif
#ifndef __inout_ecount_z
    #define __nvapi_undef__inout_ecount_z
    #define __inout_ecount_z(size)
#endif
#ifndef __inout_bcount_z
    #define __nvapi_undef__inout_bcount_z
    #define __inout_bcount_z(size)
#endif
#ifndef __inout_nz
    #define __nvapi_undef__inout_nz
    #define __inout_nz
#endif
#ifndef __inout_ecount_nz
    #define __nvapi_undef__inout_ecount_nz
    #define __inout_ecount_nz(size)
#endif
#ifndef __inout_bcount_nz
    #define __nvapi_undef__inout_bcount_nz
    #define __inout_bcount_nz(size)
#endif
#ifndef __ecount_opt
    #define __nvapi_undef__ecount_opt
    #define __ecount_opt(size)
#endif
#ifndef __bcount_opt
    #define __nvapi_undef__bcount_opt
    #define __bcount_opt(size)
#endif
#ifndef __in_opt
    #define __nvapi_undef__in_opt
    #define __in_opt
#endif
#ifndef __in_ecount_opt
    #define __nvapi_undef__in_ecount_opt
    #define __in_ecount_opt(size)
#endif
#ifndef __in_bcount_opt
    #define __nvapi_undef__in_bcount_opt
    #define __in_bcount_opt(size)
#endif
#ifndef __in_z_opt
    #define __nvapi_undef__in_z_opt
    #define __in_z_opt
#endif
#ifndef __in_ecount_z_opt
    #define __nvapi_undef__in_ecount_z_opt
    #define __in_ecount_z_opt(size)
#endif
#ifndef __in_bcount_z_opt
    #define __nvapi_undef__in_bcount_z_opt
    #define __in_bcount_z_opt(size)
#endif
#ifndef __in_nz_opt
    #define __nvapi_undef__in_nz_opt
    #define __in_nz_opt
#endif
#ifndef __in_ecount_nz_opt
    #define __nvapi_undef__in_ecount_nz_opt
    #define __in_ecount_nz_opt(size)
#endif
#ifndef __in_bcount_nz_opt
    #define __nvapi_undef__in_bcount_nz_opt
    #define __in_bcount_nz_opt(size)
#endif
#ifndef __out_opt
    #define __nvapi_undef__out_opt
    #define __out_opt
#endif
#ifndef __out_ecount_opt
    #define __nvapi_undef__out_ecount_opt
    #define __out_ecount_opt(size)
#endif
#ifndef __out_bcount_opt
    #define __nvapi_undef__out_bcount_opt
    #define __out_bcount_opt(size)
#endif
#ifndef __out_ecount_part_opt
    #define __nvapi_undef__out_ecount_part_opt
    #define __out_ecount_part_opt(size,length)
#endif
#ifndef __out_bcount_part_opt
    #define __nvapi_undef__out_bcount_part_opt
    #define __out_bcount_part_opt(size,length)
#endif
#ifndef __out_ecount_full_opt
    #define __nvapi_undef__out_ecount_full_opt
    #define __out_ecount_full_opt(size)
#endif
#ifndef __out_bcount_full_opt
    #define __nvapi_undef__out_bcount_full_opt
    #define __out_bcount_full_opt(size)
#endif
#ifndef __out_ecount_z_opt
    #define __nvapi_undef__out_ecount_z_opt
    #define __out_ecount_z_opt(size)
#endif
#ifndef __out_bcount_z_opt
    #define __nvapi_undef__out_bcount_z_opt
    #define __out_bcount_z_opt(size)
#endif
#ifndef __out_ecount_part_z_opt
    #define __nvapi_undef__out_ecount_part_z_opt
    #define __out_ecount_part_z_opt(size,length)
#endif
#ifndef __out_bcount_part_z_opt
    #define __nvapi_undef__out_bcount_part_z_opt
    #define __out_bcount_part_z_opt(size,length)
#endif
#ifndef __out_ecount_full_z_opt
    #define __nvapi_undef__out_ecount_full_z_opt
    #define __out_ecount_full_z_opt(size)
#endif
#ifndef __out_bcount_full_z_opt
    #define __nvapi_undef__out_bcount_full_z_opt
    #define __out_bcount_full_z_opt(size)
#endif
#ifndef __out_ecount_nz_opt
    #define __nvapi_undef__out_ecount_nz_opt
    #define __out_ecount_nz_opt(size)
#endif
#ifndef __out_bcount_nz_opt
    #define __nvapi_undef__out_bcount_nz_opt
    #define __out_bcount_nz_opt(size)
#endif
#ifndef __inout_opt
    #define __nvapi_undef__inout_opt
    #define __inout_opt
#endif
#ifndef __inout_ecount_opt
    #define __nvapi_undef__inout_ecount_opt
    #define __inout_ecount_opt(size)
#endif
#ifndef __inout_bcount_opt
    #define __nvapi_undef__inout_bcount_opt
    #define __inout_bcount_opt(size)
#endif
#ifndef __inout_ecount_part_opt
    #define __nvapi_undef__inout_ecount_part_opt
    #define __inout_ecount_part_opt(size,length)
#endif
#ifndef __inout_bcount_part_opt
    #define __nvapi_undef__inout_bcount_part_opt
    #define __inout_bcount_part_opt(size,length)
#endif
#ifndef __inout_ecount_full_opt
    #define __nvapi_undef__inout_ecount_full_opt
    #define __inout_ecount_full_opt(size)
#endif
#ifndef __inout_bcount_full_opt
    #define __nvapi_undef__inout_bcount_full_opt
    #define __inout_bcount_full_opt(size)
#endif
#ifndef __inout_z_opt
    #define __nvapi_undef__inout_z_opt
    #define __inout_z_opt
#endif
#ifndef __inout_ecount_z_opt
    #define __nvapi_undef__inout_ecount_z_opt
    #define __inout_ecount_z_opt(size)
#endif
#ifndef __inout_ecount_z_opt
    #define __nvapi_undef__inout_ecount_z_opt
    #define __inout_ecount_z_opt(size)
#endif
#ifndef __inout_bcount_z_opt
    #define __nvapi_undef__inout_bcount_z_opt
    #define __inout_bcount_z_opt(size)
#endif
#ifndef __inout_nz_opt
    #define __nvapi_undef__inout_nz_opt
    #define __inout_nz_opt
#endif
#ifndef __inout_ecount_nz_opt
    #define __nvapi_undef__inout_ecount_nz_opt
    #define __inout_ecount_nz_opt(size)
#endif
#ifndef __inout_bcount_nz_opt
    #define __nvapi_undef__inout_bcount_nz_opt
    #define __inout_bcount_nz_opt(size)
#endif
#ifndef __deref_ecount
    #define __nvapi_undef__deref_ecount
    #define __deref_ecount(size)
#endif
#ifndef __deref_bcount
    #define __nvapi_undef__deref_bcount
    #define __deref_bcount(size)
#endif
#ifndef __deref_out
    #define __nvapi_undef__deref_out
    #define __deref_out
#endif
#ifndef __deref_out_ecount
    #define __nvapi_undef__deref_out_ecount
    #define __deref_out_ecount(size)
#endif
#ifndef __deref_out_bcount
    #define __nvapi_undef__deref_out_bcount
    #define __deref_out_bcount(size)
#endif
#ifndef __deref_out_ecount_part
    #define __nvapi_undef__deref_out_ecount_part
    #define __deref_out_ecount_part(size,length)
#endif
#ifndef __deref_out_bcount_part
    #define __nvapi_undef__deref_out_bcount_part
    #define __deref_out_bcount_part(size,length)
#endif
#ifndef __deref_out_ecount_full
    #define __nvapi_undef__deref_out_ecount_full
    #define __deref_out_ecount_full(size)
#endif
#ifndef __deref_out_bcount_full
    #define __nvapi_undef__deref_out_bcount_full
    #define __deref_out_bcount_full(size)
#endif
#ifndef __deref_out_z
    #define __nvapi_undef__deref_out_z
    #define __deref_out_z
#endif
#ifndef __deref_out_ecount_z
    #define __nvapi_undef__deref_out_ecount_z
    #define __deref_out_ecount_z(size)
#endif
#ifndef __deref_out_bcount_z
    #define __nvapi_undef__deref_out_bcount_z
    #define __deref_out_bcount_z(size)
#endif
#ifndef __deref_out_nz
    #define __nvapi_undef__deref_out_nz
    #define __deref_out_nz
#endif
#ifndef __deref_out_ecount_nz
    #define __nvapi_undef__deref_out_ecount_nz
    #define __deref_out_ecount_nz(size)
#endif
#ifndef __deref_out_bcount_nz
    #define __nvapi_undef__deref_out_bcount_nz
    #define __deref_out_bcount_nz(size)
#endif
#ifndef __deref_inout
    #define __nvapi_undef__deref_inout
    #define __deref_inout
#endif
#ifndef __deref_inout_z
    #define __nvapi_undef__deref_inout_z
    #define __deref_inout_z
#endif
#ifndef __deref_inout_ecount
    #define __nvapi_undef__deref_inout_ecount
    #define __deref_inout_ecount(size)
#endif
#ifndef __deref_inout_bcount
    #define __nvapi_undef__deref_inout_bcount
    #define __deref_inout_bcount(size)
#endif
#ifndef __deref_inout_ecount_part
    #define __nvapi_undef__deref_inout_ecount_part
    #define __deref_inout_ecount_part(size,length)
#endif
#ifndef __deref_inout_bcount_part
    #define __nvapi_undef__deref_inout_bcount_part
    #define __deref_inout_bcount_part(size,length)
#endif
#ifndef __deref_inout_ecount_full
    #define __nvapi_undef__deref_inout_ecount_full
    #define __deref_inout_ecount_full(size)
#endif
#ifndef __deref_inout_bcount_full
    #define __nvapi_undef__deref_inout_bcount_full
    #define __deref_inout_bcount_full(size)
#endif
#ifndef __deref_inout_z
    #define __nvapi_undef__deref_inout_z
    #define __deref_inout_z
#endif
#ifndef __deref_inout_ecount_z
    #define __nvapi_undef__deref_inout_ecount_z
    #define __deref_inout_ecount_z(size)
#endif
#ifndef __deref_inout_bcount_z
    #define __nvapi_undef__deref_inout_bcount_z
    #define __deref_inout_bcount_z(size)
#endif
#ifndef __deref_inout_nz
    #define __nvapi_undef__deref_inout_nz
    #define __deref_inout_nz
#endif
#ifndef __deref_inout_ecount_nz
    #define __nvapi_undef__deref_inout_ecount_nz
    #define __deref_inout_ecount_nz(size)
#endif
#ifndef __deref_inout_bcount_nz
    #define __nvapi_undef__deref_inout_bcount_nz
    #define __deref_inout_bcount_nz(size)
#endif
#ifndef __deref_ecount_opt
    #define __nvapi_undef__deref_ecount_opt
    #define __deref_ecount_opt(size)
#endif
#ifndef __deref_bcount_opt
    #define __nvapi_undef__deref_bcount_opt
    #define __deref_bcount_opt(size)
#endif
#ifndef __deref_out_opt
    #define __nvapi_undef__deref_out_opt
    #define __deref_out_opt
#endif
#ifndef __deref_out_ecount_opt
    #define __nvapi_undef__deref_out_ecount_opt
    #define __deref_out_ecount_opt(size)
#endif
#ifndef __deref_out_bcount_opt
    #define __nvapi_undef__deref_out_bcount_opt
    #define __deref_out_bcount_opt(size)
#endif
#ifndef __deref_out_ecount_part_opt
    #define __nvapi_undef__deref_out_ecount_part_opt
    #define __deref_out_ecount_part_opt(size,length)
#endif
#ifndef __deref_out_bcount_part_opt
    #define __nvapi_undef__deref_out_bcount_part_opt
    #define __deref_out_bcount_part_opt(size,length)
#endif
#ifndef __deref_out_ecount_full_opt
    #define __nvapi_undef__deref_out_ecount_full_opt
    #define __deref_out_ecount_full_opt(size)
#endif
#ifndef __deref_out_bcount_full_opt
    #define __nvapi_undef__deref_out_bcount_full_opt
    #define __deref_out_bcount_full_opt(size)
#endif
#ifndef __deref_out_z_opt
    #define __nvapi_undef__deref_out_z_opt
    #define __deref_out_z_opt
#endif
#ifndef __deref_out_ecount_z_opt
    #define __nvapi_undef__deref_out_ecount_z_opt
    #define __deref_out_ecount_z_opt(size)
#endif
#ifndef __deref_out_bcount_z_opt
    #define __nvapi_undef__deref_out_bcount_z_opt
    #define __deref_out_bcount_z_opt(size)
#endif
#ifndef __deref_out_nz_opt
    #define __nvapi_undef__deref_out_nz_opt
    #define __deref_out_nz_opt
#endif
#ifndef __deref_out_ecount_nz_opt
    #define __nvapi_undef__deref_out_ecount_nz_opt
    #define __deref_out_ecount_nz_opt(size)
#endif
#ifndef __deref_out_bcount_nz_opt
    #define __nvapi_undef__deref_out_bcount_nz_opt
    #define __deref_out_bcount_nz_opt(size)
#endif
#ifndef __deref_inout_opt
    #define __nvapi_undef__deref_inout_opt
    #define __deref_inout_opt
#endif
#ifndef __deref_inout_ecount_opt
    #define __nvapi_undef__deref_inout_ecount_opt
    #define __deref_inout_ecount_opt(size)
#endif
#ifndef __deref_inout_bcount_opt
    #define __nvapi_undef__deref_inout_bcount_opt
    #define __deref_inout_bcount_opt(size)
#endif
#ifndef __deref_inout_ecount_part_opt
    #define __nvapi_undef__deref_inout_ecount_part_opt
    #define __deref_inout_ecount_part_opt(size,length)
#endif
#ifndef __deref_inout_bcount_part_opt
    #define __nvapi_undef__deref_inout_bcount_part_opt
    #define __deref_inout_bcount_part_opt(size,length)
#endif
#ifndef __deref_inout_ecount_full_opt
    #define __nvapi_undef__deref_inout_ecount_full_opt
    #define __deref_inout_ecount_full_opt(size)
#endif
#ifndef __deref_inout_bcount_full_opt
    #define __nvapi_undef__deref_inout_bcount_full_opt
    #define __deref_inout_bcount_full_opt(size)
#endif
#ifndef __deref_inout_z_opt
    #define __nvapi_undef__deref_inout_z_opt
    #define __deref_inout_z_opt
#endif
#ifndef __deref_inout_ecount_z_opt
    #define __nvapi_undef__deref_inout_ecount_z_opt
    #define __deref_inout_ecount_z_opt(size)
#endif
#ifndef __deref_inout_bcount_z_opt
    #define __nvapi_undef__deref_inout_bcount_z_opt
    #define __deref_inout_bcount_z_opt(size)
#endif
#ifndef __deref_inout_nz_opt
    #define __nvapi_undef__deref_inout_nz_opt
    #define __deref_inout_nz_opt
#endif
#ifndef __deref_inout_ecount_nz_opt
    #define __nvapi_undef__deref_inout_ecount_nz_opt
    #define __deref_inout_ecount_nz_opt(size)
#endif
#ifndef __deref_inout_bcount_nz_opt
    #define __nvapi_undef__deref_inout_bcount_nz_opt
    #define __deref_inout_bcount_nz_opt(size)
#endif
#ifndef __deref_opt_ecount
    #define __nvapi_undef__deref_opt_ecount
    #define __deref_opt_ecount(size)
#endif
#ifndef __deref_opt_bcount
    #define __nvapi_undef__deref_opt_bcount
    #define __deref_opt_bcount(size)
#endif
#ifndef __deref_opt_out
    #define __nvapi_undef__deref_opt_out
    #define __deref_opt_out
#endif
#ifndef __deref_opt_out_z
    #define __nvapi_undef__deref_opt_out_z
    #define __deref_opt_out_z
#endif
#ifndef __deref_opt_out_ecount
    #define __nvapi_undef__deref_opt_out_ecount
    #define __deref_opt_out_ecount(size)
#endif
#ifndef __deref_opt_out_bcount
    #define __nvapi_undef__deref_opt_out_bcount
    #define __deref_opt_out_bcount(size)
#endif
#ifndef __deref_opt_out_ecount_part
    #define __nvapi_undef__deref_opt_out_ecount_part
    #define __deref_opt_out_ecount_part(size,length)
#endif
#ifndef __deref_opt_out_bcount_part
    #define __nvapi_undef__deref_opt_out_bcount_part
    #define __deref_opt_out_bcount_part(size,length)
#endif
#ifndef __deref_opt_out_ecount_full
    #define __nvapi_undef__deref_opt_out_ecount_full
    #define __deref_opt_out_ecount_full(size)
#endif
#ifndef __deref_opt_out_bcount_full
    #define __nvapi_undef__deref_opt_out_bcount_full
    #define __deref_opt_out_bcount_full(size)
#endif
#ifndef __deref_opt_inout
    #define __nvapi_undef__deref_opt_inout
    #define __deref_opt_inout
#endif
#ifndef __deref_opt_inout_ecount
    #define __nvapi_undef__deref_opt_inout_ecount
    #define __deref_opt_inout_ecount(size)
#endif
#ifndef __deref_opt_inout_bcount
    #define __nvapi_undef__deref_opt_inout_bcount
    #define __deref_opt_inout_bcount(size)
#endif
#ifndef __deref_opt_inout_ecount_part
    #define __nvapi_undef__deref_opt_inout_ecount_part
    #define __deref_opt_inout_ecount_part(size,length)
#endif
#ifndef __deref_opt_inout_bcount_part
    #define __nvapi_undef__deref_opt_inout_bcount_part
    #define __deref_opt_inout_bcount_part(size,length)
#endif
#ifndef __deref_opt_inout_ecount_full
    #define __nvapi_undef__deref_opt_inout_ecount_full
    #define __deref_opt_inout_ecount_full(size)
#endif
#ifndef __deref_opt_inout_bcount_full
    #define __nvapi_undef__deref_opt_inout_bcount_full
    #define __deref_opt_inout_bcount_full(size)
#endif
#ifndef __deref_opt_inout_z
    #define __nvapi_undef__deref_opt_inout_z
    #define __deref_opt_inout_z
#endif
#ifndef __deref_opt_inout_ecount_z
    #define __nvapi_undef__deref_opt_inout_ecount_z
    #define __deref_opt_inout_ecount_z(size)
#endif
#ifndef __deref_opt_inout_bcount_z
    #define __nvapi_undef__deref_opt_inout_bcount_z
    #define __deref_opt_inout_bcount_z(size)
#endif
#ifndef __deref_opt_inout_nz
    #define __nvapi_undef__deref_opt_inout_nz
    #define __deref_opt_inout_nz
#endif
#ifndef __deref_opt_inout_ecount_nz
    #define __nvapi_undef__deref_opt_inout_ecount_nz
    #define __deref_opt_inout_ecount_nz(size)
#endif
#ifndef __deref_opt_inout_bcount_nz
    #define __nvapi_undef__deref_opt_inout_bcount_nz
    #define __deref_opt_inout_bcount_nz(size)
#endif
#ifndef __deref_opt_ecount_opt
    #define __nvapi_undef__deref_opt_ecount_opt
    #define __deref_opt_ecount_opt(size)
#endif
#ifndef __deref_opt_bcount_opt
    #define __nvapi_undef__deref_opt_bcount_opt
    #define __deref_opt_bcount_opt(size)
#endif
#ifndef __deref_opt_out_opt
    #define __nvapi_undef__deref_opt_out_opt
    #define __deref_opt_out_opt
#endif
#ifndef __deref_opt_out_ecount_opt
    #define __nvapi_undef__deref_opt_out_ecount_opt
    #define __deref_opt_out_ecount_opt(size)
#endif
#ifndef __deref_opt_out_bcount_opt
    #define __nvapi_undef__deref_opt_out_bcount_opt
    #define __deref_opt_out_bcount_opt(size)
#endif
#ifndef __deref_opt_out_ecount_part_opt
    #define __nvapi_undef__deref_opt_out_ecount_part_opt
    #define __deref_opt_out_ecount_part_opt(size,length)
#endif
#ifndef __deref_opt_out_bcount_part_opt
    #define __nvapi_undef__deref_opt_out_bcount_part_opt
    #define __deref_opt_out_bcount_part_opt(size,length)
#endif
#ifndef __deref_opt_out_ecount_full_opt
    #define __nvapi_undef__deref_opt_out_ecount_full_opt
    #define __deref_opt_out_ecount_full_opt(size)
#endif
#ifndef __deref_opt_out_bcount_full_opt
    #define __nvapi_undef__deref_opt_out_bcount_full_opt
    #define __deref_opt_out_bcount_full_opt(size)
#endif
#ifndef __deref_opt_out_z_opt
    #define __nvapi_undef__deref_opt_out_z_opt
    #define __deref_opt_out_z_opt
#endif
#ifndef __deref_opt_out_ecount_z_opt
    #define __nvapi_undef__deref_opt_out_ecount_z_opt
    #define __deref_opt_out_ecount_z_opt(size)
#endif
#ifndef __deref_opt_out_bcount_z_opt
    #define __nvapi_undef__deref_opt_out_bcount_z_opt
    #define __deref_opt_out_bcount_z_opt(size)
#endif
#ifndef __deref_opt_out_nz_opt
    #define __nvapi_undef__deref_opt_out_nz_opt
    #define __deref_opt_out_nz_opt
#endif
#ifndef __deref_opt_out_ecount_nz_opt
    #define __nvapi_undef__deref_opt_out_ecount_nz_opt
    #define __deref_opt_out_ecount_nz_opt(size)
#endif
#ifndef __deref_opt_out_bcount_nz_opt
    #define __nvapi_undef__deref_opt_out_bcount_nz_opt
    #define __deref_opt_out_bcount_nz_opt(size)
#endif
#ifndef __deref_opt_inout_opt
    #define __nvapi_undef__deref_opt_inout_opt
    #define __deref_opt_inout_opt
#endif
#ifndef __deref_opt_inout_ecount_opt
    #define __nvapi_undef__deref_opt_inout_ecount_opt
    #define __deref_opt_inout_ecount_opt(size)
#endif
#ifndef __deref_opt_inout_bcount_opt
    #define __nvapi_undef__deref_opt_inout_bcount_opt
    #define __deref_opt_inout_bcount_opt(size)
#endif
#ifndef __deref_opt_inout_ecount_part_opt
    #define __nvapi_undef__deref_opt_inout_ecount_part_opt
    #define __deref_opt_inout_ecount_part_opt(size,length)
#endif
#ifndef __deref_opt_inout_bcount_part_opt
    #define __nvapi_undef__deref_opt_inout_bcount_part_opt
    #define __deref_opt_inout_bcount_part_opt(size,length)
#endif
#ifndef __deref_opt_inout_ecount_full_opt
    #define __nvapi_undef__deref_opt_inout_ecount_full_opt
    #define __deref_opt_inout_ecount_full_opt(size)
#endif
#ifndef __deref_opt_inout_bcount_full_opt
    #define __nvapi_undef__deref_opt_inout_bcount_full_opt
    #define __deref_opt_inout_bcount_full_opt(size)
#endif
#ifndef __deref_opt_inout_z_opt
    #define __nvapi_undef__deref_opt_inout_z_opt
    #define __deref_opt_inout_z_opt
#endif
#ifndef __deref_opt_inout_ecount_z_opt
    #define __nvapi_undef__deref_opt_inout_ecount_z_opt
    #define __deref_opt_inout_ecount_z_opt(size)
#endif
#ifndef __deref_opt_inout_bcount_z_opt
    #define __nvapi_undef__deref_opt_inout_bcount_z_opt
    #define __deref_opt_inout_bcount_z_opt(size)
#endif
#ifndef __deref_opt_inout_nz_opt
    #define __nvapi_undef__deref_opt_inout_nz_opt
    #define __deref_opt_inout_nz_opt
#endif
#ifndef __deref_opt_inout_ecount_nz_opt
    #define __nvapi_undef__deref_opt_inout_ecount_nz_opt
    #define __deref_opt_inout_ecount_nz_opt(size)
#endif
#ifndef __deref_opt_inout_bcount_nz_opt
    #define __nvapi_undef__deref_opt_inout_bcount_nz_opt
    #define __deref_opt_inout_bcount_nz_opt(size)
#endif
#ifndef __success
    #define __nvapi_success
    #define __success(epxr)
#endif
#ifndef _Ret_notnull_
    #define __nvapi__Ret_notnull_
    #define _Ret_notnull_
#endif
#ifndef _Post_writable_byte_size_
    #define __nvapi__Post_writable_byte_size_
    #define _Post_writable_byte_size_(n)
#endif
#ifndef _Outptr_ 
    #define __nvapi_Outptr_ 
    #define _Outptr_ 
#endif


#define NVAPI_INTERFACE extern __success(return == NVAPI_OK) NvAPI_Status __cdecl

#if (defined(WIN32) || defined(_WIN32)) && defined(_MSC_VER) && (_MSC_VER > 1399) && !defined(NVAPI_INTERNAL) && !defined(NVAPI_DEPRECATED_OLD)
#ifndef __nvapi_deprecated_function
#define __nvapi_deprecated_function(message) __declspec(deprecated(message))
#endif
#ifndef __nvapi_deprecated_datatype
#define __nvapi_deprecated_datatype(FirstRelease) __declspec(deprecated("Do not use this data type - it is deprecated in release " #FirstRelease "."))
#endif
#else
#ifndef __nvapi_deprecated_function
#define __nvapi_deprecated_function(message)
#endif
#ifndef __nvapi_deprecated_datatype
#define __nvapi_deprecated_datatype(FirstRelease)
#endif
#endif


/* 64-bit types for compilers that support them, plus some obsolete variants */
#if defined(__GNUC__) || defined(__arm) || defined(__IAR_SYSTEMS_ICC__) || defined(__ghs__) || defined(_WIN64)
typedef unsigned long long NvU64; /* 0 to 18446744073709551615  */
typedef long long          NvS64; /* -9223372036854775808 to 9223372036854775807  */
#else
typedef unsigned __int64   NvU64; /* 0 to 18446744073709551615  */
typedef __int64            NvS64; /* -9223372036854775808 to 9223372036854775807  */
#endif

// mac os 32-bit still needs this
#if (defined(macintosh) || defined(__APPLE__)) && !defined(__LP64__)
typedef signed long        NvS32; /* -2147483648 to 2147483647  */   
#else
typedef signed int         NvS32; /* -2147483648 to 2147483647 */  
#endif

// mac os 32-bit still needs this
#if ( (defined(macintosh) && defined(__LP64__) && (__NVAPI_RESERVED0__)) || \
      (!defined(macintosh) && defined(__NVAPI_RESERVED0__)) ) 
typedef unsigned int       NvU32; /* 0 to 4294967295                         */
#else
typedef unsigned long      NvU32; /* 0 to 4294967295                         */
#endif

typedef signed   short   NvS16;
typedef unsigned short   NvU16;
typedef unsigned char    NvU8;
typedef signed   char    NvS8;

typedef struct _NV_RECT
{
    NvU32    left;
    NvU32    top;
    NvU32    right;
    NvU32    bottom;
} NV_RECT;



#define NV_DECLARE_HANDLE(name) struct name##__ { int unused; }; typedef struct name##__ *name

//! \addtogroup nvapihandles
//! NVAPI Handles - These handles are retrieved from various calls and passed in to others in NvAPI
//!                 These are meant to be opaque types.  Do not assume they correspond to indices, HDCs,
//!                 display indexes or anything else.
//!
//!                 Most handles remain valid until a display re-configuration (display mode set) or GPU
//!                 reconfiguration (going into or out of SLI modes) occurs.  If NVAPI_HANDLE_INVALIDATED
//!                 is received by an app, it should discard all handles, and re-enumerate them.
//! @{  
NV_DECLARE_HANDLE(NvDisplayHandle);                //!< Display Device driven by NVIDIA GPU(s) (an attached display)
NV_DECLARE_HANDLE(NvMonitorHandle);                //!< Monitor handle
NV_DECLARE_HANDLE(NvUnAttachedDisplayHandle);      //!< Unattached Display Device driven by NVIDIA GPU(s)
NV_DECLARE_HANDLE(NvLogicalGpuHandle);             //!< One or more physical GPUs acting in concert (SLI)
NV_DECLARE_HANDLE(NvPhysicalGpuHandle);            //!< A single physical GPU
NV_DECLARE_HANDLE(NvEventHandle);                  //!< A handle to an event registration instance
NV_DECLARE_HANDLE(NvVisualComputingDeviceHandle);  //!< A handle to a Visual Computing Device
NV_DECLARE_HANDLE(NvHICHandle);                    //!< A handle to a Host Interface Card
NV_DECLARE_HANDLE(NvGSyncDeviceHandle);            //!< A handle to a Sync device
NV_DECLARE_HANDLE(NvVioHandle);                    //!< A handle to an SDI device
NV_DECLARE_HANDLE(NvTransitionHandle);             //!< A handle to address a single transition request
NV_DECLARE_HANDLE(NvAudioHandle);                  //!< NVIDIA HD Audio Device
NV_DECLARE_HANDLE(Nv3DVPContextHandle);            //!< A handle for a 3D Vision Pro (3DVP) context
NV_DECLARE_HANDLE(Nv3DVPTransceiverHandle);        //!< A handle for a 3DVP RF transceiver
NV_DECLARE_HANDLE(Nv3DVPGlassesHandle);            //!< A handle for a pair of 3DVP RF shutter glasses

typedef void* StereoHandle;                        //!< A stereo handle, that corresponds to the device interface

NV_DECLARE_HANDLE(NvSourceHandle);                 //!< Unique source handle on the system
NV_DECLARE_HANDLE(NvTargetHandle);                 //!< Unique target handle on the system
NV_DECLARE_HANDLE(NVDX_SwapChainHandle);           //!< DirectX SwapChain objects
static const NVDX_SwapChainHandle NVDX_SWAPCHAIN_NONE = 0;
//! @}

//! \ingroup nvapihandles
//! @{
#define NVAPI_DEFAULT_HANDLE        0
#define NV_BIT(x)    (1 << (x)) 
//! @}


//! \ingroup nvapihandles
#define NVAPI_COPROC_DISPLAY_HANDLE  ((NvDisplayHandle) 0xde800001)       //!< Display handle + special handle (0x00800000) + index 1




//! \addtogroup nvapitypes
//! @{
#define NVAPI_GENERIC_STRING_MAX    4096
#define NVAPI_LONG_STRING_MAX       256
#define NVAPI_SHORT_STRING_MAX      64


typedef struct 
{
    NvS32   sX;
    NvS32   sY;
    NvS32   sWidth;
    NvS32   sHeight;
} NvSBox;

#ifndef NvGUID_Defined
#define NvGUID_Defined

typedef struct
{
    NvU32 data1;
    NvU16 data2;
    NvU16 data3;
    NvU8  data4[8];
} NvGUID, NvLUID;

#endif //#ifndef NvGUID_Defined


#define NVAPI_MAX_PHYSICAL_GPUS             64
#define NVAPI_MAX_PHYSICAL_BRIDGES          100
#define NVAPI_PHYSICAL_GPUS                 32
#define NVAPI_MAX_LOGICAL_GPUS              64
#define NVAPI_MAX_AVAILABLE_GPU_TOPOLOGIES  256
#define NVAPI_MAX_AVAILABLE_SLI_GROUPS      256
#define NVAPI_MAX_GPU_TOPOLOGIES            NVAPI_MAX_PHYSICAL_GPUS
#define NVAPI_MAX_GPU_PER_TOPOLOGY          8
#define NVAPI_MAX_DISPLAY_HEADS             2
#define NVAPI_ADVANCED_DISPLAY_HEADS        4
#define NVAPI_MAX_DISPLAYS                  NVAPI_PHYSICAL_GPUS * NVAPI_ADVANCED_DISPLAY_HEADS
#define NVAPI_MAX_ACPI_IDS                  16
#define NVAPI_MAX_VIEW_MODES                8
#define NV_MAX_HEADS                        4   //!< Maximum heads, each with NVAPI_DESKTOP_RES resolution
#define NVAPI_MAX_HEADS_PER_GPU             32

#define NV_MAX_HEADS        4   //!< Maximum number of heads, each with #NVAPI_DESKTOP_RES resolution
#define NV_MAX_VID_STREAMS  4   //!< Maximum number of input video streams, each with a #NVAPI_VIDEO_SRC_INFO
#define NV_MAX_VID_PROFILES 4   //!< Maximum number of output video profiles supported

#define NVAPI_SYSTEM_MAX_DISPLAYS           NVAPI_MAX_PHYSICAL_GPUS * NV_MAX_HEADS

#define NVAPI_SYSTEM_MAX_HWBCS              128
#define NVAPI_SYSTEM_HWBC_INVALID_ID        0xffffffff
#define NVAPI_MAX_AUDIO_DEVICES             16


typedef char NvAPI_String[NVAPI_GENERIC_STRING_MAX];
typedef char NvAPI_LongString[NVAPI_LONG_STRING_MAX];
typedef char NvAPI_ShortString[NVAPI_SHORT_STRING_MAX];
//! @}


// =========================================================================================
//!  NvAPI Version Definition \n
//!  Maintain per structure specific version define using the MAKE_NVAPI_VERSION macro. \n
//!  Usage: #define NV_GENLOCK_STATUS_VER  MAKE_NVAPI_VERSION(NV_GENLOCK_STATUS, 1)
//!  \ingroup nvapitypes
// =========================================================================================
#define MAKE_NVAPI_VERSION(typeName,ver) (NvU32)(sizeof(typeName) | ((ver)<<16))

//!  \ingroup nvapitypes
#define GET_NVAPI_VERSION(ver) (NvU32)((ver)>>16)

//!  \ingroup nvapitypes
#define GET_NVAPI_SIZE(ver) (NvU32)((ver) & 0xffff)


// ====================================================
//! NvAPI Status Values
//!   All NvAPI functions return one of these codes.
//!   \ingroup nvapistatus 
// ====================================================


typedef enum _NvAPI_Status
{
    NVAPI_OK                                    =  0,      //!< Success. Request is completed.
    NVAPI_ERROR                                 = -1,      //!< Generic error
    NVAPI_LIBRARY_NOT_FOUND                     = -2,      //!< NVAPI support library cannot be loaded.
    NVAPI_NO_IMPLEMENTATION                     = -3,      //!< not implemented in current driver installation
    NVAPI_API_NOT_INITIALIZED                   = -4,      //!< NvAPI_Initialize has not been called (successfully)
    NVAPI_INVALID_ARGUMENT                      = -5,      //!< The argument/parameter value is not valid or NULL.
    NVAPI_NVIDIA_DEVICE_NOT_FOUND               = -6,      //!< No NVIDIA display driver, or NVIDIA GPU driving a display, was found.
    NVAPI_END_ENUMERATION                       = -7,      //!< No more items to enumerate
    NVAPI_INVALID_HANDLE                        = -8,      //!< Invalid handle
    NVAPI_INCOMPATIBLE_STRUCT_VERSION           = -9,      //!< An argument's structure version is not supported
    NVAPI_HANDLE_INVALIDATED                    = -10,     //!< The handle is no longer valid (likely due to GPU or display re-configuration)
    NVAPI_OPENGL_CONTEXT_NOT_CURRENT            = -11,     //!< No NVIDIA OpenGL context is current (but needs to be)
    NVAPI_INVALID_POINTER                       = -14,     //!< An invalid pointer, usually NULL, was passed as a parameter
    NVAPI_NO_GL_EXPERT                          = -12,     //!< OpenGL Expert is not supported by the current drivers
    NVAPI_INSTRUMENTATION_DISABLED              = -13,     //!< OpenGL Expert is supported, but driver instrumentation is currently disabled
    NVAPI_NO_GL_NSIGHT                          = -15,     //!< OpenGL does not support Nsight

    NVAPI_EXPECTED_LOGICAL_GPU_HANDLE           = -100,    //!< Expected a logical GPU handle for one or more parameters
    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE          = -101,    //!< Expected a physical GPU handle for one or more parameters
    NVAPI_EXPECTED_DISPLAY_HANDLE               = -102,    //!< Expected an NV display handle for one or more parameters
    NVAPI_INVALID_COMBINATION                   = -103,    //!< The combination of parameters is not valid. 
    NVAPI_NOT_SUPPORTED                         = -104,    //!< Requested feature is not supported in the selected GPU
    NVAPI_PORTID_NOT_FOUND                      = -105,    //!< No port ID was found for the I2C transaction
    NVAPI_EXPECTED_UNATTACHED_DISPLAY_HANDLE    = -106,    //!< Expected an unattached display handle as one of the input parameters.
    NVAPI_INVALID_PERF_LEVEL                    = -107,    //!< Invalid perf level 
    NVAPI_DEVICE_BUSY                           = -108,    //!< Device is busy; request not fulfilled
    NVAPI_NV_PERSIST_FILE_NOT_FOUND             = -109,    //!< NV persist file is not found
    NVAPI_PERSIST_DATA_NOT_FOUND                = -110,    //!< NV persist data is not found
    NVAPI_EXPECTED_TV_DISPLAY                   = -111,    //!< Expected a TV output display
    NVAPI_EXPECTED_TV_DISPLAY_ON_DCONNECTOR     = -112,    //!< Expected a TV output on the D Connector - HDTV_EIAJ4120.
    NVAPI_NO_ACTIVE_SLI_TOPOLOGY                = -113,    //!< SLI is not active on this device.
    NVAPI_SLI_RENDERING_MODE_NOTALLOWED         = -114,    //!< Setup of SLI rendering mode is not possible right now.
    NVAPI_EXPECTED_DIGITAL_FLAT_PANEL           = -115,    //!< Expected a digital flat panel.
    NVAPI_ARGUMENT_EXCEED_MAX_SIZE              = -116,    //!< Argument exceeds the expected size.
    NVAPI_DEVICE_SWITCHING_NOT_ALLOWED          = -117,    //!< Inhibit is ON due to one of the flags in NV_GPU_DISPLAY_CHANGE_INHIBIT or SLI active.
    NVAPI_TESTING_CLOCKS_NOT_SUPPORTED          = -118,    //!< Testing of clocks is not supported.
    NVAPI_UNKNOWN_UNDERSCAN_CONFIG              = -119,    //!< The specified underscan config is from an unknown source (e.g. INF)
    NVAPI_TIMEOUT_RECONFIGURING_GPU_TOPO        = -120,    //!< Timeout while reconfiguring GPUs
    NVAPI_DATA_NOT_FOUND                        = -121,    //!< Requested data was not found
    NVAPI_EXPECTED_ANALOG_DISPLAY               = -122,    //!< Expected an analog display
    NVAPI_NO_VIDLINK                            = -123,    //!< No SLI video bridge is present
    NVAPI_REQUIRES_REBOOT                       = -124,    //!< NVAPI requires a reboot for the settings to take effect
    NVAPI_INVALID_HYBRID_MODE                   = -125,    //!< The function is not supported with the current Hybrid mode.
    NVAPI_MIXED_TARGET_TYPES                    = -126,    //!< The target types are not all the same
    NVAPI_SYSWOW64_NOT_SUPPORTED                = -127,    //!< The function is not supported from 32-bit on a 64-bit system.
    NVAPI_IMPLICIT_SET_GPU_TOPOLOGY_CHANGE_NOT_ALLOWED = -128,    //!< There is no implicit GPU topology active. Use NVAPI_SetHybridMode to change topology.
    NVAPI_REQUEST_USER_TO_CLOSE_NON_MIGRATABLE_APPS = -129,      //!< Prompt the user to close all non-migratable applications.    
    NVAPI_OUT_OF_MEMORY                         = -130,    //!< Could not allocate sufficient memory to complete the call.
    NVAPI_WAS_STILL_DRAWING                     = -131,    //!< The previous operation that is transferring information to or from this surface is incomplete.
    NVAPI_FILE_NOT_FOUND                        = -132,    //!< The file was not found.
    NVAPI_TOO_MANY_UNIQUE_STATE_OBJECTS         = -133,    //!< There are too many unique instances of a particular type of state object.
    NVAPI_INVALID_CALL                          = -134,    //!< The method call is invalid. For example, a method's parameter may not be a valid pointer.
    NVAPI_D3D10_1_LIBRARY_NOT_FOUND             = -135,    //!< d3d10_1.dll cannot be loaded.
    NVAPI_FUNCTION_NOT_FOUND                    = -136,    //!< Couldn't find the function in the loaded DLL.
    NVAPI_INVALID_USER_PRIVILEGE                = -137,    //!< Current User is not Admin.
    NVAPI_EXPECTED_NON_PRIMARY_DISPLAY_HANDLE   = -138,    //!< The handle corresponds to GDIPrimary.
    NVAPI_EXPECTED_COMPUTE_GPU_HANDLE           = -139,    //!< Setting Physx GPU requires that the GPU is compute-capable.
    NVAPI_STEREO_NOT_INITIALIZED                = -140,    //!< The Stereo part of NVAPI failed to initialize completely. Check if the stereo driver is installed.
    NVAPI_STEREO_REGISTRY_ACCESS_FAILED         = -141,    //!< Access to stereo-related registry keys or values has failed.
    NVAPI_STEREO_REGISTRY_PROFILE_TYPE_NOT_SUPPORTED = -142, //!< The given registry profile type is not supported.
    NVAPI_STEREO_REGISTRY_VALUE_NOT_SUPPORTED   = -143,    //!< The given registry value is not supported.
    NVAPI_STEREO_NOT_ENABLED                    = -144,    //!< Stereo is not enabled and the function needed it to execute completely.
    NVAPI_STEREO_NOT_TURNED_ON                  = -145,    //!< Stereo is not turned on and the function needed it to execute completely.
    NVAPI_STEREO_INVALID_DEVICE_INTERFACE       = -146,    //!< Invalid device interface.
    NVAPI_STEREO_PARAMETER_OUT_OF_RANGE         = -147,    //!< Separation percentage or JPEG image capture quality is out of [0-100] range.
    NVAPI_STEREO_FRUSTUM_ADJUST_MODE_NOT_SUPPORTED = -148, //!< The given frustum adjust mode is not supported.
    NVAPI_TOPO_NOT_POSSIBLE                     = -149,    //!< The mosaic topology is not possible given the current state of the hardware.
    NVAPI_MODE_CHANGE_FAILED                    = -150,    //!< An attempt to do a display resolution mode change has failed.        
    NVAPI_D3D11_LIBRARY_NOT_FOUND               = -151,    //!< d3d11.dll/d3d11_beta.dll cannot be loaded.
    NVAPI_INVALID_ADDRESS                       = -152,    //!< Address is outside of valid range.
    NVAPI_STRING_TOO_SMALL                      = -153,    //!< The pre-allocated string is too small to hold the result.
    NVAPI_MATCHING_DEVICE_NOT_FOUND             = -154,    //!< The input does not match any of the available devices.
    NVAPI_DRIVER_RUNNING                        = -155,    //!< Driver is running.
    NVAPI_DRIVER_NOTRUNNING                     = -156,    //!< Driver is not running.
    NVAPI_ERROR_DRIVER_RELOAD_REQUIRED          = -157,    //!< A driver reload is required to apply these settings.
    NVAPI_SET_NOT_ALLOWED                       = -158,    //!< Intended setting is not allowed.
    NVAPI_ADVANCED_DISPLAY_TOPOLOGY_REQUIRED    = -159,    //!< Information can't be returned due to "advanced display topology".
    NVAPI_SETTING_NOT_FOUND                     = -160,    //!< Setting is not found.
    NVAPI_SETTING_SIZE_TOO_LARGE                = -161,    //!< Setting size is too large.
    NVAPI_TOO_MANY_SETTINGS_IN_PROFILE          = -162,    //!< There are too many settings for a profile. 
    NVAPI_PROFILE_NOT_FOUND                     = -163,    //!< Profile is not found.
    NVAPI_PROFILE_NAME_IN_USE                   = -164,    //!< Profile name is duplicated.
    NVAPI_PROFILE_NAME_EMPTY                    = -165,    //!< Profile name is empty.
    NVAPI_EXECUTABLE_NOT_FOUND                  = -166,    //!< Application not found in the Profile.
    NVAPI_EXECUTABLE_ALREADY_IN_USE             = -167,    //!< Application already exists in the other profile.
    NVAPI_DATATYPE_MISMATCH                     = -168,    //!< Data Type mismatch 
    NVAPI_PROFILE_REMOVED                       = -169,    //!< The profile passed as parameter has been removed and is no longer valid.
    NVAPI_UNREGISTERED_RESOURCE                 = -170,    //!< An unregistered resource was passed as a parameter. 
    NVAPI_ID_OUT_OF_RANGE                       = -171,    //!< The DisplayId corresponds to a display which is not within the normal outputId range.
    NVAPI_DISPLAYCONFIG_VALIDATION_FAILED       = -172,    //!< Display topology is not valid so the driver cannot do a mode set on this configuration.
    NVAPI_DPMST_CHANGED                         = -173,    //!< Display Port Multi-Stream topology has been changed.
    NVAPI_INSUFFICIENT_BUFFER                   = -174,    //!< Input buffer is insufficient to hold the contents.    
    NVAPI_ACCESS_DENIED                         = -175,    //!< No access to the caller.
    NVAPI_MOSAIC_NOT_ACTIVE                     = -176,    //!< The requested action cannot be performed without Mosaic being enabled.
    NVAPI_SHARE_RESOURCE_RELOCATED              = -177,    //!< The surface is relocated away from video memory.
    NVAPI_REQUEST_USER_TO_DISABLE_DWM           = -178,    //!< The user should disable DWM before calling NvAPI.
    NVAPI_D3D_DEVICE_LOST                       = -179,    //!< D3D device status is D3DERR_DEVICELOST or D3DERR_DEVICENOTRESET - the user has to reset the device.
    NVAPI_INVALID_CONFIGURATION                 = -180,    //!< The requested action cannot be performed in the current state.
    NVAPI_STEREO_HANDSHAKE_NOT_DONE             = -181,    //!< Call failed as stereo handshake not completed.
    NVAPI_EXECUTABLE_PATH_IS_AMBIGUOUS          = -182,    //!< The path provided was too short to determine the correct NVDRS_APPLICATION
    NVAPI_DEFAULT_STEREO_PROFILE_IS_NOT_DEFINED = -183,    //!< Default stereo profile is not currently defined
    NVAPI_DEFAULT_STEREO_PROFILE_DOES_NOT_EXIST = -184,    //!< Default stereo profile does not exist
    NVAPI_CLUSTER_ALREADY_EXISTS                = -185,    //!< A cluster is already defined with the given configuration.
    NVAPI_DPMST_DISPLAY_ID_EXPECTED             = -186,    //!< The input display id is not that of a multi stream enabled connector or a display device in a multi stream topology 
    NVAPI_INVALID_DISPLAY_ID                    = -187,    //!< The input display id is not valid or the monitor associated to it does not support the current operation
    NVAPI_STREAM_IS_OUT_OF_SYNC                 = -188,    //!< While playing secure audio stream, stream goes out of sync
    NVAPI_INCOMPATIBLE_AUDIO_DRIVER             = -189,    //!< Older audio driver version than required
    NVAPI_VALUE_ALREADY_SET                     = -190,    //!< Value already set, setting again not allowed.
    NVAPI_TIMEOUT                               = -191,    //!< Requested operation timed out 
    NVAPI_GPU_WORKSTATION_FEATURE_INCOMPLETE    = -192,    //!< The requested workstation feature set has incomplete driver internal allocation resources
    NVAPI_STEREO_INIT_ACTIVATION_NOT_DONE       = -193,    //!< Call failed because InitActivation was not called.
    NVAPI_SYNC_NOT_ACTIVE                       = -194,    //!< The requested action cannot be performed without Sync being enabled.    
    NVAPI_SYNC_MASTER_NOT_FOUND                 = -195,    //!< The requested action cannot be performed without Sync Master being enabled.
    NVAPI_INVALID_SYNC_TOPOLOGY                 = -196,    //!< Invalid displays passed in the NV_GSYNC_DISPLAY pointer.
    NVAPI_ECID_SIGN_ALGO_UNSUPPORTED            = -197,    //!< The specified signing algorithm is not supported. Either an incorrect value was entered or the current installed driver/hardware does not support the input value.
    NVAPI_ECID_KEY_VERIFICATION_FAILED          = -198,    //!< The encrypted public key verification has failed.
    NVAPI_FIRMWARE_OUT_OF_DATE                  = -199,    //!< The device's firmware is out of date.
    NVAPI_FIRMWARE_REVISION_NOT_SUPPORTED       = -200,    //!< The device's firmware is not supported.
} NvAPI_Status;


//! @}

//!   \ingroup nvapistatus 
#define NVAPI_API_NOT_INTIALIZED        NVAPI_API_NOT_INITIALIZED       //!< Fix typo in error code

//!   \ingroup nvapistatus 
#define NVAPI_INVALID_USER_PRIVILEDGE   NVAPI_INVALID_USER_PRIVILEGE    //!< Fix typo in error code


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Initialize
//
//! This function initializes the NvAPI library (if not already initialized) but always increments the ref-counter. 
//! This must be called before calling other NvAPI_ functions. 
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 80
//!
//! \retval  NVAPI_ERROR            An error occurred during the initialization process (generic error)
//! \retval  NVAPI_LIBRARYNOTFOUND  Failed to load the NVAPI support library
//! \retval  NVAPI_OK               Initialized
//! \sa nvapistatus
//! \ingroup nvapifunctions
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Initialize();


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Unload
//
//!   DESCRIPTION: Decrements the ref-counter and when it reaches ZERO, unloads NVAPI library. 
//!                This must be called in pairs with NvAPI_Initialize. 
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//!  Note: By design, it is not mandatory to call NvAPI_Initialize before calling any NvAPI.
//!        When any NvAPI is called without first calling NvAPI_Initialize, the internal refcounter
//!        will be implicitly incremented. In such cases, calling NvAPI_Initialize from a different thread will
//!        result in incrementing the refcount again and the user has to call NvAPI_Unload twice to 
//!        unload the library. However, note that the implicit increment of the refcounter happens only once.
//!        If the client wants unload functionality, it is recommended to always call NvAPI_Initialize and NvAPI_Unload in pairs.
//!
//!  Unloading NvAPI library is not supported when the library is in a resource locked state.
//!  Some functions in the NvAPI library initiates an operation or allocates certain resources
//!  and there are corresponding functions available, to complete the operation or free the
//!  allocated resources. All such function pairs are designed to prevent unloading NvAPI library.
//!
//!  For example, if NvAPI_Unload is called after NvAPI_XXX which locks a resource, it fails with
//!  NVAPI_ERROR. Developers need to call the corresponding NvAPI_YYY to unlock the resources, 
//!  before calling NvAPI_Unload again.
//!
//! \retval ::NVAPI_ERROR            One or more resources are locked and hence cannot unload NVAPI library
//! \retval ::NVAPI_OK               NVAPI library unloaded
//!
//! \ingroup nvapifunctions
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Unload();

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetErrorMessage
//
//! This function converts an NvAPI error code into a null terminated string.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 80
//!
//! \param nr      The error code to convert
//! \param szDesc  The string corresponding to the error code
//!
//! \return NULL terminated string (always, never NULL)
//! \ingroup nvapifunctions
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetErrorMessage(NvAPI_Status nr,NvAPI_ShortString szDesc);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetInterfaceVersionString
//
//! This function returns a string describing the version of the NvAPI library.
//!               The contents of the string are human readable.  Do not assume a fixed
//!                format.
//!
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 80
//!
//! \param  szDesc User readable string giving NvAPI version information
//!
//! \return See \ref nvapistatus for the list of possible return values.
//! \ingroup nvapifunctions
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetInterfaceVersionString(NvAPI_ShortString szDesc);


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//              All display port related data types definition starts
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// This category is intentionally added before the #ifdef. The #endif should also be in the same scope
#ifndef DISPLAYPORT_STRUCTS_DEFINED
#define DISPLAYPORT_STRUCTS_DEFINED

//! \ingroup dispcontrol
//! Used in NV_DISPLAY_PORT_INFO.
typedef enum _NV_DP_LINK_RATE
{
    NV_DP_1_62GBPS            = 6,
    NV_DP_2_70GBPS            = 0xA,
    NV_DP_5_40GBPS            = 0x14
} NV_DP_LINK_RATE;


//! \ingroup dispcontrol
//! Used in NV_DISPLAY_PORT_INFO.
typedef enum _NV_DP_LANE_COUNT
{
    NV_DP_1_LANE              = 1,
    NV_DP_2_LANE              = 2,
    NV_DP_4_LANE              = 4,
} NV_DP_LANE_COUNT;


//! \ingroup dispcontrol
//! Used in NV_DISPLAY_PORT_INFO.
typedef enum _NV_DP_COLOR_FORMAT
{
    NV_DP_COLOR_FORMAT_RGB     = 0,
    NV_DP_COLOR_FORMAT_YCbCr422,
    NV_DP_COLOR_FORMAT_YCbCr444,
} NV_DP_COLOR_FORMAT;


//! \ingroup dispcontrol
//! Used in NV_DISPLAY_PORT_INFO.
typedef enum _NV_DP_COLORIMETRY
{
    NV_DP_COLORIMETRY_RGB     = 0,
    NV_DP_COLORIMETRY_YCbCr_ITU601,
    NV_DP_COLORIMETRY_YCbCr_ITU709,
} NV_DP_COLORIMETRY;


//! \ingroup dispcontrol
//! Used in NV_DISPLAY_PORT_INFO.
typedef enum _NV_DP_DYNAMIC_RANGE
{
    NV_DP_DYNAMIC_RANGE_VESA  = 0,
    NV_DP_DYNAMIC_RANGE_CEA,
} NV_DP_DYNAMIC_RANGE;


//! \ingroup dispcontrol
//! Used in NV_DISPLAY_PORT_INFO.
typedef enum _NV_DP_BPC
{
    NV_DP_BPC_DEFAULT         = 0,
    NV_DP_BPC_6,
    NV_DP_BPC_8,
    NV_DP_BPC_10,
    NV_DP_BPC_12,
    NV_DP_BPC_16,
} NV_DP_BPC;


//! Do not use the following two constants directly in the code. These will be removed.
#define NV_DP_MAX_TOPOLOGY_NODES       128
#define NV_DP_MAX_HDCP_ADDRESS_HOPS    7

#define NV_DP_MAX_ADDRESS_HOPS         15

typedef struct _NV_DP_ADDRESS
{
    NvU32 hopCount;
    NvU32 hop[NV_DP_MAX_ADDRESS_HOPS];
} NV_DP_ADDRESS;

typedef enum _NV_DP_NODE_TYPE
{
    NV_DP_NODE_TYPE_UNKNOWN                  = -1,//!< Unknown type indicates an error condition, like unable to read the monitor type 
    NV_DP_NODE_TYPE_DP                       = 0, //!< Root DP to DP
    NV_DP_NODE_TYPE_HDMI                     = 1, //!< Root DP to HDMI
    NV_DP_NODE_TYPE_DVI                      = 2, //!< Root DP to DVI
    NV_DP_NODE_TYPE_VGA                      = 3, //!< Root DP to VGA
} NV_DP_NODE_TYPE;


typedef struct
{
    NvU64  isOsVisible          : 1;    //!< this node is exposed to OS (a connected device may not be exposed to OS)
    NvU64  isStreamCloned       : 1;    //!< this node is one of the stream cloned device
    // Add DD flags here
    NvU64  reservedDD           : 30;   //!< must be 0

    NvU64  isMultistream        : 1;    //!< is set if sink supports multistream
    NvU64  isVideoSink          : 1;    //!< is set if the address represents a video sink
    NvU64  isAudioSink          : 1;    //!< is set if the address represents an audio sink
    NvU64  isLoop               : 1;    //!< is set if the last hop causes a loop. Recommendation
                                        //!< is to ask the user to remove the cable represented by the last hop.
    NvU64  isRedundant          : 1;    //!< similar to isLoop except the connection causes redundant pathways
                                        //!< to other devices. Last hop represents the connection to cut.
    NvU64  isMustDisconnect     : 1;    //!< is set if DD disconnected device and requires nvsvc to do a modeset
    NvU64  isZombie             : 1;    //!< is set if DD disconnected device
    NvU64  isCableOk            : 1;    //!< is set if something wrong with cable
    NvU64  isPowerSuspended     : 1;    //!< is set if DPCD 0x600 is suspend state
    NvU64  isActive             : 1;    //!< is set if the device has a head attached to it
    NvU64  isHdcpCapable        : 1;    //!< is set if the device is HDCP capable
    NvU64  isPathHdcpCapable    : 1;    //!< is set if the path leading to this device is HDCP capable
    NvU64  isHdcpActive         : 1;    //!< is set if HDCP is active on the device
    NvU64  isRevoked            : 1;    //!< is set if the device is revoked

    // Add DP Library flags here
    NvU64  reservedLibrary      : 18; //!< must be 0
} NV_DP_NODE_FLAGS;

//! Used in NvAPI_GPU_QueryDpTopology
//!
//! Interpreting NV_DP_BRANCH_DEVICE_PORTS_INFO
//!
//! If the bit corresponding to the port number in the aux address is high in the internalPortsMask, then the current device is internally connected to the branch device. 
//! For example, if you had an address 0.8 for a sink A with a branch B preceding it, and B's inputPortsMask has the 8th bit set, 
//! then A is connected to the internal port of B since 8 is the number of the output port of B to which A is connected.
typedef struct _NV_DP_BRANCH_DEVICE_PORTS_INFO
{
    NvU16                   validPortsMask;       //!< port i is valid, when bit i in this mask is high 
    NvU16                   inputPortsMask;       //!< port i is an input port, when bit i is high && validPortsMask bit i is high 
    NvU16                   internalPortsMask;    //!< port i is an internal port, when bit i is high && validPortsMask bit i is high
} NV_DP_BRANCH_DEVICE_PORTS_INFO;

typedef struct _NV_DP_NODE_INFO
{
     NvU32                              version;                //!< Only element 0 must be properly set
     NvU32                              displayId;              //!< Valid for sinks only, this is a unique identifier for each sink device
     NV_DP_BRANCH_DEVICE_PORTS_INFO     branchDevicePortsInfo;  //!< The information about the ports on the branch device
     NV_DP_ADDRESS                      auxAddress;             //!< The aux address of the given node.
     NvGUID                             guid;                   //!< This GUID is populated for all devices.
                                                                //!< For sinks, it is the GUID of the previous branch device
                                                                //!< For branch devices, it is the GUID of the branch device.
     NV_DP_NODE_FLAGS                   flags;                  //!< One or more flag values from NV_DP_NODE_FLAGS.
     NV_DP_NODE_TYPE                    nodeType;               //!< Node type from NV_DP_NODE_TYPE
} NV_DP_NODE_INFO;

#define NV_DP_NODE_INFO_VER          MAKE_NVAPI_VERSION(NV_DP_NODE_INFO,1)

// This category tag is intentionally added before the #endif. The corresponding #ifdef above should also be in the same scope
#endif  //#ifndef DISPLAYPORT_STRUCTS_DEFINED

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//              All display port related data types definitions end
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetEDID
//
//! \fn NvAPI_GPU_GetEDID(NvPhysicalGpuHandle hPhysicalGpu, NvU32 displayOutputId, NV_EDID *pEDID)
//!  This function returns the EDID data for the specified GPU handle and connection bit mask.
//!  displayOutputId should have exactly 1 bit set to indicate a single display. See \ref handles.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 85
//!
//! \retval    NVAPI_INVALID_ARGUMENT              pEDID is NULL; displayOutputId has 0 or > 1 bits set
//! \retval    NVAPI_OK                           *pEDID contains valid data.
//! \retval    NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found.
//! \retval    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//! \retval    NVAPI_DATA_NOT_FOUND                The requested display does not contain an EDID.
//
///////////////////////////////////////////////////////////////////////////////


//! \ingroup gpu
//! @{

#define NV_EDID_V1_DATA_SIZE   256

#define NV_EDID_DATA_SIZE      NV_EDID_V1_DATA_SIZE

typedef struct
{
    NvU32   version;        //structure version
    NvU8    EDID_Data[NV_EDID_DATA_SIZE];
} NV_EDID_V1;

//! Used in NvAPI_GPU_GetEDID()
typedef struct
{
    NvU32   version;        //!< Structure version
    NvU8    EDID_Data[NV_EDID_DATA_SIZE];
    NvU32   sizeofEDID;
} NV_EDID_V2;

//! Used in NvAPI_GPU_GetEDID()
typedef struct
{
    NvU32   version;        //!< Structure version
    NvU8    EDID_Data[NV_EDID_DATA_SIZE];
    NvU32   sizeofEDID;
    NvU32   edidId;     //!< ID which always returned in a monotonically increasing counter.
                       //!< Across a split-EDID read we need to verify that all calls returned the same edidId.
                       //!< This counter is incremented if we get the updated EDID. 
    NvU32   offset;    //!< Which 256-byte page of the EDID we want to read. Start at 0.
                       //!< If the read succeeds with edidSize > NV_EDID_DATA_SIZE,
                       //!< call back again with offset+256 until we have read the entire buffer
} NV_EDID_V3;

typedef NV_EDID_V3    NV_EDID;

#define NV_EDID_VER1    MAKE_NVAPI_VERSION(NV_EDID_V1,1)
#define NV_EDID_VER2    MAKE_NVAPI_VERSION(NV_EDID_V2,2)
#define NV_EDID_VER3    MAKE_NVAPI_VERSION(NV_EDID_V3,3)
#define NV_EDID_VER   NV_EDID_VER3

//! @}

//! \ingroup gpu
NVAPI_INTERFACE NvAPI_GPU_GetEDID(NvPhysicalGpuHandle hPhysicalGpu, NvU32 displayOutputId, NV_EDID *pEDID);

//! \ingroup gpu
//! Used in NV_GPU_CONNECTOR_DATA
typedef enum _NV_GPU_CONNECTOR_TYPE
{
    NVAPI_GPU_CONNECTOR_VGA_15_PIN                      = 0x00000000,
    NVAPI_GPU_CONNECTOR_TV_COMPOSITE                    = 0x00000010,
    NVAPI_GPU_CONNECTOR_TV_SVIDEO                       = 0x00000011,
    NVAPI_GPU_CONNECTOR_TV_HDTV_COMPONENT               = 0x00000013,
    NVAPI_GPU_CONNECTOR_TV_SCART                        = 0x00000014,
    NVAPI_GPU_CONNECTOR_TV_COMPOSITE_SCART_ON_EIAJ4120  = 0x00000016,
    NVAPI_GPU_CONNECTOR_TV_HDTV_EIAJ4120                = 0x00000017,
    NVAPI_GPU_CONNECTOR_PC_POD_HDTV_YPRPB               = 0x00000018,
    NVAPI_GPU_CONNECTOR_PC_POD_SVIDEO                   = 0x00000019,
    NVAPI_GPU_CONNECTOR_PC_POD_COMPOSITE                = 0x0000001A,
    NVAPI_GPU_CONNECTOR_DVI_I_TV_SVIDEO                 = 0x00000020,
    NVAPI_GPU_CONNECTOR_DVI_I_TV_COMPOSITE              = 0x00000021,
    NVAPI_GPU_CONNECTOR_DVI_I                           = 0x00000030,
    NVAPI_GPU_CONNECTOR_DVI_D                           = 0x00000031,
    NVAPI_GPU_CONNECTOR_ADC                             = 0x00000032,
    NVAPI_GPU_CONNECTOR_LFH_DVI_I_1                     = 0x00000038,
    NVAPI_GPU_CONNECTOR_LFH_DVI_I_2                     = 0x00000039,
    NVAPI_GPU_CONNECTOR_SPWG                            = 0x00000040,
    NVAPI_GPU_CONNECTOR_OEM                             = 0x00000041,
    NVAPI_GPU_CONNECTOR_DISPLAYPORT_EXTERNAL            = 0x00000046,
    NVAPI_GPU_CONNECTOR_DISPLAYPORT_INTERNAL            = 0x00000047,
    NVAPI_GPU_CONNECTOR_DISPLAYPORT_MINI_EXT            = 0x00000048,
    NVAPI_GPU_CONNECTOR_HDMI_A                          = 0x00000061,
    NVAPI_GPU_CONNECTOR_HDMI_C_MINI                     = 0x00000063,
    NVAPI_GPU_CONNECTOR_LFH_DISPLAYPORT_1               = 0x00000064,
    NVAPI_GPU_CONNECTOR_LFH_DISPLAYPORT_2               = 0x00000065,
    NVAPI_GPU_CONNECTOR_VIRTUAL_WFD                     = 0x00000070,    
    NVAPI_GPU_CONNECTOR_UNKNOWN                         = 0xFFFFFFFF,
} NV_GPU_CONNECTOR_TYPE;


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetConnectorInfo
//
//! \fn NvAPI_GPU_GetConnectorInfo(NvPhysicalGpuHandle hPhysicalGpu, NvU32 outputId, NV_GPU_CONNECTOR_INFO *pConnectorInfo)
//!   Given a physical GPU handle and a single outputId (exactly 1 bit set - see \ref handles),
//!   this API fills the NV_GPU_CONNECTOR_INFO with connector specific data. 
//!   \note If outputId is connected or active then the current attached connector information is returned.
//!         If there is no connector attached for the outputId then all possible connections on the board are returned.
//!         Some TV outputs may have multiple connectors attached or could have an ambiguous connector layout on the board.
//!         In that case the connector[] array will list all connectors without indicating 
//!         which one is 'active'. To get the active TV connector use NvAPI_GetTVOutputInfo.
//!         This API is compliant with displayId sent as input instead of outputId.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 95
//!
//! \retval  NVAPI_INVALID_ARGUMENT              hPhysicalGpu, outputId or pOutputsMask is NULL; or outputId has > 1 bit set
//! \retval  NVAPI_OK                           *pConnectorInfo contains valid NV_GPU_CONNECTOR_INFO data
//! \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found
//! \retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle
//! \retval  NVAPI_INCOMPATIBLE_STRUCT_VERSION   NV_GPU_CONNECTOR_INFO version not compatible with driver
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
//! Used in NV_GPU_CONNECTOR_INFO
typedef enum _NV_GPU_CONNECTOR_PLATFORM
{
    NVAPI_GPU_CONNECTOR_PLATFORM_DEFAULT_ADD_IN_CARD   = 0x00000000,
    NVAPI_GPU_CONNECTOR_PLATFORM_TWO_PLATE_ADD_IN_CARD = 0x00000001,
    NVAPI_GPU_CONNECTOR_PLATFORM_MOBILE_ADD_IN_CARD    = 0x00000008,
    NVAPI_GPU_CONNECTOR_PLATFORM_MOBILE_BACK           = 0x00000010,
    NVAPI_GPU_CONNECTOR_PLATFORM_MOBILE_BACK_LEFT      = 0x00000011,
    NVAPI_GPU_CONNECTOR_PLATFORM_MOBILE_BACK_DOCK      = 0x00000018,
    NVAPI_GPU_CONNECTOR_PLATFORM_MAINBOARD_DEFAULT     = 0x00000020,
    NVAPI_GPU_CONNECTOR_PLATFORM_UNKNOWN               = 0xFFFFFFFF,
} NV_GPU_CONNECTOR_PLATFORM;

//! \ingroup gpu
//! Used in NV_GPU_CONNECTOR_INFO
typedef struct
{
    NV_GPU_CONNECTOR_TYPE   type;           //!< Connector type
    NvU32                   locationIndex;  //!< Connector location
} NV_GPU_CONNECTOR_DATA;

//! \ingroup gpu
#define NV_API_MAX_CONNECTOR_PER_OUTPUT     4

//! \ingroup gpu
//! Used in NvAPI_GPU_GetConnectorInfo()
typedef struct _NV_GPU_CONNECTOR_INFO_V1
{
    NvU32                       version;            //!<  Structure version
    NV_GPU_CONNECTOR_PLATFORM   connectorPlatform;  //!<  Connector platform
    NvU32                       connectorCount;     //!<  Number of valid entries in connector[]
    NV_GPU_CONNECTOR_DATA       connector[NV_API_MAX_CONNECTOR_PER_OUTPUT];
} NV_GPU_CONNECTOR_INFO_V1;


//! \ingroup gpu
typedef NV_GPU_CONNECTOR_INFO_V1    NV_GPU_CONNECTOR_INFO;

#define NV_GPU_CONNECTOR_INFO_VER1  MAKE_NVAPI_VERSION(NV_GPU_CONNECTOR_INFO_V1,1)
#define NV_GPU_CONNECTOR_INFO_VER   NV_GPU_CONNECTOR_INFO_VER1


//! \ingroup gpu
NVAPI_INTERFACE NvAPI_GPU_GetConnectorInfo(NvPhysicalGpuHandle hPhysicalGpu, NvU32 outputId, NV_GPU_CONNECTOR_INFO *pConnectorInfo);



//! \ingroup gpu
//! Used in NvAPI_GPU_GetConnectorInfoEx()
typedef struct _NV_CONNECTOR_CAPS
{
    NvU32       maxDisplaysVisibleToOS;                 //!< The maximum number of displays that can be exposed to the OS
    NvU32       maxNodesInMultiStreamTopology;          //!< The maximum number of displays that can be connected in a MST behind a single connector
    NvU32       maxAddressHopsInMultiStreamTopology;    //!< The maximum number of levels that the displays can be connected in a multi stream topology (MST)
    NvU32       maxHdcpHopsSupported;                   //!< The maximum number of levels beyond which HDCP will not be supported

    NvU64       isMultiStreamCapable    : 1;            //!< Specifies if this is a multi stream capable connector
    NvU64       isStreamCloneCapable    : 1;            //!< Specifies if this is a stream clone capable connector
    NvU64       reserved                : 62;           //!< Reserved. Must be set to ZERO.
} NV_CONNECTOR_CAPS;

//! \ingroup gpu
//! Used in NvAPI_GPU_GetConnectorInfoEx()
typedef struct
{
    NvU32                       version;            //!<  Structure version
    NV_GPU_CONNECTOR_PLATFORM   connectorPlatform;  //!<  Connector platform
    NvU32                       connectorDataCount; //!<  IN: Number of entries allocated for connectorData array
                                                    //!<  OUT: The actual number of valid entries in connectorData array.
    NV_GPU_CONNECTOR_DATA*      connectorData;      //!<  IN: Pointer to an array of NV_GPU_CONNECTOR_DATA structures
                                                    //!<  OUT: The connector data is filled in by the API
    NV_CONNECTOR_CAPS           connectorCaps;      //!<  Connector capabilities

} NV_GPU_CONNECTOR_INFO_EX_V1;

typedef enum _NV_GPU_CONNECTOR_DONGLE_TYPE
{
    NV_GPU_CONNECTOR_DONGLE_TYPE_OTHER             = 0,
    NV_GPU_CONNECTOR_DONGLE_TYPE_DP2DVI            = 1,
    NV_GPU_CONNECTOR_DONGLE_TYPE_DP2HDMI           = 2,
    NV_GPU_CONNECTOR_DONGLE_TYPE_DMS592DVI         = 3,
    NV_GPU_CONNECTOR_DONGLE_TYPE_DMS592VGA         = 4,
    NV_GPU_CONNECTOR_DONGLE_TYPE_DP2VGA            = 5,
    NV_GPU_CONNECTOR_DONGLE_TYPE_ACTIVE_DP2DVI     = 6,
    NV_GPU_CONNECTOR_DONGLE_TYPE_ACTIVE_DP2HDMI    = 7,
//! keeping some reserved
    NV_GPU_CONNECTOR_DONGLE_TYPE_WFD2VGA           = 20,
    NV_GPU_CONNECTOR_DONGLE_TYPE_WFD2SVIDEO        = 21,
    NV_GPU_CONNECTOR_DONGLE_TYPE_WFD2COMPOSITE     = 22,
    NV_GPU_CONNECTOR_DONGLE_TYPE_WFD2COMPONENT     = 23,
    NV_GPU_CONNECTOR_DONGLE_TYPE_WFD2DVI           = 24,
    NV_GPU_CONNECTOR_DONGLE_TYPE_WFD2HDMI          = 25,
    NV_GPU_CONNECTOR_DONGLE_TYPE_WFD2WFD           = 26,
    NV_GPU_CONNECTOR_DONGLE_TYPE_WFD2EIAJRC5237    = 27,
    NV_GPU_CONNECTOR_DONGLE_TYPE_WFD2SDI           = 28,
    NV_GPU_CONNECTOR_DONGLE_TYPE_WFD2DP            = 29, 
    NV_GPU_CONNECTOR_DONGLE_TYPE_WFD2UDI           = 30,
} NV_GPU_CONNECTOR_DONGLE_TYPE;

typedef struct
{
    NvU32                       version;            //!<  Structure version
    NV_GPU_CONNECTOR_PLATFORM   connectorPlatform;  //!<  Connector platform
    NvU32                       connectorDataCount; //!<  IN: Number of entries allocated for connectorData array
                                                    //!<  OUT: The actual number of valid entries in connectorData array.
    NV_GPU_CONNECTOR_DATA*      connectorData;      //!<  IN: Pointer to an array of NV_GPU_CONNECTOR_DATA structures
                                                    //!<  OUT: The connector data is filled in by the API
    NV_CONNECTOR_CAPS           connectorCaps;      //!<  Connector capabilities
    NV_GPU_CONNECTOR_DONGLE_TYPE    dongleType;         //!<  dongle type. Valid for DP & WFD connector only.

} NV_GPU_CONNECTOR_INFO_EX_V2;

//! \ingroup gpu
typedef NV_GPU_CONNECTOR_INFO_EX_V2 NV_GPU_CONNECTOR_INFO_EX;

#define NV_GPU_CONNECTOR_INFO_EX_VER1  MAKE_NVAPI_VERSION(NV_GPU_CONNECTOR_INFO_EX_V1, 1)
#define NV_GPU_CONNECTOR_INFO_EX_VER2  MAKE_NVAPI_VERSION(NV_GPU_CONNECTOR_INFO_EX_V2, 2)
#define NV_GPU_CONNECTOR_INFO_EX_VER   NV_GPU_CONNECTOR_INFO_EX_VER2

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetConnectorInfoEx
//
//! \fn NvAPI_GPU_GetConnectorInfoEx(NvU32 displayId, NV_GPU_CONNECTOR_INFO_EX *pConnectorInfo)
//!
//!   Description: This API returns the connector information for a given connector identified by the input
//!                displayId parameter. For vista and above, when the display id represents a device in a multi stream topology,
//!                the information of the physical connector to which the display is rooted to, will be returned. If the 
//!                display is rooted to multiple physical connectors (when connected via a concentrator), the 
//!                output can be of either of the connectors. In such cases, the user should pass the display id
//!                of the connector specifically.
//!
//! \note The connectorData count usually is 1 unless the connector type is an analog TV. Currently the maximum number of connectors per output is defined by 
//!       NV_API_MAX_CONNECTOR_PER_OUTPUT. It is advisable the client (in order to avoid multiple calls) allocate NV_API_MAX_CONNECTOR_PER_OUTPUT elements for 
//!       the connectorData member and set connectorDataCount to NV_API_MAX_CONNECTOR_PER_OUTPUT.
//! 
//! \note If a monitor is connected or active on the given connector, then the current attached connector information is returned.
//!       If there is no monitor attached then all possible connections on the board are returned.
//!       Some TV outputs may have multiple connectors attached or could have an ambiguous connector layout on the board.
//!       In that case the connectorData array will list all connectors without indicating which one is 'active'. 
//!       To get the active TV connector use NvAPI_GetTVOutputInfo.
//!
//! \param[in]     displayId       The displayId of a device connected to the required connector
//! \param[in/out] pConnectorInfo  Pointer to NV_GPU_CONNECTOR_INFO_EX structure that will receive the data
//!
//! SUPPORTED OS:  Windows XP,  Windows Vista
//!
//!
//! \return      This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!              specific meaning for this API, they are listed below.
//!
//! \retval  NVAPI_INSUFFICIENT_BUFFER      There exists more connector data than what was allocated for the connectorData array.
//!                                         In this case the connectorDataCount will have the actual number of connector data available
//!                                         for the input connector.
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetConnectorInfoEx(__in NvU32 displayId, __inout NV_GPU_CONNECTOR_INFO_EX *pConnectorInfo);



//! \ingroup tvapi
//! Used in NvAPI_GPU_GetTvEncoderType()
typedef enum _NV_TV_ENCODER_TYPE
{ 
    NV_ENCODER_TYPE_UNKNOWN         = 0, 
           
    NV_ENCODER_TYPE_BROOKTREE_868   = 1,
    NV_ENCODER_TYPE_BROOKTREE_869   = 2,
    NV_ENCODER_TYPE_BROOKTREE_871   = 3,
    NV_ENCODER_TYPE_BROOKTREE_870   = 4,
    NV_ENCODER_TYPE_BROOKTREE_872   = 5,
    NV_ENCODER_TYPE_BROOKTREE_873   = 6,
    NV_ENCODER_TYPE_BROOKTREE_874   = 7,
    NV_ENCODER_TYPE_BROOKTREE_875   = 8,
    NV_ENCODER_TYPE_BROOKTREE_890   = 9,
    NV_ENCODER_TYPE_BROOKTREE_891   = 10,
    NV_ENCODER_TYPE_BROOKTREE_892   = 11,

    NV_ENCODER_TYPE_CHRONTEL_7003   = 12,
    NV_ENCODER_TYPE_CHRONTEL_7004   = 13,
    NV_ENCODER_TYPE_CHRONTEL_7005   = 14,
    NV_ENCODER_TYPE_CHRONTEL_7006   = 15,
    NV_ENCODER_TYPE_CHRONTEL_7007   = 16,
    NV_ENCODER_TYPE_CHRONTEL_7008   = 17,
    NV_ENCODER_TYPE_CHRONTEL_7009   = 18,
    NV_ENCODER_TYPE_CHRONTEL_7010   = 19,
    NV_ENCODER_TYPE_CHRONTEL_7011   = 20,
    NV_ENCODER_TYPE_CHRONTEL_7012   = 21,
    NV_ENCODER_TYPE_CHRONTEL_7019   = 22,
    NV_ENCODER_TYPE_CHRONTEL_7021   = 23,
    NV_ENCODER_TYPE_CHRONTEL_7301   = 24,

    NV_ENCODER_TYPE_PHILIPS_7102    = 25,
    NV_ENCODER_TYPE_PHILIPS_7103    = 26,
    NV_ENCODER_TYPE_PHILIPS_7108    = 27,
    NV_ENCODER_TYPE_PHILIPS_7109    = 28,
    NV_ENCODER_TYPE_PHILIPS_7108B   = 29,
    NV_ENCODER_TYPE_PHILIPS_7108A   = 30,
    NV_ENCODER_TYPE_PHILIPS_7109A   = 31,
    NV_ENCODER_TYPE_PHILIPS_7104    = 32,
    NV_ENCODER_TYPE_PHILIPS_7105    = 33,

    NV_ENCODER_TYPE_NVIDIA_TV17     = 34,
    NV_ENCODER_TYPE_NVIDIA_MV17     = 35,
    NV_ENCODER_TYPE_NVIDIA_MV36     = 36,
    NV_ENCODER_TYPE_NVIDIA_G80      = 37,

} NV_TV_ENCODER_TYPE;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetTvEncoderType
//
//!  This function retrieves the TV encoder type associated with the specified GPU handle.
//!  - The output ID can be the outputId of type NVAPI_GPU_OUTPUT_TV if the query is for a specific encoder in the case of a 
//!  multi-encoder board. See \ref handles.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 85
//!              
//! \retval  NVAPI_OK                            Call successful.
//! \retval  NVAPI_HANDLE_INVALIDATED            Handle passed has been invalidated (see user guide).
//! \retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle.
//! \retval  NVAPI_INVALID_ARGUMENT              pEncoderType is NULL or outputId is 0.
//! \retval  NVAPI_EXPECTED_TV_DISPLAY           Expected TV output display in outputId.
//! \ingroup tvapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetTvEncoderType(NvPhysicalGpuHandle hPhysicalGpu, NvU32 outputId, NV_TV_ENCODER_TYPE *pEncoderType); 


////////////////////////////////////////////////////////////////////////////////
//
// NvAPI_TVOutput Information
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup tvapi
//! Used in NV_DISPLAY_TV_OUTPUT_INFO
typedef enum _NV_DISPLAY_TV_FORMAT
{
    NV_DISPLAY_TV_FORMAT_NONE               = 0,
    NV_DISPLAY_TV_FORMAT_SD_NTSCM           = 0x00000001,
    NV_DISPLAY_TV_FORMAT_SD_NTSCJ           = 0x00000002,
    NV_DISPLAY_TV_FORMAT_SD_PALM            = 0x00000004,
    NV_DISPLAY_TV_FORMAT_SD_PALBDGH         = 0x00000008,
    NV_DISPLAY_TV_FORMAT_SD_PALN            = 0x00000010,
    NV_DISPLAY_TV_FORMAT_SD_PALNC           = 0x00000020,
    NV_DISPLAY_TV_FORMAT_SD_576i            = 0x00000100,
    NV_DISPLAY_TV_FORMAT_SD_480i            = 0x00000200,
    NV_DISPLAY_TV_FORMAT_ED_480p            = 0x00000400,
    NV_DISPLAY_TV_FORMAT_ED_576p            = 0x00000800,
    NV_DISPLAY_TV_FORMAT_HD_720p            = 0x00001000,
    NV_DISPLAY_TV_FORMAT_HD_1080i           = 0x00002000,
    NV_DISPLAY_TV_FORMAT_HD_1080p           = 0x00004000,
    NV_DISPLAY_TV_FORMAT_HD_720p50          = 0x00008000,
    NV_DISPLAY_TV_FORMAT_HD_1080p24         = 0x00010000,
    NV_DISPLAY_TV_FORMAT_HD_1080i50         = 0x00020000,
    NV_DISPLAY_TV_FORMAT_HD_1080p50         = 0x00040000,
    NV_DISPLAY_TV_FORMAT_UHD_4Kp30          = 0x00080000,
    NV_DISPLAY_TV_FORMAT_UHD_4Kp30_3840     = NV_DISPLAY_TV_FORMAT_UHD_4Kp30,
    NV_DISPLAY_TV_FORMAT_UHD_4Kp25          = 0x00100000,
    NV_DISPLAY_TV_FORMAT_UHD_4Kp25_3840     = NV_DISPLAY_TV_FORMAT_UHD_4Kp25,
    NV_DISPLAY_TV_FORMAT_UHD_4Kp24          = 0x00200000,
    NV_DISPLAY_TV_FORMAT_UHD_4Kp24_3840     = NV_DISPLAY_TV_FORMAT_UHD_4Kp24,
    NV_DISPLAY_TV_FORMAT_UHD_4Kp24_SMPTE    = 0x00400000,
    NV_DISPLAY_TV_FORMAT_UHD_4Kp50_3840     = 0x00800000,
    NV_DISPLAY_TV_FORMAT_UHD_4Kp60_3840     = 0x00900000,
    NV_DISPLAY_TV_FORMAT_UHD_4Kp30_4096     = 0x00A00000,
    NV_DISPLAY_TV_FORMAT_UHD_4Kp25_4096     = 0x00B00000,
    NV_DISPLAY_TV_FORMAT_UHD_4Kp24_4096     = 0x00C00000,
    NV_DISPLAY_TV_FORMAT_UHD_4Kp50_4096     = 0x00D00000,
    NV_DISPLAY_TV_FORMAT_UHD_4Kp60_4096     = 0x00E00000,

    NV_DISPLAY_TV_FORMAT_SD_OTHER           = 0x01000000,
    NV_DISPLAY_TV_FORMAT_ED_OTHER           = 0x02000000,
    NV_DISPLAY_TV_FORMAT_HD_OTHER           = 0x04000000,

    NV_DISPLAY_TV_FORMAT_ANY                = 0x80000000,

} NV_DISPLAY_TV_FORMAT;


//! \ingroup tvapi
//! Used in NvAPI_SetGpuTopologies() and NvAPI_GetGpuTopologies()
typedef struct
{
    NvU32                   version;                            //!< [IN]       Structure version.
    NvU32                   supportedFormats;                   //!< [OUT only] One or more TV formats defined in NV_DISPLAY_TV_FORMAT matching, encoder supported formats for analog TVs or EDID exposed modes for digital TVs.
    NV_DISPLAY_TV_FORMAT    currentFormat;                      //!< [IN/OUT]   One of the selected TV output format from supportedFormats defined in NV_DISPLAY_TV_FORMAT.
    NV_GPU_CONNECTOR_TYPE   currentConnector;                   //!< [IN/OUT]   For Analog TV, valid TV output connector is one of the NVAPI_GPU_CONNECTOR_TV types.
                                                                //!<            For Digital TV, valid TV output connector is one of the NVAPI_GPU_CONNECTOR_DVI types.
} NV_DISPLAY_TV_OUTPUT_INFO;    

//! \ingroup tvapi
#define NV_DISPLAY_TV_OUTPUT_INFO_VER MAKE_NVAPI_VERSION(NV_DISPLAY_TV_OUTPUT_INFO, 1)

 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetTVOutputInfo
//
//!  This function retrieves the TV display output information of the selected display.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 95
//!
//! \param [in]  hNvDisplay         NVIDIA Display selection. It can be #NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//! \param [in]  outputId           One of the selected outputId retrieved from NvAPI_GPU_GetActiveOutputs or NvAPI_GetView, to identify the targeted TV. See \ref handles.
//!                                 Can be NULL to auto pick the TV output associated with hNvDisplay.
//!                                 The outputId must be of type #NVAPI_GPU_OUTPUT_TV or #NVAPI_GPU_OUTPUT_DFP in case of a digital HDTV.
//! \param [out] pTVOutInfo         The returned TV output information.
//!                                 With digital HDTV, the supportedFormats are limited to the available EIA-861B modes in the EDID 
//!                                 or the custom 861B modes if added by the user.
//!                                 
//!
//! \retval   NVAPI_OK                           Call successful.
//! \retval   NVAPI_NVIDIA_DEVICE_NOT_FOUND      No NVIDIA GPU driving a display was found.
//! \retval   NVAPI_EXPECTED_DISPLAY_HANDLE      hNvDisplay is not a valid display handle.
//! \retval   NVAPI_INVALID_ARGUMENT             pTVOutInfo is NULL.
//! \retval   NVAPI_INCOMPATIBLE_STRUCT_VERSION  The version of the NV_DISPLAY_TV_OUTPUT_INFO_VER struct is not supported.
//! \retval   NVAPI_EXPECTED_TV_DISPLAY          Expected TV output display in outputId.
//! \ingroup tvapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetTVOutputInfo(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_DISPLAY_TV_OUTPUT_INFO *pTVOutInfo);


//! \ingroup dispcontrol
//! @{
#define NVAPI_MAX_VIEW_TARGET  2
#define NVAPI_ADVANCED_MAX_VIEW_TARGET 4

#ifndef _NV_TARGET_VIEW_MODE_
#define _NV_TARGET_VIEW_MODE_

//! Used in NvAPI_SetView().
typedef enum _NV_TARGET_VIEW_MODE
{
    NV_VIEW_MODE_STANDARD  = 0,
    NV_VIEW_MODE_CLONE     = 1,
    NV_VIEW_MODE_HSPAN     = 2,
    NV_VIEW_MODE_VSPAN     = 3,
    NV_VIEW_MODE_DUALVIEW  = 4,
    NV_VIEW_MODE_MULTIVIEW = 5,
} NV_TARGET_VIEW_MODE;
#endif

//! @}


// Following definitions are used in NvAPI_SetViewEx.

//! Scaling modes - used in NvAPI_SetViewEx().
//! \ingroup dispcontrol
typedef enum _NV_SCALING
{
    NV_SCALING_DEFAULT          = 0,        //!< No change

    // New Scaling Declarations
    NV_SCALING_GPU_SCALING_TO_CLOSEST                   = 1,  //!< Balanced  - Full Screen
    NV_SCALING_GPU_SCALING_TO_NATIVE                    = 2,  //!< Force GPU - Full Screen
    NV_SCALING_GPU_SCANOUT_TO_NATIVE                    = 3,  //!< Force GPU - Centered\No Scaling
    NV_SCALING_GPU_SCALING_TO_ASPECT_SCANOUT_TO_NATIVE  = 5,  //!< Force GPU - Aspect Ratio
    NV_SCALING_GPU_SCALING_TO_ASPECT_SCANOUT_TO_CLOSEST = 6,  //!< Balanced  - Aspect Ratio
    NV_SCALING_GPU_SCANOUT_TO_CLOSEST                   = 7,  //!< Balanced  - Centered\No Scaling
    
    // Legacy Declarations
    NV_SCALING_MONITOR_SCALING                          = NV_SCALING_GPU_SCALING_TO_CLOSEST,
    NV_SCALING_ADAPTER_SCALING                          = NV_SCALING_GPU_SCALING_TO_NATIVE,
    NV_SCALING_CENTERED                                 = NV_SCALING_GPU_SCANOUT_TO_NATIVE,
    NV_SCALING_ASPECT_SCALING                           = NV_SCALING_GPU_SCALING_TO_ASPECT_SCANOUT_TO_NATIVE,

    NV_SCALING_CUSTOMIZED       = 255       //!< For future use
} NV_SCALING;

//! Rotate modes- used in NvAPI_SetViewEx().
//! \ingroup dispcontrol
typedef enum _NV_ROTATE
{
    NV_ROTATE_0           = 0,
    NV_ROTATE_90          = 1,
    NV_ROTATE_180         = 2,
    NV_ROTATE_270         = 3,
    NV_ROTATE_IGNORED     = 4,
} NV_ROTATE;

//! Color formats- used in NvAPI_SetViewEx().
//! \ingroup dispcontrol
#define NVFORMAT_MAKEFOURCC(ch0, ch1, ch2, ch3)                              \
                         ((NvU32)(NvU8)(ch0) | ((NvU32)(NvU8)(ch1) << 8) |   \
                     ((NvU32)(NvU8)(ch2) << 16) | ((NvU32)(NvU8)(ch3) << 24 ))



//! Color formats- used in NvAPI_SetViewEx().
//! \ingroup dispcontrol
typedef enum _NV_FORMAT
{
    NV_FORMAT_UNKNOWN           =  0,       //!< unknown. Driver will choose one as following value.
    NV_FORMAT_P8                = 41,       //!< for 8bpp mode
    NV_FORMAT_R5G6B5            = 23,       //!< for 16bpp mode
    NV_FORMAT_A8R8G8B8          = 21,       //!< for 32bpp mode
    NV_FORMAT_A16B16G16R16F     = 113,      //!< for 64bpp(floating point) mode.
    NV_FORMAT_R8G8B8            = 20,
    NV_FORMAT_X8R8G8B8          = 22,
    NV_FORMAT_X1R5G5B5          = 24,
    NV_FORMAT_A1R5G5B5          = 25,
    NV_FORMAT_A4R4G4B4          = 26,
    NV_FORMAT_R3G3B2            = 27,
    NV_FORMAT_A8                = 28,
    NV_FORMAT_A8R3G3B2          = 29,
    NV_FORMAT_X4R4G4B4          = 30,
    NV_FORMAT_A2B10G10R10       = 31,
    NV_FORMAT_A8B8G8R8          = 32,
    NV_FORMAT_X8B8G8R8          = 33,
    NV_FORMAT_G16R16            = 34,
    NV_FORMAT_A2R10G10B10       = 35,
    NV_FORMAT_A16B16G16R16      = 36,
    NV_FORMAT_A8P8              = 40,
    NV_FORMAT_L8                = 50,
    NV_FORMAT_A8L8              = 51,
    NV_FORMAT_A4L4              = 52,
    NV_FORMAT_V8U8              = 60,
    NV_FORMAT_L6V5U5            = 61,
    NV_FORMAT_X8L8V8U8          = 62,
    NV_FORMAT_Q8W8V8U8          = 63,
    NV_FORMAT_V16U16            = 64,
    NV_FORMAT_W11V11U10         = 65, 
    NV_FORMAT_A2W10V10U10       = 67,
    NV_FORMAT_UYVY              = NVFORMAT_MAKEFOURCC('U', 'Y', 'V', 'Y'),
    NV_FORMAT_R8G8_B8G8         = NVFORMAT_MAKEFOURCC('R', 'G', 'B', 'G'),
    NV_FORMAT_YUY2              = NVFORMAT_MAKEFOURCC('Y', 'U', 'Y', '2'),
    NV_FORMAT_G8R8_G8B8         = NVFORMAT_MAKEFOURCC('G', 'R', 'G', 'B'),
    NV_FORMAT_DXT1              = NVFORMAT_MAKEFOURCC('D', 'X', 'T', '1'),
    NV_FORMAT_DXT2              = NVFORMAT_MAKEFOURCC('D', 'X', 'T', '2'),
    NV_FORMAT_DXT3              = NVFORMAT_MAKEFOURCC('D', 'X', 'T', '3'),
    NV_FORMAT_DXT4              = NVFORMAT_MAKEFOURCC('D', 'X', 'T', '4'),
    NV_FORMAT_DXT5              = NVFORMAT_MAKEFOURCC('D', 'X', 'T', '5'),
    NV_FORMAT_D16_LOCKABLE      = 70,
    NV_FORMAT_D32               = 71,
    NV_FORMAT_D15S1             = 73,
    NV_FORMAT_D24S8             = 75,
    NV_FORMAT_D24X8             = 77,
    NV_FORMAT_D24X4S4           = 79,
    NV_FORMAT_D16               = 80,
    NV_FORMAT_D32F_LOCKABLE     = 82,
    NV_FORMAT_D24FS8            = 83,
    NV_FORMAT_D32_LOCKABLE      = 84,
    NV_FORMAT_S8_LOCKABLE       = 85,
    NV_FORMAT_S1D15             = 72,
    NV_FORMAT_S8D24             = 74,
    NV_FORMAT_X8D24             = 76,
    NV_FORMAT_X4S4D24           = 78,
    NV_FORMAT_L16               = 81,
    NV_FORMAT_VERTEXDATA        =100,
    NV_FORMAT_INDEX16           =101,
    NV_FORMAT_INDEX32           =102,
    NV_FORMAT_Q16W16V16U16      =110,
    NV_FORMAT_R16F              =111,
    NV_FORMAT_G16R16F           =112,
    NV_FORMAT_R32F              =114,
    NV_FORMAT_G32R32F           =115,
    NV_FORMAT_A32B32G32R32F     =116,
    NV_FORMAT_CxV8U8            =117,
    NV_FORMAT_A1                =118,

} NV_FORMAT;

// TV standard


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SetDisplaySettings
///////////////////////////////////////////////////////////////////////////////


//! \ingroup dispcontrol
//! The connector is not supported yet; must be set to _AUTO
typedef enum _NV_CONNECTOR
{
    NV_CONN_AUTO = 0,
}NV_CONNECTOR;

typedef struct 
{
    float x;    //!<  x-coordinate of the viewport top-left point
    float y;    //!<  y-coordinate of the viewport top-left point
    float w;    //!<  Width of the viewport
    float h;    //!<  Height of the viewport
} NV_VIEWPORTF;



//! \ingroup dispcontrol
//! The timing override is not supported yet; must be set to _AUTO. \n


typedef enum _NV_TIMING_OVERRIDE
{
    NV_TIMING_OVERRIDE_CURRENT = 0,          //!< get the current timing
    NV_TIMING_OVERRIDE_AUTO,                 //!< the timing the driver will use based the current policy
    NV_TIMING_OVERRIDE_EDID,                 //!< EDID timing
    NV_TIMING_OVERRIDE_DMT,                  //!< VESA DMT timing
    NV_TIMING_OVERRIDE_DMT_RB,               //!< VESA DMT timing with reduced blanking
    NV_TIMING_OVERRIDE_CVT,                  //!< VESA CVT timing
    NV_TIMING_OVERRIDE_CVT_RB,               //!< VESA CVT timing with reduced blanking
    NV_TIMING_OVERRIDE_GTF,                  //!< VESA GTF timing
    NV_TIMING_OVERRIDE_EIA861,               //!< EIA 861x pre-defined timing
    NV_TIMING_OVERRIDE_ANALOG_TV,            //!< analog SD/HDTV timing
    NV_TIMING_OVERRIDE_CUST,                 //!< NV custom timings
    NV_TIMING_OVERRIDE_NV_PREDEFINED,        //!< NV pre-defined timing (basically the PsF timings)
    NV_TIMING_OVERRIDE_NV_PSF                = NV_TIMING_OVERRIDE_NV_PREDEFINED,
    NV_TIMING_OVERRIDE_NV_ASPR,
    NV_TIMING_OVERRIDE_SDI,                  //!< Override for SDI timing

    NV_TIMING_OVRRIDE_MAX,                   
}NV_TIMING_OVERRIDE;


#ifndef NV_TIMING_STRUCTS_DEFINED
#define NV_TIMING_STRUCTS_DEFINED

//***********************
// The Timing Structure
//***********************
//
//! \ingroup dispcontrol
//!  NVIDIA-specific timing extras \n
//! Used in NV_TIMING.
typedef struct tagNV_TIMINGEXT
{
    NvU32   flag;          //!< Reserved for NVIDIA hardware-based enhancement, such as double-scan.
    NvU16   rr;            //!< Logical refresh rate to present
    NvU32   rrx1k;         //!< Physical vertical refresh rate in 0.001Hz
    NvU32   aspect;        //!< Display aspect ratio Hi(aspect):horizontal-aspect, Low(aspect):vertical-aspect
    NvU16   rep;           //!< Bit-wise pixel repetition factor: 0x1:no pixel repetition; 0x2:each pixel repeats twice horizontally,..
    NvU32   status;        //!< Timing standard 
    NvU8    name[40];      //!< Timing name
}NV_TIMINGEXT;



//! \ingroup dispcontrol
//!The very basic timing structure based on the VESA standard:
//! \code
//!            |<----------------------------htotal--------------------------->| 
//!             ---------"active" video-------->|<-------blanking------>|<-----  
//!            |<-------hvisible-------->|<-hb->|<-hfp->|<-hsw->|<-hbp->|<-hb->| 
//! --------- -+-------------------------+      |       |       |       |      | 
//!   A      A |                         |      |       |       |       |      | 
//!   :      : |                         |      |       |       |       |      | 
//!   :      : |                         |      |       |       |       |      | 
//!   :vertical|    addressable video    |      |       |       |       |      | 
//!   : visible|                         |      |       |       |       |      | 
//!   :      : |                         |      |       |       |       |      | 
//!   :      : |                         |      |       |       |       |      | 
//! vertical V |                         |      |       |       |       |      | 
//!  total   --+-------------------------+      |       |       |       |      | 
//!   :      vb         border                  |       |       |       |      | 
//!   :      -----------------------------------+       |       |       |      |  
//!   :      vfp        front porch                     |       |       |      |  
//!   :      -------------------------------------------+       |       |      | 
//!   :      vsw        sync width                              |       |      | 
//!   :      ---------------------------------------------------+       |      | 
//!   :      vbp        back porch                                      |      | 
//!   :      -----------------------------------------------------------+      | 
//!   V      vb         border                                                 | 
//! ---------------------------------------------------------------------------+ 
//! \endcode
typedef struct _NV_TIMING
{
    // VESA scan out timing parameters:
    NvU16 HVisible;         //!< horizontal visible 
    NvU16 HBorder;          //!< horizontal border 
    NvU16 HFrontPorch;      //!< horizontal front porch
    NvU16 HSyncWidth;       //!< horizontal sync width
    NvU16 HTotal;           //!< horizontal total
    NvU8  HSyncPol;         //!< horizontal sync polarity: 1-negative, 0-positive

    NvU16 VVisible;         //!< vertical visible
    NvU16 VBorder;          //!< vertical border
    NvU16 VFrontPorch;      //!< vertical front porch
    NvU16 VSyncWidth;       //!< vertical sync width
    NvU16 VTotal;           //!< vertical total
    NvU8  VSyncPol;         //!< vertical sync polarity: 1-negative, 0-positive
    
    NvU16 interlaced;       //!< 1-interlaced, 0-progressive
    NvU32 pclk;             //!< pixel clock in 10 kHz

    //other timing related extras
    NV_TIMINGEXT etc;          
}NV_TIMING;
#endif //NV_TIMING_STRUCTS_DEFINED


//! \addtogroup dispcontrol
//! Timing-related constants
//! @{
#define NV_TIMING_H_SYNC_POSITIVE                             0
#define NV_TIMING_H_SYNC_NEGATIVE                             1
#define NV_TIMING_H_SYNC_DEFAULT                              NV_TIMING_H_SYNC_NEGATIVE
//
#define NV_TIMING_V_SYNC_POSITIVE                             0
#define NV_TIMING_V_SYNC_NEGATIVE                             1
#define NV_TIMING_V_SYNC_DEFAULT                              NV_TIMING_V_SYNC_POSITIVE
//
#define NV_TIMING_PROGRESSIVE                                 0
#define NV_TIMING_INTERLACED                                  1
#define NV_TIMING_INTERLACED_EXTRA_VBLANK_ON_FIELD2           1
#define NV_TIMING_INTERLACED_NO_EXTRA_VBLANK_ON_FIELD2        2
//! @}

//! \ingroup dispcontrol
typedef enum _NVAPI_TIMING_TYPE
{
    NV_TIMING_TYPE_DMT = 1,                                 //!< DMT 
    NV_TIMING_TYPE_GTF,                                     //!< GTF
    NV_TIMING_TYPE_ASPR,                                    //!< wide aspect ratio timing, for legacy support only
    NV_TIMING_TYPE_NTSC_TV,                                 //!< NTSC TV timing. for legacy support only
    NV_TIMING_TYPE_PAL_TV,                                  //!< PAL TV timing, legacy support only
    NV_TIMING_TYPE_CVT,                                     //!< CVT timing
    NV_TIMING_TYPE_CVT_RB,                                  //!< CVT timing with reduced blanking
    NV_TIMING_TYPE_CUST,                                    //!< Customized timing
    NV_TIMING_TYPE_EDID_DTD,                                //!< EDID detailed timing
    NV_TIMING_TYPE_EDID_STD,                                //!< EDID standard timing
    NV_TIMING_TYPE_EDID_EST,                                //!< EDID established timing
    NV_TIMING_TYPE_EDID_CVT,                                //!< EDID defined CVT timing (EDID 1.4)
    NV_TIMING_TYPE_EDID_861ST,                              //!< EDID defined CEA/EIA 861 timing (in the EDID 861 extension)
    NV_TIMING_TYPE_NV_PREDEFINED,                           //!< NV pre-defined timings (PsF timings)
    NV_TIMING_TYPE_DMT_RB,                                  //!< DMT timing with reduced blanking
    NV_TIMING_TYPE_EDID_EXT_DTD,                            //!< EDID detailed timing in the extension
    NV_TIMING_TYPE_SDTV,                                    //!< SDTV timing (including NTSC, PAL etc)
    NV_TIMING_TYPE_HDTV,                                    //!< HDTV timing (480p,480i,720p, 1080i etc)
}NVAPI_TIMING_TYPE;



//! \ingroup dispcontrol
//! Config on the specified display is not supported yet.
#define NV_DISP_INDEX_AUTO 0



//! \ingroup dispcontrol
//! The generic display target configuration info, independent of any specific mode. \n
//! Used in NvAPI_SetDisplaySettings() and NvAPI_GetDisplaySettings()
typedef struct 
{
    NvU32                   version;    //!<  Structure version

    NvU32                   device;     //!<  Target display ID or target device mask 
    NV_GPU_CONNECTOR_TYPE   connector;

    NvU32                   srcID;        //!<  The source display index

    NvU32                   srcImportance;   //!< (OUT) Indicates if this is the GPU's primary view target. This is not the desktop GDI primary.
                                             //!< NvAPI_SetDisplaySettings automatically selects the first target in NV_DISP_PATH index 0 as the GPU's primary view.
    
    // the source mode information
    NvU32                   width;      
    NvU32                   height;
    NvU32                   depth;
    NV_ROTATE               rotation;
    NV_FORMAT               colorFormat;       //!< Color format. Not used now.
  
    // the section of the source surface for scan out, defined in normalized desktop coordinates
    NV_VIEWPORTF            srcPartition;      // not used now

    // the scan out viewport in (at the front end, i.e. the compositor/CRTC).
    // defined in the normalized desktop coordinates
    NV_VIEWPORTF            viewportIn ;       // not used now

    // the scaling mode
    NV_SCALING              scaling;
    
    // the scan out viewport out (at the front end, i.e. the compositor/CRTC). 
    // this is for the future arbitrary scaling support (not supported by any the current GPUs)
    // defined in the normalized raster/backend timing coordinates
    // viewportOut is not supported yet, must be set to {0.0, 0.0, 0.0, 0.0}
    NV_VIEWPORTF            viewportOut;       // not used now

    // the backend (raster) timing standard
    NV_TIMING_OVERRIDE      timingOverride; 

    NvU32                   refreshRate;        //!< only used for backward compatible when NV_DISP_PATH_VER1 is specified
    NvU32                   interlaced    :1;   //!< only used for backward compatible when NV_DISP_PATH_VER1 is specified
    NvU32                   hwModeSetOnly :1;   //!< if this flag is set, the modeset is a pure h/w modeset without OS update. Only used with NV_DISP_PATH_VER;
    NvU32                   SelectCustomTiming:1;    //!< For HD modes over DVI to select custom timings
    NvU32                   needNullModeset   :1;    //!< Read only - indicating a NULL modeset is needed on this monitor (for internal DP link training)
    NvU32                   need6x4Modeset    :1;    //!< Read only - indicating a 640x480x32 at 60Hz modeset is needed (for bad EDID on DP fallback)
    NvU32                   forceModeSet      :1;    //!< Used only on Win7 and higher during a call to NvAPI_SetDisplaySettings(). Turns off optimization & forces OS to set supplied mode.
    NvU32                   gpuId             :24;   //!< The display/target physical Gpu ID which is the owner of the scan out (for SLI multimon, display from the slave Gpu)
    NvU32                   isSliFocusDisplay :1;    //!< this display path is the sli focus (so far it's read only)
    NvU32                   forceModeEnum     :1;    //!< Used only on Windows7 and higher during a call to NvAPI_SetDisplaySettings(). Requests a modeset after forced mode enumeration.

    NV_DISPLAY_TV_FORMAT    tvFormat;           //!<  Valid only on TV device. Set to 0 for other devices.
    NV_TIMING               timing;             //!<  The scan out timing, NV_DISP_PATH_VER2 only, ignored it's on analog TV.
} NV_DISP_PATH_V1;

//! \ingroup dispcontrol
typedef struct
{
    NvU32                   version;    //!< Structure version

    NvU32                   device;     //!< target display ids or target device mask
    NV_GPU_CONNECTOR_TYPE   connector;

    // the source display index
    NvU32                   srcID;

    // the source importance
    NvU32                   srcImportance; //!<(OUT) Indicates if this is the GPU's primary view target. This is not the desktop GDI primary.
                                           //!<NvAPI_SetDisplaySettings automatically selects the first target in NV_DISP_PATH index 0 as the GPU's primary view.
    // the source mode information
    NvU32                   width;
    NvU32                   height;
    NvU32                   depth;
    NV_ROTATE               rotation;
    NV_FORMAT               colorFormat;       //!< Color format. Not used now.

    // the section of the source surface for scan out, defined in normalized desktop coordinates
    NV_VIEWPORTF            srcPartition;      //!< Not used now.

    // the scan out viewport in (at the front end, i.e. the compositor/CRTC).
    // defined in the normalized desktop coordinates
    NV_VIEWPORTF            viewportIn ;       //!< Not used now.


    // the scaling mode
    NV_SCALING              scaling;

    // the scan out viewport out (at the front end, i.e. the compositor/CRTC).
    // this is for the future arbitrary scaling support (not supported by any the current GPUs)
    // defined in the normalized raster/backend timing coordinates
    // viewportOut is not supported yet, must be set to {0.0, 0.0, 0.0, 0.0}
    NV_VIEWPORTF            viewportOut;       // not used now

    // the backend (raster) timing standard
    NV_TIMING_OVERRIDE      timingOverride;

    NvU32                   refreshRate;        //!< Only used for backward compatible when NV_DISP_PATH_VER1 is specified.
    NvU32                   interlaced    :1;   //!< Only used for backward compatible when NV_DISP_PATH_VER1 is specified.
    NvU32                   hwModeSetOnly :1;   //!< If this flag is set, the modeset is a pure h/w modeset without OS update. Only used with NV_DISP_PATH_VER.
    NvU32                   SelectCustomTiming:1;    //!< For HD modes over DVI to select custom timings.
    NvU32                   needNullModeset   :1;    //!< For read only - indicating a NULL modeset is needed on this monitor (for internal DP link training)
    NvU32                   need6x4Modeset    :1;    //!< For read only - indicating a 640x480x32bppx60Hz modeset is needed (for DP bad EDID fallback)
    NvU32                   forceModeSet      :1;    //!< Used only on Win7 and higher during a call to NvAPI_SetDisplaySettings. Turns off optimization & forces the OS to set supplied mode.
    NvU32                   gpuId             :24;   //!< The display/target physical GPU id which is the owner of the scan out (for SLI multimon, display from the slave GPU)
    NvU32                   isSliFocusDisplay :1;    //!< This display path is the SLI focus (so far it's read only).
    NvU32                   forceModeEnum     :1;    //!< Used only on Win7 and higher during a call to NvAPI_SetDisplaySettings. Requests a modeset after forced mode enumeration.

    NV_DISPLAY_TV_FORMAT    tvFormat;           //!< Valid only on TV device. set to 0 for other devices.

    NV_TIMING               timing;             //!< The scan out timing, NV_DISP_PATH_VER2 only, ignored if it's on analog TV.
    
    NvU32                   refreshRate1K;      //!< Refresh rate reported to the OS.
} NV_DISP_PATH_V2;


//! \ingroup dispcontrol
typedef NV_DISP_PATH_V2 NV_DISP_PATH;


//! \addtogroup dispcontrol
//! Macros for constructing the version field of NV_DISP_PATH
//! @{
#define NV_DISP_PATH_VER3 MAKE_NVAPI_VERSION(NV_DISP_PATH_V1, 3)
#define NV_DISP_PATH_VER2 MAKE_NVAPI_VERSION(NV_DISP_PATH_V1, 2)
#define NV_DISP_PATH_VER1 MAKE_NVAPI_VERSION(NV_DISP_PATH_V1, 1)
#define NV_DISP_PATH_VER4 MAKE_NVAPI_VERSION(NV_DISP_PATH_V2, 4)

#define NV_DISP_PATH_VER  NV_DISP_PATH_VER4

//! @}


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SetDisplaySettings
//
//!  This function sets the display settings for the selected display sources.
//!   \note Display PATH with this API is limited to a single GPU. DualView across GPUs cannot be enabled with this API. 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 100
//!
//! \param [in]  hNvDisplay      NVIDIA Display selection \n
//!                              #NVAPI_DEFAULT_HANDLE is not allowed, it must be a handle enumerated with NvAPI_EnumNVidiaDisplayHandle().
//! \param [in]  paths          Detailed target display arrangement for clone, span and edge blending display modes.
//! \param [in]  pathCount       Count of targets for the selected display source.
//!
//! \retval  NVAPI_OK                Completed request
//! \retval  NVAPI_ERROR             Miscellaneous error occurred.
//! \retval  NVAPI_INVALID_ARGUMENT  Invalid input parameter
//! \retval  NVAPI_INCOMPATIBLE_STRUCT_VERSION  Incorrect struct version specified.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetDisplaySettings(NvDisplayHandle hNvDisplay, NV_DISP_PATH *paths, NvU32 pathCount);





///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_SetView
//
//! \fn NvAPI_SetView(NvDisplayHandle hNvDisplay, NV_VIEW_TARGET_INFO *pTargetInfo, NV_TARGET_VIEW_MODE targetView)
//!  This function lets the caller modify the target display arrangement of the selected source display handle in any nView mode.
//!  It can also modify or extend the source display in Dualview mode.
//!  \note Maps the selected source to the associated target Ids.
//!  \note Display PATH with this API is limited to single GPU. DUALVIEW across GPUs cannot be enabled with this API. 
//!
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_DISP_SetDisplayConfig.
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 90
//!
//! \param [in]  hNvDisplay       NVIDIA Display selection. #NVAPI_DEFAULT_HANDLE is not allowed, it has to be a handle enumerated with NvAPI_EnumNVidiaDisplayHandle().
//! \param [in]  pTargetInfo      Pointer to array of NV_VIEW_TARGET_INFO, specifying device properties in this view.
//!                               The first device entry in the array is the physical primary.
//!                               The device entry with the lowest source id is the desktop primary.
//! \param [in]  targetCount      Count of target devices specified in pTargetInfo.
//! \param [in]  targetView       Target view selected from NV_TARGET_VIEW_MODE.
//!
//! \retval  NVAPI_OK               Completed request
//! \retval  NVAPI_ERROR            Miscellaneous error occurred
//! \retval  NVAPI_INVALID_ARGUMENT Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup dispcontrol
//! Used in NvAPI_SetView() and NvAPI_GetView()
typedef struct
{
    NvU32 version;     //!< (IN) structure version
    NvU32 count;       //!< (IN) target count
    struct 
    {
        NvU32 deviceMask;    //!< (IN/OUT) Device mask
        NvU32 sourceId;      //!< (IN/OUT) Source ID - values will be based on the number of heads exposed per GPU.
        NvU32 bPrimary:1;    //!< (OUT) Indicates if this is the GPU's primary view target. This is not the desktop GDI primary.
                             //!< NvAPI_SetView automatically selects the first target in NV_VIEW_TARGET_INFO index 0 as the GPU's primary view.
        NvU32 bInterlaced:1; //!< (IN/OUT) Indicates if the timing being used on this monitor is interlaced.
        NvU32 bGDIPrimary:1; //!< (IN/OUT) Indicates if this is the desktop GDI primary.
        NvU32 bForceModeSet:1;//!< (IN) Used only on Win7 and higher during a call to NvAPI_SetView(). Turns off optimization & forces OS to set supplied mode.
    } target[NVAPI_MAX_VIEW_TARGET];
} NV_VIEW_TARGET_INFO; 

//! \ingroup dispcontrol
#define NV_VIEW_TARGET_INFO_VER  MAKE_NVAPI_VERSION(NV_VIEW_TARGET_INFO,2)


//! \ingroup dispcontrol
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use NvAPI_DISP_SetDisplayConfig.")
NVAPI_INTERFACE NvAPI_SetView(NvDisplayHandle hNvDisplay, NV_VIEW_TARGET_INFO *pTargetInfo, NV_TARGET_VIEW_MODE targetView);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_SetViewEx
//
//!  \fn NvAPI_SetViewEx(NvDisplayHandle hNvDisplay, NV_DISPLAY_PATH_INFO *pPathInfo, NV_TARGET_VIEW_MODE displayView)
//!  This function lets caller to modify the display arrangement for selected source display handle in any of the nview modes.
//!  It also allows to modify or extend the source display in dualview mode.
//!   \note Maps the selected source to the associated target Ids.
//!   \note Display PATH with this API is limited to single GPU. DUALVIEW across GPUs cannot be enabled with this API. 
//!
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_DISP_SetDisplayConfig.
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 95
//!
//! \param [in]  hNvDisplay   NVIDIA Display selection. #NVAPI_DEFAULT_HANDLE is not allowed, it has to be a handle enumerated with 
//!                           NvAPI_EnumNVidiaDisplayHandle().
//! \param [in]  pPathInfo    Pointer to array of NV_VIEW_PATH_INFO, specifying device properties in this view.
//!                           The first device entry in the array is the physical primary.
//!                           The device entry with the lowest source id is the desktop primary.
//! \param [in]  pathCount    Count of paths specified in pPathInfo.
//! \param [in]  displayView  Display view selected from NV_TARGET_VIEW_MODE.
//!
//! \retval  NVAPI_OK                Completed request
//! \retval  NVAPI_ERROR             Miscellaneous error occurred
//! \retval  NVAPI_INVALID_ARGUMENT  Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup dispcontrol
#define NVAPI_MAX_DISPLAY_PATH  NVAPI_MAX_VIEW_TARGET

//! \ingroup dispcontrol
#define NVAPI_ADVANCED_MAX_DISPLAY_PATH  NVAPI_ADVANCED_MAX_VIEW_TARGET



//! \ingroup dispcontrol
//! Used in NV_DISPLAY_PATH_INFO.
typedef struct
{
    NvU32                   deviceMask;     //!< (IN) Device mask
    NvU32                   sourceId;       //!< (IN) Values will be based on the number of heads exposed per GPU(0, 1?)
    NvU32                   bPrimary:1;     //!< (IN/OUT) Indicates if this is the GPU's primary view target. This is not the desktop GDI primary.
                                            //!< NvAPI_SetViewEx() automatically selects the first target in NV_DISPLAY_PATH_INFO index 0 as the GPU's primary view.
    NV_GPU_CONNECTOR_TYPE   connector;      //!< (IN) Specify connector type. For TV only.

    // source mode information
    NvU32                   width;          //!< (IN) Width of the mode
    NvU32                   height;         //!< (IN) Height of the mode
    NvU32                   depth;          //!< (IN) Depth of the mode
    NV_FORMAT               colorFormat;    //!<      Color format if it needs to be specified. Not used now.

    //rotation setting of the mode
    NV_ROTATE               rotation;       //!< (IN) Rotation setting.

    // the scaling mode
    NV_SCALING              scaling;        //!< (IN) Scaling setting

    // Timing info
    NvU32                   refreshRate;    //!< (IN) Refresh rate of the mode
    NvU32                   interlaced:1;   //!< (IN) Interlaced mode flag

    NV_DISPLAY_TV_FORMAT    tvFormat;       //!< (IN) To choose the last TV format set this value to NV_DISPLAY_TV_FORMAT_NONE

    // Windows desktop position
    NvU32                   posx;           //!< (IN/OUT) X-offset of this display on the Windows desktop
    NvU32                   posy;           //!< (IN/OUT) Y-offset of this display on the Windows desktop
    NvU32                   bGDIPrimary:1;  //!< (IN/OUT) Indicates if this is the desktop GDI primary.

    NvU32                   bForceModeSet:1;//!< (IN) Used only on Win7 and higher during a call to NvAPI_SetViewEx(). Turns off optimization & forces OS to set supplied mode.
    NvU32                   bFocusDisplay:1;//!< (IN) If set, this display path should have the focus after the GPU topology change
    NvU32                   gpuId:24;       //!< (IN) the physical display/target Gpu id which is the owner of the scan out (for SLI multimon, display from the slave Gpu)

} NV_DISPLAY_PATH;

//! \ingroup dispcontrol
//! Used in NvAPI_SetViewEx() and NvAPI_GetViewEx().
typedef struct
{
    NvU32 version;     //!< (IN) Structure version
    NvU32 count;       //!< (IN) Path count
    NV_DISPLAY_PATH path[NVAPI_MAX_DISPLAY_PATH];
} NV_DISPLAY_PATH_INFO_V3; 

//! \ingroup dispcontrol
//! Used in NvAPI_SetViewEx() and NvAPI_GetViewEx().
typedef struct
{
    NvU32 version;     //!< (IN) Structure version
    NvU32 count;       //!< (IN) Path count
    NV_DISPLAY_PATH path[NVAPI_ADVANCED_MAX_DISPLAY_PATH];
} NV_DISPLAY_PATH_INFO; 

//! \addtogroup dispcontrol
//! Macro for constructing the version fields of NV_DISPLAY_PATH_INFO
//! @{
#define NV_DISPLAY_PATH_INFO_VER  NV_DISPLAY_PATH_INFO_VER4
#define NV_DISPLAY_PATH_INFO_VER4 MAKE_NVAPI_VERSION(NV_DISPLAY_PATH_INFO,4)
#define NV_DISPLAY_PATH_INFO_VER3 MAKE_NVAPI_VERSION(NV_DISPLAY_PATH_INFO,3)
#define NV_DISPLAY_PATH_INFO_VER2 MAKE_NVAPI_VERSION(NV_DISPLAY_PATH_INFO,2)
#define NV_DISPLAY_PATH_INFO_VER1 MAKE_NVAPI_VERSION(NV_DISPLAY_PATH_INFO,1)
//! @}


//! \ingroup dispcontrol
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use NvAPI_DISP_SetDisplayConfig.")
NVAPI_INTERFACE NvAPI_SetViewEx(NvDisplayHandle hNvDisplay, NV_DISPLAY_PATH_INFO *pPathInfo, NV_TARGET_VIEW_MODE displayView);




///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetHDCPLinkParameters
//
//!    \fn NvAPI_GetHDCPLinkParameters(NvDisplayHandle hNvDisplay, NV_HDCP_INFO *pNvHdcpInfo
//!    This function enumerate fields within the NV_HDCP_INFO.
//!
//!    The API provides support for the HDCP Upstream Protocol. The caller is responsible to fill the input fields 
//!    within NV_HDCP_PACKET to ensure that the specified HDCP_COMMANDS can be fulfilled. Different HDCP_COMMANDS will 
//!    enumerate different fields inside NV_HDCP_INFO. The following are the HDCP_COMMANDS supported   
//!
//!    - (A) HDCP_CMD_QUERY_HEAD_CONFIG  : Enumerates ports attached to a head. 
//!    - (B) HDCP_CMD_READ_LINK_STATUS   : Reads the Status of the cipher returning a signed status and connection state. 
//!    - (C) HDCP_CMD_VALIDATE_LINK      : Returns the parameters necessary to validate the links for the specified attach-point.
//!    - (D) HDCP_CMD_RENEGOTIATE        : Forced renegotiation of the link.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 95
//!
//! \param [in]     hNvDisplay        NVIDIA Display selection. It should be a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//! \param [in]     pNvHdcpInfo       Pointer to NV_HDCP_INFO that contains the requested command and input parameters.
//!
//! \retval         NVAPI_OK                           Completed request
//! \retval         NVAPI_ERROR                        Miscellaneous error occurred.
//! \retval         NVAPI_INVALID_ARGUMENT             pNvHdcpPacket is NULL.
//! \retval         NVAPI_INCOMPATIBLE_STRUCT_VERSION  The version of NV_HDCP_INFO struct is not supported.
//
///////////////////////////////////////////////////////////////////////////////


//! \addtogroup dispcontrol
//! @{

#define NVAPI_MAX_NUM_AP        16      //!< Max number of ports / attach points supported in HDCP Connection State
#define NVAPI_MAX_DEVICES       127     //!< Max number of Receiver & Repeater devices



//! Used in NV_HDCP_PACKET
typedef struct 
{
    union 
    {
        NvU32  data1;
        struct 
        {
            NvU8    revMin;
            NvU8    revMaj;
            NvU8    verMin;
            NvU8    verMaj;
        } ver;
    };
    NvU16 data2;
    NvU16 data3;
    NvU8  data4[8];
} NV_UID;


//! Used in NV_HDCP_PACKET
typedef struct 
{
#pragma pack(1)
    NvU64 uSessionID    : 37;   //!< [36:0] Random number
    NvU64 uDisplay      : 3;    //!< [39:37] O/S level display device
    NvU64 uReserved     : 24;   //!< [63:40] Reserved
#pragma pack()
} NV_HDCP_CN;


//! Used in NV_HDCP_PACKET
typedef struct 
{
    union 
    {
        NvU64   quadWord;
        struct 
        {
            NvU64 hugePart      : 40; // lower 40 in little endian
            NvU64 unusedPart    : 24;
        } parts;
    };
} NV_U40;


//! Used in NV_HDCP_PACKET
typedef struct
{
    union 
    {
        NvU64   quadWord;
        struct 
        {
            NvU64 hugePart      : 56; // lower 56 in little endian
            NvU64 unusedPart    : 8;
        } parts;
    };
} NV_U56;


//! Structure of data returned from monitor - as defined in HDCP Spec \n
//! Used in NV_HDCP_PACKET
typedef struct 
{
#pragma pack(1)
    NvU32 ucDeviceCount         : 7;    //!< [6:0] Total Receivers (except rep)
    NvU32 bMaxDevicesExceeded   : 1;    //!< [7] Topology Error > 127 devices 
    NvU32 bRepeaterDepth        : 3;    //!< [10:8] Repeater depth 
    NvU32 bMaxCascadeExceeded   : 1;    //!< [11] Topology Error > 7 levels repeater 
    NvU32 bHDMImode             : 1;    //!< [12] HDCP Receiver in HDMI mode
    NvU32 bReserved             : 19;   //!< [31:13] Reserved for future expansion
#pragma pack()
} NV_HDCP_BSTATUS;

//! The Connection State \n
//! Used in NV_HDCP_PACKET
typedef struct 
{
#pragma pack(1)
    NvU64 uAttachPoints         : 16;       //!< [15:0] Transmitting Attach Point    
    NvU64 bNonHDCP              : 1;        //!< [16] Transmitting Attach Point 
    NvU64 uHeadIndex            : 4;        //!< [20:17] Index of Head
    NvU64 uRFUPlanes            : 8;        //!< [28:21] *NOT* yet supported
    NvU64 uNumberOfActiveHeads  : 1;        //!< [29:29] Number of Heads - 1, To be removed as it has invalid bit size to fit  number of heads
    NvU64 bHDCP22Encrypting     : 1;        //!< [30:30] HDCP22 encryption status
    NvU64 uStreamIdType         : 1;        //!< [31:31] HDCP22 StreamID Type 
    NvU64 uReserved2            : 8;        //!< [39:32] Reserved for future use
    NvU64 uAttachedPlanes       : 8;        //!< [47:40] Will be moved to 28:21 in future chips
    NvU64 bCloneMode            : 1;        //!< [48] Dual-Display Clone Mode *NOT* yet supported
    NvU64 bSpanMode             : 1;        //!< [49] Dual-Display Span Mode *NOT* yet supported
    NvU64 reserved              : 14;       //!< [63:50] To fill up qword
#pragma pack()
} NV_HDCP_CS;

//! The Status of the Attach-Point (HDCP-capable or other) \n
//! Used in NV_HDCP_PACKET
typedef struct
{
#pragma pack(1)
    NvU64 bEncrypting           : 1;        //!<  [0] This Attach Point is Transmitting and has Output Encryption Enabled
    NvU64 bRepeater             : 1;        //!<  [1] This Attach Point is Transmitting to a Repeater 
    NvU64 bUserAccessible       : 1;        //!<  [2] This Attach Point is Transmitting on a user-accessible external digital port
    NvU64 bExtUnprotected       : 1;        //!<  [3] This Attach-point is Transmitting externally and is unprotected
    NvU64 uPortIndex            : 4;        //!<  [7:4] Port/Attach-point index
    NvU64 uNumPorts             : 4;        //!<  [11:8] Number of Connectable
    NvU64 bInternalPanel        : 1;        //!<  [12] Compliant Internal / Non-User accessible Port Panel without HDCP Encryption
    NvU64 bWideScope            : 1;        //!<  [13] Cs:16 is not enough to determine presence of non-compliant outputs+    (always '1')
    NvU64 bHasCs                : 1;        //!<  [14] Supports Connection State (always '1')
    NvU64 bReadZ                : 1;        //!<  [15] Supports ReadZ (always '0')
    NvU64 uReserved             : 24;       //!<  [39:16] Reserved for Future Expansion
    NvU64 bDualLinkEven         : 1;        //!<  [40] The Even half of a Dual-Link (0x74)
    NvU64 bDualLinkOdd          : 1;        //!<  [41] The Odd half of a Dual-Link (0x76)
    NvU64 bDualLinkCapable      : 1;        //!<  [42] This Attach Point has Dual-Link capability
    NvU64 reserved              : 21;       //!<  [63:43] To fill up qword
    NvU32 DisplayId;                        //!<  ID of the Display on this attach point
#pragma pack()
} NV_HDCP_STATUS;

// Structure of data returned from monitor - as defined in HDCP Spec
typedef struct {
#pragma pack(1)
    NvU32 BCaps                 : 15;   // [14:0]  BCaps of HDCP22/HDCP1X
    NvU32 HDCPMode              : 1;    // [15:15] HDCP opearting mode DP/TMDS
    NvU32 HDCPVersion           : 8;    // [23:16] HDCP Version
    NvU32 bReserved             : 8;    // [31:24] Reserved for future expansion
#pragma pack()
} NV_HDCP_BCAPS;


//! Flags used for indicating active member elements \n
//! Used in NV_HDCP_PACKET
typedef enum 
{
    NV_HDCP_FLAGS_NULL          = 0x00000000, //!< Get AP Status
    NV_HDCP_FLAGS_APINDEX       = 0x00000001, //!< Index of Attach Point
    NV_HDCP_FLAGS_AN            = 0x00000010, //!< Downstream Session ID
    NV_HDCP_FLAGS_AKSV          = 0x00000020, //!< Downstream/Xmtr KSV
    NV_HDCP_FLAGS_BKSV          = 0x00000040, //!< Downstream/Rcvr KSV
    NV_HDCP_FLAGS_BSTATUS       = 0x00000080, //!< Link/Repeater Status
    NV_HDCP_FLAGS_CN            = 0x00000100, //!< Upstream Session ID
    NV_HDCP_FLAGS_CKSV          = 0x00000200, //!< Upstream ClientApp KSV
    NV_HDCP_FLAGS_DKSV          = 0x00000400, //!< Upstream/Xmtr KSV
    NV_HDCP_FLAGS_KP            = 0x00001000, //!< Signature
    NV_HDCP_FLAGS_S             = 0x00002000, //!< Status 
    NV_HDCP_FLAGS_CS            = 0x00004000, //!< Connection State
    NV_HDCP_FLAGS_V             = 0x00010000, //!< V of the KSVList
    NV_HDCP_FLAGS_MP            = 0x00020000, //!< Encrypted initializer for KSV List
    NV_HDCP_FLAGS_BKSVLIST      = 0x00040000, //!< NumKsvs & BksvList[NumKsvs]
    NV_HDCP_FLAGS_DUAL_LINK     = 0x00100000, //!< Two sets of An, Aksv, Kp, Bksv, Dksv
    NV_HDCP_FLAGS_ALWAYS_AUTH   = 0x00200000, //!< Always authenticate
    NV_HDCP_FLAGS_ON_BY_DEMAND  = 0x00000000, //!< Authenticate on demand
    NV_HDCP_FLAGS_ABORT_UNTRUST = 0x00400000, //!< Abort, Kp didn't match
    NV_HDCP_FLAGS_ABORT_UNRELBL = 0x00800000, //!< Abort, Repeated Link Failures
    NV_HDCP_FLAGS_ABORT_KSV_LEN = 0x01000000, //!< Abort, incorrect KSV Length
    NV_HDCP_FLAGS_ABORT_KSV_SIG = 0x02000000, //!< Abort, bad KSV Signature
    NV_HDCP_FLAGS_ABORT_SRM_SIG = 0x04000000, //!< Abort, bad SRM Signature
    NV_HDCP_FLAGS_ABORT_SRM_REV = 0x08000000, //!< Abort due to SRM Revocation
    NV_HDCP_FLAGS_ABORT_NORDY   = 0x10000000, //!< Abort, Repeater Not Ready
    NV_HDCP_FLAGS_ABORT_KSVTOP  = 0x20000000, //!< Abort, KSV Topology Error
    NV_HDCP_FLAGS_ABORT_BADBKSV = 0x40000000, //!< Abort due to invalid Bksv
} NV_HDCP_FLAGS;

//! HDCP Commands \n
//! Used in NV_HDCP_PACKET
typedef enum 
{
    NV_HDCP_CMD_NULL               = 0x00, //!< Null command
    NV_HDCP_CMD_QUERY_HEAD_CONFIG  = 0x01, //!< Status of the head attach-points
    NV_HDCP_CMD_READ_LINK_STATUS   = 0x02, //!< Get the Status 
    NV_HDCP_CMD_VALIDATE_LINK      = 0x03, //!< Gets M & V 
    NV_HDCP_CMD_RENEGOTIATE        = 0x04, //!< Forced renegotiation of the link
    NV_HDCP_CMD_ABORTAUTHENTICATION= 0x05, //!< Abort authentication protocol
    NV_HDCP_CMD_SETLINKPOLICY      = 0x06, //!< Set the link policy  
} NV_HDCP_COMMANDS;


//! HDCP Return Status \n
//! Used in NV_HDCP_PACKET 
typedef enum 
{
    NV_HDCP_STATUS_SUCCESS                 = (0x00000000L), //!< Function completed successfully
    NV_HDCP_STATUS_UNSUCCESSFUL            = (0xC0000001L), //!< Function failed
    NV_HDCP_STATUS_PENDING                 = (0x00000103L), //!< Renegotiation is not complete, check status later
    NV_HDCP_STATUS_LINK_FAILED             = (0xC000013EL), //!< Renegotiation could not complete
    NV_HDCP_STATUS_INVALID_PARAMETER       = (0xC000000DL), //!< One or more of the calling parameters was invalid
    NV_HDCP_STATUS_INVALID_PARAMETER_MIX   = (0xC0000030L), //!< The combination of flFlags was invalid
    NV_HDCP_STATUS_NO_MEMORY               = (0xC0000017L), //!< Insufficient buffer space was allocated. Re-allocate using the size returned in the dwSize member
    NV_HDCP_STATUS_BAD_TOKEN_TYPE          = (0xC00000A8L), //!< The Session ID &/or KSV supplied were rejected
} NV_HDCP_RET_STATUS;


//! HDCP Packet \n
//! Used in NV_HDCP_INFO
typedef struct _NV_HDCP_PACKET_V1
{
#pragma pack(4)
    NV_UID              uidHDCP;                        //!<  (IN) 
    NvU32               packetSize;                     //!<  (IN/OUT)
    NvU32               hDisplayContext;                //!<  (IN/OUT) 
    NV_HDCP_COMMANDS    cmdCommand;                     //!<  (IN)
    NV_HDCP_FLAGS       flFlags;                        //!<  (IN/OUT) 
    NV_HDCP_RET_STATUS  hdcpPacketStatus;               //!<  (OUT)

    NvU32               apIndex;                        //!<  (IN) Attach point index
    NV_HDCP_CN          cN;                             //!<  (IN) Client Session ID
    NV_U40              cKsv;                           //!<  (IN)

    NV_HDCP_BSTATUS     bStatus[NVAPI_MAX_NUM_AP];      //!<  (OUT) 
    NV_HDCP_STATUS      hdcpStatus[NVAPI_MAX_NUM_AP];   //!<  (OUT)
    NV_HDCP_CS          cS;                             //!<  (OUT) Connection State
         
    NV_U56              kP[2];                          //!<  (OUT) KPRIME value
    NV_U40              aN[2];                          //!<  (OUT)
    NV_U40              aKsv[2];                        //!<  (OUT)
    NV_U40              dKsv[2];                        //!<  (OUT) 
    NvU8                vP[20];                         //!<  (OUT) VPRIME value
    NvU64               mP;                             //!<  (OUT) MPRIME value
    NvU32               numBKSVs;                       //!<  (OUT) Valid KSVs in the bKsvList. Maximum is 127 devices 
    NV_U40              bKsvList[NVAPI_MAX_DEVICES];    //!<  (OUT) Up to 127 receivers & repeaters
#pragma pack()
} NV_HDCP_PACKET_V1;

//! HDCP Packet \n
//! Used in NV_HDCP_INFO
typedef struct _NV_HDCP_PACKET
{
#pragma pack(4)
    NV_UID              uidHDCP;                        //!<  (IN) 
    NvU32               packetSize;                     //!<  (IN/OUT)
    NvU32               hDisplayContext;                //!<  (IN/OUT) 
    NV_HDCP_COMMANDS    cmdCommand;                     //!<  (IN)
    NV_HDCP_FLAGS       flFlags;                        //!<  (IN/OUT) 
    NV_HDCP_RET_STATUS  hdcpPacketStatus;               //!<  (OUT)

    NvU32               apIndex;                        //!<  (IN) Attach point index
    NV_HDCP_CN          cN;                             //!<  (IN) Client Session ID
    NV_U40              cKsv;                           //!<  (IN)

    NV_HDCP_BSTATUS     bStatus[NVAPI_MAX_NUM_AP];      //!<  (OUT) 
    NV_HDCP_STATUS      hdcpStatus[NVAPI_MAX_NUM_AP];   //!<  (OUT)
    NV_HDCP_CS          cS;                             //!<  (OUT) Connection State
         
    NV_U56              kP[2];                          //!<  (OUT) KPRIME value
    NV_U40              aN[2];                          //!<  (OUT)
    NV_U40              aKsv[2];                        //!<  (OUT)
    NV_U40              dKsv[2];                        //!<  (OUT) 
    NvU8                vP[20];                         //!<  (OUT) VPRIME value
    NvU64               mP;                             //!<  (OUT) MPRIME value
    NvU32               numBKSVs;                       //!<  (OUT) Valid KSVs in the bKsvList. Maximum is 127 devices 
    NV_U40              bKsvList[NVAPI_MAX_DEVICES];    //!<  (OUT) Up to 127 receivers & repeaters
    NV_HDCP_BCAPS       hdcpBCaps[NVAPI_MAX_NUM_AP];    //!<  (OUT)
#pragma pack()
} NV_HDCP_PACKET;

//! Used in NvAPI_GetHDCPLinkParameters()
typedef struct _NV_HDCP_INFO_V1
{
    NvU32 version;
    NV_HDCP_PACKET_V1 nvHdcpPacket;
} NV_HDCP_INFO_V1;

//! Used in NvAPI_GetHDCPLinkParameters()
typedef struct _NV_HDCP_INFO_V2
{
    NvU32 version;
    NV_HDCP_PACKET nvHdcpPacket;
} NV_HDCP_INFO_V2;

typedef NV_HDCP_INFO_V2 NV_HDCP_INFO; 

#define NV_HDCP_INFO_VER1  MAKE_NVAPI_VERSION(NV_HDCP_INFO_V1,1)
#define NV_HDCP_INFO_VER2  MAKE_NVAPI_VERSION(NV_HDCP_INFO_V2,2)

#define NV_HDCP_INFO_VER  NV_HDCP_INFO_VER2

//! @}


//! \ingroup dispcontrol
NVAPI_INTERFACE NvAPI_GetHDCPLinkParameters(__in NvDisplayHandle hNvDisplay, __out NV_HDCP_INFO *pNvHdcpInfo);





//! \ingroup hybridapi
#define NVAPI_MAX_3D_Apps 128

//! \ingroup hybridapi
//! Structure to get application processIds and processNames. \n
//! Used in NvAPI_QueryNonMigratableApps(). 
typedef struct
{
  NvU32 version;    //!< Structure version
  NvU32 processId;
  NvAPI_ShortString   processName;
}NV_3D_APP_INFO_V1;

typedef struct
{
  NvU32 version;    // Structure version
  NvU32 processId;
  NvAPI_LongString   processName;
} NV_3D_APP_INFO_V2;

typedef NV_3D_APP_INFO_V2     NV_3D_APP_INFO;



//! \ingroup hybridapi
//! Used in NV_3D_APP_INFO.
//! Macro for constructing the version field of NV_3D_APP_INFO
//! @{
#define NV_3D_APP_INFO_VER_1  MAKE_NVAPI_VERSION(NV_3D_APP_INFO_V1,1)
#define NV_3D_APP_INFO_VER_2  MAKE_NVAPI_VERSION(NV_3D_APP_INFO_V2,2)
#define NV_3D_APP_INFO_VER    NV_3D_APP_INFO_VER_2
//! @}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_QueryNonMigratableApps
//
//!  This function queries all non-migratable applications which block successful driver reload such 
//!  as for SLI or Hybrid transitions.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 173
//!
//! \param [in,out]  apps       Empty structure passed as an input and upon successful exit, 
//!                             contains a list of non-migratable applications and processIDs.
//! \param [in,out]  total      Total number of non-migratable applications currently running in the system.
//! 
//! \retval          NVAPI_OK                 Completed request
//! \retval          NVAPI_ERROR              Miscellaneous error occurred
//! \retval          NVAPI_INVALID_ARGUMENT   Invalid input parameter
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_QueryNonMigratableApps(NV_3D_APP_INFO apps[NVAPI_MAX_3D_Apps], NvU32 *total);




#ifndef NV_PAN_AND_SCAN_DEFINED
#define NV_PAN_AND_SCAN_DEFINED
#endif


///////////////////////////////////////////////////////////////////////////////
// SetDisplayConfig/GetDisplayConfig
///////////////////////////////////////////////////////////////////////////////
//! \ingroup dispcontrol

typedef struct _NV_POSITION
{
    NvS32   x;
    NvS32   y;
} NV_POSITION;

//! \ingroup dispcontrol
typedef struct _NV_RESOLUTION
{
    NvU32   width;
    NvU32   height;
    NvU32   colorDepth;
} NV_RESOLUTION;

//! \ingroup dispcontrol
typedef struct _NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1
{
    NvU32                   version;

    // Rotation and Scaling
    NV_ROTATE               rotation;       //!< (IN) rotation setting.
    NV_SCALING              scaling;        //!< (IN) scaling setting.

    // Refresh Rate
    NvU32                   refreshRate1K;  //!< (IN) Non-interlaced Refresh Rate of the mode, multiplied by 1000, 0 = ignored
                                            //!< This is the value which driver reports to the OS.
    // Flags
    NvU32                   interlaced:1;   //!< (IN) Interlaced mode flag, ignored if refreshRate == 0
    NvU32                   primary:1;      //!< (IN) Declares primary display in clone configuration. This is *NOT* GDI Primary.
                                            //!< Only one target can be primary per source. If no primary is specified, the first 
                                            //!< target will automatically be primary.
#ifdef NV_PAN_AND_SCAN_DEFINED 
    NvU32                   isPanAndScanTarget:1; //!< Whether on this target Pan and Scan is enabled or has to be enabled. Valid only 
                                                  //!< when the target is part of clone topology.
#else
    NvU32                   reservedBit1:1;
#endif
    NvU32                   disableVirtualModeSupport:1;
    NvU32                   isPreferredUnscaledTarget:1;
    NvU32                   reserved:27;  
    // TV format information
    NV_GPU_CONNECTOR_TYPE   connector;      //!< Specify connector type. For TV only, ignored if tvFormat == NV_DISPLAY_TV_FORMAT_NONE
    NV_DISPLAY_TV_FORMAT    tvFormat;       //!< (IN) to choose the last TV format set this value to NV_DISPLAY_TV_FORMAT_NONE
                                            //!< In case of NvAPI_DISP_GetDisplayConfig(), this field will indicate the currently applied TV format;
                                            //!< if no TV format is applied, this field will have NV_DISPLAY_TV_FORMAT_NONE value.
                                            //!< In case of NvAPI_DISP_SetDisplayConfig(), this field should only be set in case of TVs; 
                                            //!< for other displays this field will be ignored and resolution & refresh rate specified in input will be used to apply the TV format.

    // Backend (raster) timing standard
    NV_TIMING_OVERRIDE      timingOverride;     //!< Ignored if timingOverride == NV_TIMING_OVERRIDE_CURRENT
    NV_TIMING               timing;             //!< Scan out timing, valid only if timingOverride == NV_TIMING_OVERRIDE_CUST
                                                //!< The value NV_TIMING::NV_TIMINGEXT::rrx1k is obtained from the EDID. The driver may 
                                                //!< tweak this value for HDTV, stereo, etc., before reporting it to the OS. 
} NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1;

//! \ingroup dispcontrol
typedef NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1 NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO;

//! \ingroup dispcontrol
#define NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_VER1     MAKE_NVAPI_VERSION(NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1,1)

//! \ingroup dispcontrol
#define NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_VER      NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_VER1

//! \ingroup dispcontrol
typedef struct _NV_DISPLAYCONFIG_PATH_TARGET_INFO_V1
{
    NvU32                                           displayId;  //!< Display ID
    NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO*     details;    //!< May be NULL if no advanced settings are required. NULL for Non-NVIDIA Display.
} NV_DISPLAYCONFIG_PATH_TARGET_INFO_V1;

//! \ingroup dispcontrol
typedef struct _NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2
{
    NvU32                                           displayId;  //!< Display ID
    NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO*     details;    //!< May be NULL if no advanced settings are required
    NvU32                                           targetId;   //!< Windows CCD target ID. Must be present only for non-NVIDIA adapter, for NVIDIA adapter this parameter is ignored.
} NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2;


//! \ingroup dispcontrol
//! As version is not defined for this structure, we will be using version of NV_DISPLAYCONFIG_PATH_INFO
typedef NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2 NV_DISPLAYCONFIG_PATH_TARGET_INFO; 


//! \ingroup dispcontrol
typedef enum _NV_DISPLAYCONFIG_SPANNING_ORIENTATION
{
    NV_DISPLAYCONFIG_SPAN_NONE          = 0,
    NV_DISPLAYCONFIG_SPAN_HORIZONTAL    = 1,
    NV_DISPLAYCONFIG_SPAN_VERTICAL      = 2,
} NV_DISPLAYCONFIG_SPANNING_ORIENTATION;

//! \ingroup dispcontrol
typedef struct _NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1
{
    NV_RESOLUTION                           resolution;
    NV_FORMAT                               colorFormat;                //!< Ignored at present, must be NV_FORMAT_UNKNOWN (0)
    NV_POSITION                             position;                   //!< Is all positions are 0 or invalid, displays will be automatically
                                                                        //!< positioned from left to right with GDI Primary at 0,0, and all
                                                                        //!< other displays in the order of the path array.
    NV_DISPLAYCONFIG_SPANNING_ORIENTATION   spanningOrientation;        //!< Spanning is only supported on XP
    NvU32                                   bGDIPrimary : 1;
    NvU32                                   bSLIFocus : 1;
    NvU32                                   reserved : 30;              //!< Must be 0
} NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1;



typedef struct _NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V2
{
    NV_RESOLUTION                           resolution;
    NV_FORMAT                               colorFormat;                //!< Ignored at present, must be NV_FORMAT_UNKNOWN (0)
    NV_POSITION                             position;                   //!< Is all positions are 0 or invalid, displays will be automatically
                                                                        //!< positioned from left to right with GDI Primary at 0,0, and all
                                                                        //!< other displays in the order of the path array.
    NV_DISPLAYCONFIG_SPANNING_ORIENTATION   spanningOrientation;        //!< Spanning is only supported on XP
    NvU32                                   bGDIPrimary : 1;
    NvU32                                   bSLIFocus : 1;
    NvU32                                   reserved : 30;              //!< Must be 0

    NvU32                                   sourceId;                   //!< Valid only in case of DWM clone.
} NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V2;

typedef NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V2 NV_DISPLAYCONFIG_SOURCE_MODE_INFO; 

//! \ingroup dispcontrol
typedef struct _NV_DISPLAYCONFIG_PATH_INFO_V1
{
    NvU32                                   version;
    NvU32                                   reserved_sourceId;     	//!< This field is reserved. There is ongoing debate if we need this field.
                                                                        //!< Identifies sourceIds used by Windows. If all sourceIds are 0, 
                                                                        //!< these will be computed automatically.
    NvU32                                   targetInfoCount;            //!< Number of elements in targetInfo array
    NV_DISPLAYCONFIG_PATH_TARGET_INFO_V1*   targetInfo;
    NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1*   sourceModeInfo;             //!< May be NULL if mode info is not important
} NV_DISPLAYCONFIG_PATH_INFO_V1;

//! \ingroup dispcontrol
//! This define is temporary and must be removed once DVS failure is fixed.
#define _NV_DISPLAYCONFIG_PATH_INFO_V2 _NV_DISPLAYCONFIG_PATH_INFO

//! \ingroup dispcontrol
typedef struct _NV_DISPLAYCONFIG_PATH_INFO_V2
{
    NvU32                                   version;
    union {
        NvU32                                   sourceId;            	//!< Identifies sourceId used by Windows CCD. This can be optionally set.
        NvU32                                   reserved_sourceId;      //!< Only for compatibility
    };

    NvU32                                   targetInfoCount;            //!< Number of elements in targetInfo array
    NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2*   targetInfo;
    NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1*   sourceModeInfo;             //!< May be NULL if mode info is not important
    NvU32                                   IsNonNVIDIAAdapter : 1;     //!< True for non-NVIDIA adapter.
    NvU32                                   reserved : 31;              //!< Must be 0
    void                                    *pOSAdapterID;              //!< Used by Non-NVIDIA adapter for pointer to OS Adapter of LUID 
                                                                        //!< type, type casted to void *.
} NV_DISPLAYCONFIG_PATH_INFO_V2;

//! \ingroup dispcontrol
#define NV_DISPLAYCONFIG_PATH_INFO_VER1                 MAKE_NVAPI_VERSION(NV_DISPLAYCONFIG_PATH_INFO_V1,1)

//! \ingroup dispcontrol
#define NV_DISPLAYCONFIG_PATH_INFO_VER2                 MAKE_NVAPI_VERSION(NV_DISPLAYCONFIG_PATH_INFO_V2,2)


typedef struct _NV_DISPLAYCONFIG_PATH_INFO_V3
{
    NvU32                                   version;
    union {
        NvU32                                   sourceId;               //!< Identifies sourceId used by Windows CCD. This can be optionally set. 
                                                                        //!< Ignore this member in case of DWM Clone. Refer to the sourceId defined in 
                                                                        //!< NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V2 structure.
        NvU32                                   reserved_sourceId;      //!< Only for compatibility
    };

    NvU32                                   targetInfoCount;            //!< Number of elements in targetInfo array
    NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2*   targetInfo;    
    NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V2*   sourceModeInfo;             //!< May be NULL if mode info is not important
    NvU32                                   IsNonNVIDIAAdapter : 1;     //!< True for non-NVIDIA adapter.
    NvU32                                   reserved : 31;              //!< Must be 0
    void                                    *pOSAdapterID;              //!< Used by Non-NVIDIA adapter for pointer to OS Adapter of LUID 
                                                                        //!< type, type casted to void *.
    NvU32                                   sourceModeInfoCount;        //!< Number of elements in sourceModeInfo array.
} NV_DISPLAYCONFIG_PATH_INFO_V3;

//! \ingroup dispcontrol
#define NV_DISPLAYCONFIG_PATH_INFO_VER3                 MAKE_NVAPI_VERSION(NV_DISPLAYCONFIG_PATH_INFO_V3,3)

typedef NV_DISPLAYCONFIG_PATH_INFO_V3 NV_DISPLAYCONFIG_PATH_INFO;

#define NV_DISPLAYCONFIG_PATH_INFO_VER                  NV_DISPLAYCONFIG_PATH_INFO_VER3

#ifndef NV_DISPLAYCONFIG_PATH_INFO_VER

typedef NV_DISPLAYCONFIG_PATH_INFO_V2 NV_DISPLAYCONFIG_PATH_INFO;

#define NV_DISPLAYCONFIG_PATH_INFO_VER                  NV_DISPLAYCONFIG_PATH_INFO_VER2

typedef NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1 NV_DISPLAYCONFIG_SOURCE_MODE_INFO; 

#endif


//! \ingroup dispcontrol
typedef enum _NV_DISPLAYCONFIG_FLAGS
{
    NV_DISPLAYCONFIG_VALIDATE_ONLY          = 0x00000001,
    NV_DISPLAYCONFIG_SAVE_TO_PERSISTENCE    = 0x00000002, 
    NV_DISPLAYCONFIG_DRIVER_RELOAD_ALLOWED  = 0x00000004,               //!< Driver reload is permitted if necessary
    NV_DISPLAYCONFIG_FORCE_MODE_ENUMERATION = 0x00000008,               //!< Refresh OS mode list.
} NV_DISPLAYCONFIG_FLAGS;


#define NVAPI_UNICODE_STRING_MAX                             2048
#define NVAPI_BINARY_DATA_MAX                                4096

typedef NvU16 NvAPI_UnicodeString[NVAPI_UNICODE_STRING_MAX];
typedef const NvU16 *NvAPI_LPCWSTR;

//! \addtogroup sysevent
//! @{

//! Event IDs. Used in \ref NV_EVENT.
typedef enum
{
    NV_EVENT_ID_DIAG, 
    NV_EVENT_ID_ACPI_HOTKEY, 
    NV_EVENT_ID_POWER_CONNECTOR, 
    NV_EVENT_ID_THERMAL,
    NV_EVENT_ID_DRIVER_RECONNECTED,
    NV_EVENT_ID_HYBRID_DUALVIEW_FAIL_ATTACH,
    NV_EVENT_ID_HYBRID_CHANGE_STATE, 
    NV_EVENT_ID_HYBRID_NOTIFY_TRIGGER_RECOMMANDVIDPN, 
    NV_EVENT_ID_HYBRID_NOTIFY_TRIGGER_POLL_CHILD_CONNECT,
    NV_EVENT_ID_HYBRID_NEXTDISPLAY_STATE,
    NV_EVENT_ID_HYBRID_NOTIFY_TRIGGER_GET_DGPU_EDIDS,
    NV_EVENT_ID_HYBRID_NOTIFY_LIGHTWEIGHT_STATE,
    NV_EVENT_ID_HYBRID_NOTIFY_HIDE_HEADS,
    NV_EVENT_ID_HYBRID_MUX_DEVICE_HOTPLUG,
    NV_EVENT_ID_NULL_MODESET,
    NV_EVENT_ID_BAD_EDID_MODESET,
    NV_EVENT_ID_SLI_SWAP_MASTER_GPU,
    NV_EVENT_ID_PSTATE_CHANGE,
    NV_EVENT_ID_HYBRID_WIN7_HOTPLUG_POWERUP_DGPU,           //!< Win7 hotplug of dgpu monitor on montevina hybrid when no other external monitor is connected.
                                                            //! CCD always lights up the hotplugged monitor. Hence always transition to perf mode in this
                                                            //! scenario. No topology or resolution is specified.
    NV_EVENT_ID_HYBRID_WIN7_HOTKEY_TOPOLOGY_POWERUP_DGPU,   //!< Win7 hotkey switches on montevina hybrid. Power up dgpu if needed and switch to specifed topology.
    NV_EVENT_ID_OVERLAY_FAILURE,
    NV_EVENT_ID_GSYNC,
    NV_EVENT_ID_HYBRID_WIN7_FULL_TOPOLOGY_POWERUP_DGPU,     //!< Win7 MSPanel switches with DGPU monitors. Also used for CCD induced modesets for hotplug
                                                            //! when there is at least one other external monitor already connected. The topology and 
                                                            //! resolution + depth + refresh rate is specified.
    NV_EVENT_ID_PINNED_SURFACE_ALLOC,                       //!< Requests nvsvc to create or free an allocation on behalf of KMD        
    NV_EVENT_ID_PINNED_SURFACE_FREE,
    NV_EVENT_ID_COPROC_POWER_REF_COUNT,                     //!< For Coproc/Gplex/Carlsbad - broadcast when safe/unsafe to power down this adapter.
    NV_EVENT_ID_HYBRID_DGPU_EVENT,                          //!< GPIO event when DeepIdle cannot occur because PMU state stays high.
    NV_EVENT_ID_RESUME_FROM_HIBERNATION_COMMIT_VIDPN_DONE,  //!< Deprecated - Use NV_EVENT_ID_COMMIT_VIDPN_DONE. 
                                                            //! Was used to notify nvsvc for LDDM_CommitVidPn done when resume from hibernation (bug 579496)
    NV_EVENT_ID_RESUME_FROM_STANDBY_COMMIT_VIDPN_DONE,      //!< Deprecated - Use NV_EVENT_ID_COMMIT_VIDPN_DONE. 
                                                            //! Was used to notify nvsvc for LDDM_CommitVidPn done when resume from standby (bug 606410)
    NV_EVENT_ID_VMODE,                                      //!< Sent when entering/leaving virtual mode.  See NEC LUI project
    NV_EVENT_ID_COPROC_RESOLUTION_LIMIT_CHANGED,            //!< For Coproc - broadcast when desktop resolution size limit changed.
    NV_EVENT_ID_COPROC_HOTKEY_NEXT_MDTL_INDEX_TO_NVSVC,     //!< notify nvsvc that Hotkey event has occured and send the next mdtl index.
    NV_EVENT_ID_DEPRECATED_01,                              //!< Deprecated - was used to notify nvsvc that a commit occured on IDM head.
    NV_EVENT_ID_PHYSX_INVALID_CONFIG,                       //!< Notify PhysX of invalid config
    NV_EVENT_ID_FAN_SPEED_CHANGE,                           //!< Notify for fanSpeed change
    NV_EVENT_ID_THERMAL_CHANGE,                             //!< Notify for Thermal change
    NV_EVENT_ID_HCLONE_SET_SURFACE_INFO_AND_MODESET,        //!< Notify when DD is waiting for NVL_ESC_ID_COMMON_HCLONE_SET_SURFACE_INFO_AND_MODESET escape to 
                                                            //!< be called after capture surface setup. This event will be fired by DD when client sets HCLONE
                                                            //!< topology using NVL_ESC_ID_COMMON_HCLONE_SET_TOPOLOGY.
    NV_EVENT_ID_COLOR_PROFILE_CHANGE,                       //!< Notify for Colorspace Profile updates
    NV_EVENT_ID_COPROC_FORCE_GPU_SWITCH,                    //!< Notify for IGPU or DGPU hw switch setting
    NV_EVENT_ID_DISPLAYPORT_TOPOLOGY_CHANGED,               //!< Notify something has changed in the displayport topology
    NV_EVENT_ID_COPROC_POWER_STATE_CHANGE,                  //!< Notify coproc power state change
    NV_EVENT_ID_HOTKEY_TOPOLOGY_CHANGE,                     //!< Notify ACPI Hotkey topology change event.
    NV_EVENT_ID_MONITOR_CONNECTION_STATUS_CHANGE,           //!< Currently used to notify nvsvc in case when SLIMM2.0 is not supported and device is hotplugged/unplugged on slave GPU.
    NV_EVENT_ID_GC5_STATE_CHANGE,                           //!< Broadcast GC5 state change (GC5 armed or disarmed)
    NV_EVENT_ID_COMMIT_VIDPN_DONE,                          //!< notify nvsvc for LDDM_CommitVidPn done (bug 1254137)
    NV_EVENT_ID_GC6_NOTIFY_STATE_CHANGE,                    //!< GC6 State Change Event for GPU logging feature during GC6 state change
    NV_EVENT_ID_CURSOR_SHAPE_CHANGE,                        //!< Cursor shape change event.
    NV_EVENT_ID_DESKTOP_REDRAW_REQUEST,                     //!< notify nvsvc for LDDM_CommitVidPn done (bug 1254137)
    NV_EVENT_ID_DWM_CHANGE_REQUEST,                         //!< Event indicating a request to enable/disable DWM composition.
    NV_EVENT_ID_REQUEST_FORCED_TDR,                         //!< Event specifying that the GPU is in bad state & need to be TDRed to be able to function properly.
    NV_EVENT_ID_DSR_STATE_CHANGE,                           //!< Notify CPL DSR state change
    NV_EVENT_ID_STOP_DISPLAY_CHANGE_HONORING,              //!< Notify CPL to stop their state refresh
    NV_EVENT_ID_START_DISPLAY_CHANGE_HONORING              //!< Notify CPL to start their state refresh
} NV_EVENT_ID;


//! Additional Information Block IDs used in \ref NV_EVENT.
typedef enum 
{
    NV_EVENT_BLOCK_ID_NONE,                                         //!< No associated data block for this event
    NV_EVENT_BLOCK_ID_ACPI,                                         //!< ACPI hotkey display change event block
    NV_EVENT_BLOCK_ID_HYBRID_CHANGE_STATE,                          //!< ACPI hybrid transition
    NV_EVENT_BLOCK_ID_HYBRID_NEXTDISPLAY_STATE,                     //!< Hot-key toggle sequence
    NV_EVENT_BLOCK_ID_HYBRID_NOTIFY_LIGHTWEIGHT_STATE,              //!< Notify state of lightweight startup
    NV_EVENT_BLOCK_ID_HYBRID_DIAG_NOTIFY,                           //!< ACPI DIAG notification
    NV_EVENT_BLOCK_ID_HYBRID_CHANGE_STATE_V2,                       //!< ACPI hybrid transition
    NV_EVENT_BLOCK_ID_HYBRID_MUX_DEVICE_HOTPLUG_NOTIFY,             //!< Device hotplug notifications
    NV_EVENT_BLOCK_ID_PSTATE_CHANGE,                                //!< P-state change event block
    NV_EVENT_BLOCK_ID_HYBRID_WIN7_HOTKEY_TOPOLOGY_POWERUP_DGPU,
    NV_EVENT_BLOCK_ID_OVERLAY_FAILURE,                              //!< KMD overlay creation failure due to IMP etc.
    NV_EVENT_BLOCK_ID_GSYNC,                                        //!< G-Sync notifications  
    NV_EVENT_BLOCK_ID_HYBRID_WIN7_FULL_TOPOLOGY_POWERUP_DGPU,
    NV_EVENT_BLOCK_ID_PINNED_SURFACE_ALLOC,                         //!< Request for a pinned surface from KMD
    NV_EVENT_BLOCK_ID_PINNED_SURFACE_FREE,    
    NV_EVENT_BLOCK_ID_COPROC_POWER_REF_COUNT,
    NV_EVENT_BLOCK_ID_HYBRID_DGPU_EVENT,                            //!< See ::NV_EVENT_ID_HYBRID_DGPU_EVENT
    NV_EVENT_BLOCK_ID_VMODE,                                        //!< See ::NV_EVENT_ID_VMODE
    NV_EVENT_BLOCK_ID_COPROC_RESOLUTION_LIMIT_CHANGED,              //!< See ::NV_EVENT_ID_COPROC_RESOLUTION_LIMIT_CHANGED
    NV_EVENT_BLOCK_ID_COPROC_HOTKEY_NEXT_MDTL_INDEX_TO_NVSVC,       //!< See ::NV_EVENT_ID_COPROC_HOTKEY_MDTL_NEXT_INDEX_TO_NVSVC
    NV_EVENT_BLOCK_ID_PHYSX_INVALID_CONFIG,                         //!< See ::NV_EVENT_ID_PHYSX_INVALID_CONFIG
    NV_EVENT_BLOCK_ID_FAN_SPEED_CHANGE,                             //!< See ::NV_EVENT_ID_FAN_SPEED_CHANGE
    NV_EVENT_BLOCK_ID_THERMAL_CHANGE,                               //!< See ::NV_EVENT_ID_THERMAL_CHANGE
    NV_EVENT_BLOCK_ID_COLOR_PROFILE_CHANGE,                         //!< See ::NV_EVENT_ID_COLOR_PROFILE_CHANGE
    NV_EVENT_BLOCK_ID_COPROC_FORCE_GPU_SWITCH,                      //!< Force IGPU or DGPU hardware switch notification
    NV_EVENT_BLOCK_ID_DISPLAYPORT_TOPOLOGY_CHANGED,                 //!< See ::NV_EVENT_ID_DISPLAYPORT_TOPOLOGY_CHANGED
    NV_EVENT_BLOCK_ID_SET_SURFACE_INFO_AND_MODESET,                 //!< See ::NV_EVENT_ID_SET_SURFACE_INFO_AND_MODESET
    NV_EVENT_BLOCK_ID_COPROC_POWER_STATE_CHANGE,                    //!< See ::NV_EVENT_ID_COPROC_POWER_STATE_CHANGE
    NV_EVENT_BLOCK_ID_HOTKEY_TOPOLOGY_CHANGE,                       //!< Will come under NV_EVENT_ID_HOTKEY_TOPOLOGY_CHANGE, see NV_EVENT_BLOCK_HOTKEY_TOPOLOGY_DATA structre.
    NV_EVENT_BLOCK_ID_MONITOR_CONNECTION_STATUS_CHANGE,             //!< Block data used for event NV_EVENT_MONITOR_CONNECTION_STATUS_CHANGE
    NV_EVENT_BLOCK_ID_GC5_STATE_CHANGE,                       		//!< see NV_EVENT_ID_COPROC_EXIT_GC5
    NV_EVENT_BLOCK_ID_COMMIT_VIDPN_DONE,                            //!< see ::NV_EVENT_ID_COMMIT_VIDPN_DONE
    NV_EVENT_BLOCK_ID_GC6_NOTIFY_STATE_CHANGE,                      //!< see NV_EVENT_ID_GC6_NOTIFY_STATE_CHANGE
    NV_EVENT_BLOCK_ID_DESKTOP_REDRAW_REQUEST,                       //!< see ::NV_EVENT_ID_DESKTOP_REDRAW_REQUEST
    NV_EVENT_BLOCK_ID_DWM_CHANGE_REQUEST,                           //!< see ::NV_EVENT_ID_DWM_CHANGE_REQUEST
    NV_EVENT_BLOCK_ID_REQUEST_FORCED_TDR,                           //!< see ::NV_EVENT_ID_REQUEST_FORCED_TDR
    NV_EVENT_BLOCK_ID_DSR_STATE_CHANGE,                              //!< See ::NV_EVENT_BLOCK_ID_DSR_STATE_CHANGE
    NV_EVENT_BLOCK_ID_START_DISPLAY_CHANGE_HONORING,               //!< See ::NV_EVENT_ID_START_DISPLAY_CHANGE_HONORING
} NV_EVENT_BLOCK_ID;



//! Core NV_EVENT structure declaration: Used \ref NV_EVENT_CALLBACK. 
typedef struct
{
    NvU32 cbSize;                 //!< Size of the buffer, include both header and extra data
    NvU32 version;                //!< Version field to ensure minimum version compatibility
    NvU32 cbBlockOffset;          //!< Offset from the beginning of NV_EVENT to NV_EVENT_BLOCK, in bytes
    NV_EVENT_ID EventId;          //!< ID of the event being sent
    NV_EVENT_BLOCK_ID BlockId;    //!< Type ID for NV_EVENT_BLOCK structure
    union
    {
        NvPhysicalGpuHandle PhysicalGpu;  //!< This field will become Physical GPU handle during the PopEvent
                                          //!< by NvApiEscape.cpp
        NvU32 Reserved32;         //!< This field is to ensure proper sizing with the driver.
        NvU64 Reserved64;         //!< This field is to ensure proper sizing with the driver.
    };
} NV_EVENT, *PNV_EVENT;



#define NV_EVENT_VERSION        MAKE_NVAPI_VERSION(NV_EVENT,1)



//! ACPI hotkey NV_EVENT structure declaration: Used in \ref NV_EVENT_BLOCK_ID.
typedef struct
{
    NvU32                  ulInvalidatedDeviceMask;  //!< The display devices to switch to after the event 
    NvU32                  ulConnectedDeviceMask;    //!< The display devices that are currently connected
    NV_TARGET_VIEW_MODE    config;                   //!< The expected configuration for the new set of devices
} NV_EVENT_BLOCK_ACPI, *PNV_EVENT_BLOCK_ACPI;


//---------------------------------------------------------------------------------
//! Structures for NV_EVENT_BLOCK_ID_HOTKEY_TOPOLOGY.

typedef struct 
{
    NvU32   srcID;                 //!< A number that will help to decide the view with multiple paths/targets. 
                                   //!< This srcID will use just to figure the topology it is not actual sourceID used in driver. 
    union 
    {
        NvU32 targetID;            //!< Target id of the display attached to non-Nvidia GPU.
        NvU32 displayID;           //!< Display Id of the display attached to Nvidia GPU.
    };
    NvU32     isNonNVPath : 1;     //!< If 1 then it is Non-Nvidia path else it is Nvidia path.
    NvU32     reserved    : 31;    //!< Reserved.
}PATH_INFO, *PPATH_INFO;

typedef struct
{
    NvU32        pathCount;        //!< Number of elements in the pathInfo array.
    PATH_INFO    pathInfo[NVAPI_MAX_DISPLAYS]; //!< Array of PATH_INFO structure of length NVAPI_MAX_DISPLAYS.
}NV_EVENT_BLOCK_HOTKEY_TOPOLOGY_DATA, *PNV_EVENT_BLOCK_HOTKEY_TOPOLOGY_DATA;

#define NV_INVALID_SRC_ID    -1    //!< Invalid source ID.

//---------------------------------------------------------------------------------

//! Used in (TBD).
typedef struct _NV_EVENT_BLOCK_HYBRID_CHANGE_STATE
{
    NvU32    hybridState;     //!< Hybrid Transition state requested from the system BIOS 
                              //!   - 1 means iGPU mode
                              //!   - 2 means dGPU mode
} NV_EVENT_BLOCK_HYBRID_CHANGE_STATE, *PNV_EVENT_BLOCK_HYBRID_CHANGE_STATE;




typedef struct _NV_EVENT_BLOCK_HYBRID_CHANGE_STATE_V2
{
    NvU32    hybridState;     //!< Hybrid Transition state requested from SBios
                              //!  - 0 means adaptive (Follow Power Policy, if available)
                              //!  - 1 means iGPU mode
                              //!  - 2 means dGPU mode
                              //!  - 3 means Multi-Adapter
    NvU32    flags;           //!< Request Flags Bits, starting with LSB (0)
                              //!  - bit 0: Prevent Vista Power Policy Override
                              //!  - bit 1: Override non-migratable
} NV_EVENT_BLOCK_HYBRID_CHANGE_STATE_V2, *PNV_EVENT_BLOCK_HYBRID_CHANGE_STATE_V2;




typedef struct _NV_EVENT_BLOCK_HYBRID_NEXT_DISPLAY
{
    NvU8  transitionRequest;        //!< Indicates if there is need for policy transition 
                                    //! - bit 0 for transition
                                    //! - bit 1 for passing DeviceMask instead of ACPIId.
    union {
        NvU32 ulACPIId1;                 //!< ACPI ID of Display 1
        NvU32 ulDeviceMask;              //!< or device mask for all the devices
    };

    NvU32 ulACPIId2;                 //!< ACPI ID of Display 2
} NV_EVENT_HYBRID_NEXT_DISPLAY, *PNV_EVENT_HYBRID_NEXT_DISPLAY;



typedef struct _NV_EVENT_BLOCK_PINNED_SURFACE_ALLOC
{
    NvU64 hKmHandle;                //!< adapter identifier
    NvU32 dwPinnedMemId;            //!< unique identifier for this allocation request
    NvU32 size;                     //!< size in bytes
}NV_EVENT_BLOCK_PINNED_SURFACE_ALLOC, *PNV_EVENT_BLOCK_PINNED_SURFACE_ALLOC;


typedef struct _NV_EVENT_BLOCK_PINNED_SURFACE_FREE
{
    NvU64 hKmHandle;                //!< adapter identifier
    NvU32 hMem;                     //!< memory handle of the allocation to free
}NV_EVENT_BLOCK_PINNED_SURFACE_FREE, *PNV_EVENT_BLOCK_PINNED_SURFACE_FREE;






//! Used in _NV_EVENT_BLOCK_HYBRID_NOTIFY_LIGHTWEIGHT_STATE.
typedef enum
{
    NV_STATE_UNDEFINED = 0,
    NV_STATE_EDID_REQUESTED = 1,
} NvEventLightweightState;




typedef struct _NV_EVENT_BLOCK_HYBRID_NOTIFY_LIGHTWEIGHT_STATE
{
    NvEventLightweightState state;   //!< Lightweight Start State
} NV_EVENT_BLOCK_HYBRID_NOTIFY_LIGHTWEIGHT_STATE, *PNV_EVENT_BLOCK_HYBRID_NOTIFY_LIGHTWEIGHT_STATE;





//! ACPI diag notifications
typedef struct _NV_EVENT_BLOCK_HYBRID_DIAG_NOTIFY
{
    NvU32    ulACPINotification;
} NV_EVENT_BLOCK_HYBRID_DIAG_NOTIFY, *PNV_EVENT_BLOCK_HYBRID_DIAG_NOTIFY;



//! Hybrid mux device hotplug
typedef struct _NV_EVENT_BLOCK_HYBRID_MUX_DEVICE_HOTPLUG_NOTIFY
{
    NvU32    ulACPIId;          
} NV_EVENT_BLOCK_HYBRID_MUX_DEVICE_HOTPLUG_NOTIFY, *PNV_EVENT_BLOCK_HYBRID_MUX_DEVICE_HOTPLUG_NOTIFY;


typedef struct _NV_EVENT_BLOCK_PSTATE_CHANGE
{
    NvU32 Pstate;
} NV_EVENT_BLOCK_PSTATE_CHANGE, *PNV_EVENT_BLOCK_PSTATE_CHANGE;


typedef struct _NV_EVENT_BLOCK_HYBRID_WIN7_HOTKEY_TOPOLOGY_POWERUP_DGPU
{
    NvU32 ulACPIId1;  //!< For clone/dualview mode, this device will be the primary device.
    NvU32 ulChildId1; //!< To be used to program CCD.    
    NvU32 ulACPIId2;  //!< Will be zero for standard mode. Will be non-zero for clone or dualview mode.
    NvU32 ulChildId2; //!< To be used to program CCD.
    NvU32 ulReserved; //!< May be used for the third head support in fermi
    NV_TARGET_VIEW_MODE ViewMode; //!< NV_VIEW_MODE_STANDARD/CLONE/DUALVIEW
    NvU32 ulPowerUpDgpu; //!< - 1: At least one of the indicated devices is a dgpu-only device and dgpu is currently powered off, 
                         //!   hence nvsvc should first power up the dgpu
                         //!  - 0: No need to power up the dgpu
} NV_EVENT_BLOCK_HYBRID_WIN7_HOTKEY_TOPOLOGY_POWERUP_DGPU, *PNV_EVENT_BLOCK_HYBRID_WIN7_HOTKEY_TOPOLOGY_POWERUP_DGPU;


typedef enum _NV_OVERLAY_FAILURE_TYPE
{
    NV_OVERLAY_FAILURE_GENERAL  = 0,
    NV_OVERLAY_FAILURE_IMP  = 1,
} NV_OVERLAY_FAILURE_TYPE;



typedef struct _NV_EVENT_BLOCK_OVERLAY_FAILURE
{
    NV_OVERLAY_FAILURE_TYPE type;
    NvU32 ulProcessId;
    NvU32 ulPathCount;

} NV_EVENT_BLOCK_OVERLAY_FAILURE, *PNV_EVENT_BLOCK_OVERLAY_FAILURE;


typedef enum 
{
    NV_GSYNC_EVENT_NONE                          =  (0x00000000),
    NV_GSYNC_EVENT_SMART_SYNC_LOSS               =  (0x00000001),
    NV_GSYNC_EVENT_SMART_SYNC_GAIN               =  (0x00000002),
    NV_GSYNC_EVENT_SMART_STEREO_LOSS             =  (0x00000004),
    NV_GSYNC_EVENT_SMART_STEREO_GAIN             =  (0x00000008),
    NV_GSYNC_EVENT_SMART_HOUSESYNC_GAIN          =  (0x00000010),
    NV_GSYNC_EVENT_SMART_HOUSESYNC_LOSS          =  (0x00000020),
    NV_GSYNC_EVENT_SMART_RJ45_GAIN               =  (0x00000040),
    NV_GSYNC_EVENT_SMART_RJ45_LOSS               =  (0x00000080),
    NV_GSYNC_EVENT_SMART_SYNC_STATE_CHANGE       =  (0x00010000)  // DD Event starts with this enum value, keeping buffer for future RM events

} NV_GSYNC_EVENT;

typedef struct _NV_EVENT_BLOCK_GSYNC
{
    NvU32 ulData;  //!< see NV_GSYNC_EVENT
} NV_EVENT_BLOCK_GSYNC, *PNV_EVENT_BLOCK_GSYNC;

typedef struct _NV_EVENT_BLOCK_DSR_STATE_CHANGE
{
    NvU32 ulData;  // Display ID
} NV_EVENT_BLOCK_DSR_STATE_CHANGE, *PNV_EVENT_BLOCK_DSR_STATE_CHANGE;

typedef struct _NV_EVENT_BLOCK_MONITOR_CONNECTION_STATUS_CHANGE
{
    NvU32 targetId;
    NvU32 ulFlags; // MONITOR_FLAGS_HOTPLUGIN 1
                   // MONITOR_FLAGS_HOTUNPLUG 2

} NV_EVENT_BLOCK_MONITOR_CONNECTION_STATUS_CHANGE, *PNV_EVENT_BLOCK_MONITOR_CONNECTION_STATUS_CHANGE;




#define FULL_TOPOLOGY_POWERUP_DGPU_MAX_HEADS 4


//! See also ::D3DKMDT_VIDPN_PRESENT_PATH_IMPORTANCE.
typedef struct _HYBRID_WIN7_FULL_TOPOLOGY_POWERUP_DGPU_PATH_INFO
{
    NvU32                   ChildId;
    NvU32                   SourceId;       
    
    // source mode information
    NvU32                   Width;              //!< Width of the mode
    NvU32                   Height;             //!< Height of the mode
    NvU32                   PixelFormat;        //!< Pixel format of the mode indicating the depth.
    NvU32                   VSyncNumerator;     //!< Numerator of the refresh rate of the mode
    NvU32                   VSyncDenominator;   //!< Denominator of the refresh rate of the mode
    
    // These fields will be based on the corresponding D3DKMDT_VIDPN_PRESENT_PATH_IMPORTANCE/ROTATION/SCALING enums.
    NvU32                   ImportanceOrdinal;  //!< Reference  
    NvU32                   Rotation;           //!< Rotation setting
    NvU32                   Scaling;            //!< Scaling setting
    NvU32                   ScanlineOrdering;   //!< Interlaced or progressive mode flag
} *PHYBRID_WIN7_FULL_TOPOLOGY_POWERUP_DGPU_PATH_INFO, HYBRID_WIN7_FULL_TOPOLOGY_POWERUP_DGPU_PATH_INFO;


//! Power up the DGPU, switch to hybrid perf mode, and do a modeset with the full specified topology.
//! This gets called for the following scenarios: 
//! - CCD restoring persistence when another external monitor is already connected.
//! - User going to MSPanel to activate the dgpu monitor.
//! - Any general running application doing a modeset to activate the dgpu monitor.
typedef struct _NV_EVENT_BLOCK_HYBRID_WIN7_FULL_TOPOLOGY_POWERUP_DGPU
{
    NvU32 NumPathCount;  // Number of paths.
    HYBRID_WIN7_FULL_TOPOLOGY_POWERUP_DGPU_PATH_INFO PathInfo[FULL_TOPOLOGY_POWERUP_DGPU_MAX_HEADS];
} NV_EVENT_BLOCK_HYBRID_WIN7_FULL_TOPOLOGY_POWERUP_DGPU, *PNV_EVENT_BLOCK_HYBRID_WIN7_FULL_TOPOLOGY_POWERUP_DGPU;


//! Coproc/Gplex/Carlsbad \n
//! Container for NV_EVENT_ID_COPROC_POWER_REF_COUNT
typedef struct _NV_EVENT_BLOCK_COPROC_POWER_REF_COUNT
{
    NvU64       SequenceNumber;     //!< Keeps events and queries in order

    NvU32       ReferenceCount;     //!< Will be 0 or 1
                                    //! 0 - safe to power off this adapter.
                                    //!< nonzero - not safe to power off.
    NvU32       pad0;

} NV_EVENT_BLOCK_COPROC_POWER_REF_COUNT;



typedef struct _NV_EVENT_BLOCK_HYBRID_DGPU_EVENT
{
    NvU32 gpioEvent;  //!< Event fired off by dGpu gpio if DeepIdle fails.
} NV_EVENT_BLOCK_HYBRID_DGPU_EVENT, *PNV_EVENT_BLOCK_HYBRID_DGPU_EVENT;




//
//! Desktop resolution limit changed event - 
//! Sent when the KMD needs NvSvc to re-enumerate display modes and set the desktop resolution.
typedef struct _NV_EVENT_BLOCK_COPROC_RESOLUTION_LIMIT_CHANGED
{
    NvU32   ulCurMaxResolutionSize;     //!< current limit as W x H in pixels
    NvU32   bDisabled;                  //!< true if ulCurMaxResolutionSize is 0; false, otherwise

} NV_EVENT_BLOCK_COPROC_RESOLUTION_LIMIT_CHANGED, *PNV_EVENT_BLOCK_COPROC_RESOLUTION_LIMIT_CHANGED;

//
//! Hotkey Event on CoProc - 
//! This Event is triggered to NvSvc whenever there is a HotKey Event on Coproc systems.
typedef struct _NV_EVENT_BLOCK_COPROC_HOTKEY_NEXT_MDTL_INDEX_TO_NVSVC
{
    NvU32 ulMDTLNextSequenceIndex;
    
}NV_EVENT_BLOCK_COPROC_HOTKEY_NEXT_MDTL_INDEX_TO_NVSVC,*PNV_EVENT_BLOCK_COPROC_HOTKEY_NEXT_MDTL_INDEX_TO_NVSVC;

typedef struct _NV_EVENT_BLOCK_PHYSX_INVALID_CONFIG
{
    NvU64 hProcessId;
} NV_EVENT_BLOCK_PHYSX_INVALID_CONFIG, *PNV_EVENT_BLOCK_PHYSX_INVALID_CONFIG;


typedef enum _NV_COPROC_FORCE_GPU_MODE
{
    NV_COPROC_NONE,           //!< Non Optimus platforms.
    NV_COPROC_FORCE_IGPU,     //!< Forced IGPU mode.
    NV_COPROC_FORCE_DGPU,     //!< Forced DGPU mode.
    NV_COPROC_OPTIMUS,        //!< Normal Optimus platform.
} NV_COPROC_FORCE_GPU_MODE;

//! ACPI event on coproc for hardware switch - 
//! This Event is triggered to NvSvc whenever there is a hardware switch ACPI Event on Coproc systems.
typedef struct _NV_EVENT_BLOCK_COPROC_FORCE_GPU_POLICY
{
    NV_COPROC_FORCE_GPU_MODE forcedGPUMode;
} NV_EVENT_BLOCK_COPROC_FORCE_GPU_POLICY, *PNV_EVENT_BLOCK_COPROC_FORCE_GPU_POLICY;



//! Fan Speed Level
typedef struct _NV_EVENT_BLOCK_FAN_SPEED_CHANGE
{
    NvU32 fanSpeedLevel;         //!< Returns fan Speed Level
}NV_EVENT_BLOCK_FAN_SPEED_CHANGE, *PNV_EVENT_BLOCK_FAN_SPEED_CHANGE;

//! Thermal Level
typedef struct _NV_EVENT_BLOCK_THERMAL_CHANGE
{
    NvU32 thermalLevel;          //!< Returns thermal Level
}NV_EVENT_BLOCK_THERMAL_CHANGE, *PNV_EVENT_BLOCK_THERMAL_CHANGE;


typedef enum _NV_COLOR_PROFILE_CHANGE_TYPE
{
    NV_COLOR_PROFILE_CHANGE_DISABLE_OVERRIDE   = 0x00,
    NV_COLOR_PROFILE_CHANGE_ENABLE_OVERRIDE    = 0x01,
} NV_COLOR_PROFILE_CHANGE_TYPE;

typedef struct _NV_EVENT_BLOCK_COLOR_PROFILE_CHANGE
{
    NV_COLOR_PROFILE_CHANGE_TYPE profileChange;   //!< change requested
    NvU32 gpuId;                                  //!< GPU to which the target display is attached
    NvU32 outputId;                               //!< Source to which the target display is attached
    NvU32 position;                               //!< If clone, target display's position relative to source
} NV_EVENT_BLOCK_COLOR_PROFILE_CHANGE, *PNV_EVENT_BLOCK_COLOR_PROFILE_CHANGE;



typedef enum
{
    NV_EVENT_BLOCK_VMODE_TRANSITION_ENTERING_VMODE = 1,
    NV_EVENT_BLOCK_VMODE_TRANSITION_LEAVING_VMODE,
} NV_EVENT_BLOCK_VMODE_TRANSITION;

typedef struct _NV_EVENT_BLOCK_VMODE
{
    NV_EVENT_BLOCK_VMODE_TRANSITION transition;
} NV_EVENT_BLOCK_VMODE, *PNV_EVENT_BLOCK_VMODE;

typedef enum _NV_DISPLAY_CONFIG_TYPE
{
    NV_DISPLAY_CONFIG_TYPE_STANDARD      = 1,
    NV_DISPLAY_CONFIG_TYPE_STREAM_CLONED = 2,
    NV_DISPLAY_CONFIG_TYPE_MOSAIC        = 3, 
} NV_DISPLAY_CONFIG_TYPE;

typedef enum _NV_TOPO_EVENTTYPE
{
    NV_TOPO_EVENTTYPE_DISPLAY_HOTPLUG         = 1,  // For monitors associated with the OS monitor
    NV_TOPO_EVENTTYPE_DISPLAY_UNPLUG          = 2,  // For monitors associated with the OS monitor
    NV_TOPO_EVENTTYPE_NEW_DEVICE              = 3,  // For DP12 devices
    NV_TOPO_EVENTTYPE_LOST_DEVICE             = 4,
    NV_TOPO_EVENTTYPE_DETECT_COMPLETED        = 5,
    NV_TOPO_EVENTTYPE_BANDWIDTH_CHANGED       = 6,
    NV_TOPO_EVENTTYPE_MUST_DISCONNECT         = 7,
    NV_TOPO_EVENTTYPE_ZOMBIE_STATE_CHANGED    = 8,
    NV_TOPO_EVENTTYPE_CABLE_STATE_CHANGED     = 9,
} NV_TOPO_EVENTTYPE;

//! NOTES:
//! - gpuId, subDeviceId and displayId are used to describe the connector the device/node is attached. The values are always valid.
//! - childUid is the same id reported to OS and is associated with this node (for now, video sinks). If the node is not reported to OS, it is invalid and is NVL_MONITOR_INVALID_TARGETID(0).
//! - dpNode.displayId may contain the current displayId associated to this node.  If the device is active, the value is valid.  Otherwise, it is invalid and is 0.
//! - dpNode.dpAddress is aux address for this node. If the node is a stream cloning node, representing one or more cloned devices, this value is invalid and is NVL_MONITOR_INVALID_DPMSTADDRESS(0).
//! - In stream cloning, the chilUid can be used to enumerate the dpAddresses of member devices
//! - A connector event, non-node, is reported when both childUid and dpNode.dpAddress is zero
//! displayType is to identify a display type when event is regarding OS monitor object

typedef struct _NV_EVENT_BLOCK_TOPOLOGY_CHANGED
{
    NV_TOPO_EVENTTYPE     eventType;          //!< may need to check flags for the associated eventType, e.g. Zombie state changed, check isZombie flag
    NvU32               gpuId;                //!< gpuId of the connector to which the device is attached
    NvU32               subdeviceId;          //!< subdeviceId of the connector to which the device is attached
    NvU32               connectorId;          //!< connectorId of the connector to which the device is attached
    NvU32               childUid;             //!< Zero if the device is not reported to the OS, e.g. branch devices, audio only devices
    union // depend on eventtype, 1 and 2 uses displaytype
    {
        NV_DISPLAY_CONFIG_TYPE    displayType;       //!< indicate whether it is standard monitor, stream clone monitor, mosaic monitor, etc representing abstract concept that the OS cares
        NV_DP_NODE_INFO           dpNode;            //!< Node-specific info
    };
} NV_EVENT_BLOCK_TOPOLOGY_CHANGED;

typedef struct _NV_EVENT_TOPOLOGY_CHANGED
{
    NV_EVENT header;
    NV_EVENT_BLOCK_TOPOLOGY_CHANGED data;
} NV_EVENT_TOPOLOGY_CHANGED;

//! Indicates why the display driver is calling nvsvc with the SET_SURFACE_INFO_AND_MODESET call.
typedef enum _NV_HCLONE_EVENT_REASON
{
    NV_HCLONE_EVENT_REASON_SETTING_HCLONE_TOPOLOGY=0,            //!< The caller is setting up an hclone topology.
                                                              
    NV_HCLONE_EVENT_REASON_CLEARING_HCLONE_TOPOLOGY_VOLUNTARY,   //!< The caller is voluntarily clearing hclone topology.
                                                                 //!< Consequently the secondary surface needs to be freed and force mode
                                                                 //!< enumeration needs to be done.
                                                              
    NV_HCLONE_EVENT_REASON_CLEARING_HCLONE_TOPOLOGY_INVOLUNTARY, //!< HClone topology is being cleared involuntarily. This can happen when DD
                                                                 //!< detects certain conditions such as target grabbing by the OS, source
                                                                 //!< grabbing by the OS with no additional hardware sources available,
                                                                 //!< StopDevice() called on one of the adapters in the hclone topology,
                                                                 //!< etc... the secondary surface needs to be freed and force mode
                                                                 //!< enumeration needs to be done.
    NV_HCLONE_EVENT_REASON_RESOLUTION_CHANGED,                   //!< Topology is unchanged. But the resolution has changed. So DD has 
                                                                 //!< NULLified the hclone secondary surface.
                                                                 //!< need to recreate the secondary surface appropriately.
    NV_HCLONE_EVENT_REASON_ZERO_FIND_ZEROR_GAMMA,                //!< When enable HClone, zero gamma table is detected by DD
                                                                 //!< Issue this event to CPL to reset OS gamma.
} NV_HCLONE_EVENT_REASON;

typedef struct _NV_EVENT_BLOCK_HCLONE_SET_SURFACE_INFO_AND_MODESET
{
    NV_HCLONE_EVENT_REASON       eventReason;          //!< The reason why DD triggered this event to nvsvc.
} NV_EVENT_BLOCK_HCLONE_SET_SURFACE_INFO_AND_MODESET;

typedef struct _NV_EVENT_HCLONE_SET_SURFACE_INFO_AND_MODESET
{
    NV_EVENT header;
    NV_EVENT_BLOCK_HCLONE_SET_SURFACE_INFO_AND_MODESET data;
} NV_EVENT_HCLONE_SET_SURFACE_INFO_AND_MODESET;

typedef enum _NV_COPROC_POWER_STATE_CHANGE
{
    NV_COPROC_POWER_STATE_CHANGE_ON   = 0x206E4F20,
    NV_COPROC_POWER_STATE_CHANGE_GOLD = 0x476F6C64,
} NV_COPROC_POWER_STATE_CHANGE;

typedef struct _NV_EVENT_BLOCK_COPROC_POWER_STATE_CHANGE
{
    NV_COPROC_POWER_STATE_CHANGE coprocPowerStateChange;
} NV_EVENT_BLOCK_COPROC_POWER_STATE_CHANGE, *PNV_EVENT_BLOCK_COPROC_POWER_STATE_CHANGE;

typedef enum _NV_GC5_STATE_CHANGE
{
    NV_GC5_STATE_CHANGE_DISARMED = 0,       // The system may no longer enter the GC5 low power state
    NV_GC5_STATE_CHANGE_ARMED    = 1,       // The system may now enter the GC5 low power state
} NV_GC5_STATE_CHANGE;

typedef enum _NV_GC6_NOTIFY_STATE_CHANGE
{
    NV_GC6_NOTIFY_STATE_CHANGE_ENTRY = 0,       // System enter to GC6 entry point
    NV_GC6_NOTIFY_STATE_CHANGE_EXIT  = 1,       // System enter to GC6 Exit point
} NV_GC6_NOTIFY_STATE_CHANGE;


//---------------------------------------------------------------------------------
//! Structures for NV_EVENT_ID_COMMIT_VIDPN_DONE.

typedef enum _NV_EVENT_ENUM_COMMIT_VIDPN_DONE_SCENARIO
{
    NV_EVENT_ENUM_COMMIT_VIDPN_DONE_SCENARIO_DEFAULT = 0,
    NV_EVENT_ENUM_COMMIT_VIDPN_DONE_SCENARIO_RESUME_FROM_HIBERNATION,
    NV_EVENT_ENUM_COMMIT_VIDPN_DONE_SCENARIO_RESUME_FROM_STANDBY,
} NV_EVENT_BLOCK_COMMIT_VIDPN_DONE_SCENARIO;

typedef struct _NV_EVENT_BLOCK_COMMIT_VIDPN_DONE
{
    NV_EVENT_BLOCK_COMMIT_VIDPN_DONE_SCENARIO   scenario;
} NV_EVENT_BLOCK_COMMIT_VIDPN_DONE;

typedef struct _NV_EVENT_COMMIT_VIDPN_DONE
{
    NV_EVENT                                    header;
    NV_EVENT_BLOCK_COMMIT_VIDPN_DONE            data;            
} NV_EVENT_COMMIT_VIDPN_DONE;

//---------------------------------------------------------------------------------
typedef struct _NV_EVENT_BLOCK_GC5_STATE_CHANGE
{
    NV_GC5_STATE_CHANGE gc5StateChange;
} NV_EVENT_BLOCK_GC5_STATE_CHANGE, *PNV_EVENT_BLOCK_GC5_STATE_CHANGE;

typedef struct _NV_EVENT_GC5_STATE_CHANGE
{
    NV_EVENT header;
    NV_EVENT_BLOCK_GC5_STATE_CHANGE data;
} NV_EVENT_GC5_STATE_CHANGE, *PNV_EVENT_GC5_STATE_CHANGE;

//------------------------------------------------------------------------------------

typedef struct _NV_EVENT_BLOCK_GC6_NOTIFY_STATE_CHANGE
{
    NV_GC6_NOTIFY_STATE_CHANGE gc6StateChange;
} NV_EVENT_BLOCK_GC6_NOTIFY_STATE_CHANGE, *PNV_EVENT_BLOCK_GC6_NOTIFY_STATE_CHANGE;

typedef struct _NV_EVENT_GC6_NOTIFY_STATE_CHANGE
{
    NV_EVENT header;
    NV_EVENT_BLOCK_GC6_NOTIFY_STATE_CHANGE data;
} NV_EVENT_GC6_NOTIFY_STATE_CHANGE, *PNV_EVENT_GC6_NOTIFY_STATE_CHANGE;

//---------------------------------------------------------------------------------
//! Structures for NV_EVENT_ID_DESKTOP_REDRAW_REQUEST.

typedef enum _NV_EVENT_ENUM_DESKTOP_REDRAW_REQUEST_METHOD
{
    NV_EVENT_ENUM_DESKTOP_REDRAW_REQUEST_METHOD_SET_PIXEL = 0,
    NV_EVENT_ENUM_DESKTOP_REDRAW_REQUEST_METHOD_RENDER_BEFORE_FLIP,
    NV_EVENT_ENUM_DESKTOP_REDRAW_REQUEST_METHOD_GDI_DESKTOP_REDRAW,
    NV_EVENT_ENUM_DESKTOP_REDRAW_REQUEST_METHOD_REDRAW_DESKTOP,
    NV_EVENT_ENUM_DESKTOP_REDRAW_REQUEST_METHOD_NONE
} NV_EVENT_ENUM_DESKTOP_REDRAW_REQUEST_METHOD;

typedef struct _NV_EVENT_BLOCK_DESKTOP_REDRAW_REQUEST
{
    NvU32                                        redraw;    //!< true nvservice should redraw (portions of) the desktop
    NV_EVENT_ENUM_DESKTOP_REDRAW_REQUEST_METHOD  method;    //!< method to use when redrawing (portions of) the desktop
    NvU32                                        displayId; //!< set if method is GDI_DESKTOP_REDRAW

} NV_EVENT_BLOCK_DESKTOP_REDRAW_REQUEST;

typedef struct _NV_EVENT_DESKTOP_REDRAW_REQUEST
{
    NV_EVENT                                    header;
    NV_EVENT_BLOCK_DESKTOP_REDRAW_REQUEST       data;            
} NV_EVENT_DESKTOP_REDRAW_REQUEST;

//---------------------------------------------------------------------------------
//! Structures & enums for NV_EVENT_ID_REQUEST_FORCED_TDR.

typedef enum _TDR_REASON
{
    TDR_REASON_UNKNOWN   = 0,
    TDR_REASON_BUS_RESET = 1,
    TDR_REASON_GC6_RESET = 2,
    TDR_REASON_NORMAL_RESET = 3
} TDR_REASON;

typedef struct _NV_EVENT_BLOCK_REQUEST_FORCED_TDR
{
    TDR_REASON tdrReason;
} NV_EVENT_BLOCK_REQUEST_FORCED_TDR, *PNV_EVENT_BLOCK_REQUEST_FORCED_TDR;

typedef struct _NV_EVENT_REQUEST_FORCED_TDR
{
    NV_EVENT header;
    NV_EVENT_BLOCK_REQUEST_FORCED_TDR data;
} NV_EVENT_REQUEST_FORCED_TDR, *PNV_EVENT_REQUEST_FORCED_TDR;

//! Callback Format
typedef void (__cdecl *NV_EVENT_CALLBACK)(NV_EVENT* Event, void* CallbackParam);

//---------------------------------------------------------------------------------
//! Structures for NV_EVENT_ID_DWM_CHANGE_REQUEST.
typedef struct _NV_EVENT_BLOCK_DWM_CHANGE_REQUEST
{
    NvU32                                 disable_dwm;  //!< true nvservice should disable DWM else enable
} NV_EVENT_BLOCK_DWM_CHANGE_REQUEST;

typedef struct _NV_EVENT_DWM_CHANGE_REQUEST
{
    NV_EVENT                               header;
    NV_EVENT_BLOCK_DWM_CHANGE_REQUEST      data;
} NV_EVENT_DWM_CHANGE_REQUEST;

typedef struct _NV_EVENT_BLOCK_START_DISPLAY_CHANGE_HONORING_REQUEST
{
    NvU32            numberOfDisplays;
} NV_EVENT_BLOCK_START_DISPLAY_CHANGE_HONORING_REQUEST;

typedef struct _NV_EVENT_START_DISPLAY_CHANGE_HONORING_REQUEST
{
    NV_EVENT                                                     header;
    NV_EVENT_BLOCK_START_DISPLAY_CHANGE_HONORING_REQUEST        data;            
} NV_EVENT_START_DISPLAY_CHANGE_HONORING_REQUEST;

//! @}



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Event_RegisterForEvents
//
//! DESCRIPTION:  This function registers the process for events.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 165
//!
//!  \param [in]  Callback          Pointer to the function to call on new events
//!  \param [in]  CallbackParam     void* Parameter to be passed to the callback function
//!  \param [out] phClient          Handle to the client for use with an unregister function
//!
//!  \retval      NVAPI_OK          Completed request
//!  \retval      NVAPI_ERROR       Miscellaneous error occurred
//!
//!  \ingroup sysevent
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Event_RegisterForEvents(NV_EVENT_CALLBACK Callback, 
                                              void* CallbackParam, 
                                              NvEventHandle* phClient);
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Event_Unregister
//
//! DESCRIPTION:  This function unregisters an event handle.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 165
//!
//!   \param [in] hClient      The handle associated with this listener's
//!                            event queue. It is the same handle passed by 
//!                            NvAPI_Event_RegisterForEvents().
//!
//!   \retval     NVAPI_OK     Completed request
//!   \retval     NVAPI_ERROR  Miscellaneous error occurred
//!
//!   \ingroup    sysevent
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Event_Unregister(NvEventHandle hClient);




///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:  NvAPI_SYS_SetDisplayDeviceInfo
//
//! \fn NvAPI_SYS_SetDisplayDeviceInfo(__in NvU32 displayDeviceCount, __in_ecount(displayDeviceCount) NVAPI_DISPLAY_DEVICE_INFO *displayDeviceInfo, __in NVAPI_DEVICE_INFO_TYPE infoType)
//! 
//! DESCRIPTION:   This API sends information about display devices to the display driver.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in] displayDeviceCount - Number of elements in the displayDeviceInfo array.
//! \param [in] displayDeviceInfo  - Array of NVAPI_DISPLAY_DEVICE_INFO structure which holds the display info.
//! \param [in] infoType           - Possible values are : 
//!                                  1. NVAPI_DEVICE_INFO_HOTKEY_INIT :
//!                                     This flag should be when user mode wants to send this information (in the case of hotkey handling), 
//!                                     and the caller is sending fresh data for the first time.
//!                                     Caller should send target id and ACPI id in this call.
//!                                  2. NVAPI_DEVICE_INFO_HOTKEY_UPDATE :
//!                                     This flag should be used when user mode wants to send this information (in the case of hotkey handling), 
//!                                     and the caller is sending the updated information.
//!                                     Caller should send target id, isConnected and isActive information in this call.
//!                                  3. NVAPI_DEVICE_INFO_DEVICE_CHANGE_UPDATE :
//!                                     This flag should be used when user mode wants to send this information while the caller is sending the
//!                                     updated information after a device change event.
//!                                     Caller should send target id, isConnected and isActive information in this call.
//!
//! \return        This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
//! 
//!  \retval  ::NVAPI_VALUE_ALREADY_SET      If the API is called with isUpdatedInfo as value zero more than once, the API will
//!                                          return this error code from second call. 
//!
///////////////////////////////////////////////////////////////////////////////

//! \ingroup sysevent
//! Information of the display device connected to non-Nvidia GPU.

typedef enum
{
    NVAPI_DEVICE_INFO_UNKNOWN = 0,
    NVAPI_DEVICE_INFO_HOTKEY_INIT,           //!< New information under hotkey path.
    NVAPI_DEVICE_INFO_HOTKEY_UPDATE,         //!< Updated information under hotkey path.
    NVAPI_DEVICE_INFO_DEVICE_CHANGE_UPDATE   //!< Updated information after device change event.
}NVAPI_DEVICE_INFO_TYPE;

typedef struct
{
        NvU32 version;
        
        NvU32 targetID;            //!< Target Id of the display.
        NvU32 acpiID;              //!< ACPI Id of the display
        NvU32 isNonNVDisplay : 1;  //!< Whether the display is connected to an NVIDIA GPU or non-NVIDIA GPU.
        NvU32 isConnected    : 1;  //!< Whether the display is connected or not.
        NvU32 isActive       : 1;  //!< Whether the display is active or not.
        NvU32 reserved       : 29; //!< Reserved.
}NVAPI_DISPLAY_DEVICE_INFO_V1;

typedef NVAPI_DISPLAY_DEVICE_INFO_V1     NVAPI_DISPLAY_DEVICE_INFO;

#define NVAPI_DISPLAY_DEVICE_INFO_VER1   MAKE_NVAPI_VERSION(NVAPI_DISPLAY_DEVICE_INFO_V1, 1) 
#define NVAPI_DISPLAY_DEVICE_INFO_VER    NVAPI_DISPLAY_DEVICE_INFO_VER1 

//! \ingroup sysevent
NVAPI_INTERFACE NvAPI_SYS_SetDisplayDeviceInfo(__in NvU32 displayDeviceCount, __in_ecount(displayDeviceCount) NVAPI_DISPLAY_DEVICE_INFO *displayDeviceInfo, __in NVAPI_DEVICE_INFO_TYPE infoType);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_3DVP_CreateContext
//
//! \code
//! INPUT:         phContext  - Pointer to store handle of created 3D Vision Pro
//!                             context handle to.
//!
//! OUTPUT:        *phContext - Handle of a 3D Vision Pro context (NULL on
//!                             failure).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Creates 3D VISION PRO (3DVP) context. May fail if 3DVP
//!                - is generally not supported on this system, or
//!                - it has been already acquired by another thread and
//!                  concurrent access is not supported.
//!
//! RETURN STATUS: NVAPI_OK                      - Success
//!               NVAPI_ERROR                   - Unspecified error
//!                NVAPI_API_NOT_INITIALIZED     - NvAPI was not intialized
//!                NVAPI_INVALID_POINTER         - phContext is NULL
//!                NVAPI_OUT_OF_MEMORY           - Failed to create context due to OOM
//!                NVAPI_NVIDIA_DEVICE_NOT_FOUND - No NVIDIA GPU found
//!                NVAPI_NOT_SUPPORTED           - 3DVP is not supported on this system
//!                NVAPI_NO_IMPLEMENTATION       - Function is not implemented by SW
//! \endcode
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_3DVP_CreateContext( Nv3DVPContextHandle * phContext );



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_3DVP_DestroyContext
//
//! \code
//! INPUT:         hContext - Handle of 3DVP context to destroy.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Destroys 3DVP context.
//!
//! RETURN STATUS: NVAPI_OK                  - Success
//!                NVAPI_ERROR               - Unspecified error
//!                NVAPI_API_NOT_INITIALIZED - NvAPI was not intialized
//!                NVAPI_INVALID_HANDLE      - Invalid context handle
//!                NVAPI_NO_IMPLEMENTATION   - Function is not implemented by SW
//! \endcode
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_3DVP_DestroyContext( Nv3DVPContextHandle hContext );



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_3DVP_EnumTransceiver
//
//! \code
//! INPUT:         hContext       - Handle of 3DVP context to enumerate
//!                                 transceivers for.
//!                phTransceiver  - Pointer to transceiver handle. Set
//!                                 *phTransceiver to NULL to begin an
//!                                 enumeration, and to the result of the
//!                                 last enumeration to continue an enumeration.
//!
//! OUTPUT:        *phTransceiver - Handle of enumerated transceiver (NULL on
//!                                 failure, or at the end of an enumeration).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Enumerates transceivers for given context. Set
//!                *phTransceiver to NULL to start a new enumeration, and to
//!                the last enumeration result to continue an enumeration.
//!                Returns NVAPI_END_ENUMERATION and sets *phTransceiver to
//!                NULL at the end of an enumeration.
//!
//! RETURN STATUS: NVAPI_OK                  - Success
//!                NVAPI_ERROR               - Unspecified error
//!                NVAPI_API_NOT_INITIALIZED - NvAPI was not intialized
//!                NVAPI_INVALID_POINTER     - phTransceiver is NULL
//!                NVAPI_INVALID_HANDLE      - Invalid context or transceiver handle
//!                NVAPI_END_ENUMERATION     - No more transceivers to enumerate
//!                NVAPI_NO_IMPLEMENTATION   - Function is not implemented by SW
//! \endcode
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_3DVP_EnumTransceiver( Nv3DVPContextHandle hContext, Nv3DVPTransceiverHandle * phTransceiver );






///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_3DVP_OpenTransceiver
//
//! \fn NvAPI_3DVP_OpenTransceiver
//! \code
//! INPUT:         hContext     - Handle of 3DVP context to open given transceiver for.
//!                hTransceiver - Handle of transceiver to open.
//!                access       - Access mode to open transceiver with.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Opens a transceiver for given context in given access mode.
//!                May fail if a transceiver was already opened by another
//!                context and cannot be shared in given access mode (e.g.
//!                N readers, but max. one writer). Also note that this might
//!                cause other transceivers to be closed for given context due
//!                to resource constraints. Finally, the access mode for a
//!                transceiver determines the access mode to all glasses that
//!                are paired to this transceiver.
//!
//! RETURN STATUS: NVAPI_OK                  - Success
//!                NVAPI_ERROR               - Unspecified error
//!                NVAPI_API_NOT_INITIALIZED - NvAPI was not intialized
//!                NVAPI_INVALID_HANDLE      - Invalid context or transceiver handle
//!                NVAPI_INVALID_ARGUMENT    - Invalid access mode
//!                NVAPI_ACCESS_DENIED       - Transceiver was already opened by another
//!                                            context and cannot be shared in given access mode
//!                NVAPI_NO_IMPLEMENTATION   - Function is not implemented by SW
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \ingroup stereo3dvpapi
//! 3D Vision Pro access modes:
typedef enum _NVAPI_3DVP_ACCESS
{
    NVAPI_3DVP_ACC_NONE = 0,  //!< No access
    NVAPI_3DVP_ACC_READ,      //!< Read-only access
    NVAPI_3DVP_ACC_READWRITE, //!< Read+write access
    NVAPI_3DVP_ACC_COUNT,     //!< Number of access modes
} NVAPI_3DVP_ACCESS;

//! \ingroup stereo3dvpapi
NVAPI_INTERFACE NvAPI_3DVP_OpenTransceiver( Nv3DVPContextHandle hContext, Nv3DVPTransceiverHandle hTransceiver, NVAPI_3DVP_ACCESS access );






///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_3DVP_OpenTransceiverPriviledged
//
//! \code
//! INPUT:         hContext     - Handle of 3DVP context to open given transceiver for.
//!                hTransceiver - Handle of transceiver to open.
//!                access       - Access mode to open transceiver with.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Same as above except that this function will stay private to
//!                be exclusively used by the NVIDIA control panel.
//!
//! RETURN STATUS: NVAPI_OK                  - Success
//!                NVAPI_ERROR               - Unspecified error
//!                NVAPI_API_NOT_INITIALIZED - NvAPI was not intialized
//!                NVAPI_INVALID_HANDLE      - Invalid context or transceiver handle
//!                NVAPI_INVALID_ARGUMENT    - Invalid access mode
//!                NVAPI_NO_IMPLEMENTATION   - Function is not implemented by SW
//! \endcode
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_3DVP_OpenTransceiverPriviledged( Nv3DVPContextHandle hContext, Nv3DVPTransceiverHandle hTransceiver, NVAPI_3DVP_ACCESS access );



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_3DVP_CloseTransceiver
//
//! \code
//! Input:         hContext     - Handle of 3DVP context to close transceiver for.
//!                hTransceiver - Handle of transceiver to close.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Closes a transceiver.
//!
//! RETURN STATUS: NVAPI_OK                  - Success
//!                NVAPI_ERROR               - Unspecified error
//!                NVAPI_API_NOT_INITIALIZED - NvAPI was not intialized
//!                NVAPI_INVALID_HANDLE      - Invalid context or transceiver handle
//!                NVAPI_NO_IMPLEMENTATION   - Function is not implemented by SW
//! \endcode
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_3DVP_CloseTransceiver( Nv3DVPContextHandle hContext, Nv3DVPTransceiverHandle hTransceiver );



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_3DVP_GetTransceiverAccess
//
//! \code
//! INPUT:         hContext     - Handle of 3DVP context of which to get the access mode
//!                               for given transceiver.
//!                hTransceiver - Handle of transceiver to get access mode for.
//!                pMode        - Pointer to store the NVAPI_3DVP_ACCESS mode to.
//!
//! OUTPUT:        *pMode       - Mode in which given context can access given
//!                               transceiver (NVAPI_3DVP_ACC_NONE on failure, or
//!                               if given transceiver was not opened for given
//!                               context at all).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Retrieves the mode in which a given context can access a
//!                specific transceiver.
//!
//! RETURN STATUS: NVAPI_OK                  - Success
//!                NVAPI_ERROR               - Unspecified error
//!                NVAPI_API_NOT_INITIALIZED - NvAPI was not intialized
//!                NVAPI_INVALID_HANDLE      - Invalid context or transceiver handle
//!                NVAPI_INVALID_POINTER     - pMode is NULL
//!                NVAPI_NO_IMPLEMENTATION   - Function is not implemented by SW
//! \endcode
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_3DVP_GetTransceiverAccess( Nv3DVPContextHandle hContext, Nv3DVPTransceiverHandle hTransceiver, NVAPI_3DVP_ACCESS * pAccess );



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_3DVP_ResetTransceiverToFactorySettings
//
//! \code
//! INPUT:         hContext     - Handle of 3DVP context with access to given transceiver.
//!                hTransceiver - Handle of transceiver to reset.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Resets a transceiver to its factory settings. Fails if
//!                context has no write-access for given transceiver.
//!
//! RETURN STATUS: NVAPI_OK                  - Success
//!                NVAPI_ERROR               - Unspecified error
//!                NVAPI_API_NOT_INITIALIZED - NvAPI was not intialized
//!                NVAPI_INVALID_HANDLE      - Invalid context or transceiver handle
//!                NVAPI_ACCESS_DENIED       - Context has insufficient access rights to given transceiver 
//!                NVAPI_NOT_SUPPORTED       - Function is not supported by HW
//!                NVAPI_NO_IMPLEMENTATION   - Function is not implemented by SW
//! \endcode
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_3DVP_ResetTransceiverToFactorySettings( Nv3DVPContextHandle hContext, Nv3DVPTransceiverHandle hTransceiver );





///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_3DVP_GetTransceiverInfo
//
//! \fn NvAPI_3DVP_GetTransceiverInfo
//! \code
//! INPUT:         hContext     - Handle of 3DVP context with access to given transceiver.
//!                hTransceiver - Handle of transceiver to get info about.
//!                pInfo        - Pointer to store transceiver info to.
//!
//! OUTPUT:        *pInfo       - Retrieved transceiver info (undefined on
//!                               failure).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Retrieves common information about a transceiver. Fails if
//!                context has no read-access to given transceiver.
//!
//! RETURN STATUS: NVAPI_OK                          - Success
//!                NVAPI_ERROR                       - Unspecified error
//!                NVAPI_API_NOT_INITIALIZED         - NvAPI was not intialized
//!                NVAPI_INVALID_HANDLE              - Invalid context or transceiver handle
//!                NVAPI_INVALID_POINTER             - pInfo is NULL
//!                NVAPI_INCOMPATIBLE_STRUCT_VERSION - *pInfo version incompatible 
//!                NVAPI_ACCESS_DENIED               - Context has insufficient access rights to given transceiver 
//!                NVAPI_NOT_SUPPORTED               - Function is not supported by HW
//!                NVAPI_NO_IMPLEMENTATION           - Function is not implemented by SW
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \ingroup stereo3dvpapi
//! @{


//! 3D Vision Pro RF address - just 5 opaque bytes (like a MAC address):
typedef struct
{
    NvU8 a0;
    NvU8 a1;
    NvU8 a2;
    NvU8 a3;
    NvU8 a4;
} NVAPI_3DVP_RF_ADDRESS;

//! 3D Vision Pro HW serial number - array of NVAPI_3DVP_SERIAL_NUMBER_LENGTH digits
#define NVAPI_3DVP_SERIAL_NUMBER_LENGTH 13
typedef NvU8 NVAPI_3DVP_SERIAL_NUMBER[NVAPI_3DVP_SERIAL_NUMBER_LENGTH];

//! 3D Vision Pro transceiver info:
typedef struct
{
    NvU32                    version;      //!< NvAPI struct version
    NvU32                    hwFeatures;   //!< opaque bitfield of HW features
    NvU32                    fwRevA;       //!< firmware version of chip A
    NvU32                    fwRevB;       //!< firmware version of chip B
    NvU32                    fwRevC;       //!< firmware version of chip C
    NVAPI_3DVP_RF_ADDRESS    rfAddress;    //!< RF address of this transceiver
    NvU32                    channelCount; //!< number of channels on this transceiver
    NVAPI_3DVP_SERIAL_NUMBER serialNumber; //!< serial number
    NvU32                    isEmbedded;   //!< embedded transceiver?
} NVAPI_3DVP_TRANSCEIVER_INFO;

//! NVAPI_3DVP_TRANSCEIVER_INFO version history:
//! 1 - intial version
//! 2 - added serialNumber, isEmbedded
#define NVAPI_3DVP_TRANSCEIVER_INFO_VER MAKE_NVAPI_VERSION(NVAPI_3DVP_TRANSCEIVER_INFO,2)

//! @}


//! \ingroup stereo3dvpapi
NVAPI_INTERFACE NvAPI_3DVP_GetTransceiverInfo( Nv3DVPContextHandle hContext, Nv3DVPTransceiverHandle hTransceiver, NVAPI_3DVP_TRANSCEIVER_INFO * pInfo );





///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_3DVP_IsAirplaneModeEnabled
//
//! DESCRIPTION:   Queries whether airplane mode is enabled for given transceiver.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//!
//! \param [in]  hContext     - Handle of 3DVP context with access to given
//!                             transceiver
//! \param [in]  hTransceiver - Handle of transceiver to get the airplane mode state for
//! \param [out] pEnabled    - != 0: Airplane mode is enabled, 0: otherwise
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. 
//!          If there are return error codes with specific meaning for this API, 
//!          they are listed below.
//!
//! \retval NVAPI_ACCESS_DENIED - Context has insufficient access rights to given transceiver 
//!
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_3DVP_IsAirplaneModeEnabled( __in  Nv3DVPContextHandle hContext,
                                                  __in  Nv3DVPTransceiverHandle hTransceiver,
                                                  __out NvU32 * pEnabled );




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_3DVP_GetTransceiverSignalQuality
//
//! DESCRIPTION:   Retrieves the current signal quality for a specific transceiver.
//!                Fails if context has no read-access for given transceiver.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//!
//! \param [in]  hContext     - Handle of 3DVP context with access to given
//!                             transceiver
//! \param [in]  hTransceiver - Handle of transceiver to get the signal quality for
//! \param [out] pQuality     - Signal quality [0(worst)..100(best)]
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. 
//!          If there are return error codes with specific meaning for this API, 
//!          they are listed below.
//!
//! \retval ::NVAPI_ACCESS_DENIED - Context has insufficient access rights to given transceiver 
//!
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_3DVP_GetTransceiverSignalQuality( __in  Nv3DVPContextHandle hContext,
                                                        __in  Nv3DVPTransceiverHandle hTransceiver,
                                                        __out NvU8 * pQuality );


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_3DVP_GetTransceiverChannelInfo
//
//! \fn NvAPI_3DVP_GetTransceiverChannelInfo
//! \code
//! INPUT:         hContext     - Handle of 3DVP context with access to given transceiver.
//!                hTransceiver - Handle of transceiver to get channel info for.
//!                channelIndex - Index of channel to get info about, range:
//!                                (0..NVAPI_3DVP_TRANSCEIVER_INFO.channelCount].
//!                pInfo        - Pointer to store channel info to.
//!
//! OUTPUT:        *pInfo       - Retrieved channel info (undefined on failure).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Retrieves info about a channel of a given transceiver. Fails
//!                if context has no read-access to given transceiver.
//!
//! RETURN STATUS: NVAPI_OK                          - Success
//!                NVAPI_ERROR                       - Unspecified error
//!                NVAPI_API_NOT_INITIALIZED         - NvAPI was not intialized
//!                NVAPI_INVALID_HANDLE              - Invalid context or transceiver handle
//!                NVAPI_INVALID_POINTER             - pInfo is NULL
//!                NVAPI_INCOMPATIBLE_STRUCT_VERSION - *pInfo version incompatible 
//!                NVAPI_ACCESS_DENIED               - Context has insufficient access rights to given transceiver 
//!                NVAPI_NOT_SUPPORTED               - Function is not supported by HW
//!                NVAPI_NO_IMPLEMENTATION           - Function is not implemented by SW
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \ingroup stereo3dvpapi
//! @{

//! 3D Vision Pro transceiver channel info:
typedef struct
{
    NvU32 version;   //!< NvAPI struct version
    NvU32 frequency; //!< Channel frequency (kHz)
    NvU32 quality;   //!< Channel quality (percent)
} NVAPI_3DVP_CHANNEL_INFO;

#define NVAPI_3DVP_CHANNEL_INFO_VER MAKE_NVAPI_VERSION(NVAPI_3DVP_CHANNEL_INFO,1)

//! @}

//! \ingroup stereo3dvpapi
NVAPI_INTERFACE NvAPI_3DVP_GetTransceiverChannelInfo(__in Nv3DVPContextHandle hContext, __in Nv3DVPTransceiverHandle hTransceiver, __in NvU32 channelIndex, __inout NVAPI_3DVP_CHANNEL_INFO * pInfo );






///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_3DVP_GetTransceiverChannels
//
//! \fn NvAPI_3DVP_GetTransceiverChannels( __in Nv3DVPContextHandle hContext, __in Nv3DVPTransceiverHandle hTransceiver, __out NVAPI_3DVP_CHANNELS * pChannels )
//! DESCRIPTION:   Retrieves the channel sequence that is currently used by a
//!                specific transceiver. Fails if context has no read-access
//!                for given transceiver.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  hContext     - Handle of 3DVP context with access to given
//!                             transceiver
//! \param [in]  hTransceiver - Handle of transceiver to get the current channel for
//! \param [out] pChannels    - Channel sequence used by transceiver for
//!                             communication ({0,0,0,0} on failure)
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. 
//!          If there are return error codes with specific meaning for this API, 
//!          they are listed below.
//!
//! \retval ::NVAPI_ACCESS_DENIED - Context has insufficient access rights to given transceiver 
//!
///////////////////////////////////////////////////////////////////////////////

//! \ingroup stereo3dvpapi
typedef struct {
    NvU8 c0;
    NvU8 c1;
    NvU8 c2;
    NvU8 c3;            
} NVAPI_3DVP_CHANNELS;

//! \ingroup stereo3dvpapi
NVAPI_INTERFACE NvAPI_3DVP_GetTransceiverChannels( __in  Nv3DVPContextHandle hContext,
                                                   __in  Nv3DVPTransceiverHandle hTransceiver,
                                                   __out NVAPI_3DVP_CHANNELS * pChannels );


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_3DVP_SetTransceiverChannels
//
//! DESCRIPTION:   Defines the channel sequence that is to be used by given
//!                transceiver, where i) pChannels->c0..c3 should be within
//!                [0..NVAPI_3DVP_TRANSCEIVER_INFO.channelCount] with at least
//!                one non-zero channel, or ii) pChannels should be NULL to
//!                make the transceiver auto-select a channel sequence.
//!                Fails if context has no write-access for given transceiver.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//!
//! \param [in] hContext     - Handle of 3DVP context with access to given
//!                            transceiver
//! \param [in] hTransceiver - Handle of transceiver to set the current channel for
//! \param [in] pChannels    - Channel sequence to be used by given transceiver
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. 
//!          If there are return error codes with specific meaning for this API, 
//!          they are listed below.
//!
//! \retval ::NVAPI_ACCESS_DENIED - Context has insufficient access rights to given transceiver 
//!
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_3DVP_SetTransceiverChannels( __in Nv3DVPContextHandle hContext,
                                                   __in Nv3DVPTransceiverHandle hTransceiver,
                                                   __in_opt NVAPI_3DVP_CHANNELS * pChannels );

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_3DVP_GetTransceiverChannel
//
//! \code
//! INPUT:         hContext       - Handle of 3DVP context with access to given
//!                                 transceiver
//!                hTransceiver   - Handle of transceiver to get the current channel for
//!                pChannelIndex  - Pointer to store channel index to
//!
//! OUTPUT:        *pChannelIndex - Index of channel used by transceiver for
//!                                 communication (0 on failure)
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Retrieves the channel that is currently used by a specific
//!                transceiver. Fails if context has no read-access for given
//!                transceiver.
//!
//! RETURN STATUS: NVAPI_OK                  - Success
//!                NVAPI_ERROR               - Unspecified error
//!                NVAPI_API_NOT_INITIALIZED - NvAPI was not intialized
//!                NVAPI_INVALID_HANDLE      - Invalid context or transceiver handle
//!                NVAPI_INVALID_POINTER     - pChannelIndex is NULL
//!                NVAPI_ACCESS_DENIED       - Context has insufficient access rights to given transceiver 
//!                NVAPI_NOT_SUPPORTED       - Function is not supported by HW
//!                NVAPI_NO_IMPLEMENTATION   - Function is not implemented by SW
//! \endcode
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_3DVP_GetTransceiverChannel( Nv3DVPContextHandle hContext, Nv3DVPTransceiverHandle hTransceiver, NvU32 * pChannelIndex );



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_3DVP_SetTransceiverChannel
//
//! \code
//! INPUT:         hContext     - Handle of 3DVP context with access to given transceiver
//!                hTransceiver - Handle of transceiver to set the channel for
//!                channelIndex - Index of channel that should be used by
//!                               given transceiver
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Sets the channel that a specific transceiver should use for
//!                communication. Fails if context has no write-access to given
//!                transceiver.
//!
//! RETURN STATUS: NVAPI_OK                  - Success
//!                NVAPI_ERROR               - Unspecified error
//!                NVAPI_API_NOT_INITIALIZED - NvAPI was not intialized
//!                NVAPI_INVALID_HANDLE      - Invalid context or transceiver handle
//!                NVAPI_INVALID_ARGUMENT    - channelIndex out of range
//!                NVAPI_ACCESS_DENIED       - Context has insufficient access rights to given transceiver 
//!                NVAPI_NOT_SUPPORTED       - Function is not supported by HW
//!                NVAPI_NO_IMPLEMENTATION   - Function is not implemented by SW
//! \endcode
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_3DVP_SetTransceiverChannel( Nv3DVPContextHandle hContext, Nv3DVPTransceiverHandle hTransceiver, NvU32 channelIndex );



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_3DVP_GetTransceiverMode
//
//! \fn NvAPI_3DVP_GetTransceiverMode
//! \code
//! INPUT:         hContext     - Handle of 3DVP context with access to given transceiver.
//!                hTransceiver - Handle of transceiver to get mode for.
//!                pMode        - Pointer to store mode to.
//!
//! OUTPUT:        *pMode       - Transceiver mode (NVAPI_3DVP_TM_INVALID on failure)
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Retrieves mode in which a transceiver operates. Fails if
//!                context has no read-access for given transceiver.
//!
//! RETURN STATUS: NVAPI_OK                  - Success
//!                NVAPI_ERROR               - Unspecified error
//!                NVAPI_API_NOT_INITIALIZED - NvAPI was not intialized
//!                NVAPI_INVALID_HANDLE      - Invalid context or transceiver handle
//!                NVAPI_INVALID_POINTER     - pMode is NULL
//!                NVAPI_ACCESS_DENIED       - Context has insufficient access rights to given transceiver 
//!                NVAPI_NOT_SUPPORTED       - Function is not supported by HW
//!                NVAPI_NO_IMPLEMENTATION   - Function is not implemented by SW
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \ingroup stereo3dvpapi
//! 3D Vision Pro transceiver mode:
typedef enum _NVAPI_3DVP_TRANSCEIVER_MODE
{
    NVAPI_3DVP_TM_INVALID = 0,  //!< invalid
    NVAPI_3DVP_TM_LOW_RANGE,    //!< bidirectional
    NVAPI_3DVP_TM_MEDIUM_RANGE, //!< bidirectional
    NVAPI_3DVP_TM_HIGH_RANGE,   //!< may be bidirectinoal just up to a given range, and unidirectional beyond it
    NVAPI_3DVP_TM_COUNT,        //!< total number of transceiver modes
} NVAPI_3DVP_TRANSCEIVER_MODE;


//! \ingroup stereo3dvpapi
NVAPI_INTERFACE NvAPI_3DVP_GetTransceiverMode( Nv3DVPContextHandle hContext, Nv3DVPTransceiverHandle hTransceiver, NVAPI_3DVP_TRANSCEIVER_MODE * pMode );



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_3DVP_SetTransceiverMode
//
//! \code
//! INPUT:         hContext     - Handle of 3DVP context with access to given transceiver.
//!                hTransceiver - Handle of transceiver to set mode for.
//!                mode         - Mode that should be used by transceiver.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Sets the mode in which a transceiver should operate. Fails
//!                if context has no write-access to given transceiver.
//!
//! RETURN STATUS: NVAPI_OK                  - Success
//!                NVAPI_ERROR               - Unspecified error
//!                NVAPI_API_NOT_INITIALIZED - NvAPI was not intialized
//!                NVAPI_INVALID_HANDLE      - Invalid context or transceiver handle
//!                NVAPI_INVALID_ARGUMENT    - mode out of range
//!                NVAPI_ACCESS_DENIED       - Context has insufficient access rights to given transceiver 
//!                NVAPI_NOT_SUPPORTED       - Function is not supported by HW
//!                NVAPI_NO_IMPLEMENTATION   - Function is not implemented by SW
//! \endcode
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_3DVP_SetTransceiverMode( Nv3DVPContextHandle hContext, Nv3DVPTransceiverHandle hTransceiver, NVAPI_3DVP_TRANSCEIVER_MODE mode );




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_3DVP_GetTransceiverState
//
//! \fn NvAPI_3DVP_GetTransceiverState
//! \code
//! INPUT:         hContext     - Handle of 3DVP context with access to given transceiver.
//!                hTransceiver - Handle of transceiver to get state for.
//!                pState       - Pointer to store transceiver state to.
//!
//! OUTPUT:        *pState      - Current transceiver state (undefined on
//!                               failure).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Retrieves the hardware state of a transceiver. Fails if
//!                context cannot be accessed.
//!
//! RETURN STATUS: NVAPI_OK                          - Success
//!                NVAPI_ERROR                       - Unspecified error
//!                NVAPI_API_NOT_INITIALIZED         - NvAPI was not intialized
//!                NVAPI_INVALID_HANDLE              - Invalid context or transceiver handle
//!                NVAPI_INVALID_POINTER             - pState is NULL
//!                NVAPI_INCOMPATIBLE_STRUCT_VERSION - *pState version incompatible
//!                NVAPI_ACCESS_DENIED               - Context has insufficient access rights to given transceiver 
//!                NVAPI_NOT_SUPPORTED               - Function is not supported by HW
//!                NVAPI_NO_IMPLEMENTATION           - Function is not implemented by SW
//! \endcode
///////////////////////////////////////////////////////////////////////////////


//! \ingroup stereo3dvpapi
//! 3D Vision Pro transceiver state:
typedef struct
{
    NvU32 version; // NvAPI struct version
    NvU32 button;  // button state [bitfield: button0, ..., button31]
    NvS32 wheel;   // wheel state [relative clicks]
}  NVAPI_3DVP_TRANSCEIVER_STATE;

//! \ingroup stereo3dvpapi
#define NVAPI_3DVP_TRANSCEIVER_STATE_VER MAKE_NVAPI_VERSION(NVAPI_3DVP_TRANSCEIVER_STATE,1)

//! \ingroup stereo3dvpapi
NVAPI_INTERFACE NvAPI_3DVP_GetTransceiverState( Nv3DVPContextHandle hContext, Nv3DVPTransceiverHandle hTransceiver, NVAPI_3DVP_TRANSCEIVER_STATE * pState );


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_3DVP_PairGlasses
//
//! \fn NvAPI_3DVP_PairGlasses
//! \code
//! INPUT:         hContext     - Handle of 3DVP context with access to given transceiver.
//!                hTransceiver - Handle of transceiver to pair glasses on.
//!                timeOut      - Pairing timeout in seconds or pairing mode (see description).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Puts a transceiver into pairing mode to gather additional
//!                3DVP glasses, where the time out value controls the pairing:
//!                - STOP_PAIRING stops any pairing by zero timeout,
//!                - START_PAIRING_BEACON starts continuous pairing via beacon
//!                  mode, and
//!                - any other number N puts the transceiver into pairing mode
//!                  for N seconds.
//!                Fails if context has no write-access to given transceiver.
//!
//! RETURN STATUS: NVAPI_OK                  - Success
//!                NVAPI_ERROR               - Unspecified error
//!                NVAPI_API_NOT_INITIALIZED - NvAPI was not intialized
//!                NVAPI_INVALID_HANDLE      - Invalid context or transceiver handle
//!                NVAPI_ACCESS_DENIED       - Context has insufficient access rights to given transceiver 
//!                NVAPI_NOT_SUPPORTED       - Function is not supported by HW
//!                NVAPI_NO_IMPLEMENTATION           - Function is not implemented by SW
//! \endcode
///////////////////////////////////////////////////////////////////////////////


//! \ingroup stereo3dvpapi
//! 3D Vision Pro pairing mode - to be used as timeOur values for PairGlasses() to control beacon pairing
typedef enum _NVAPI_3DVP_PAIRING_MODE
{
    NVAPI_3DVP_PM_STOP_PAIRING         = 0,          //!< stops any pairing
    NVAPI_3DVP_PM_START_PAIRING_BEACON = 0xFFFFFFFF, //!< starts pairing in beacon mode
} NVAPI_3DVP_PAIRING_MODE;

//! \ingroup stereo3dvpapi
NVAPI_INTERFACE NvAPI_3DVP_PairGlasses( Nv3DVPContextHandle hContext, Nv3DVPTransceiverHandle hTransceiver, NvU32 timeOut );



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_3DVP_UnpairGlasses
//
//! \code
//! INPUT:         hContext     - Handle of 3DVP context with access to given transceiver.
//!                hTransceiver - Handle of transceiver to unpair glasses from.
//!                hGlasses     - Handle of glasses to unpair from transceiver. Set this
//!                               to NULL to unpair *any* glasses.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Tells a specific pair of glasses ( glasses != NULL ), or
//!                *all* glasses ( glasses == NULL ) to unpair (glasses will
//!                "forget" the address of the transceiver to which they have
//!                been paired). Fails if context has no write-access to given
//!                transceiver.
//!
//! RETURN STATUS: NVAPI_OK                  - Success
//!                NVAPI_ERROR               - Unspecified error
//!                NVAPI_API_NOT_INITIALIZED - NvAPI was not intialized
//!                NVAPI_INVALID_HANDLE      - Invalid context or transceiver handle
//!                NVAPI_ACCESS_DENIED       - Context has insufficient access rights to given transceiver 
//!                NVAPI_NOT_SUPPORTED       - Function is not supported by HW
//!                NVAPI_NO_IMPLEMENTATION           - Function is not implemented by SW
//! \endcode
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_3DVP_UnpairGlasses( Nv3DVPContextHandle hContext, Nv3DVPTransceiverHandle hTransceiver, Nv3DVPGlassesHandle hGlasses );



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_3DVP_DiscoverGlasses
//! \code
//! INPUT:         hContext     - Handle of 3DVP context with access to given transceiver.
//!                hTransceiver - Handle of transceiver to discover glasses on.
//!                timeOut      - Timeout in seconds for discovering glasses.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Glasses that have been paired using START_PAIRING_BEACON are
//!                unknown to the transceiver until they are manually discovered
//!                using NvAPI_3DVP_DiscoverGlasses.
//!
//! RETURN STATUS: NVAPI_OK                  - Success
//!                NVAPI_ERROR               - Unspecified error
//!                NVAPI_API_NOT_INITIALIZED - NvAPI was not intialized
//!                NVAPI_INVALID_HANDLE      - Invalid context or transceiver handle
//!                NVAPI_ACCESS_DENIED       - Context has insufficient access rights to given transceiver 
//!                NVAPI_NOT_SUPPORTED       - Function is not supported by HW
//!                NVAPI_NO_IMPLEMENTATION   - Function is not implemented by SW
//! \endcode
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_3DVP_DiscoverGlasses( Nv3DVPContextHandle hContext, Nv3DVPTransceiverHandle hTransceiver, NvU32 timeOut );






///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_3DVP_EnumGlasses
//
//! \code
//! INPUT:         hContext     - Handle of 3DVP context with access to given transceiver.
//!                hTransceiver - Handle of transceiver to enumerate glasses on.
//!                phGlasses    - Pointer to store glasses handle to. Set this
//!                               to NULL to begin an enumeration, and pass last
//!                               result to continue an enumeration.
//!
//! OUTPUT:        *phGlasses   - Enumerated transceiver handle (NULL on failure
//!                               and on end of enumeration).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Enumerates glasses on a given transceiver. Set
//!                *phGlasses to NULL to start a new enumeration, and to
//!                the last enumeration result to continue an enumeration.
//!                Returns NVAPI_END_ENUMERATION and sets *phGlasses to
//!                NULL at the end of an enumeration. Fails if context has no
//!                read-access for given transceiver.
//!
//! RETURN STATUS: NVAPI_OK                  - Success
//!                NVAPI_ERROR               - Unspecified error
//!                NVAPI_API_NOT_INITIALIZED - NvAPI was not intialized
//!                NVAPI_INVALID_HANDLE      - Invalid context or transceiver handle
//!                NVAPI_INVALID_POINTER     - phGlasses is NULL
//!                NVAPI_ACCESS_DENIED       - Context has insufficient access rights to given transceiver 
//!                NVAPI_NOT_SUPPORTED       - Function is not supported by HW
//!                NVAPI_NO_IMPLEMENTATION   - Function is not implemented by SW
//! \endcode
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_3DVP_EnumGlasses( Nv3DVPContextHandle hContext, Nv3DVPTransceiverHandle hTransceiver, Nv3DVPGlassesHandle * phGlasses );



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_3DVP_GetTransceiver
//
//! \code
//! INPUT:         hContext       - Handle of 3DVP context with access to given glasses.
//!                hGlasses       - Handle of glasses to get transceiver for.
//!                phTransceiver  - Pointer to store transceiver handle to.
//!
//! OUTPUT:        *phTransceiver - Handle of transceiver to which given glasses
//!                                 are paired (NULL on failure).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Retrieves transceiver to that given glasses are associated.
//!
//! RETURN STATUS: NVAPI_OK                  - Success
//!                NVAPI_ERROR               - Unspecified error
//!                NVAPI_API_NOT_INITIALIZED - NvAPI was not intialized
//!                NVAPI_INVALID_HANDLE      - Invalid context or glasses handle
//!                NVAPI_INVALID_POINTER     - phTransceiver is NULL
//!                NVAPI_NO_IMPLEMENTATION   - Function is not implemented by SW
//! \endcode
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_3DVP_GetTransceiver( Nv3DVPContextHandle hContext, Nv3DVPGlassesHandle hGlasses, Nv3DVPTransceiverHandle * pTransceiver );



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_3DVP_GetGlassesAccess
//
//! \code
//! INPUT:         hContext - Handle of 3DVP context with access to given glasses.
//!                hGlasses - Handle of glasses to get access mode for.
//!                pAccess  - Pointer to store access mode to.
//!
//! OUTPUT:        *pAccess - Glasses access mode (NVAPI_3DVP_ACC_NONE on
//!                          failure).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Retrieves the access mode for given glasses, which is
//!                inherited from (= equals) the access mode to the
//!                transceiver to which given glasses are paired.
//!
//! RETURN STATUS: NVAPI_OK                  - Success
//!                NVAPI_ERROR               - Unspecified error
//!                NVAPI_API_NOT_INITIALIZED - NvAPI was not intialized
//!                NVAPI_INVALID_HANDLE      - Invalid context or glasses handle
//!                NVAPI_INVALID_POINTER     - pAccess is NULL
//!                NVAPI_NO_IMPLEMENTATION   - Function is not implemented by SW
//! \endcode
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_3DVP_GetGlassesAccess( Nv3DVPContextHandle hContext, Nv3DVPGlassesHandle hGlasses, NVAPI_3DVP_ACCESS * pAccess );



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_3DVP_IdentifyGlasses
//
//! \code
//! INPUT:         hContext - Handle of 3DVP context with access to given glasses.
//!                hGlasses - Handle of glasses to identify.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Causes glasses LEDs to flash for a short period of time.
//!                Fails if context has no write-access for given glasses.
//!
//! RETURN STATUS: NVAPI_OK                  - Success
//!                NVAPI_ERROR               - Unspecified error
//!                NVAPI_API_NOT_INITIALIZED - NvAPI was not intialized
//!                NVAPI_INVALID_HANDLE      - Invalid context or glasses handle
//!                NVAPI_ACCESS_DENIED       - Context has insufficient access rights to given glasses
//!                NVAPI_NOT_SUPPORTED       - Function is not supported by HW
//!                NVAPI_NO_IMPLEMENTATION   - Function is not implemented by SW
//! \endcode
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_3DVP_IdentifyGlasses( Nv3DVPContextHandle hContext, Nv3DVPGlassesHandle hGlasses );



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_3DVP_ResetGlassesToFactorySettings
//
//! \code
//! INPUT:         hContext - Handle of 3DVP context with access to given glasses.
//!                hGlasses - Handle of glasses to reset.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Resets glasses to factory settings. Fails if given context
//!                has no write-access for given glasses.
//!
//! RETURN STATUS: NVAPI_OK                  - Success
//!                NVAPI_ERROR               - Unspecified error
//!                NVAPI_API_NOT_INITIALIZED - NvAPI was not intialized
//!                NVAPI_INVALID_HANDLE      - Invalid context or glasses handle
//!                NVAPI_ACCESS_DENIED       - Context has insufficient access rights to given glasses
//!                NVAPI_NOT_SUPPORTED       - Function is not supported by HW
//!                NVAPI_NO_IMPLEMENTATION   - Function is not implemented by SW
//! \endcode
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_3DVP_ResetGlassesToFactorySettings( Nv3DVPContextHandle hContext, Nv3DVPGlassesHandle hGlasses );



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_3DVP_GetGlassesInfo
//
//! \fn NvAPI_3DVP_GetGlassesInfo
//! \code
//! INPUT:         hContext - Handle of 3DVP context with access to given glasses.
//!                hGlasses - Handle of glasses to get info for.
//!                pInfo    - Pointer to store glasses info to.
//!
//! OUTPUT:        *pInfo   - Glasses info (undefined on failure).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Retrieves info about glasses. Fails if context has no
//!                read-access to given glasses.
//!
//! RETURN STATUS: NVAPI_OK                          - Success
//!                NVAPI_ERROR                       - Unspecified error
//!                NVAPI_API_NOT_INITIALIZED         - NvAPI was not intialized
//!                NVAPI_INVALID_HANDLE              - Invalid context or glasses handle
//!                NVAPI_INVALID_POINTER             - pInfo is NULL
//!                NVAPI_INCOMPATIBLE_STRUCT_VERSION - *pInfo version incompatible
//!                NVAPI_ACCESS_DENIED               - Context has insufficient access rights to given glasses
//!                NVAPI_NOT_SUPPORTED               - Function is not supported by HW
//!                NVAPI_NO_IMPLEMENTATION           - Function is not implemented by SW
//! \endcode
///////////////////////////////////////////////////////////////////////////////


//! \ingroup stereo3dvpapi
//! 3D Vision Pro glasses info:
typedef struct
{
    NvU32                    version;      //!< NvAPI struct version
    NvU32                    hwFeatures;   //!< opaque bitfield of HW features
    NvU32                    fwRevA;       //!< firmware version of chip A
    NVAPI_3DVP_RF_ADDRESS    rfAddress;    //!< RF address assigned to these glasses
    NVAPI_3DVP_SERIAL_NUMBER serialNumber; //!< serial number
    NvU32                    repairCount;  //!< number of times these glasses have been re-paired
}  NVAPI_3DVP_GLASSES_INFO;

//! NVAPI_3DVP_GLASSES_INFO version history:
//! 1 - intial version
//! 2 - added serialNumber, repairCount
#define NVAPI_3DVP_GLASSES_INFO_VER MAKE_NVAPI_VERSION(NVAPI_3DVP_GLASSES_INFO,2)

//! \ingroup stereo3dvpapi
NVAPI_INTERFACE NvAPI_3DVP_GetGlassesInfo( Nv3DVPContextHandle hContext, Nv3DVPGlassesHandle hGlasses, NVAPI_3DVP_GLASSES_INFO * pInfo );


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_3DVP_GetGlassesSyncCycle
//
//! \code
//! INPUT:         hContext - Handle of 3DVP context with access to given glasses.
//!                hGlasses - Handle of glasses to get sync cycle for.
//!                pCycle   - Pointer to store glasses sync cycle to.
//!
//! OUTPUT:        *pCycle  - Glasses sync cycle [milliseconds] (0 on failure).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Retrieves the sync cycle duration [milliseconds] of glasses.
//!                Fails if context has no read-access to given glasses.
//!
//! RETURN STATUS: NVAPI_OK                  - Success
//!                NVAPI_ERROR               - Unspecified error
//!                NVAPI_API_NOT_INITIALIZED - NvAPI was not intialized
//!                NVAPI_INVALID_HANDLE      - Invalid context or glasses handle
//!                NVAPI_INVALID_POINTER     - pCycle is NULL
//!                NVAPI_ACCESS_DENIED       - Context has insufficient access rights to given glasses
//!                NVAPI_NOT_SUPPORTED       - Function is not supported by HW
//!                NVAPI_NO_IMPLEMENTATION   - Function is not implemented by SW
//! \endcode
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_3DVP_GetGlassesSyncCycle( Nv3DVPContextHandle hContext, Nv3DVPGlassesHandle hGlasses, NvU32 * pSyncCycle );



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_3DVP_SetGlassesSyncCycle
//
//! \code
//! INPUT:         hContext - Handle of 3DVP context with access to given glasses.
//!                hGlasses - Handle of glasses to set sync cycle for.
//!                cycle    - Glasses sync cycle [milliseconds].
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Sets the sync cycle duration [milliseconds] that glasses
//!                should use. Fails if context has no write-access for given
//!                glasses.
//!
//! RETURN STATUS: NVAPI_OK                  - Success
//!                NVAPI_ERROR               - Unspecified error
//!                NVAPI_API_NOT_INITIALIZED - NvAPI was not intialized
//!                NVAPI_INVALID_HANDLE      - Invalid context or glasses handle
//!                NVAPI_ACCESS_DENIED       - Context has insufficient access rights to given glasses
//!                NVAPI_NOT_SUPPORTED       - Function is not supported by HW
//!                NVAPI_NO_IMPLEMENTATION   - Function is not implemented by SW
//! \endcode
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_3DVP_SetGlassesSyncCycle( Nv3DVPContextHandle hContext, Nv3DVPGlassesHandle hGlasses, NvU32 syncCycle );



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_3DVP_GetGlassesName
//
//! \code
//! INPUT:         hContext - Handle of 3DVP context with access to given glasses.
//!                hGlasses - Handle of glasses to get name of.
//!                pName    - Pointer to store glasses name to.
//!
//! OUTPUT:        *pName   - Glasses name ("" on failure).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Retrieves name of glasses. Fails if context has no
//!                read-access for given glasses.
//!
//! RETURN STATUS: NVAPI_OK                  - Success
//!                NVAPI_ERROR               - Unspecified error
//!                NVAPI_API_NOT_INITIALIZED - NvAPI was not intialized
//!                NVAPI_INVALID_HANDLE      - Invalid context or glasses handle
//!                NVAPI_INVALID_POINTER     - pName is NULL
//!                NVAPI_ACCESS_DENIED       - Context has insufficient access rights to given glasses
//!                NVAPI_NOT_SUPPORTED       - Function is not supported by HW
//!                NVAPI_NO_IMPLEMENTATION   - Function is not implemented by SW
//! \endcode
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_3DVP_GetGlassesName( Nv3DVPContextHandle hContext, Nv3DVPGlassesHandle hGlasses, NvAPI_UnicodeString * pName );



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_3DVP_SetGlassesName
//
//! \code
//! INPUT:         hContext - Handle of 3DVP context with access to given glasses.
//!                hGlasses - Handle of glasses to set name of.
//!                name     - Glasses name.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Sets name that glasses should use. Fails if context has no
//!                write-access for given glasses.
//!
//! RETURN STATUS: NVAPI_OK                  - Success
//!                NVAPI_ERROR               - Unspecified error
//!                NVAPI_API_NOT_INITIALIZED - NvAPI was not intialized
//!                NVAPI_INVALID_HANDLE      - Invalid context or glasses handle
//!                NVAPI_ACCESS_DENIED       - Context has insufficient access rights to given glasses
//!                NVAPI_NOT_SUPPORTED       - Function is not supported by HW
//!                NVAPI_NO_IMPLEMENTATION   - Function is not implemented by SW
//! \endcode
//! \ingroup stereo3dvpapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_3DVP_SetGlassesName( Nv3DVPContextHandle hContext, Nv3DVPGlassesHandle hGlasses, NvAPI_UnicodeString name );



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_3DVP_GetGlassesState
//
//! \fn NvAPI_3DVP_GetGlassesState
//! \code
//! INPUT:         hContext - Handle of 3DVP context with access to given glasses.
//!                hGlasses - Handle of glasses to get state for.
//!                pState   - Pointer to store glasses state to.
//!
//! OUTPUT:        *pState  - Current state of given glasses (undefined on
//!                           failure).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Retrieves state of glasses - note that the state of glasses
//!                is updated just once per sync cycle so that its update
//!                frequency equals 1 / (glasses' sync cycle duration).
//!                Fails if context has no read-access for given glasses.
//!
//! RETURN STATUS: NVAPI_OK                          - Success
//!                NVAPI_ERROR                       - Unspecified error
//!                NVAPI_API_NOT_INITIALIZED         - NvAPI was not intialized
//!                NVAPI_INVALID_HANDLE              - Invalid context or glasses handle
//!                NVAPI_INVALID_POINTER             - pState is NULL
//!                NVAPI_INCOMPATIBLE_STRUCT_VERSION - *pState version incompatible
//!                NVAPI_ACCESS_DENIED               - Context has insufficient access rights to given glasses
//!                NVAPI_NOT_SUPPORTED               - Function is not supported by HW
//!                NVAPI_NO_IMPLEMENTATION           - Function is not implemented by SW
//! \endcode
///////////////////////////////////////////////////////////////////////////////


//! \ingroup stereo3dvpapi
//! 3D Vision Pro glasses state:
typedef struct
{
    NvU32 version;         //!< NvAPI struct version
    NvU32 missedCycles;    //!< number of recently missed state sync cycles
    NvU32 battery;         //!< battery level [percent]
    NvU32 batteryVoltage;  //!< battery voltage
    NvU32 batteryCharging; //!< battery charge state
}  NVAPI_3DVP_GLASSES_STATE;

//! NVAPI_3DVP_GLASSES_STATE version history:
//! 1 - intial version
//! 2 - added batteryVoltage, batteryCharging; removed compass, accel
#define NVAPI_3DVP_GLASSES_STATE_VER MAKE_NVAPI_VERSION(NVAPI_3DVP_GLASSES_STATE,1)

//! \ingroup stereo3dvpapi
NVAPI_INTERFACE NvAPI_3DVP_GetGlassesState( Nv3DVPContextHandle hContext, Nv3DVPGlassesHandle hGlasses, NVAPI_3DVP_GLASSES_STATE * pState );

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_3DVP_WaitEvent
//
//! \fn NvAPI_3DVP_WaitEvent
//! \code
//! INPUT:         hContext - Handle of 3DVP context on whose events to wait.
//!                pEvent   - Pointer to store an event to
//!                timeout  - Timeout in milliseconds used to wait for events.
//!
//! OUTPUT:        *pEvent  - 3DVP event (undefined on failure).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:   Waits for a 3DVP event and stores it in *pEvent. Note that
//!                this functions blocks until an event was generated, so that
//!                it should be executed in a dedicated thread.
//!                Destroy the context passed to WaitEvent to stop waiting for
//!                events (WaitEvent will return a CONTEXT_DESTROYED event).
//!
//! RETURN STATUS: NVAPI_OK                          - Success
//!                NVAPI_TIMEOUT                     - WaitEvent timed out waiting for events
//!                NVAPI_ERROR                       - Unspecified error
//!                NVAPI_API_NOT_INITIALIZED         - NvAPI was not intialized
//!                NVAPI_INVALID_HANDLE              - Invalid context handle
//!                NVAPI_INVALID_POINTER             - pEvent is NULL
//!                NVAPI_INCOMPATIBLE_STRUCT_VERSION - *pEvent version incompatible
//!                NVAPI_NOT_SUPPORTED               - Function is not supported by HW
//!                NVAPI_NO_IMPLEMENTATION           - Function is not implemented by SW
//! \endcode
///////////////////////////////////////////////////////////////////////////////


//! \ingroup stereo3dvpapi
// 3D Vision Pro event types:
typedef enum _NVAPI_3DVP_EVENT_TYPE
{
    NVAPI_3DVP_ET_INVALID = 0,                  //!< no event type
    NVAPI_3DVP_ET_CONTEXT_DESTROYED,            //!< context that was passed to WaitEvent has been destroyed
    NVAPI_3DVP_ET_TRANSCEIVER_ENUM_DIRTY,       //!< enumeration of transceivers has been invalidated (PnP)
    NVAPI_3DVP_ET_TRANSCEIVER_STALLED,          //!< given transceiver stalled due to an internal error
    NVAPI_3DVP_ET_AIRPLANE_MODE_TOGGLED,        //!< airplane mode was toggled for given transceiver
    NVAPI_3DVP_ET_SIGNAL_QUALITY_CHANGED,       //!< signal quality changed for given transceiver
    NVAPI_3DVP_ET_PAIRING_GLASSES_STARTED,      //!< given transceiver started pairing glasses
    NVAPI_3DVP_ET_PAIRING_GLASSES_COMPLETE,     //!< given transceiver completed pairing glasses
    NVAPI_3DVP_ET_DISCOVERING_GLASSES_STARTED,  //!< given transceiver started discovering glasses
    NVAPI_3DVP_ET_DISCOVERING_GLASSES_COMPLETE, //!< given transceiver completed discovering glasses
    NVAPI_3DVP_ET_GLASSES_ENUM_DIRTY,           //!< enumeration of glasses changed for given transceiver
    NVAPI_3DVP_ET_GLASSES_NAMES_CHANGED,        //!< names of some glasses changed for given transceiver
    NVAPI_3DVP_ET_GLASSES_STATES_CHANGED,       //!< state of some glasses changed for given transceiver
    NVAPI_3DVP_ET_COUNT,                        //!< total number of event types (not an event type)
} NVAPI_3DVP_EVENT_TYPE;

//! 3D Vision Pro event:
typedef struct
{
    NvU32                   version;      //!< NvAPI struct version
    NVAPI_3DVP_EVENT_TYPE   type;         //!< event type (see above)
    Nv3DVPTransceiverHandle hTransceiver; //!< optional: transceiver this events refers to (see NVAPI_3DVP_EVENT_TYPE)
} NVAPI_3DVP_EVENT;

//! NVAPI_3DVP_EVENT version history:
//! 1 - intial version
//! 2 - replaced event arg union by single, optional transceiver parameter
#define NVAPI_3DVP_EVENT_VER MAKE_NVAPI_VERSION(NVAPI_3DVP_EVENT,2)

//! \ingroup stereo3dvpapi
NVAPI_INTERFACE NvAPI_3DVP_WaitEvent( __in  Nv3DVPContextHandle hContext,
                                      __inout NVAPI_3DVP_EVENT * pEvent,
                                      __in NvU32 timeout );

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetDisplayDriverVersion
//! \fn NvAPI_GetDisplayDriverVersion(NvDisplayHandle hNvDisplay, NV_DISPLAY_DRIVER_VERSION *pVersion)
//! This function returns a struct that describes aspects of the display driver
//!                build.
//!
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_SYS_GetDriverAndBranchVersion.
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 80
//!
//! \param [in]  hNvDisplay NVIDIA display handle.
//! \param [out] pVersion Pointer to NV_DISPLAY_DRIVER_VERSION struc
//!
//! \retval NVAPI_ERROR
//! \retval NVAPI_OK
///////////////////////////////////////////////////////////////////////////////

//! \ingroup driverapi
//! Used in NvAPI_GetDisplayDriverVersion()
typedef struct 
{
    NvU32              version;             // Structure version
    NvU32              drvVersion;           
    NvU32              bldChangeListNum;     
    NvAPI_ShortString  szBuildBranchString; 
    NvAPI_ShortString  szAdapterString;
} NV_DISPLAY_DRIVER_VERSION;

//! \ingroup driverapi
#define NV_DISPLAY_DRIVER_VERSION_VER  MAKE_NVAPI_VERSION(NV_DISPLAY_DRIVER_VERSION,1)


//! \ingroup driverapi
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use NvAPI_SYS_GetDriverAndBranchVersion.")
NVAPI_INTERFACE NvAPI_GetDisplayDriverVersion(NvDisplayHandle hNvDisplay, NV_DISPLAY_DRIVER_VERSION *pVersion);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SYS_GetDriverAndBranchVersion
//
//!   DESCRIPTION: This API returns display driver version and driver-branch string.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//! 
//! \param [out]  pDriverVersion         Contains the driver version after successful return.
//! \param [out]  szBuildBranchString    Contains the driver-branch string after successful return.
//!
//! \retval ::NVAPI_INVALID_ARGUMENT: either pDriverVersion is NULL or enum index too big
//! \retval ::NVAPI_OK - completed request
//! \retval ::NVAPI_API_NOT_INTIALIZED - NVAPI not initialized
//! \retval ::NVAPI_ERROR - miscellaneous error occurred
//! 
//! \ingroup driverapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_GetDriverAndBranchVersion(NvU32* pDriverVersion, NvAPI_ShortString szBuildBranchString);

//! \ingroup driverapi
//! Used in NvAPI_GPU_GetMemoryInfo().
typedef struct 
{
    NvU32   version;                        //!< Version info
    NvU32   dedicatedVideoMemory;           //!< Size(in kb) of the physical framebuffer.
    NvU32   availableDedicatedVideoMemory;  //!< Size(in kb) of the available physical framebuffer for allocating video memory surfaces.
    NvU32   systemVideoMemory;              //!< Size(in kb) of system memory the driver allocates at load time.
    NvU32   sharedSystemMemory;             //!< Size(in kb) of shared system memory that driver is allowed to commit for surfaces across all allocations.

} NV_DISPLAY_DRIVER_MEMORY_INFO_V1;


//! \ingroup driverapi
//! Used in NvAPI_GPU_GetMemoryInfo().
typedef struct
{
    NvU32   version;                           //!< Version info
    NvU32   dedicatedVideoMemory;              //!< Size(in kb) of the physical framebuffer.
    NvU32   availableDedicatedVideoMemory;     //!< Size(in kb) of the available physical framebuffer for allocating video memory surfaces.
    NvU32   systemVideoMemory;                 //!< Size(in kb) of system memory the driver allocates at load time.
    NvU32   sharedSystemMemory;                //!< Size(in kb) of shared system memory that driver is allowed to commit for surfaces across all allocations.
    NvU32   curAvailableDedicatedVideoMemory;  //!< Size(in kb) of the current available physical framebuffer for allocating video memory surfaces.

} NV_DISPLAY_DRIVER_MEMORY_INFO_V2;


//! \ingroup driverapi
typedef NV_DISPLAY_DRIVER_MEMORY_INFO_V2 NV_DISPLAY_DRIVER_MEMORY_INFO;

//! \ingroup driverapi
//! Macro for constructing the version field of NV_DISPLAY_DRIVER_MEMORY_INFO_V1
#define NV_DISPLAY_DRIVER_MEMORY_INFO_VER_1  MAKE_NVAPI_VERSION(NV_DISPLAY_DRIVER_MEMORY_INFO_V1,1)

//! \ingroup driverapi
//! Macro for constructing the version field of NV_DISPLAY_DRIVER_MEMORY_INFO_V2
#define NV_DISPLAY_DRIVER_MEMORY_INFO_VER_2  MAKE_NVAPI_VERSION(NV_DISPLAY_DRIVER_MEMORY_INFO_V2,2)

//! \ingroup driverapi
#define NV_DISPLAY_DRIVER_MEMORY_INFO_VER    NV_DISPLAY_DRIVER_MEMORY_INFO_VER_2




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetMemoryInfo
//
//!   DESCRIPTION: This function retrieves the available driver memory footprint for the specified GPU. 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 177
//!
//!  \param [in]   hPhysicalGpu  Handle of the physical GPU for which the memory information is to be extracted.
//!  \param [out]  pMemoryInfo   The memory footprint available in the driver. See NV_DISPLAY_DRIVER_MEMORY_INFO.
//!
//!  \retval       NVAPI_INVALID_ARGUMENT             pMemoryInfo is NULL.
//!  \retval       NVAPI_OK                           Call successful.
//!  \retval       NVAPI_NVIDIA_DEVICE_NOT_FOUND      No NVIDIA GPU driving a display was found.
//!  \retval       NVAPI_INCOMPATIBLE_STRUCT_VERSION  NV_DISPLAY_DRIVER_MEMORY_INFO structure version mismatch.
//!
//!  \ingroup  driverapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetMemoryInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_DISPLAY_DRIVER_MEMORY_INFO *pMemoryInfo);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetDisplayDriverMemoryInfo
//
//! This function retrieves the display driver memory information for the active display handle. \n 
//! In a multi-GPU scenario, the physical framebuffer information is obtained for the GPU associated with active display handle. \n
//! In an SLI-mode scenario, the physical framebuffer information is obtained only from the display owner GPU. \n
//!
//!
//! \deprecated  Do not use this function - it is deprecated in release 313. Instead, use NvAPI_GPU_GetMemoryInfo.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 95
//!
//! \param [in]  hNvDisplay   NVIDIA Display selection. It can be #NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//! \param [out] pMemoryInfo  The memory footprint available in the driver.
//!
//! \retval  NVAPI_INVALID_ARGUMENT             pMemoryInfo is NULL.
//! \retval  NVAPI_OK                           Call successful.
//! \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND      No NVIDIA GPU driving a display was found.
//! \retval  NVAPI_EXPECTED_DISPLAY_HANDLE      hNvDisplay is not a valid display handle.
//! \retval  NVAPI_INCOMPATIBLE_STRUCT_VERSION  NV_DISPLAY_DRIVER_MEMORY_INFO structure version mismatch.
//! \ingroup driverapi
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 313. Instead, use NvAPI_GPU_GetMemoryInfo.")
NVAPI_INTERFACE NvAPI_GetDisplayDriverMemoryInfo(NvDisplayHandle hNvDisplay, NV_DISPLAY_DRIVER_MEMORY_INFO *pMemoryInfo);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetDriverMemoryInfo
//
//! \fn NvAPI_GetDriverMemoryInfo(NvDisplayHandle hNvDisplay, NV_DRIVER_MEMORY_INFO *pMemoryInfo)
//!   DESCRIPTION: This function retrieves the display driver memory information for the active display handle. 
//!                In case of a multi-GPU scenario the physical framebuffer information is obtained for the GPU
//!                associated with the active display handle.
//!                In the case of SLI, the physical framebuffer information is obtained only from the display owner GPU.
//!
//! \deprecated  Do not use this function - it is deprecated in release 313. Instead, use NvAPI_GPU_GetMemoryInfo.
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 177
//!
//! \param [in]   hNvDisplay        NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//! \param [out]  pMemoryInfo       The memory footprint available in the driver.
//!
//! \retval ::NVAPI_INVALID_ARGUMENT
//! \retval ::NVAPI_OK
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND
//! \retval ::NVAPI_EXPECTED_DISPLAY_HANDLE 
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION   NV_DISPLAY_DRIVER_MEMORY_INFO structure version mismatch.
//
///////////////////////////////////////////////////////////////////////////////

 
//! \ingroup driverapi
//! Driver memory information - used in NvAPI_GetDriverMemoryInfo().
typedef struct 
{
    NvU32   version;                        //!< Version info
    NvU32   dedicatedVideoMemory;           //!< Size(in kb) of the physical framebuffer.
    NvU32   systemVideoMemory;              //!< Size(in kb) of system memory the driver allocates at load time.
    NvU32   sharedSystemMemory;             //!< Size(in kb) of shared system memory that driver is allowed to commit for surfaces across all allocations.

} NV_DRIVER_MEMORY_INFO;

//! \ingroup driverapi
//! Used in NV_DRIVER_MEMORY_INFO.
#define NV_DRIVER_MEMORY_INFO_VER   MAKE_NVAPI_VERSION(NV_DRIVER_MEMORY_INFO,1)


//! \ingroup driverapi 
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 313. Instead, use NvAPI_GPU_GetMemoryInfo.")
NVAPI_INTERFACE NvAPI_GetDriverMemoryInfo(NvDisplayHandle hNvDisplay, NV_DRIVER_MEMORY_INFO *pMemoryInfo);






///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetDisplayDriverBuildTitle
//
//!  This function retrieves a string describing the driver build (its title).
//!  This corresponds in the driver build to the #define NV_DISPLAY_DRIVER_TITLE. 
//!
//!  For example, for "Nightly nvr40 40021217 Chloe_Palenchar"
//!        -  The first word is one of "Official" (for BM), "Nightly" (for BM),
//!           "DVSvirtual", "DVSreal", or "Private", describing the build source.
//!        - The second word will be the branch, minus "OEM/" if it exists eg: R40B4, nvr40, main
//!        - The third word will either be a version or a directory-ish name eg: 41.11, 35021216, NV021216
//!        - The fourth word is the author of the most recent changelist that went into the build 
//!          (or author of virtual submission), or "unknown".
//!        - There will always be at least 2 space characters in the string. 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \return  NVAPI_ERROR or NVAPI_OK
//! \ingroup driverapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetDisplayDriverBuildTitle(NvDisplayHandle hNvDisplay, NvAPI_String szTitle);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetDisplayDriverCompileType
//
//! \fn NvAPI_GetDisplayDriverCompileType(NvDisplayHandle hNvDisplay, NvU32 *pCompileType)
//!  This function retrieves a value describing the compile type of the display driver.
//!
//!                See enum ::NVAPI_COMPILE_TYPE
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \return  NVAPI_ERROR or NVAPI_OK
///////////////////////////////////////////////////////////////////////////////

//! \ingroup driverapi
typedef enum
{
    NVAPI_COMPILE_TYPE_UNKNONW = 0,
    NVAPI_COMPILE_TYPE_DEBUG   = 1,
    NVAPI_COMPILE_TYPE_RELEASE = 2,
    NVAPI_COMPILE_TYPE_DEVELOP = 3
} NVAPI_COMPILE_TYPE;

//! \ingroup driverapi
NVAPI_INTERFACE NvAPI_GetDisplayDriverCompileType(NvDisplayHandle hNvDisplay, NvU32 *pCompileType);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetDisplayDriverSecurityType
//
//!  This function retrieves a value describing the display driver security level.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \return  NVAPI_ERROR or NVAPI_OK
//! \ingroup driverapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetDisplayDriverSecurityLevel(NvDisplayHandle hNvDisplay, NvU32 *pdrvSecurityLevel);





///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Diag_GetNvConfigData
//
//! \fn NvAPI_Diag_GetNvConfigData(NV_DIAG_NVCONFIG_DATA *pNvConfigData)
//! \code
//!   DESCRIPTION: Retrieves an encrypted form of the nvconfig data active when nvapi.dll
//!                was constructed.  Consumed by swak.
//!
//!   dataSize member is set to the size of the data returned in the 'data' member
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//!                NVAPI_INCOMPATIBLE_STRUCT_VERSION: if NV_DIAG_NVCONFIG_DATA structure version mismatches.
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \ingroup driverapi
#define NV_MAX_NVCONFIG_BUFFER_SIZE (128*1024)

//! \ingroup driverapi
typedef struct
{
    NvU32      version;       //!< structure version
    NvU32      dataSize;      //!< number of nvconfig bytes actually loaded
    NvU8       data[NV_MAX_NVCONFIG_BUFFER_SIZE];
} NV_DIAG_NVCONFIG_DATA;

//! \ingroup driverapi
//! Macro for constructing the version field of NV_DIAG_NVCONFIG_DATA
#define NV_DIAG_NVCONFIG_DATA_VER  MAKE_NVAPI_VERSION(NV_DIAG_NVCONFIG_DATA,1)

//! \ingroup driverapi
NVAPI_INTERFACE NvAPI_Diag_GetNvConfigData(NV_DIAG_NVCONFIG_DATA *pNvConfigData);




//! \ingroup driverapi
//! Driver access type flags - used in NV_REGISTRY_DATA
typedef enum 
{
    // driver access type flags
    NVAPI_REG_READ_DWORD      , //!< read a dword registry value
    NVAPI_REG_WRITE_DWORD     , //!< write a dword registry value
    NVAPI_REG_READ_BINARY     , //!< read a binary registry value
    NVAPI_REG_WRITE_BINARY    , //!< write a binary registry value
    NVAPI_REG_DELETE_VALUE    , //!< deletes a specific value

} NVAPI_REG_ACCESS_TYPE;

//! \ingroup driverapi
#define NV_MAX_REGISTRY_KEY_NAME 1024

//! \ingroup driverapi
#define NV_MAX_REGISTRY_KEY_VALUE_SIZE 32768

//! \ingroup driverapi
//! Used in NvAPI_AccessDisplayDriverRegistry()
typedef struct
{
    NvU32                      version;                              //!< structure version
    NVAPI_REG_ACCESS_TYPE      iAccessType;                          //!< read or write, DWORD or binary
    char                       pszKeyName[NV_MAX_REGISTRY_KEY_NAME]; //!< display driver registry key to read or write
    NvU32                      cbData;                               //!< size of data to read or write
    void                       *pvData;                              //!< data to read or write
} NV_REGISTRY_DATA;

//! \ingroup driverapi
#define NV_REGISTRY_DATA_VER  MAKE_NVAPI_VERSION(NV_REGISTRY_DATA,1)


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_AccessDisplayDriverRegistry
//
//
//!  This function allows DWORD or binary read/write access to the display driver registry.
//!  The path to the registry is fixed to the display driver registry path for
//!  the hNvDisplay.  Only that registry path will be used and is determined at runtime.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 85
//!
//! \param  hNvDisplay  handle to display you wish to read/write values for
//! \param  pnvRegData  Parameter block for registry operation.  Only pass in the
//!                     key name, not a path.
//!
//! \return  NVAPI_ERROR, NVAPI_OK, or invalid device
//! \ingroup driverapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_AccessDisplayDriverRegistry(NvDisplayHandle hNvDisplay, NV_REGISTRY_DATA *pnvRegData);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetDisplayDriverRegistryPath
//
//!  This function retrieves the display device registry path.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \return  NVAPI_ERROR or NVAPI_OK
//! \ingroup driverapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetDisplayDriverRegistryPath(NvDisplayHandle hNvDisplay, NvAPI_String szRegistryPath);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetUnAttachedDisplayDriverRegistryPath
//
//!  This function retrieves the display device registry path for the unattached display.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Version: 95
//!
//! \return  NVAPI_ERROR or NVAPI_OK
//! \ingroup driverapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetUnAttachedDisplayDriverRegistryPath(NvUnAttachedDisplayHandle hNvUnAttachedDisp, NvAPI_String szRegistryPath);






///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_OGL_ExpertModeSet[Get]
//
//! \name NvAPI_OGL_ExpertModeSet[Get] Functions
//@{
//!  This function configures OpenGL Expert Mode, an API usage feedback and
//!  advice reporting mechanism. The effects of this call are
//!  applied only to the current context, and are reset to the
//!  defaults when the context is destroyed.
//!
//!  \note  This feature is valid at runtime only when GLExpert
//!         functionality has been built into the OpenGL driver
//!         installed on the system. All Windows Vista OpenGL
//!         drivers provided by NVIDIA have this instrumentation
//!         included by default. Windows XP, however, requires a
//!         special display driver available with the NVIDIA
//!         PerfSDK found at developer.nvidia.com.
//!
//!  \note These functions are valid only for the current OpenGL
//!        context. Calling these functions prior to creating a
//!        context and calling MakeCurrent with it will result
//!        in errors and undefined behavior.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \param   expertDetailMask  Mask made up of NVAPI_OGLEXPERT_DETAIL bits,
//!                            this parameter specifies the detail level in
//!                            the feedback stream.
//!
//! \param   expertReportMask  Mask made up of NVAPI_OGLEXPERT_REPORT bits,
//!                            this parameter specifies the areas of
//!                            functional interest.
//!
//! \param   expertOutputMask  Mask made up of NVAPI_OGLEXPERT_OUTPUT bits,
//!                            this parameter specifies the feedback output
//!                            location.
//!
//! \param   expertCallback    Used in conjunction with OUTPUT_TO_CALLBACK,
//!                            this is a simple callback function the user
//!                            may use to obtain the feedback stream. The
//!                            function will be called once per fully
//!                            qualified feedback stream extry.
//!
//! \retval  NVAPI_API_NOT_INTIALIZED          NVAPI not initialized
//! \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND     No NVIDIA GPU found
//! \retval  NVAPI_OPENGL_CONTEXT_NOT_CURRENT  No NVIDIA OpenGL context
//!                                            which supports GLExpert
//!                                            has been made current
//! \retval  NVAPI_ERROR                       OpenGL driver failed to load properly
//! \retval  NVAPI_OK                          Success
//
///////////////////////////////////////////////////////////////////////////////

//! \addtogroup oglapi
//! @{
#define NVAPI_OGLEXPERT_DETAIL_NONE                 0x00000000
#define NVAPI_OGLEXPERT_DETAIL_ERROR                0x00000001
#define NVAPI_OGLEXPERT_DETAIL_SWFALLBACK           0x00000002
#define NVAPI_OGLEXPERT_DETAIL_BASIC_INFO           0x00000004
#define NVAPI_OGLEXPERT_DETAIL_DETAILED_INFO        0x00000008
#define NVAPI_OGLEXPERT_DETAIL_PERFORMANCE_WARNING  0x00000010
#define NVAPI_OGLEXPERT_DETAIL_QUALITY_WARNING      0x00000020
#define NVAPI_OGLEXPERT_DETAIL_USAGE_WARNING        0x00000040
#define NVAPI_OGLEXPERT_DETAIL_ALL                  0xFFFFFFFF

#define NVAPI_OGLEXPERT_REPORT_NONE                 0x00000000
#define NVAPI_OGLEXPERT_REPORT_ERROR                0x00000001
#define NVAPI_OGLEXPERT_REPORT_SWFALLBACK           0x00000002
#define NVAPI_OGLEXPERT_REPORT_PIPELINE_VERTEX      0x00000004
#define NVAPI_OGLEXPERT_REPORT_PIPELINE_GEOMETRY    0x00000008
#define NVAPI_OGLEXPERT_REPORT_PIPELINE_XFB         0x00000010
#define NVAPI_OGLEXPERT_REPORT_PIPELINE_RASTER      0x00000020
#define NVAPI_OGLEXPERT_REPORT_PIPELINE_FRAGMENT    0x00000040
#define NVAPI_OGLEXPERT_REPORT_PIPELINE_ROP         0x00000080
#define NVAPI_OGLEXPERT_REPORT_PIPELINE_FRAMEBUFFER 0x00000100
#define NVAPI_OGLEXPERT_REPORT_PIPELINE_PIXEL       0x00000200
#define NVAPI_OGLEXPERT_REPORT_PIPELINE_TEXTURE     0x00000400
#define NVAPI_OGLEXPERT_REPORT_OBJECT_BUFFEROBJECT  0x00000800
#define NVAPI_OGLEXPERT_REPORT_OBJECT_TEXTURE       0x00001000
#define NVAPI_OGLEXPERT_REPORT_OBJECT_PROGRAM       0x00002000
#define NVAPI_OGLEXPERT_REPORT_OBJECT_FBO           0x00004000
#define NVAPI_OGLEXPERT_REPORT_FEATURE_SLI          0x00008000
#define NVAPI_OGLEXPERT_REPORT_ALL                  0xFFFFFFFF


#define NVAPI_OGLEXPERT_OUTPUT_TO_NONE       0x00000000
#define NVAPI_OGLEXPERT_OUTPUT_TO_CONSOLE    0x00000001
#define NVAPI_OGLEXPERT_OUTPUT_TO_DEBUGGER   0x00000004
#define NVAPI_OGLEXPERT_OUTPUT_TO_CALLBACK   0x00000008
#define NVAPI_OGLEXPERT_OUTPUT_TO_ALL        0xFFFFFFFF

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION TYPE: NVAPI_OGLEXPERT_CALLBACK
//
//!   DESCRIPTION: Used in conjunction with OUTPUT_TO_CALLBACK, this is a simple 
//!                callback function the user may use to obtain the feedback 
//!                stream. The function will be called once per fully qualified 
//!                feedback stream entry.
//!
//!   \param   categoryId    Contains the bit from the NVAPI_OGLEXPERT_REPORT 
//!                          mask that corresponds to the current message
//!   \param   messageId     Unique ID for the current message
//!   \param   detailLevel   Contains the bit from the NVAPI_OGLEXPERT_DETAIL
//!                          mask that corresponds to the current message
//!   \param   objectId      Unique ID of the object that corresponds to the
//!                          current message
//!   \param   messageStr    Text string from the current message
//!
//!   \ingroup oglapi
///////////////////////////////////////////////////////////////////////////////
typedef void (* NVAPI_OGLEXPERT_CALLBACK) (unsigned int categoryId, unsigned int messageId, unsigned int detailLevel, int objectId, const char *messageStr);



//! \ingroup oglapi
//! SUPPORTED OS:  Windows XP and higher
//!
NVAPI_INTERFACE NvAPI_OGL_ExpertModeSet(NvU32 expertDetailLevel,
                                        NvU32 expertReportMask,
                                        NvU32 expertOutputMask,
                     NVAPI_OGLEXPERT_CALLBACK expertCallback);

//! \addtogroup oglapi
//! SUPPORTED OS:  Windows XP and higher
//!
NVAPI_INTERFACE NvAPI_OGL_ExpertModeGet(NvU32 *pExpertDetailLevel,
                                        NvU32 *pExpertReportMask,
                                        NvU32 *pExpertOutputMask,
                     NVAPI_OGLEXPERT_CALLBACK *pExpertCallback);

//@}
///////////////////////////////////////////////////////////////////////////////
//
//! \name NvAPI_OGL_ExpertModeDefaultsSet[Get] Functions
//!
//@{
//!  This function configures OpenGL Expert Mode global defaults. These settings
//!  apply to any OpenGL application which starts up after these
//!  values are applied (i.e. these settings *do not* apply to
//!  currently running applications).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \param   expertDetailLevel Value which specifies the detail level in
//!                            the feedback stream. This is a mask made up
//!                            of NVAPI_OGLEXPERT_LEVEL bits.
//!
//! \param   expertReportMask  Mask made up of NVAPI_OGLEXPERT_REPORT bits,
//!                            this parameter specifies the areas of
//!                            functional interest.
//!
//! \param   expertOutputMask  Mask made up of NVAPI_OGLEXPERT_OUTPUT bits,
//!                            this parameter specifies the feedback output
//!                            location. Note that using OUTPUT_TO_CALLBACK
//!                            here is meaningless and has no effect, but
//!                            using it will not cause an error.
//!
//! \return  ::NVAPI_ERROR or ::NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup oglapi
//! SUPPORTED OS:  Windows XP and higher
//!
NVAPI_INTERFACE NvAPI_OGL_ExpertModeDefaultsSet(NvU32 expertDetailLevel,
                                                NvU32 expertReportMask,
                                                NvU32 expertOutputMask);

//! \addtogroup oglapi
//! SUPPORTED OS:  Windows XP and higher
//!
NVAPI_INTERFACE NvAPI_OGL_ExpertModeDefaultsGet(NvU32 *pExpertDetailLevel,
                                                NvU32 *pExpertReportMask,
                                                NvU32 *pExpertOutputMask);
//@}



///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_GetPersistenceData [Set]
//
//   DESCRIPTION: Retrieves, saves, and finds persist data stored in the persist file              
//
//         INPUT: hPhysicalGpu - unused (reserved for later)
//
//                pData - Detailed persistence data structure.
//
//                flags - Persistence find flags (see defines for description)
//                              
//
// RETURN STATUS: NVAPI_INVALID_ARGUMENT: hNvDisplay is invalid
//                NVAPI_OK: the persist operation succeed
//                NVAPI_ERROR: the persist operation failed
///////////////////////////////////////////////////////////////////////////////

// Persistence find flags

//! \name Inputs: for NVAPI_GetPersistenceData() 
// @{
//! Find last mode configuration
//! - activeMask: required [index 0 is GDI primary display]
//! - connectedMasks: optional
//! - hPhysicalGpu: optional
//! \ingroup driverapi
#define NV_PERSIST_FIND_LAST_MODE     0x00000001            


//! Find last active configuration
//! - connectedMasks: optional
//! - hPhysicalGpu: optional
//! \ingroup driverapi
#define NV_PERSIST_FIND_LAST_ACTIVE   0x00000002 



//! This flag must be ORed with an NV_PERSIST_FIND_ method. 
//! This flag is used when the EDIDs of the connected devices are already known (supplied in the structure), and
//! a lookup for persistence is needed based on this information.
//! - connectedMasks: required [EDIDs are ordered from rightmost bit to left]
//! - activeMask: based on the NV_PERSIST_FIND_ method selected
//! - hPhysicalGpu: ignored
//!
//! NOTE: Not supported for NV_PERSIST_FIND_CURRENT
//! \ingroup driverapi
#define NV_PERSIST_EDID_SUPPLIED      0x80000000           


           
//! Find current active configuration
//! - activeMask: required [index 0 is GDI primary display]
//! - connectedMasks: optional
//! - hPhysicalGpu: optional
//! \ingroup driverapi
#define NV_PERSIST_FIND_CURRENT       0x00000003           


//! Defines to support backward compatibility (to be removed once integration completed)
//! \ingroup driverapi
#define MAX_PERSIST_DEVICES 8

// @}

//! \ingroup driverapi
//! Used in NV_PERSIST_DATA
typedef struct
{
    NvU32 width;                                //!< (IN/OUT) GDI width
    NvU32 height;                               //!< (IN/OUT) GDI height
    NvU32 depth;                                //!< (IN/OUT) GDI color depth
    NvU32 refresh;                              //!< (IN/OUT) GDI refresh rate
    NvU32 interlaced;                           //!< (IN/OUT) Interlaced mode
    NvU32 primary:1;                            //!< (IN/OUT) Desktop primary
    NvU32 posx;                                 //!< (IN/OUT) GDI x position
    NvU32 posy;                                 //!< (IN/OUT) GDI y position
} NV_PERSIST_MODE;

//! \ingroup driverapi
//! Used in NV_PERSIST_DATA_INFO
typedef struct 
{
    NvU32                  activeMask;          //!< (IN/OUT) Active device mask
    NV_TARGET_VIEW_MODE    state;               //!< (IN/OUT) nView state
    NvU32                  rotation;            //!< (IN/OUT) nView rotation
    NvU32                  scaling;             //!< (IN/OUT) nView scaling
    NvU32                  tvFormat;            //!< (IN/OUT) TV format
    NV_PERSIST_MODE        physicalMode;        //!< (IN/OUT) Physical mode
    NV_PERSIST_MODE        virtualMode;         //!< (IN/OUT) Virtual mode
} NV_PERSIST_DATA1;


//! \ingroup driverapi
//! Used in NV_PERSIST_DATA_INFO
typedef struct
{
    NvU32 activeMask;                           //!< (IN/OUT) Active device mask
    NV_TARGET_VIEW_MODE state;                  //!< (IN/OUT) nView state
    NvU32 rotation;                             //!< (IN/OUT) nView rotation
    NvU32 scaling;                              //!< (IN/OUT) nView scaling
    NvU32 tvFormat;                             //!< (IN/OUT) TV format
    NV_PERSIST_MODE physicalMode;               //!< (IN/OUT) Physical mode
    NV_PERSIST_MODE virtualMode;                //!< (IN/OUT) Virtual mode
    NvU32 connectedCRC32CommonEDIDs;            //!< (IN/OUT) Only the part of EDID that should be common for the same make of the displays. For finding partial match.
    NvU32 ulUnderscanX;                         //!< (IN/OUT) Underscan % for X
    NvU32 ulUnderscanY;                         //!< (IN/OUT) Underscan % for Y
} NV_PERSIST_DATA2;

//! \addtogroup driverapi
//! @{

typedef NV_PERSIST_DATA2        NV_PERSIST_DATA;

//! Macro for constructing the version field of NV_PERSIST_DATA1
#define NV_PERSIST_DATA_VER1    MAKE_NVAPI_VERSION(NV_PERSIST_DATA1, 1);

//! Macro for constructing the version field of NV_PERSIST_DATA2
#define NV_PERSIST_DATA_VER2    MAKE_NVAPI_VERSION(NV_PERSIST_DATA2, 2);


#define NV_PERSIST_DATA_VER     NV_PERSIST_DATA_VER2

//! @}




//! \ingroup driverapi
//! Used in NvAPI_GetPersistenceData() and NvAPI_SetPersistenceData()
typedef struct
{
    NvU32                   version;                        //!< (IN) Structure version
    NvAPI_LongString        lookupKey;                      //!< (IN/OUT) Look-up Key strings
    NvU32                   connectedMasks;                 //!< (IN/OUT) Connected device mask
    NvU32                   count;                          //!< (IN/OUT) Target count
    NV_PERSIST_DATA1        target[NVAPI_MAX_VIEW_TARGET];  //!< (IN/OUT) Persistence data
} NV_PERSIST_DATA_INFO1;


//! \ingroup driverapi
//! Used in NvAPI_GetPersistenceData() and NvAPI_SetPersistenceData()
typedef struct
{
    NvU32                   version;                        //!< (IN) Structure version
    NvAPI_LongString        lookupKey;                      //!< (IN/OUT) Lookup Key strings
    NvU32                   connectedMasks;                 //!< (IN/OUT) Connected device mask
    NvU32                   count;                          //!< (IN/OUT) Target count
    NV_PERSIST_DATA1        target[NVAPI_MAX_VIEW_TARGET];  //!< (IN/OUT) Persist data
    NV_EDID                 connectedEDIDs[NVAPI_MAX_HEADS_PER_GPU];    //!< (IN) Connected EDID list, based on connectedMask from right to left
} NV_PERSIST_DATA_INFO2;




//! \addtogroup driverapi
//! @{

//! Used in NvAPI_GetPersistenceData() and NvAPI_SetPersistenceData()
typedef struct
{
    NvU32                   version;                        //!<  (IN) structure version
    NvAPI_LongString        lookupKey;                      //!<  (IN/OUT) lookupKey strings
    NvU32                   connectedMasks;                 //!<  (IN/OUT) connected device mask
    NvU32                   count;                          //!<  (IN/OUT) target count
    NV_PERSIST_DATA1        target[NVAPI_ADVANCED_MAX_VIEW_TARGET];  //!<  (IN/OUT) persist data
    NV_EDID                 connectedEDIDs[NVAPI_MAX_HEADS_PER_GPU]; //!<  (IN) Connected EDID list, based on connectedMask from right to left
} NV_PERSIST_DATA_INFO3;


//! Used in NvAPI_GetPersistenceData() and NvAPI_SetPersistenceData()
typedef struct
{
    NvU32                   version;                        //!< (IN) structure version
    NvAPI_LongString        lookupKey;                      //!< (IN/OUT) lookupKey strings
    NvU32                   connectedMasks;                 //!< (IN/OUT) connected device mask
    NvU32                   count;                          //!< (IN/OUT) target count
    NV_PERSIST_DATA         target[NVAPI_ADVANCED_MAX_VIEW_TARGET];  //!< (IN/OUT) persist data
    NV_EDID                 connectedEDIDs[NVAPI_MAX_HEADS_PER_GPU]; //!< (IN) Connected EDID list, based on connectedMask from right to left
} NV_PERSIST_DATA_INFO4;



typedef NV_PERSIST_DATA_INFO4  NV_PERSIST_DATA_INFO;

//! Macro for constructing the version field of NV_PERSIST_DATA_INFO1
#define NV_PERSIST_DATA_INFO_VER1  MAKE_NVAPI_VERSION(NV_PERSIST_DATA_INFO1,1)

//! Macro for constructing the version field of NV_PERSIST_DATA_INFO2
#define NV_PERSIST_DATA_INFO_VER2  MAKE_NVAPI_VERSION(NV_PERSIST_DATA_INFO2,2)

//! Macro for constructing the version field of NV_PERSIST_DATA_INFO3
#define NV_PERSIST_DATA_INFO_VER3  MAKE_NVAPI_VERSION(NV_PERSIST_DATA_INFO3,3)

//! Macro for constructing the version field of NV_PERSIST_DATA_INFO4
#define NV_PERSIST_DATA_INFO_VER4  MAKE_NVAPI_VERSION(NV_PERSIST_DATA_INFO4,4)


#define NV_PERSIST_DATA_INFO_VER   NV_PERSIST_DATA_INFO_VER4

//! @}


//////////////////////////////////////////////////////////////////////////////////////////////////////
//
//! \name NvAPI_GetPersistenceData [Set] Functions
// @{
//! These functions retrieve, save, and find persistence data stored in the persist file.              
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 95
//!
//! \param [in] hPhysicalGpu Unused (reserved for later)
//! \param pData             Detailed persistence data structure.
//! \param flags             Persistence find flags (see defines for description)
//!                              
//!
//! \retval  NVAPI_INVALID_ARGUMENT  hNvDisplay is invalid
//! \retval  NVAPI_OK                The persist operation succeed
//! \retval  NVAPI_ERROR             The persist operation failed

//! \ingroup driverapi
//! SUPPORTED OS:  Windows XP and higher
//!
NVAPI_INTERFACE NvAPI_GetPersistenceData(NvPhysicalGpuHandle hPhysicalGpu, NV_PERSIST_DATA_INFO *pData, NvU32 flags);

//! \ingroup driverapi
//! SUPPORTED OS:  Windows XP and higher
//!
NVAPI_INTERFACE NvAPI_SetPersistenceData(NvPhysicalGpuHandle hPhysicalGpu, NV_PERSIST_DATA_INFO *pData);

// @}






///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Diag_DP_ASSR
//
//! \code
//!   DESCRIPTION: Makes a control call to RM to get ASSR status/disable ASSR
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \param [in]	   nvGPUHandle The GPU Handle to which the display is connected.
//!                            This parameter is ignored when the outputID is an NvAPI displayId.
//! \param [in]    outputID    Output mask or NvAPI DisplayID for the display.
//! \param [in]    disable     The parameter representing the request for the specific operation.
//!                            0 : Get ASSR status
//!                            1 : Disable ASSR
//! \param [out]   enabled     The parameter representing the current ASSR status.
//!                            0 : ASSR is currently disabled.
//!                            1 : ASSR is currently enabled.
//!                            This parameter is optional for 'disable ASSR' request.
//! param [out]    err         This parameter represents the error code returned by RM.
//!                            0 : NV0073_CTRL_DP_ASSR_ERR_CAP_NOERR
//!                            1 : NV0073_CTRL_DP_ASSR_ERR_CAP_ERR
//!
//! \return    This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//! \endcode
//! \ingroup driverapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Diag_DP_ASSR(__in_opt NvPhysicalGpuHandle nvGPUHandle, __in NvU32 outputID, __in NvU32 disable, __out_opt NvU32 *enabled, __out NvU32 *err);







///////////////////////////////////////////////////////////////////////////////
//
// (*obsolete*) 
//  We are trying to move away from NvAPI_EnumAppStatistics into NvAPI_GetAppStatistics
// (*obsolete*)
// FUNCTION NAME:   NvAPI_EnumAppStatistics
//
//!   \fn NvAPI_EnumAppStatistics(NvU32 enumIndex, NvU32 flags, NVAPI_PROCESS_POLL_INFO *pProcessInfo)
//!   DESCRIPTION:   This API polls the driver for any 3D contexts that have been created/destroyed.
//!                  This information will be collected by the GeForce Experience client, and sent to
//!                  NVIDIA servers for data-mining purposes. The client should keep enumerating until it
//!                  returns NVAPI_END_ENUMERATION.
//!                  - Both executed and running applications are treated the same. Running applications would have 0 closeTime.
//!                  - Time is defined as a count of 100-nanosecond intervals since January 1, 1601.
//!                  - Operation mode is specified by Flags. 
//! 
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_GetAppStatistics.
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 177
//!
//!   \param [in]      flags         Either ::NV_APPENUMFLAG_READ, ::NV_APPENUMFLAG_READERASE, or ::NV_APPENUMFLAG_READACTIVE. 
//!   \param [in,out]  enumIndex     Indicates the position where the enumeration starts
//!   \param [out]     pProcessInfo   
//!
//!   \retval          NVAPI_OK                Completed request, and potentially have more entry
//!   \retval          NVAPI_END_ENUMERATION   No more entries
//!   \retval          NVAPI_ERROR             Miscellaneous error occurred
//!   \retval          NVAPI_INVALID_ARGUMENT  Invalid argument
//
/////////////////////////////////////////////////////////////////////////////////

//! \addtogroup driverapi
//! @{
#define NV_APPENUMFLAG_READ                 0x00000000  //!< Read only. See NvAPI_EnumAppStatistics().
#define NV_APPENUMFLAG_READERASE            0x00000001  //!< Read then erase. See NvAPI_EnumAppStatistics().
#define NV_APPENUMFLAG_READACTIVE           0x00000002  //!< Read only active applications. See NvAPI_EnumAppStatistics().
#define NV_APPENUMFLAG_READERASE_INACTIVE   0x00000003   
//! @}

//! \ingroup driverapi
#define NVAPI_MAX_CODEC_ENTRIES_PER_PROCESSID 32  //!< Arbitrarily large number. Flash in Firefox uses the same PID for all tabs that might be playing video.



//! \ingroup driverapi
//! Used in NVAPI_PROCESS_POLL_INFO.
typedef enum
{
    NVAPI_API_UNKNOWN      = -1,
    NVAPI_API_OPENGL       = 0x1,
    NVAPI_API_DX9          = 0x2,
    NVAPI_API_DX10         = 0x3,
    NVAPI_API_DX9_CUDA     = 0x4,
    NVAPI_API_DX10_CUDA    = 0x5,
    NVAPI_API_OPENGL_CUDA  = 0x6,
    NVAPI_API_DX9_VIDEO    = 0x7,
    NVAPI_API_DX10_1       = 0x8,
    NVAPI_API_DX10_1_CUDA  = 0x9,
    NVAPI_API_DX11         = 0xA,
    NVAPI_API_DX11_CUDA    = 0xB,
    NVAPI_API_CUDA         = 0xC,
    NVAPI_API_PHYSX        = 0x20, 
    NVAPI_API_OPENGL_PHYSX = 0x21,
    NVAPI_API_DX9_PHYSX    = 0x22,
    NVAPI_API_DX10_PHYSX   = 0x23,
    NVAPI_API_DX10_1_PHYSX = 0x28,
    NVAPI_API_DX11_PHYSX   = 0x2A,
    NVAPI_API_OPENCL       = 0x40,
    NVAPI_API_OPENGL_OPENCL= 0x41,
    NVAPI_API_DX9_OPENCL   = 0x42,
    NVAPI_API_DX10_OPENCL  = 0x43,
    NVAPI_API_DX10_1_OPENCL= 0x48,
    NVAPI_API_DX11_OPENCL  = 0x4A

} NVAPI_API_TYPE;


//! \ingroup videoapi
typedef enum
{
    NVAPI_VIDEO_CODEC_UNKNOWN = 0,
    NVAPI_VIDEO_CODEC_MPEG,
    NVAPI_VIDEO_CODEC_H264,
    NVAPI_VIDEO_CODEC_VC1,
    NVAPI_VIDEO_CODEC_MPEG4,
} NVAPI_VIDEO_CODEC_TYPE;

//! \ingroup videoapi
typedef struct
{
    NVAPI_VIDEO_CODEC_TYPE codecTypes[NVAPI_MAX_CODEC_ENTRIES_PER_PROCESSID];//!< codec type
    NvU64 instanceCount;  //!< number of instances in which processID is the same but codecs are different
} NVAPI_VIDEO_CODEC_INFO;


//! \ingroup gpu
typedef enum _NVAPI_SLI_TOPOLOGY
{
    NVAPI_SLI_TOPOLOGY_AUTOSELECT  = 0,     //!< AutoSelect
    NVAPI_SLI_TOPOLOGY_AFR         = 1,     //!< Alternate Frames
    NVAPI_SLI_TOPOLOGY_SFR         = 2,     //!< Split Frame
    NVAPI_SLI_TOPOLOGY_SINGLE      = 3,     //!< Single GPU
    NVAPI_SLI_TOPOLOGY_AFR_OF_SFR  = 4      //!< AFR of SFR
} NVAPI_SLI_TOPOLOGY;


//! \ingroup gpu
typedef struct
{
    NVAPI_SLI_TOPOLOGY  mode;            //!< [OUT] Current SLI mode
    NvU32   numSLIAA;
    NvU32   numSFR;
    NvU32   numAFR;
    NvU32   numActiveGpus;
} NVAPI_SLI_RUNTIME_INFO;


//! \ingroup gpu

#define NVAPI_FPS_HISTOGRAM_NUM_BUCKETS 32
#define NVAPI_FPS_HIST_MIN 10
#define NVAPI_FPS_HIST_MAX 150
#define NVAPI_FPS_MIN_IN_MS (1000.0 / (NvF32)NVAPI_FPS_HIST_MIN)
#define NVAPI_FPS_MAX_IN_MS (1000.0 / (NvF32)NVAPI_FPS_HIST_MAX)
#define NVAPI_FPS_MS_RESOLUTION ((NVAPI_FPS_MAX_IN_MS-NVAPI_FPS_MIN_IN_MS) / NVAPI_FPS_HISTOGRAM_NUM_BUCKETS)
#define NVAPI_FRAME_RATE_DERIVATIVE_HISTOGRAM_NUM_BUCKETS 32
#define NVAPI_FPS_DELTA_MIN_RANGE -2.0
#define NVAPI_FPS_DELTA_MAX_RANGE 2.0
#define NVAPI_FPS_DELTA_RESOLUTION = ((NVAPI_FPS_DELTA_MAX_RANGE - NVAPI_FPS_DELTA_MIN_RANGE) / (NvF32)NVAPI_FRAME_RATE_DERIVATIVE_HISTOGRAM_NUM_BUCKETS)

#define PSTATE_HISTOGRAM_NUM_BUCKETS 10
#define NVCLK_HISTOGRAM_NUM_BUCKETS  16
#define GPCCLK_HISTOGRAM_NUM_BUCKETS 16

//! \ingroup gpu
typedef struct
{
    NvU32                           perFrameCreateTimeHistogram[NVAPI_FPS_HISTOGRAM_NUM_BUCKETS];                               //!< [OUT] A histogram of frame creation times (in MS)
    NvU32                           perFrameCreateTimeDerivativeHistogram[NVAPI_FRAME_RATE_DERIVATIVE_HISTOGRAM_NUM_BUCKETS];   //!< [OUT] A histogram of the derivative of frame to frame creation times.
    NvU32                           pStateHistogram[PSTATE_HISTOGRAM_NUM_BUCKETS];                                              //!< [OUT] A histogram of pstates used.
    float                           batteryPct;                                                                                 //!< [OUT] Percent of time the battery is used to power the computer.
    float                           cordedPct;                                                                                  //!< [OUT] Percent of time the computer is plugged in.
} NVAPI_GFE_INFO;


//! \ingroup gpu
typedef struct
{
    NvU32 isStereoActivated         : 1;
    NvU32 isStereoBlocked           : 1;
    NvU32 isAnaglyph                : 1;
    NvU32 isHDMIStereo              : 1;
    NvU32 isHDMIAllowed             : 1;
    NvU32 isHDMISupported           : 1;
    NvU32 isHDMIProtected           : 1;
    NvU32 isHDMIWindowed            : 1;
    NvU32 isSliBroadcast            : 1;
    NvU32 isClonedMode              : 1;
    NvU32 isBulkLicense             : 1;
    NvU32 isFullLicense             : 1;
    NvU32 isUserLicense             : 1;
    NvU32 isPanelReleased           : 1;
    NvU32 isTestLicense             : 1;
    NvU32 isDisplayIdentified       : 1;
    NvU32 isDisplayReleased         : 1;
    NvU32 isNB                      : 1;
    NvU32 isDisableHighVBIOverride  : 1;
    NvU32 isDisableAuthentication   : 1;
    NvU32 isBrowserStereoApp        : 1;
    NvU32 isAeroEnabled             : 1;
    NvU32 isGDIWindowModeEnabled    : 1;
    NvU32 isGDIWindowModeActivated  : 1;
    NvU32 isSandbox                 : 1;
    NvU32 isGameProfiled            : 1;
    NvU32 isNBInternalPanel         : 1;
    NvU32 isEnabledInRegistry       : 1;

    NvU32 stereoHWType;
} NVAPI_STEREO_RUNTIME_INFO;




//! \ingroup driverapi
//! Used in NvAPI_EnumAppStatistics().
typedef struct
{
    NvU32                           version;
    NVAPI_API_TYPE                  APIType;
    NvU32                           processId;
    NvU64                           openTime;
    NvU64                           closeTime;
    NvU64                           averageFrameRate;
    char                            exeName[NVAPI_LONG_STRING_MAX];
} NVAPI_PROCESS_POLL_INFO_V1;


//! \ingroup driverapi
//! Used in NvAPI_EnumAppStatistics().
typedef struct
{
    NvU32                           version;
    NVAPI_API_TYPE                  APIType;
    NvU32                           processId;
    NvU64                           openTime;
    NvU64                           closeTime;
    NvU64                           averageFrameRate;
    char                            exeName[NVAPI_LONG_STRING_MAX];
    NVAPI_VIDEO_CODEC_INFO          videoCodecInfo;                     //!< video codec info (check only if APITYPE == NVAPI_API_DX9_VIDEO)
} NVAPI_PROCESS_POLL_INFO_V2;

//! \ingroup driverapi
#define NVAPI_PATH_MAX_LENGTH                260 // same as MAX_PATH defined in windows

//! \ingroup driverapi
typedef struct
{
    NvU32                           version;
    NVAPI_API_TYPE                  APIType;
    NvU32                           processId;
    NvU64                           openTime;
    NvU64                           closeTime;
    NvU64                           averageFrameRate;
    char                            exeName[NVAPI_LONG_STRING_MAX];
    NVAPI_VIDEO_CODEC_INFO          videoCodecInfo;                     //!< video codec info (check only if APITYPE == NVAPI_API_DX9_VIDEO)
    NVAPI_SLI_RUNTIME_INFO          sliInfo;
    char                            pathName[NVAPI_PATH_MAX_LENGTH];
    float                           minFrameRate;
    float                           maxFrameRate;
} NVAPI_PROCESS_POLL_INFO_V3;

//! \ingroup driverapi
typedef struct
{
    NvU32                           version;
    NVAPI_API_TYPE                  APIType;
    NvU32                           processId;
    NvU64                           openTime;
    NvU64                           closeTime;
    NvU64                           averageFrameRate;
    char                            exeName[NVAPI_LONG_STRING_MAX];   
    NVAPI_VIDEO_CODEC_INFO          videoCodecInfo;                     //!< video codec info (check only if APITYPE == NVAPI_API_DX9_VIDEO)
    NVAPI_SLI_RUNTIME_INFO          sliInfo;
    char                            pathName[NVAPI_PATH_MAX_LENGTH];
    float                           minFrameRate;
    float                           maxFrameRate;
    NVAPI_GFE_INFO                  gfeInfo;
    NVAPI_STEREO_RUNTIME_INFO       stereoInfo;
    NvAPI_UnicodeString             exeNameW;    
    NvAPI_UnicodeString             pathNameW;    
    NvAPI_UnicodeString             workingDirNameW;
} NVAPI_PROCESS_POLL_INFO_V4;

//! \ingroup driverapi
typedef struct
{
    NvU32                           version;
    NVAPI_API_TYPE                  APIType;
    NvU32                           processId;
    NvU64                           openTime;
    NvU64                           closeTime;
    NvU64                           averageFrameRate;
    char                            exeName[NVAPI_LONG_STRING_MAX];   
    NVAPI_VIDEO_CODEC_INFO          videoCodecInfo;                     //!< video codec info (check only if APITYPE == NVAPI_API_DX9_VIDEO)
    NVAPI_SLI_RUNTIME_INFO          sliInfo;
    char                            pathName[NVAPI_PATH_MAX_LENGTH];
    float                           minFrameRate;
    float                           maxFrameRate;
    NVAPI_GFE_INFO                  gfeInfo;
    NVAPI_STEREO_RUNTIME_INFO       stereoInfo;
    NvAPI_UnicodeString             exeNameW;    
    NvAPI_UnicodeString             pathNameW;    
    NvAPI_UnicodeString             workingDirNameW;
    NvAPI_UnicodeString             cmdLineArgsW;    
    char                            sid[NVAPI_LONG_STRING_MAX];                                                   //!< [OUT] Security identifier of the user who ran the app.
} NVAPI_PROCESS_POLL_INFO_V5;

//! \ingroup driverapi
//! @{

typedef NVAPI_PROCESS_POLL_INFO_V4     NVAPI_PROCESS_POLL_INFO_LIVE;                                              //!< Version that is currently in the wild.
typedef NVAPI_PROCESS_POLL_INFO_V5     NVAPI_PROCESS_POLL_INFO;                                                   //!< Version to be released next.

#define NVAPI_PROCESS_POLL_INFO_VER_1  MAKE_NVAPI_VERSION(NVAPI_PROCESS_POLL_INFO_V1,1)
#define NVAPI_PROCESS_POLL_INFO_VER_2  MAKE_NVAPI_VERSION(NVAPI_PROCESS_POLL_INFO_V2,2)
#define NVAPI_PROCESS_POLL_INFO_VER_3  MAKE_NVAPI_VERSION(NVAPI_PROCESS_POLL_INFO_V3,3)
#define NVAPI_PROCESS_POLL_INFO_VER_4  MAKE_NVAPI_VERSION(NVAPI_PROCESS_POLL_INFO_V4,4)
#define NVAPI_PROCESS_POLL_INFO_VER_5  MAKE_NVAPI_VERSION(NVAPI_PROCESS_POLL_INFO_V5, 5)
#define NVAPI_PROCESS_POLL_INFO_VER    NVAPI_PROCESS_POLL_INFO_VER_5

//! @}


//!   \ingroup driverapi
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use NvAPI_GetAppStatistics.")
NVAPI_INTERFACE NvAPI_EnumAppStatistics(NvU32 enumIndex, NvU32 flags, NVAPI_PROCESS_POLL_INFO *pProcessInfo);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetAppStatistics
//
//! \fn NvAPI_GetAppStatistics(NvU32 *pNum, NvU32 flags, NVAPI_PROCESS_POLL_INFO *pProcessInfo)
//!   DESCRIPTION:   This API polls the driver for any 3D contexts that have been created or destroyed. 
//!                  This information is collected by the GeForce Experience client and sent to
//!                  our servers for data-mining purposes. The client would get all entries at once.
//!                  \note Both executed and running applications are treated the same. A running application would have 0 closeTime.
//!                  Time is defined as is a count of 100-nanosecond intervals since January 1, 1601.
//!                  Operation mode is specified by Flags.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//! 
//! \param [in]     flags       These flags are exclusive, and cannot be combined in usage:
//!                             - NV_APPENUMFLAG_READ                 read only
//!                             - NV_APPENUMFLAG_READERASE            read then erase
//!                             - NV_APPENUMFLAG_READACTIVE           read only active apps
//!                             - NV_APPENUMFLAG_READERASE_INACTIVE   read then erase inactive apps.
//!                  
//! \param [in,out] pNum          - in(the number of entries in pProcessInfo array)
//!                               - out(the number of entries being filled)
//! \param [out]    pProcessInfo  An array of NVAPI_PROCESS_POLL_INFO
//!
//! \retval ::NVAPI_OK - completed request, and potentially have more entry
//! \retval ::NVAPI_ERROR - miscellaneous error occurred
//! \retval ::NVAPI_INVALID_ARGUMENT - invalid argument
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup driverapi
#define NVAPI_MAX_PROCESS_INFO_ENTRIES  16


//! \ingroup driverapi
NVAPI_INTERFACE NvAPI_GetAppStatistics(NvU32 *pNum, NvU32 flags, NVAPI_PROCESS_POLL_INFO *pProcessInfo);




// 3D profile for one key cinema feature



//! \addtogroup appprofileapi
//! @{

//! See NV_3D_SETTING_RANGE.
#define NV_3D_MAX_RANGE         25


//! 3D property names used in NV_3D_SETTING and NV_3D_SETTING_RANGE
typedef enum
{
    NV_3D_PROPERTY_AS         = 1,  //!< Anti-Aliasing selector
    NV_3D_PROPERTY_AA         = 2,  //!< Anti-Aliasing setting
    NV_3D_PROPERTY_AF         = 3,  //!< Anisotropic filtering
    NV_3D_PROPERTY_MAX_FRAMES = 4,  //!< Maximum pre-rendered frames
    NV_3D_PROPERTY_TEX_FILTER = 5,  //!< Texture filtering
} NV_3D_PROPERTY;


//! Used in NvAPI_3D_GetProperty() and NvAPI_3D_SetProperty().
typedef struct
{
    NvU32           version;                //!< [in] Structure version
    NV_3D_PROPERTY  settingName;            //!< [in] 3D setting
    NvU32           flags;                  //!< [out] Indicates whether the settings are read only
    NvU32           defaultValue;           //!< [out] Default base value at driver install
    NvU32           currentValue;           //!< [in/out] Current value or new value to update
} NV_3D_SETTING;


//! Used in NvAPI_3D_GetPropertyRange().
typedef struct
{
    NvU32           version;                //!< [in] Structure version
    NV_3D_PROPERTY  settingName;            //!< [in] 3D setting
    NvU32           value[NV_3D_MAX_RANGE]; //!< [out] Range of values as unique array of numbers
    NvU32           validRangeCount;        //!< [out] Number of valid items in the property
} NV_3D_SETTING_RANGE;


//! Macro for constructing the version field of NV_3D_SETTING
#define NV_3D_PROFILE_VERSION           MAKE_NVAPI_VERSION(NV_3D_SETTING,1)


//! Macro for constructing the version field of NV_3D_SETTING_RANGE
#define NV_3D_PROFILE_RANGE_VERSION     MAKE_NVAPI_VERSION(NV_3D_SETTING_RANGE,1)


//! @}

/////////////////////////////////////////////////////////////////////////////// 
// 
// FUNCTION NAME:  NvAPI_3D_GetProperty 
// 
//! DESCRIPTION:    This API gets the specific 3D profile property. \n
//! HOW TO USE:    
//!                -# Set profileName to "Base Profile"
//!                -# Set 3D property name to settingName of NV_3D_SETTING
//!                -# On call success: It returns the specific profile property setting
//!
//! \param [in]     profileName  Which profile to access
//! \param [in,out] p3dSettings  Setting of the 3D profile property 
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//! 
//! \retval ::NVAPI_OK  
//! \retval ::NVAPI_ERROR 
//! \retval ::NVAPI_INVALID_ARGUMENT 
//!
//! \ingroup appprofileapi
/////////////////////////////////////////////////////////////////////////////// 
NVAPI_INTERFACE NvAPI_3D_GetProperty(NvAPI_ShortString szProfileName, NV_3D_SETTING* p3dSetting);

/////////////////////////////////////////////////////////////////////////////// 
// 
// FUNCTION NAME:  NvAPI_3D_SetProperty 
// 
//! DESCRIPTION:    This API sets the specific 3D profile property. \n
//! HOW TO USE:    
//!                -# Set profileName to "Base Profile"
//!                -# Set 3D property name to settingName of NV_3D_SETTING
//!                -# On call success: It returns the specific profile property setting
//!
//! \param [in]     profileName  Which profile to access
//! \param [in,out] p3dSettings  Setting of the 3D profile property 
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//! 
//! \retval ::NVAPI_OK 
//! \retval ::NVAPI_ERROR 
//! \retval ::NVAPI_INVALID_ARGUMENT 
//!
//! \ingroup appprofileapi
/////////////////////////////////////////////////////////////////////////////// 
NVAPI_INTERFACE NvAPI_3D_SetProperty(NvAPI_ShortString szProfileName, NV_3D_SETTING* p3dSetting);

/////////////////////////////////////////////////////////////////////////////// 
// 
// FUNCTION NAME:  NvAPI_3D_GetPropertyRange 
//
//! DESCRIPTION:    This API gets the specific 3D profile property setting range. \n
//! HOW TO USE:    -# Set profileName to "Base Profile".
//!                -# Set 3D property name to settingName of NV_3D_SETTING_RANGE.
//!                -# On call success: It returns the specific profile property setting.
//!
//! \param [in]     profileName      Which profile to access
//! \param [in,out] p3dSettingRange  Setting range of the 3D profile property 
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//! 
//! \retval ::NVAPI_OK  
//! \retval ::NVAPI_ERROR 
//! \retval ::NVAPI_INVALID_ARGUMENT 
//!
//! \ingroup appprofileapi
/////////////////////////////////////////////////////////////////////////////// 
NVAPI_INTERFACE NvAPI_3D_GetPropertyRange(NvAPI_ShortString szProfileName, NV_3D_SETTING_RANGE* p3dsettingRange);





///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GPU_GetAppStatistics
//
//! \code
//!   DESCRIPTION:   This API lets caller to lets us poll the driver for
//!                  any 3D contexts that have been created/destroyed on a GPU. 
//!                  This information will be collected by the GeForce Experience client, and sent to
//!                  our servers for data-mining purposes. The client would get all entries at once
//!                  (Both executed and running apps are treated the same.  Running app would have 0 closeTime.)
//!                  (Time is defined as is a count of 100-nanosecond intervals since January 1, 1601)
//!                  (Operation mode is specified by Flags. )
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!    PARAMETERS: (IN)      hPhysicalGpu    Handle for Physical GPU Handle for which statistics will be retrieved.
//!                (IN)      flags           reserved for future use, (must be 0)
//!                (IN/OUT)  pNum            in(the number of entries in pProcessInfo array)
//!                (OUT)     pProcessInfo    an array of NVAPI_PROCESS_POLL_INFO
//!
//! RETURN STATUS:   NVAPI_OK - completed request, and potentially have more entry
//!                  NVAPI_ERROR - miscellaneous error occurred
//!                  NVAPI_INVALID_ARGUMENT - invalid argument
//! \endcode
//! \ingroup driverapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetAppStatistics(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pNum, NvU32 flags, NVAPI_PROCESS_POLL_INFO *pProcessInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Mjolnir_SetupStreamingSession
//
//! \fn NvAPI_Mjolnir_SetupStreamingSession(NvU32 streamingProcessId, NvU32 flags)
//! DESCRIPTION: This function activates streaming interface between nvStreamer and UMD if streamingProcessId is not 0 and matches id of a process making this call. 
//!              If streamingProcessId is not 0 but does not match id of a process making this call then this function registers streamingProcessId as a child of streaming session.
//!              If streamingProcessId is 0 - streaming interface gets deactivated.
//!              flags parameter specifies additional information reqired for process registration.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]  streamingProcessId   Process ID that owns a streaming session or needs to be registered.
//! \param [in]  flags                Additional flags for registration.
//!
//! \return      This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!              specific meaning for this API, they are listed below.
//!
//! \retval      NVAPI_INVALID_ARGUMENT  request to register a streaming session child when streaming session is not active. 
//
///////////////////////////////////////////////////////////////////////////////


//! \ingroup nvapifunctions
//! @{

//! \ingroup nvapifunctions
//! Available flag values
#define REGISTER_PROCESS_AS_GAME_ID 1

//! \ingroup nvapifunctions
NVAPI_INTERFACE NvAPI_Mjolnir_SetupStreamingSession(__in NvU32 streamingProcessId, __in NvU32 flags);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Mjolnir_GetStreamingInfo
//
//! \fn NvAPI_Mjolnir_GetStreamingInfo(NV_MJOLNIR_STREAMING_INFO *pStreamingInfo)
//! DESCRIPTION: This API returns information about current streaming session.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in, out]     pStreamingInfo      Pointer to NV_MJOLNIR_STREAMING_INFO structure with current streaming session info.
//!
//! \return    This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//!
//! \retval    NVAPI_INCOMPATIBLE_STRUCT_VERSION - NV_MJOLNIR_STREAMING_INFO structure version mismatch. 
//! \retval    NVAPI_INVALID_POINTER             - pStreamingInfo pointer is invalid. 
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup nvapifunctions
//! Array sizes
#define MAX_GAME_IDS     4
#define MAX_PROCESS_IDS 16

//! \ingroup nvapifunctions
//! @{

typedef struct _NV_MJOLNIR_STREAMING_INFO
{
    NvU32   version;             // Structure version
    NvU32   streamingSessionActive;
    NvU32   streamingSessionOwnerId;
    NvU32   fullScreen;
    NvU32   streamingSessionGameIds[MAX_GAME_IDS];
    NvU32   streamingSessionProcessIds[MAX_PROCESS_IDS];
} NV_MJOLNIR_STREAMING_INFO;

//! @}

//! \ingroup nvapifunctions
//! Macro for constructing the version field of STREAMING_INFO_VER_1
#define NV_MJOLNIR_STREAMING_INFO_VER_1  MAKE_NVAPI_VERSION(NV_MJOLNIR_STREAMING_INFO,1)

//! \ingroup nvapifunctions
NVAPI_INTERFACE NvAPI_Mjolnir_GetStreamingInfo(__inout NV_MJOLNIR_STREAMING_INFO *pStreamingInfo);
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetHybridPadInfo
//
//! \fn NvAPI_GPU_GetHybridPadInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_GET_HYBRID_PAD_INFO *hybridPadInfo)
//! \code
//!   DESCRIPTION: This API returns the Hybrid/Aux pad information of the specified physical ports.
//!                It tells the physical port count. If hybridPadInfo->pHybridPadInfo is NULL then the API gives the physical port count.
//!                Again called calles API with physical port count and pHybridPadInfo to get pad information about
//!                whether the pad is a hybrid pad, the pad's mode, the pad's current power state,
//!                and also the display mask associated with the pad.
//!                Following is the Wiki link with details about hybrid pads:
//!                https://wiki.nvidia.com/engwiki/index.php/Hybrid_pads_project
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! RETURN STATUS: NVAPI_OK: request is completed and required information is in the parameter
//!                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//!                NVAPI_API_NOT_INITIALIZED: no  initialization of NvAPI
//!                NVAPI_NO_IMPLEMENTATION: Implementation is not found of NvAPI
//!                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//!                NVAPI_NOT_SUPPORTED: if the interface is not supported
//!                NVAPI_INVALID_POINTER: if the pointer passed is NULL
//!                NVAPI_OUT_OF_MEMORY: if memory is not allocated.
//!                NVAPI_ERROR: miscellaneous error occurred
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
typedef struct
{
    NvU32  displayMask;                             //!< Output: Display mask of a specified physical port.
    NvU32  padCurrMode;                             //!< Output: Current mode of a port can be I2C or AUX.
    NvU32  padPowerState :1;                        //!< Output: Power state of the specified pad.
    NvU32  usesHybridPad :1;                        //!< Output: Specifies whether or not the hybrid pad is used.
    NvU32  reserved :30;
} NV_HYBRID_PAD_DATA;

//! \ingroup gpu
typedef struct
{
    NvU32               version;                    //!< Input: Structure version.
    NvU32               phyPortCount;               //!< Output: Tells about physical port count.
    NV_HYBRID_PAD_DATA  *pHybridPadInfo;            //!< Output: Contain all information about hybrid pads.
} NV_GET_HYBRID_PAD_INFO_V1;

//! \ingroup gpu
#define NV_GET_HYBRID_PAD_INFO_VER1 MAKE_NVAPI_VERSION(NV_GET_HYBRID_PAD_INFO_V1, 1)

//! \ingroup gpu
#define NV_GET_HYBRID_PAD_INFO_VER  NV_GET_HYBRID_PAD_INFO_VER1

//! \ingroup gpu
typedef NV_GET_HYBRID_PAD_INFO_V1   NV_GET_HYBRID_PAD_INFO;

//! \ingroup gpu
NVAPI_INTERFACE NvAPI_GPU_GetHybridPadInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_GET_HYBRID_PAD_INFO *hybridPadInfo);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_EnumPhysicalGPUs
//
//! This function returns an array of physical GPU handles.
//! Each handle represents a physical GPU present in the system.
//! That GPU may be part of an SLI configuration, or may not be visible to the OS directly.
//!
//! At least one GPU must be present in the system and running an NVIDIA display driver.
//!
//! The array nvGPUHandle will be filled with physical GPU handle values. The returned
//! gpuCount determines how many entries in the array are valid.
//!
//! \note In drivers older than 105.00, all physical GPU handles get invalidated on a
//!       modeset. So the calling applications need to renum the handles after every modeset.\n
//!       With drivers 105.00 and up, all physical GPU handles are constant.
//!       Physical GPU handles are constant as long as the GPUs are not physically moved and 
//!       the SBIOS VGA order is unchanged.
//!
//!       For GPU handles in TCC MODE please use NvAPI_EnumTCCPhysicalGPUs()
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \par Introduced in
//! \since Release: 80
//!
//! \retval NVAPI_INVALID_ARGUMENT         nvGPUHandle or pGpuCount is NULL
//! \retval NVAPI_OK                       One or more handles were returned
//! \retval NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_EnumPhysicalGPUs(NvPhysicalGpuHandle nvGPUHandle[NVAPI_MAX_PHYSICAL_GPUS], NvU32 *pGpuCount);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_EnumTCCPhysicalGPUs
//
//! This function returns an array of physical GPU handles that are in TCC Mode.
//! Each handle represents a physical GPU present in the system in TCC Mode.
//! That GPU may not be visible to the OS directly.
//!
//! The array nvGPUHandle will be filled with physical GPU handle values. The returned
//! gpuCount determines how many entries in the array are valid.
//!
//! NOTE: Handles enumerated by this API are only valid for NvAPIs that are tagged as TCC_SUPPORTED
//!       If handle is passed to any other API, it will fail with NVAPI_INVALID_HANDLE
//!
//!       For WDDM GPU handles please use NvAPI_EnumPhysicalGPUs()
//!
//! SUPPORTED OS:  Windows Vista and higher,  Mac OS X
//!
//!
//! 
//! \param [out]   nvGPUHandle      Physical GPU array that will contain all TCC Physical GPUs
//! \param [out]   pGpuCount        count represent the number of valid entries in nvGPUHandle
//!  
//!
//! \retval NVAPI_INVALID_ARGUMENT         nvGPUHandle or pGpuCount is NULL
//! \retval NVAPI_OK                       One or more handles were returned
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_EnumTCCPhysicalGPUs( NvPhysicalGpuHandle nvGPUHandle[NVAPI_MAX_PHYSICAL_GPUS], NvU32 *pGpuCount);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_EnumLogicalGPUs
//
//! This function returns an array of logical GPU handles.
//!
//! Each handle represents one or more GPUs acting in concert as a single graphics device.
//!
//! At least one GPU must be present in the system and running an NVIDIA display driver.
//!
//! The array nvGPUHandle will be filled with logical GPU handle values.  The returned
//! gpuCount determines how many entries in the array are valid.
//!
//! \note All logical GPUs handles get invalidated on a GPU topology change, so the calling 
//!       application is required to renum the logical GPU handles to get latest physical handle
//!       mapping after every GPU topology change activated by a call to NvAPI_SetGpuTopologies().
//!
//! To detect if SLI rendering is enabled, use NvAPI_D3D_GetCurrentSLIState().
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 80
//!
//! \retval NVAPI_INVALID_ARGUMENT         nvGPUHandle or pGpuCount is NULL
//! \retval NVAPI_OK                       One or more handles were returned
//! \retval NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_EnumLogicalGPUs(NvLogicalGpuHandle nvGPUHandle[NVAPI_MAX_LOGICAL_GPUS], NvU32 *pGpuCount);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetPhysicalGPUsFromDisplay
//
//! This function returns an array of physical GPU handles associated with the specified display.
//!
//! At least one GPU must be present in the system and running an NVIDIA display driver.
//!
//! The array nvGPUHandle will be filled with physical GPU handle values.  The returned
//! gpuCount determines how many entries in the array are valid.
//!
//! If the display corresponds to more than one physical GPU, the first GPU returned
//! is the one with the attached active output.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \retval NVAPI_INVALID_ARGUMENT         hNvDisp is not valid; nvGPUHandle or pGpuCount is NULL
//! \retval NVAPI_OK                       One or more handles were returned
//! \retval NVAPI_NVIDIA_DEVICE_NOT_FOUND  no NVIDIA GPU driving a display was found
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetPhysicalGPUsFromDisplay(NvDisplayHandle hNvDisp, NvPhysicalGpuHandle nvGPUHandle[NVAPI_MAX_PHYSICAL_GPUS], NvU32 *pGpuCount);
 

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_EnumPhysicalGPUsInternal
//
//!   DESCRIPTION: Description and usage is the same as NvAPI_EnumPhysicalGPUs().  
//!                Only the PhysX engine and PhysX APIs can use this API due to the WAR for http://nvbugs/388093.
//!                The WAR applies only to NvAPI_EnumPhysicalGPUs() and NvAPI_EnumLogicalGPUs(), and is 
//!                for applications such as 3dmarkvantage.exe, crysis64.exe, etc. 
//!                In the workaround the driver returns fake logical and physical GPUs instead of system wide GPUs.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 180
//!  \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_EnumPhysicalGPUsInternal(NvPhysicalGpuHandle nvGPUHandle[NVAPI_MAX_PHYSICAL_GPUS], NvU32 *pGpuCount);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_EnumLogicalGPUsInternal
//
//!   DESCRIPTION: Description and usage is the same as NvAPI_EnumLogicalGPUs().  
//!                Only the PhysX engine and PhysX APIs can use this due to the WAR for http://nvbugs/388093.
//!                This WAR applies only to NvAPI_EnumLogicalGPUs() and NvAPI_EnumPhysicalGPUs() and is 
//!                for applications such as 3dmarkvantage.exe, crysis64.exe, etc. 
//!                In the workaround the driver returns fake logical and physical GPUs instead of system wide GPUs.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 180
//!  \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_EnumLogicalGPUsInternal(NvLogicalGpuHandle nvGPUHandle[NVAPI_MAX_LOGICAL_GPUS], NvU32 *pGpuCount);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetDisplayFromPhysicalGPU
//
//!   DESCRIPTION: This API returns a display associated with a physical GPU handle.
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//
//! \since Release: 180
//!
//!  \retval ::NVAPI_INVALID_ARGUMENT  nvGPUHandle is not valid; hNvDisp is NULL
//!  \retval ::NVAPI_OK                one handle was returned
//!
//!  \ingroup gpu
/////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetDisplayFromPhysicalGPU(NvPhysicalGpuHandle nvGPUHandle, NvDisplayHandle *hNvDisp);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DISP_GetUnAttachedDisplayFromPhysicalGPU
//
//!   DESCRIPTION: Returns an unattached display associated with a physical GPU handle.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! RETURN STATUS: NVAPI_INVALID_ARGUMENT: nvGPUHandle is not valid; hNvDisp is NULL
//!                NVAPI_OK: one handle was returned
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_GetUnAttachedDisplayFromPhysicalGPU(NvPhysicalGpuHandle nvGPUHandle, NvUnAttachedDisplayHandle *hUnAttachedNvDisp);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetAssociatedDisplayFromOutputId
//
//!   DESCRIPTION: Returns a display a associated with a physical GPU handle and the outputId.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! RETURN STATUS: This API can return any of the error codes enumerated in #NvAPI_Status. 
//!                If there are return error codes with specific meaning for this API, they are listed below.
//!                (None)
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetAssociatedDisplayFromOutputId(NvPhysicalGpuHandle nvGPUHandle, NvU32 outputId, NvDisplayHandle *hNvDisp);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetPhysicalGPUFromUnAttachedDisplay
//
//! This function returns a physical GPU handle associated with the specified unattached display.
//! The source GPU is a physical render GPU which renders the frame buffer but may or may not drive the scan out.
//!
//! At least one GPU must be present in the system and running an NVIDIA display driver.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \retval NVAPI_INVALID_ARGUMENT         hNvUnAttachedDisp is not valid or pPhysicalGpu is NULL.
//! \retval NVAPI_OK                       One or more handles were returned
//! \retval NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetPhysicalGPUFromUnAttachedDisplay(NvUnAttachedDisplayHandle hNvUnAttachedDisp, NvPhysicalGpuHandle *pPhysicalGpu);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetLogicalGPUFromDisplay
//
//! This function returns the logical GPU handle associated with the specified display.
//! At least one GPU must be present in the system and running an NVIDIA display driver.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \retval NVAPI_INVALID_ARGUMENT         hNvDisp is not valid; pLogicalGPU is NULL
//! \retval NVAPI_OK                       One or more handles were returned
//! \retval NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetLogicalGPUFromDisplay(NvDisplayHandle hNvDisp, NvLogicalGpuHandle *pLogicalGPU);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DISP_GetLogicalCudaGPUFromDisplay
//
//!   DESCRIPTION: This API returns a logical GPU handle associated with the specified display.
//!                On Hybrid SLI systems, this returns the GPU on which CUDA will be 
//!                running (so it returns the rendering GPU and not the scan-out GPU, unlike the
//!                behavior of NvAPI_GetLogicalGPUFromDisplay()). This is a hotfix for bug 506582.  
//!                For fixing bug 523171, we will need a more comprehensive solution.
//!
//!                At least one GPU must be present in the system and running an NVIDA display driver.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//!
//! \since Release: 180
//!
//! \retval ::NVAPI_INVALID_ARGUMENT         hNvDisp is not valid; pLogicalGPU is NULL
//! \retval ::NVAPI_OK                       One or more handles were returned
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_GetLogicalCudaGPUFromDisplay(NvDisplayHandle hNvDisp, NvLogicalGpuHandle *pLogicalGPU);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetLogicalGPUFromPhysicalGPU
//
//! This function returns the logical GPU handle associated with specified physical GPU handle.
//! At least one GPU must be present in the system and running an NVIDIA display driver.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 80
//!
//! \retval NVAPI_INVALID_ARGUMENT         hPhysicalGPU is not valid; pLogicalGPU is NULL
//! \retval NVAPI_OK                       One or more handles were returned
//! \retval NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetLogicalGPUFromPhysicalGPU(NvPhysicalGpuHandle hPhysicalGPU, NvLogicalGpuHandle *pLogicalGPU);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetPhysicalGPUsFromLogicalGPU
//
//!  This function returns the physical GPU handles associated with the specified logical GPU handle.
//!  At least one GPU must be present in the system and running an NVIDIA display driver.
//!
//!  The array hPhysicalGPU will be filled with physical GPU handle values.  The returned
//!  gpuCount determines how many entries in the array are valid.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \retval NVAPI_INVALID_ARGUMENT             hLogicalGPU is not valid; hPhysicalGPU is NULL
//! \retval NVAPI_OK                           One or more handles were returned
//! \retval NVAPI_NVIDIA_DEVICE_NOT_FOUND      No NVIDIA GPU driving a display was found
//! \retval NVAPI_EXPECTED_LOGICAL_GPU_HANDLE  hLogicalGPU was not a logical GPU handle
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetPhysicalGPUsFromLogicalGPU(NvLogicalGpuHandle hLogicalGPU,NvPhysicalGpuHandle hPhysicalGPU[NVAPI_MAX_PHYSICAL_GPUS], NvU32 *pGpuCount);
   
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetPhysicalGPUsFromLogicalGPUInEngineOrder
//
//!  This function returns the physical GPU handles associated with the specified logical GPU handle.
//!  At least one GPU must be present in the system and running an NVIDIA display driver.
//!
//!  The array hPhysicalGPU will be filled with physical GPU handle values.  The returned
//!  gpuCount determines how many entries in the array are valid.
//!
//!  The ordering of the returned GPUs will be a best-guess at the engine-ordinal ordering
//!  of the GPUs.  In particular, creating a WDDM context with D3DKMT_CREATECONTEXT::EngineAffinity
//!  set to (1 << i) will result in work being executed on physical GPU hPhysicalGPU[i].
//!
//!  It should be noted that by 'best-guess' here, we mean 'the first and last elements
//!  are probably right, but the middle ones may be muddled.'  PhysX is only impacted by 
//!  the last element, so this will fix the relevant PhysX issues.  It may be valuable
//!  at some point to retrieve the full predicted engine ordering.
//!
//!  This API is a hot-fix and is already deprecated, see bug 922240.
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_GetPhysicalGPUsFromLogicalGPUInEngineOrder.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 290
//!
//! \retval NVAPI_INVALID_ARGUMENT             hLogicalGPU is not valid; hPhysicalGPU is NULL
//! \retval NVAPI_OK                           One or more handles were returned
//! \retval NVAPI_NVIDIA_DEVICE_NOT_FOUND      No NVIDIA GPU driving a display was found
//! \retval NVAPI_EXPECTED_LOGICAL_GPU_HANDLE  hLogicalGPU was not a logical GPU handle
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use NvAPI_GetPhysicalGPUsFromLogicalGPUInEngineOrder.")
NVAPI_INTERFACE NvAPI_GetPhysicalGPUsFromLogicalGPUInEngineOrder(NvLogicalGpuHandle hLogicalGPU,NvPhysicalGpuHandle hPhysicalGPU[NVAPI_MAX_PHYSICAL_GPUS], NvU32 *pGpuCount);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetPhysicalGPUFromDisplay
//
//!   DESCRIPTION: This function returns the physical GPU handle that is associated with the specified attached display handle. 
//!                \note This API reflects the GPU association that the OS is aware of, unlike NvAPI_GetPhysicalGPUsFromDisplay().
//!
//!                At least one GPU must be present in the system and running an NVIDIA display driver.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 175
//!
//!  \retval  ::NVAPI_INVALID_ARGUMENT   
//!  \retval  ::NVAPI_OK 
//!  \retval  ::NVAPI_NVIDIA_DEVICE_NOT_FOUND
//!
//!  \ingroup gpu
//////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetPhysicalGPUFromDisplay(NvDisplayHandle hNvDisplay, NvPhysicalGpuHandle *pPhysicalGpu);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetPhysicalGPUFromGPUID
//
//!  This function returns the physical GPU handle associated with the RM's GPUID value.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 80
//!
//! \retval NVAPI_INVALID_ARGUMENT         rmGPUID is zero or pPhysicalGPU is NULL
//! \retval NVAPI_OK                       Handle was returned
//! \retval NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetPhysicalGPUFromGPUID(NvU32 gpuId, NvPhysicalGpuHandle *pPhysicalGPU);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetGPUIDfromPhysicalGPU
//
//! Returns the GPUID for the queried GPU handle. This ID can be used to maintain persistence 
//! in the calling applications when switching between GPU topologies.
//! \note GPU IDs are invalid if the graphics boards are physically removed or swapped.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 95
//!
//! \retval NVAPI_INVALID_ARGUMENT         hPhysicalGPUID is NULL or invalid. Re-enumerate the GPU handles.
//! \retval NVAPI_OK                       Handle was returned
//! \retval NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetGPUIDfromPhysicalGPU(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pGpuId);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DISP_GetTargetPhysicalGPUsFromUnAttachedDisplay
//
//!   DESCRIPTION: This API returns an array of physical display GPU handles that can possibly drive the specified unattached display handle.
//!                The target GPU is a physical display GPU which can be used to drive scan out but may or may not render the frame buffer. 
//!
//!                At least one GPU must be present in the system and running an NVIDIA display driver.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \retval ::NVAPI_INVALID_ARGUMENT         hNvUnAttachedDisp is not valid or pPhysicalGpu is NULL.
//! \retval ::NVAPI_OK                       One or more handles were returned
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_GetTargetPhysicalGPUsFromUnAttachedDisplay(NvUnAttachedDisplayHandle hNvUnAttachedDisp, NvPhysicalGpuHandle nvGPUHandle[NVAPI_MAX_PHYSICAL_GPUS], NvU32 *pGpuCount);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetPerGpuRegistryPath(NvPhysicalGpuHandle hPhysicalGpu, char *pRegistryPath)
//
//! \code
//!   DESCRIPTION: Retrieves the GPU registry path. This is different for each GPU.
//!                This is needed since writing to the per display registry 
//!                writes to only the GPU's which have displays attached.
//!                
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   PARAMETERS: hPhysicalGpu  - handle to the GPU you wish to read/write values for
//!               pRegistryPath - path of the per GPU registry hive
//!
//!   RETURN STATUS: NVAPI_OK: GPU Registry hive data returned
//!                  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle,
//!                  NVAPI_INVALID_ARGUMENT: pRegistryPath is NULL
//!                  NVAPI_ERROR: Error finding the corresponding registry path
//! \endcode
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetPerGpuRegistryPath(NvPhysicalGpuHandle hPhysicalGpu, char *pRegistryPath);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetRawFuseData
//
//! \fn NvAPI_GPU_GetRawFuseData(NvPhysicalGpuHandle hPhysicalGpu,NV_RAW_FUSE_DATA *pFuseData)
//!  This function retrieves the raw bytes of the fuse data of each GPU.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 100
//!
//! \retval  NVAPI_INVALID_ARGUMENT              pFuseData is NULL
//! \retval  NVAPI_OK                            Fuse data was returned
//! \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found
//! \retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
#define NVAPI_MAX_RAW_FUSE_DATA_SIZE   64

//! \ingroup gpu
//! Used in NvAPI_GPU_GetRawFuseData()
typedef struct _NV_RAW_FUSE_DATA_V1
{
    NvU32   version;        // structure version
    
    NvU8    fuseData[NVAPI_MAX_RAW_FUSE_DATA_SIZE];
    NvU32   fuseDataSize;
} NV_RAW_FUSE_DATA_V1;

//! \ingroup gpu
typedef NV_RAW_FUSE_DATA_V1    NV_RAW_FUSE_DATA;

#define NV_RAW_FUSE_DATA_VER1  MAKE_NVAPI_VERSION(NV_RAW_FUSE_DATA_V1,1)
#define NV_RAW_FUSE_DATA_VER   NV_RAW_FUSE_DATA_VER1


//! \ingroup gpu
NVAPI_INTERFACE NvAPI_GPU_GetRawFuseData(NvPhysicalGpuHandle hPhysicalGpu,NV_RAW_FUSE_DATA *pFuseData);

 

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetFoundry
//
//! \fn NvAPI_GPU_GetFoundry(NvPhysicalGpuHandle hPhysicalGpu,NVAPI_FOUNDRY_ID *pFoundry)
//!  DESCRIPTION: This function retrieves the identity of the foundry that manufactured the GPU.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//!  \param [out]  pFoundry                       See \ref NVAPI_FOUNDRY_ID for list of possible values.
//!
//!  \retval  NVAPI_INVALID_ARGUMENT              pFoundry is NULL
//!  \retval  NVAPI_OK                            Foundry ID was returned
//!  \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found
//!  \retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle
//!  \retval  NVAPI_NOT_SUPPORTED                 The interface is not supported (pre-G80 GPU)
//
//////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
//! Used in NvAPI_GPU_GetFoundry().
typedef enum
{
    NVAPI_FOUNDRY_UNKNOWN      = 0,
    NVAPI_FOUNDRY_TSMC         = 1,
    NVAPI_FOUNDRY_UMC          = 2,
    NVAPI_FOUNDRY_IBM          = 3,
    NVAPI_FOUNDRY_SMIC         = 4,
    NVAPI_FOUNDRY_CHARTERED    = 5,
    NVAPI_FOUNDRY_TOSHIBA      = 6,
} NVAPI_FOUNDRY_ID;


//!  \ingroup gpu
NVAPI_INTERFACE NvAPI_GPU_GetFoundry(NvPhysicalGpuHandle hPhysicalGpu,NVAPI_FOUNDRY_ID *pFoundry);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetVPECount
//
//! This function retrieves the number of Vertex Processing Engines (VPEs) on the GPU.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 95
//!
//! \retval NVAPI_INVALID_ARGUMENT              pCount is NULL.
//! \retval NVAPI_OK                           *pCount is set.
//! \retval NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found.
//! \retval NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetVPECount(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pCount);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetShaderPipeCount
//
//!  This function retrieves the number of Shader Pipes on the GPU.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \retval NVAPI_INVALID_ARGUMENT              pCount is NULL.
//! \retval NVAPI_OK                           *pCount is set.
//! \retval NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found.
//! \retval NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetShaderPipeCount(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pCount);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetShaderSubPipeCount
//
//!   DESCRIPTION: This function retrieves the number of Shader SubPipes on the GPU
//!                On newer architectures, this corresponds to the number of SM units
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//!
//! RETURN STATUS: NVAPI_INVALID_ARGUMENT: pCount is NULL
//!                NVAPI_OK: *pCount is set
//!                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//!                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//!
//! \ingroup   gpu  
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetShaderSubPipeCount(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pCount);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_RegisterOp
//
//! \fn NvAPI_GPU_RegisterOp(NvPhysicalGpuHandle hPhysicalGpu,NV_GPU_REGISTER_OP_DATA *pRegOps)
//!   DESCRIPTION: This function performs one or more read or write operations on GPU registers.
//!
//!      !! This is an extremely sensitive API and CANNOT be exported outside of NVIDIA. !!
//!      !! It is meant only for use by our internal developers for diagnostics.         !!
//!
//!   A series of operations on registers are described by an array of NV_GPU_REGISTER_OP structs.
//!
//!   For each operation, flags define read/write, global or GR Context, 32 or 64 bit;
//!   - A 32-bit offset into BAR0 defines the starting offset.
//!   - A 64-bit writeMask field defines which bits to preserve in the destination.
//!   - A 64-bit value field defines the data to write, or the bits that were read.
//!   - A returned status field reports the result of each register operation.
//!
//!   \note
//!   This interface is only supported on G8x onward.
//!
//!   See nvidia/sdk/inc/ctrl/ctrl2080/ctrl2080gpu.h NV2080_CTRL_GPU_REG_OP for further
//!   details on the underlying RM interface.
//!
//!   NVAPI_GPU_REG_OP_FLAG_TYPE_GLOBAL - The register is a global privileged register.
//!      Write operations take effect immediately.
//!
//!   NVAPI_GPU_REG_OP_FLAG_TYPE_GR_CTX - The register is a graphics context register.
//!      Read operations return the current value from the associated global register.
//!      Write operations are applied to all existing graphics engine contexts.  Any 
//!      newly created graphics engine contexts will also be modified.
//!
//!
//!   32bit read operations       \n                  
//!   ------------------------------------------    \n  
//!   regValueLo = read(bar0 + offset)\n                
//!   regValueHi = 0                                  
//!
//!   64bit read operations\n  
//!   ---------------------------------------------\n  
//!   regValueLo = read(bar0 + offset)\n  
//!   regValueHi = read(bar0 + offset + 4)  
//!
//!   32bit write operations  \n                      
//!   ------------------------------------------------------   \n 
//!   new = ((read(bar0 + offset) & ~writeMaskLo) | valueLo) write(bar0 + offset, new)  
//!
//!   64bit write operations  \n
//!   ------------------------------------------------------------- \n
//!   new_lo = ((read(bar0 + offset) & ~writeMaskLo) | valueLo)  \n
//!   new_hi = ((read(bar0 + offset + 4) &  ~writeMaskHi) | valueHi) 
//!   write(bar0 + offset, new_lo)
//!   write(bar0 + offset + 4, new_hi)  
//!
//!   See nvapichk for example usage.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 165
//!
//!   \retval  NVAPI_INVALID_ARGUMENT              pRegOps is NULL or opCount is illegal.
//!   \retval  NVAPI_NOT_SUPPORTED                 The interface is not supported (eg: earlier than G8x).
//!   \retval  NVAPI_OK                            Data was returned.
//!   \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found.
//!   \retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
#define NVAPI_GPU_MAX_REGISTER_OP_COUNT 256

//! \ingroup gpu
//! Used in \ref NV_GPU_REGISTER_OP.
typedef enum
{
    NVAPI_GPU_REG_OP_FLAG_READ             = 0x00000001,
    NVAPI_GPU_REG_OP_FLAG_WRITE            = 0x00000002,
    NVAPI_GPU_REG_OP_FLAG_32BIT            = 0x00000004,
    NVAPI_GPU_REG_OP_FLAG_64BIT            = 0x00000008,
    NVAPI_GPU_REG_OP_FLAG_TYPE_GLOBAL      = 0x00000010,
    NVAPI_GPU_REG_OP_FLAG_TYPE_GR_CTX      = 0x00000020,
} NVAPI_GPU_REG_OP_FLAGS;

//! \ingroup gpu
//! Used in \ref NV_GPU_REGISTER_OP.
typedef enum
{
    NVAPI_GPU_REG_OP_STATUS_SUCCESS        = 0x00000000,
    NVAPI_GPU_REG_OP_STATUS_INVALID_OP     = 0x00000001,    //!< Operation is not valid. 
    NVAPI_GPU_REG_OP_STATUS_INVALID_TYPE   = 0x00000002,    //!< Type (global/Gr_ctx) is not valid.
    NVAPI_GPU_REG_OP_STATUS_INVALID_OFFSET = 0x00000004,    //!< Offset is not valid.
    NVAPI_GPU_REG_OP_STATUS_UNSUPPORTED_OP = 0x00000008,    //!< Operation is not supported at this offset.
} NVAPI_GPU_REG_OP_STATUS;

//! \ingroup gpu
//! Used in \ref NV_GPU_REGISTER_OP_DATA.
typedef struct
{
    NvU16 flags;     // bit flags from NVAPI_GPU_REG_OP_FLAGS
    NvU16 status;    // status of this operation from NVAPI_GPU_REG_OP_STATUS
    NvU32 offset;    // Offset from BAR0
    NvU64 writeMask; // Bits set here indicate which bits of the value field to write to the target offset
    NvU64 value;     // register value to write (or result from read)
} NV_GPU_REGISTER_OP;

//! \ingroup gpu
//! Used in NvAPI_GPU_RegisterOp().
typedef struct _NV_GPU_REGISTER_OP_DATA_V1
{
    NvU32              version;  // structure version [implicitly versions NV_GPU_REGISTER_OP as well]
    NvU32              opCount;
    NV_GPU_REGISTER_OP op[NVAPI_GPU_MAX_REGISTER_OP_COUNT];
} NV_GPU_REGISTER_OP_DATA_V1;

//! \ingroup gpu
typedef NV_GPU_REGISTER_OP_DATA_V1    NV_GPU_REGISTER_OP_DATA;

#define NV_GPU_REGISTER_OP_DATA_VER1  MAKE_NVAPI_VERSION(NV_GPU_REGISTER_OP_DATA_V1,1)
#define NV_GPU_REGISTER_OP_DATA_VER   NV_GPU_REGISTER_OP_DATA_VER1



//!   \ingroup gpu
NVAPI_INTERFACE NvAPI_GPU_RegisterOp(NvPhysicalGpuHandle hPhysicalGpu,NV_GPU_REGISTER_OP_DATA *pRegOps);





///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetPartitionCount
//
//!  This function retrieves the number of memory partitions on the GPU.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 95
//!
//! \retval NVAPI_INVALID_ARGUMENT              pCount is NULL.
//! \retval NVAPI_OK                           *pCount is set.
//! \retval NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found.
//! \retval NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetPartitionCount(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pCount);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetMemPartitionMask
//
//!   DESCRIPTION: This function retrieves a 32-bit mask showing which memory partitions are enabled.
//!                NvAPI_GPU_GetPartitionCount() returns the count of enabled partitions.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 177
//! 
//!  \retval  NVAPI_INVALID_ARGUMENT              pMask is NULL
//!  \retval  NVAPI_OK                           *pMask is set
//!  \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found
//!  \retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle
//!
//!  \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetMemPartitionMask(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pMask);


//! \ingroup gpu
//! Used in NvAPI_GPU_GetFrameBufferDetails()
#define NV_GPU_MAX_FBPS   32

//! \ingroup gpu
//! Used in NvAPI_GPU_GetFrameBufferDetails()
typedef struct
{
    NvU32 version;                  //!< Input:  Structure version.
    NvU32 fbpMask;                  //!< Output: A 32-bit mask showing which Frame Buffer Partitions (FBPs) are enabled.
	NvU32 fbpCount;                 //!< Output: The number of Frame Buffer Partitions (FBPs) on the GPU.
	NvU32 ltcCount;                 //!< Output: The number of Level Two Cache units (LTCs) across all FBPs.
	NvU32 ltsCount;                 //!< Output: The number of Level Two Slices (LTSs) across all LTCs.
    NvU32 ltcMask[NV_GPU_MAX_FBPS]; //!< Output: An array of 32-bit masks showing which Level Two Cache units (LTCs)
                                    //!          are enabled on each Frame Buffer Partition (FBP). Only the FBP indexes
                                    //!          enabled in the fbpMask have valid values.
} NV_GPU_FRAME_BUFFER_DETAILS_V1;

#define NV_GPU_FRAME_BUFFER_DETAILS_VER_1   MAKE_NVAPI_VERSION(NV_GPU_FRAME_BUFFER_DETAILS_V1,1)

typedef NV_GPU_FRAME_BUFFER_DETAILS_V1		NV_GPU_FRAME_BUFFER_DETAILS;

#define NV_GPU_FRAME_BUFFER_DETAILS_VER		NV_GPU_FRAME_BUFFER_DETAILS_VER_1

///////////////////////////////////////////////////////////////////////////////
//!  This escape is meant FOR SWAK USE ONLY.  Please contact sw-nvapi if you
//!  wish to use this interface.
//!
//! FUNCTION NAME: NvAPI_GPU_GetFrameBufferDetails
//!
//!  This function retrieves details about the Frame Buffer (FB) on the GPU.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 352
//! 
//! \param [in]  hPhysicalGpu    GPU selection
//! \param [out] pDetails        Structure containing details about the Frame Buffer.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetFrameBufferDetails(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_FRAME_BUFFER_DETAILS *pDetails);


///////////////////////////////////////////////////////////////////////////////
//!  This escape is meant FOR SWAK USE ONLY.  Please contact
//!  sw-nvapi if you wish to use this interface.
//!
//! FUNCTION NAME: NvAPI_GPU_GetGPCMask
//!
//! \code
//!   DESCRIPTION: Retrieves a 32-bit mask showing which GPCs (Graphics Processor Cluster)
//!                are enabled.
//!
//!                Returns 0 on pre-Fermi architectures.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! RETURN STATUS: NVAPI_INVALID_ARGUMENT: pMask is NULL
//!                NVAPI_OK: *pMask is set
//!                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//!                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//!                NVAPI_NOT_SUPPORTED: API call is not supported on current architecture
//! \endcode
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetGPCMask(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pMask);



///////////////////////////////////////////////////////////////////////////////
//!  This escape is meant FOR SWAK USE ONLY.  Please contact
//!  sw-nvapi if you wish to use this interface.
//!
//! FUNCTION NAME: NvAPI_GPU_GetTPCMaskOnGPC
//!
//! \code
//!  DESCRIPTION: Retrieves a 32-bit mask showing which Fermi TPCs
//!                (Texture Processor Cluster) are enabled on the GPC idenified by gpcId.
//!
//!                gpcId values start at 0 and correspond to the position of bits
//!                returned by NvAPI_GPU_GetGPCMask().
//!
//!                Returns 0 on pre-Fermi architectures.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! RETURN STATUS: NVAPI_INVALID_ARGUMENT: pMask is NULL
//!                NVAPI_OK: *pMask is set
//!                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//!                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//!                NVAPI_NOT_SUPPORTED: API call is not supported on current architecture
//! \endcode
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetTPCMaskOnGPC(NvPhysicalGpuHandle hPhysicalGpu,NvU32 gpcId,NvU32 *pMask);

///////////////////////////////////////////////////////////////////////////////
//!  This escape is meant FOR SWAK USE ONLY.  Please contact
//!  sw-nvapi if you wish to use this interface.
//!
//! FUNCTION NAME: NvAPI_GPU_GetZCULLMask
//!
//! \code
//!   DESCRIPTION: Retrieves a 32-bit mask showing which ZCULL
//!                are enabled on the GPC idenified by gpcId.
//!
//!                gpcId values start at 0 and correspond to the position of bits
//!                returned by NvAPI_GPU_GetGPCMask().
//!
//!                Returns 0 on pre-Fermi architectures.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! RETURN STATUS: NVAPI_INVALID_ARGUMENT: pMask is NULL
//!                NVAPI_OK: *pMask is set
//!                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//!                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//!                NVAPI_NOT_SUPPORTED: API call is not supported on current architecture
//! \endcode
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetZCULLMask(NvPhysicalGpuHandle hPhysicalGpu,NvU32 gpcId,NvU32 *pMask);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetTPCMask
//
//!   DESCRIPTION: This function retrieves a 32-bit mask showing which TPCs 
//!                (Texture Processor Cluster) are enabled.  
//!                Returns 0 on architectures that don't have TPCs.
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 177
//! 
//!  \retval  NVAPI_INVALID_ARGUMENT              pMask is NULL
//!  \retval  NVAPI_OK                           *pMask is set
//!  \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found
//!  \retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle
//!  \retval  NVAPI_NOT_SUPPORTED                 API call is not supported on current architecture
//!
//!  \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetTPCMask(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pMask);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetSMMask
//
//!   DESCRIPTION: This function retrieves a 32-bit mask showing which SMs 
//!                (Streaming Multiprocessors) are enabled on the TPC identified by tpcNdx. \n
//!                tpcNdx values start at 0 and correspond to the position of bits
//!                returned by NvAPI_GPU_GetTPCMask().  [mask bit = 2^tpcNdx]
//!                Returns 0 on architectures that don't have SMs.
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 177
//!  
//!  \retval   NVAPI_INVALID_ARGUMENT              pMask is NULL, or tpcId does not match a TPC
//!  \retval   NVAPI_OK                           *pMask is set
//!  \retval   NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found
//!  \retval   NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//!  \retval  NVAPI_NOT_SUPPORTED                 API call is not supported on current architecture
//!
//!  \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetSMMask(NvPhysicalGpuHandle hPhysicalGpu,NvU32 tpcId,NvU32 *pMask);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetTotalTPCCount
//
//!   DESCRIPTION: This function retrieves the total number of enabled TPCs (Texture Processor Clusters)
//!                Returns 0 on architectures that don't have TPCs.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!  
//! \retval  NVAPI_INVALID_ARGUMENT              pCount is NULL
//! \retval  NVAPI_OK                           *pCount is set
//! \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found
//! \retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetTotalTPCCount(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pCount);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetTotalSMCount
//
//!   DESCRIPTION: This function retrieves the total number of enabled SMs 
//!               (Streaming Multiprocessors) across all TPCs (Texture Processor Clusters). \n 
//!                Returns 0 on architectures that don't have SMs.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!   
//! \retval  NVAPI_INVALID_ARGUMENT: pCount is NULL
//! \retval  NVAPI_OK: *pCount is set
//! \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//! \retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//!  \retval  NVAPI_NOT_SUPPORTED                 API call is not supported on current architecture
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetTotalSMCount(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pCount);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetTotalSPCount
//
//!   DESCRIPTION: This function retrieves the total number of enabled SPs across all SMs 
//!                (Streaming Multiprocessors) on all TPCs (Texture Processor Clusters). \n
//!                Returns 0 on architectures that don't have SPs.
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!   
//! \retval  NVAPI_INVALID_ARGUMENT: pCount is NULL
//! \retval  NVAPI_OK: *pCount is set
//! \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//! \retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//!  \retval  NVAPI_NOT_SUPPORTED                 API call is not supported on current architecture
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetTotalSPCount(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pCount);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetGpuCoreCount
//
//!   DESCRIPTION: Retrieves the total number of cores defined for a GPU.
//!                Returns 0 on architectures that don't define GPU cores.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \retval ::NVAPI_INVALID_ARGUMENT              pCount is NULL
//! \retval ::NVAPI_OK                            *pCount is set
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND       no NVIDIA GPU driving a display was found
//! \retval ::NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle
//! \retval ::NVAPI_NOT_SUPPORTED                 API call is not supported on current architecture
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetGpuCoreCount(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pCount);


////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetDisplayChangeInhibitState
//
//! \fn NvAPI_GPU_GetDisplayChangeInhibitState(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pInhibitState)
//!  This function retrieves the display change inhibit state. See NV_GPU_DISPLAY_CHANGE_INHIBIT.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 100
//!
//! \retval  NVAPI_INVALID_ARGUMENT              pInhibitState is NULL
//! \retval  NVAPI_OK                           *pInhibitState is set to one or more values in NV_GPU_DISPLAY_CHANGE_INHIBIT
//! \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found
//! \retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////


//! \ingroup dispcontrol
//! Used in NvAPI_GPU_GetDisplayChangeInhibitState()
typedef enum _NV_GPU_DISPLAY_CHANGE_INHIBIT
{
    NVAPI_GPU_DISPLAY_CHANGE_INHIBIT_SPAN             = 0x00000001,
    NVAPI_GPU_DISPLAY_CHANGE_INHIBIT_VIDEO            = 0x00000002,
    NVAPI_GPU_DISPLAY_CHANGE_INHIBIT_3D_FULLSCREEN    = 0x00000004,
    NVAPI_GPU_DISPLAY_CHANGE_INHIBIT_DOS_FULLSCREEN   = 0x00000008,
} NV_GPU_DISPLAY_CHANGE_INHIBIT;



//! \ingroup dispcontrol
NVAPI_INTERFACE NvAPI_GPU_GetDisplayChangeInhibitState(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pInhibitState);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetAllOutputs
//
//!  This function returns set of all GPU-output identifiers as a bitmask.
//!
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_GPU_GetAllDisplayIds.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 85
//!
//! \retval   NVAPI_INVALID_ARGUMENT              hPhysicalGpu or pOutputsMask is NULL.
//! \retval   NVAPI_OK                           *pOutputsMask contains a set of GPU-output identifiers.
//! \retval   NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found.
//! \retval   NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use NvAPI_GPU_GetAllDisplayIds.")
NVAPI_INTERFACE NvAPI_GPU_GetAllOutputs(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pOutputsMask);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetInternalDisplays
//!
//! \code
//!   DESCRIPTION: Returns set of internal Displays as a bitmask.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! RETURN STATUS: NVAPI_INVALID_ARGUMENT: hPhysicalGpu or pOutputsMask is NULL
//!                NVAPI_OK: *pInternalDisplaysMask contains a set of GPU-internal display identifiers
//!                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//!                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//! \endcode
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetInternalDisplays(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pInternalDisplaysMask);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetConnectedOutputs
//
//! This function is the same as NvAPI_GPU_GetAllOutputs() but returns only the set of GPU output 
//! identifiers that are connected to display devices.
//!
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_GPU_GetConnectedDisplayIds.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \retval   NVAPI_INVALID_ARGUMENT              hPhysicalGpu or pOutputsMask is NULL.
//! \retval   NVAPI_OK                           *pOutputsMask contains a set of GPU-output identifiers.
//! \retval   NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found.
//! \retval   NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use NvAPI_GPU_GetConnectedDisplayIds.")
NVAPI_INTERFACE NvAPI_GPU_GetConnectedOutputs(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pOutputsMask);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetConnectedSLIOutputs
//
//!   DESCRIPTION: This function is the same as NvAPI_GPU_GetConnectedOutputs() but returns only the set of GPU-output 
//!                identifiers that can be selected in an SLI configuration. 
//!                 NOTE: This function matches NvAPI_GPU_GetConnectedOutputs()
//!                 - On systems which are not SLI capable.
//!                 - If the queried GPU is not part of a valid SLI group.
//!
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_GPU_GetConnectedDisplayIds.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//!
//! \retval   NVAPI_INVALID_ARGUMENT              hPhysicalGpu or pOutputsMask is NULL
//! \retval   NVAPI_OK                           *pOutputsMask contains a set of GPU-output identifiers
//! \retval   NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found
//! \retval   NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//! 
//! \ingroup gpu  
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use NvAPI_GPU_GetConnectedDisplayIds.")
NVAPI_INTERFACE NvAPI_GPU_GetConnectedSLIOutputs(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pOutputsMask);




//! \ingroup gpu
//! @[
#define NV_GPU_CONNECTED_FLAG_UNCACHED      0x0     //!< Deprecated - This is a ZERO value flag and does not make sense.
#define NV_GPU_CONNECTED_FLAG_CACHED        0x1     //!< When this is not set, it equals to uncached
#define NV_GPU_CONNECTED_FLAG_FAKE          0x2
#define NV_GPU_CONNECTED_FLAG_DIRECTMODE    0x4
//! @}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetConnectedOutputsEx
//
//!   DESCRIPTION: This function is the same as NvAPI_GPU_GetConnectedOutputs() except it takes a flag to request cached
//!                or uncached connected devices. Currently XP cached/uncached is the same, so this is private.
//!
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_GPU_GetConnectedDisplayIds.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 105
//!
//! \retval  NVAPI_INVALID_ARGUMENT              hPhysicalGpu or pOutputsMask is NULL
//! \retval  NVAPI_OK                           *pOutputsMask contains a set of GPU-output identifiers
//! \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found
//! \retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use NvAPI_GPU_GetConnectedDisplayIds.")
NVAPI_INTERFACE NvAPI_GPU_GetConnectedOutputsEx(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pOutputsMask, NvU32 flag);




//! \ingroup gpu
typedef enum
{
    NV_MONITOR_CONN_TYPE_UNINITIALIZED = 0,
    NV_MONITOR_CONN_TYPE_VGA,
    NV_MONITOR_CONN_TYPE_COMPONENT,
    NV_MONITOR_CONN_TYPE_SVIDEO,
    NV_MONITOR_CONN_TYPE_HDMI,
    NV_MONITOR_CONN_TYPE_DVI,
    NV_MONITOR_CONN_TYPE_LVDS,
    NV_MONITOR_CONN_TYPE_DP,
    NV_MONITOR_CONN_TYPE_COMPOSITE,
    NV_MONITOR_CONN_TYPE_UNKNOWN =  -1
} NV_MONITOR_CONN_TYPE;


//! \addtogroup gpu
//! @{
#define NV_GPU_CONNECTED_IDS_FLAG_UNCACHED          NV_BIT(0) //!< Get uncached connected devices
#define NV_GPU_CONNECTED_IDS_FLAG_SLI               NV_BIT(1) //!< Get devices such that those can be selected in an SLI configuration
#define NV_GPU_CONNECTED_IDS_FLAG_LIDSTATE          NV_BIT(2) //!< Get devices such that to reflect the Lid State
#define NV_GPU_CONNECTED_IDS_FLAG_FAKE              NV_BIT(3) //!< Get devices that includes the fake connected monitors
#define NV_GPU_CONNECTED_IDS_FLAG_EXCLUDE_MST       NV_BIT(4) //!< Excludes devices that are part of the multi stream topology.               
#define NV_GPU_CONNECTED_IDS_FLAG_SYMMETRIC         NV_BIT(5) //!< Get devices in symmetric order across GPUs.
#define NV_GPU_CONNECTED_IDS_FLAG_ORDERED           NV_BIT(6) //!< Get devices ordered by display number. NOT supported on winxp.
#define NV_GPU_CONNECTED_IDS_DIRECT_MODE            NV_BIT(7) //!< Get devices that are detected as Direct Mode. 

//! @}

//! \ingroup gpu
typedef struct _NV_GPU_DISPLAYIDS
{
    NvU32    version;
    NV_MONITOR_CONN_TYPE connectorType; //!< out: vga, tv, dvi, hdmi and dp. This is reserved for future use and clients should not rely on this information. Instead get the 
                                        //!< GPU connector type from NvAPI_GPU_GetConnectorInfo/NvAPI_GPU_GetConnectorInfoEx
    NvU32    displayId;                 //!< this is a unique identifier for each device
    NvU32    isDynamic:1;               //!< if bit is set then this display is part of MST topology and it's a dynamic
    NvU32    isMultiStreamRootNode:1;   //!< if bit is set then this displayID belongs to a multi stream enabled connector(root node). Note that when multi stream is enabled and 
                                        //!< a single multi stream capable monitor is connected to it, the monitor will share the display id with the RootNode. 
                                        //!< When there is more than one monitor connected in a multi stream topology, then the root node will have a separate displayId.
    NvU32    isActive:1;                //!< if bit is set then this display is being actively driven
    NvU32    isCluster:1;               //!< if bit is set then this display is the representative display
    NvU32    isOSVisible:1;             //!< if bit is set, then this display is reported to the OS
    NvU32    isWFD:1;                   //!< if bit is set, then this display is wireless 
    NvU32    isConnected:1;             //!< if bit is set, then this display is connected
    NvU32    isTile:1;                  //!< if bit is set, then this display is a tile
    NvU32    isVirtual:1;               //!< Reserved for future use. Do not use.
    NvU32    isSingleHeadMode:1;        //!< if bit is set, then this display is in singleHead mode
    NvU32    isVRDisplay : 1;           //!< if bit is set, then this display is VR capable
    NvU32    isDirectMode : 1;          //!< if bit is set, then this display is in Direct Mode
    NvU32    reservedInternal:5;        //!< Reserved for future use. Add private bits here.
    NvU32    isPhysicallyConnected:1;   //!< if bit is set, then this display is a phycially connected display; Valid only when isConnected bit is set
    NvU32    reserved: 14;              //!< must be zero
} NV_GPU_DISPLAYIDS;

//! \ingroup gpu
//! Macro for constructing the version field of ::_NV_GPU_DISPLAYIDS
#define NV_GPU_DISPLAYIDS_VER1          MAKE_NVAPI_VERSION(NV_GPU_DISPLAYIDS,1)
//! Intentionally passing 3 while creating NV_GPU_DISPLAYIDS_VER2 as we have a internal private ver made by passing 2
#define NV_GPU_DISPLAYIDS_VER2          MAKE_NVAPI_VERSION(NV_GPU_DISPLAYIDS,3)

#define NV_GPU_DISPLAYIDS_VER NV_GPU_DISPLAYIDS_VER2

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetConnectedDisplayIds
//
//! \code
//!   DESCRIPTION: Due to space limitation NvAPI_GPU_GetConnectedOutputs can return maximum 32 devices, but 
//!                this is no longer true for DPMST. NvAPI_GPU_GetConnectedDisplayIds will return all 
//!                the connected display devices in the form of displayIds for the associated hPhysicalGpu.
//!                This function can accept set of flags to request cached, uncached, sli and lid to get the connected devices.
//!                Default value for flags will be cached .
//! HOW TO USE: 1) for each PhysicalGpu, make a call to get the number of connected displayId's 
//!                using NvAPI_GPU_GetConnectedDisplayIds by passing the pDisplayIds as NULL
//!                On call success:
//!             2) Allocate memory based on pDisplayIdCount then make a call NvAPI_GPU_GetConnectedDisplayIds to populate DisplayIds
//! SUPPORTED OS:  Windows XP and higher
//!
//! PARAMETERS:     hPhysicalGpu (IN)  - GPU selection
//!                 flags        (IN)  - One or more defines from NV_GPU_CONNECTED_IDS_FLAG_* as valid flags. 
//!                 pDisplayIds  (IN/OUT) - Pointer to an NV_GPU_DISPLAYIDS struct, each entry represents a one displayID and its attributes
//!                 pDisplayIdCount(OUT)- Number of displayId's.
//!
//! RETURN STATUS: NVAPI_INVALID_ARGUMENT: hPhysicalGpu or pDisplayIds or pDisplayIdCount is NULL
//!                NVAPI_OK: *pDisplayIds contains a set of GPU-output identifiers
//!                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//!                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//! \endcode
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetConnectedDisplayIds(__in NvPhysicalGpuHandle hPhysicalGpu,  __inout_ecount_part_opt(*pDisplayIdCount, *pDisplayIdCount) NV_GPU_DISPLAYIDS* pDisplayIds, __inout NvU32* pDisplayIdCount, __in NvU32 flags);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetAllDisplayIds
//
//!   DESCRIPTION: This API returns display IDs for all possible outputs on the GPU.
//!                For DPMST connector, it will return display IDs for all the video sinks in the topology. \n
//! HOW TO USE: 1. The first call should be made to get the all display ID count. To get the display ID count, send in \n
//!                  a) hPhysicalGpu    - a valid GPU handle(enumerated using NvAPI_EnumPhysicalGPUs()) as input,      \n
//!                  b) pDisplayIds     - NULL, as we just want to get the display ID count.                           \n 
//!                  c) pDisplayIdCount - a valid pointer to NvU32, whose value is set to ZERO.                        \n
//!                If all parameters are correct and this call is successful, this call will return the display ID's count. \n
//!             2. To get the display ID array, make the second call to NvAPI_GPU_GetAllDisplayIds() with              \n
//!                  a) hPhysicalGpu    - should be same value which was sent in first call,                           \n
//!                  b) pDisplayIds     - pointer to the display ID array allocated by caller based on display ID count,    \n 
//!                                       eg. malloc(sizeof(NV_GPU_DISPLAYIDS) * pDisplayIdCount).                     \n
//!                  c) pDisplayIdCount - a valid pointer to NvU32. This indicates for how many display IDs            \n
//!                                       the memory is allocated(pDisplayIds) by the caller.                          \n
//!                If all parameters are correct and this call is successful, this call will return the display ID array and actual
//!                display ID count (which was obtained in the first call to NvAPI_GPU_GetAllDisplayIds). If the input display ID count is
//!                less than the actual display ID count, it will overwrite the input and give the pDisplayIdCount as actual count and the
//!                API will return NVAPI_INSUFFICIENT_BUFFER.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]     hPhysicalGpu         GPU selection.
//! \param [in,out] DisplayIds           Pointer to an array of NV_GPU_DISPLAYIDS structures, each entry represents one displayID 
//!                                      and its attributes.
//! \param [in,out] pDisplayIdCount      As input, this parameter indicates the number of display's id's for which caller has 
//!                                      allocated the memory. As output, it will return the actual number of display IDs.
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \retval  NVAPI_INSUFFICIENT_BUFFER  When the input buffer(pDisplayIds) is less than the actual number of display IDs, this API 
//!                                     will return NVAPI_INSUFFICIENT_BUFFER. 
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetAllDisplayIds(__in NvPhysicalGpuHandle hPhysicalGpu, __inout_ecount_part_opt(*pDisplayIdCount, *pDisplayIdCount) NV_GPU_DISPLAYIDS* pDisplayIds, __inout NvU32* pDisplayIdCount);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetConnectedOutputsWithLidState
//
//!  This function is similar to NvAPI_GPU_GetConnectedOutputs(), and returns the connected display identifiers that are connected 
//!  as an output mask but unlike NvAPI_GPU_GetConnectedOutputs() this API "always" reflects the Lid State in the output mask.
//!  Thus if you expect the LID close state to be available in the connection mask use this API.
//!  - If LID is closed then this API will remove the LID panel from the connected display identifiers. 
//!  - If LID is open then this API will reflect the LID panel in the connected display identifiers. 
//!
//! \note This API should be used on notebook systems and on systems where the LID state is required in the connection 
//!       output mask. On desktop systems the returned identifiers will match NvAPI_GPU_GetConnectedOutputs().
//!
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_GPU_GetConnectedDisplayIds.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 95
//!
//! \retval  NVAPI_INVALID_ARGUMENT              hPhysicalGpu or pOutputsMask is NULL
//! \retval  NVAPI_OK                           *pOutputsMask contains a set of GPU-output identifiers
//! \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found
//! \retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use NvAPI_GPU_GetConnectedDisplayIds.")
NVAPI_INTERFACE NvAPI_GPU_GetConnectedOutputsWithLidState(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pOutputsMask);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetConnectedSLIOutputsWithLidState
//
//!   DESCRIPTION: This function is the same as NvAPI_GPU_GetConnectedOutputsWithLidState() but returns only the set
//!                of GPU-output identifiers that can be selected in an SLI configuration. With SLI disabled,
//!                this function matches NvAPI_GPU_GetConnectedOutputsWithLidState().
//!
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_GPU_GetConnectedDisplayIds.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//!
//! \retval  NVAPI_INVALID_ARGUMENT              hPhysicalGpu or pOutputsMask is NULL
//! \retval  NVAPI_OK                           *pOutputsMask contains a set of GPU-output identifiers
//! \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found
//! \retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use NvAPI_GPU_GetConnectedDisplayIds.")
NVAPI_INTERFACE NvAPI_GPU_GetConnectedSLIOutputsWithLidState(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pOutputsMask);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetConnectedOutputsWithLidStateEx
//
//!   DESCRIPTION: This function is similar to NvAPI_GPU_GetConnectedOutputsWithLidState() except takes a flag to request
//!                cached or uncached connection data.  Currently XP cached/uncached is the same, so 
//!                this is private.
//!
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_GPU_GetConnectedDisplayIds.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 100
//!
//! \retval  NVAPI_INVALID_ARGUMENT              hPhysicalGpu or pOutputsMask is NULL
//! \retval  NVAPI_OK                           *pOutputsMask contains a set of GPU-output identifiers
//! \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found
//! \retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use NvAPI_GPU_GetConnectedDisplayIds.")
NVAPI_INTERFACE NvAPI_GPU_GetConnectedOutputsWithLidStateEx(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pOutputsMask, NvU32 flag);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetConnectedSLIOutputsWithLidStateEx
//
//!   DESCRIPTION: This function is the same as NvAPI_GPU_GetConnectedOutputsWithLidStateEx() but returns only the set of GPU-output 
//!                identifiers that can be selected in an SLI configuration. With SLI disabled
//!                this function matches NvAPI_GPU_GetConnectedOutputsWithLidStateEx().
//!
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_GPU_GetConnectedDisplayIds.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 173
//!
//! \retval  NVAPI_INVALID_ARGUMENT              hPhysicalGpu or pOutputsMask is NULL
//! \retval  NVAPI_OK                           *pOutputsMask contains a set of GPU-output identifiers
//! \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found
//! \retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use NvAPI_GPU_GetConnectedDisplayIds.")
NVAPI_INTERFACE NvAPI_GPU_GetConnectedSLIOutputsWithLidStateEx(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pOutputsMask, NvU32 flag);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetSystemType
//
//! \fn NvAPI_GPU_GetSystemType(NvPhysicalGpuHandle hPhysicalGpu, NV_SYSTEM_TYPE *pSystemType)
//!  This function identifies whether the GPU is a notebook GPU or a desktop GPU.
//!       
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 95
//!         
//! \retval  NVAPI_INVALID_ARGUMENT              hPhysicalGpu or pOutputsMask is NULL
//! \retval  NVAPI_OK                           *pSystemType contains the GPU system type
//! \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found
//! \retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
//! Used in NvAPI_GPU_GetSystemType()
typedef enum
{
    NV_SYSTEM_TYPE_UNKNOWN = 0,
    NV_SYSTEM_TYPE_LAPTOP  = 1,
    NV_SYSTEM_TYPE_DESKTOP = 2,

} NV_SYSTEM_TYPE;



//! \ingroup gpu
NVAPI_INTERFACE NvAPI_GPU_GetSystemType(NvPhysicalGpuHandle hPhysicalGpu, NV_SYSTEM_TYPE *pSystemType);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetActiveOutputs
//
//!  This function is the same as NvAPI_GPU_GetAllOutputs but returns only the set of GPU output 
//!  identifiers that are actively driving display devices.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 85
//!
//! \retval    NVAPI_INVALID_ARGUMENT              hPhysicalGpu or pOutputsMask is NULL.
//! \retval    NVAPI_OK                           *pOutputsMask contains a set of GPU-output identifiers.
//! \retval    NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found.
//! \retval    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetActiveOutputs(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pOutputsMask);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetEdidEx
//
//! fn NvAPI_GPU_GetEdidEx(NvU32 displayId, NV_EDID_FLAG *pFlag, NV_EDID *pEdid)
//! \code
//!   DESCRIPTION: Returns the EDID data for the specified display Id
//!
//!   PARAMETERS:    displayId(IN) - NVIDIA Display ID. It is the value 
//!                                  returned from 
//!                                  NvAPI_SYS_GetDisplayIdFromGpuAndOutputId()
//!                  flags(IN/OUT) - the type of EDID to retrieve (IN)
//!                                  and the actual EDID type returned (OUT)
//!                                  If _DEFAULT or _COOKED is passed in and _COOKED is
//!                                  returned, then the returned EDID may or may not be
//!                                  the same as the raw (unmodified) EDID.
//!                  pEdid(OUT)    - The pointer to the NV_EDID structure which has 
//!                                  the EDID returned from the driver. It can be NULL
//!                                  so the API only returns the EDID type/flag from "flags".
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! RETURN STATUS: NVAPI_INVALID_ARGUMENT: pEDID is NULL; displayId is invalid
//!                NVAPI_OK: *pEDID contains valid data.
//!                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found.
//!                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle.
//!                NVAPI_DATA_NOT_FOUND: requested display does not contain an EDID
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
typedef enum
{
    NV_EDID_FLAG_DEFAULT  = 0,   //!< the EDID which is actively used by the driver, it could be _RAW/_COOKED/_FORCED/_INF.
    NV_EDID_FLAG_RAW      = 1,   //!< the EDID which is not modified by the driver. If there's no _FORCED edid engaged, it 
                                 //!< will be the unmodified monitor EDID from the I2C bus. Otherwise it is original _FORCED edid.
    NV_EDID_FLAG_COOKED   = 2,   //!< the EDID has been modified by the driver for compatibility
    NV_EDID_FLAG_FORCED   = 3,   //!< the EDID is forced by the end-user over s/w interface, 
    NV_EDID_FLAG_INF      = 4,   //!< the EDID is from monitor INF
    NV_EDID_FLAG_HW       = 5,   //!< the EDID is from the monitor over I2C bus without any modification.
} NV_EDID_FLAG;

//! \ingroup gpu
NVAPI_INTERFACE NvAPI_GPU_GetEdidEx(NvU32 displayId, NV_EDID_FLAG *pFlag, NV_EDID *pEdid);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetEdidEx2
//
//! \code
//!   DESCRIPTION:   Returns the EDID data for the specified display Id
//!                  (NvAPI_GPU_GetConnectedDisplayIds() can be used to get the DisplayIds).
//!                  pEdid buffer has to be allocated by caller and to get the size of pEdid buffer,
//!                  call this function with pEdid as NULL. In most of the cases
//!                  buffer size of 384 bytes is sufficient, hence ideal way to call
//!                  this function is by allocating 384 bytes of memory to pEdid and
//!                  set pSizeofEDID to 384. If the function returns NVAPI_INSUFFICIENT_BUFFER
//!                  call this function again after freeing old buffer and
//!                  allocating a new buffer of size pSizeofEDID, returned in previous call.
//!
//!   PARAMETERS:    displayId(IN)       -   NVIDIA Display ID.
//!                  pFlag(IN/OUT)       -   The type of EDID to retrieve (IN)
//!                                          and the actual EDID type returned (OUT)
//!                                          This can be null.
//!                  pEdid(OUT)          -   The pointer to the buffer, in which,
//!                                          the EDID data is returned from the driver.
//!                                          Buffer has to be allocated by the caller.
//!                                          It can be NULL so the API only returns the
//!                                          EDID type/flag from "flags" and pSizeofEDID.
//!                                          If pEdid is present, pSizeofEDID cannot
//!                                          be NULL and value pointed by pSizeofEDID
//!                                          cannot be 0.
//!                  pSizeofEDID(IN/OUT) -   Size of input pEdid buffer on input and
//!                                          size of actual EDID data on output.
//!                                          If this parameter is NULL, pEdid has to be NULL
//!                                          and pFlag has to be present.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! RETURN STATUS: NVAPI_INVALID_ARGUMENT: Invalid combination of argument. Few of them quoted below
//!                                        * All NULL.
//!                                        * Neither pFlag nor pSizeofEDID is present. 
//!                                        * pEdid present and pSizeofEDID is NULL.
//!                                        * pEdid present and value pointed by pSizeofEDID is 0.
//!                NVAPI_OK: *pEDID contains valid data.
//!                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found.
//!                NVAPI_DATA_NOT_FOUND: requested display does not contain an EDID.
//!                NVAPI_INSUFFICIENT_BUFFER: Reallocate buffer with pSizeofEDID and call again to get complete data.
//!                                        In this case pEdid is contains undefined data.
//!                                        This error occurs only when pEdid is present.
//! \endcode
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetEdidEx2(NvU32 displayId, NV_EDID_FLAG *pFlag, NvU8 *pEdid, NvU32 *pSizeofEDID);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DISP_ValidateEdid
//
//! \fn NvAPI_DISP_ValidateEdid(NvU32 displayId, NV_EDID *pEdid, NvU32 *pVFlag)
//! \code 
//!   DESCRIPTION: Check the possible errors with the given Edid
//!
//!   PARAMETERS:    displayId(IN) - NVIDIA Display Id (it is the value returned from NvAPI_GPU_GetConnectedDisplayIds()). 
//!                                  It could be zero, so the NvAPI does not check the compatibility between the Edid and the displayId.
//!                  pEdid(IN)     - The pointer to the NV_EDID structure which has the Edid data to check
//!                  pVFlag(OUT)   - bit-wised Edid errors
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! RETURN STATUS: NVAPI_OK : the validation result is valid in pVFlag
//!                NVAPI_INVALID_ARGUMENT: pEDID/pVFlag is NULL; 
//!                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found.
//!                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle.
//!                NVAPI_DATA_NOT_FOUND: requested display does not contain an EDID
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \addtogroup gpu
//! @{
#define NV_EDID_OK                               0    //!< the EDID is good
#define NV_EDID_BAD_CHECKSUM                     0x1  //!< the EDID has bad checksum (base or extension block)
#define NV_EDID_INCOMPATIBLE_CONNECTOR           0x2  //!< the EDID claimed the interface/connector is incompatible with the physical connector
#define NV_EDID_UNSUPPORTED_PIXEL_CLOCK          0x4  //!< the EDID claimed certain timings with pixel above the h/w limit
#define NV_EDID_INCOMPATIBLE_VESA_SPEC           0x8  //!< the EDID is not fully compatible with the VESA/EDID spec
//! @}

//! \ingroup gpu
NVAPI_INTERFACE NvAPI_DISP_ValidateEdid(NvU32 displayId, NV_EDID *pEdid, NvU32 *pVFlag);





///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_SetEDID
//
//!  Thus function sets the EDID data for the specified GPU handle and connection bit mask.
//!  displayOutputId should have exactly 1 bit set to indicate a single display. See \ref handles.
//!  \note The EDID will be cached across the boot session and will be enumerated to the OS in this call.
//!        To remove the EDID set sizeofEDID to zero.
//!        OS and NVAPI connection status APIs will reflect the newly set or removed EDID dynamically.
//!
//!                This feature will NOT be supported on the following boards:
//!                - GeForce
//!                - Quadro VX 
//!                - Tesla  
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 100
//!
//! \retval  NVAPI_INVALID_ARGUMENT              pEDID is NULL; displayOutputId has 0 or > 1 bits set
//! \retval  NVAPI_OK                           *pEDID data was applied to the requested displayOutputId.
//! \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found.
//! \retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle.
//! \retval  NVAPI_NOT_SUPPORTED                 For the above mentioned GPUs
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetEDID(NvPhysicalGpuHandle hPhysicalGpu, NvU32 displayOutputId, NV_EDID *pEDID);


///////////////////////////////////////////////////////////////////////////////
//! \fn NvAPI_GPU_SetEDIDInternal(NvU32 displayId, NV_EDID_LOCKING_FLAG flag, NvU8 *pEDID, NvU32 SizeofEDID)
//! \code
//! FUNCTION NAME: NvAPI_GPU_SetEDIDInternal
//!
//!   DESCRIPTION: This API sets the EDID data for the specified Display.
//!                Note:The EDID will be cached across the boot session and will be enumerated to the OS in this call.
//!                     To remove the EDID set SizeofEDID to zero.
//!                     OS and NVAPI connection status APIs will reflect the newly set or removed EDID dynamically.
//!   PARAMETERS:    displayId(IN)       -   NVIDIA Display ID. It is the value
//!                                          returned from
//!                                          NvAPI_SYS_GetDisplayIdFromGpuAndOutputId()
//!                  flag                -   Must be set to NVAPI_EDID_LOCKING_DEFAULT, other values are defined for internal usage.
//!                                          Indicates if this use is internal to NVIDIA,
//!                                          It will have enum values defined by NV_EDID_LOCKING_FLAG.
//!                  pEDID               -   pEDID points to the buffer containing EDID data of SizeofEDID.
//!                                          Currently only NV_EDID_DATA_SIZE bytes of EDID data is supported.
//!                  SizeofEDID          -   Size of the buffer to which pEDID points.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! RETURN STATUS:   NVAPI_INVALID_ARGUMENT: displayId is 0 or SizeofEDID is non zero and pEDID is null.
//!                  NVAPI_OK: *pEDID data was applied to the requested displayId.
//!                  NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found.
//!                  NVAPI_ARGUMENT_EXCEED_MAX_SIZE: SizeofEDID is greater than NV_EDID_DATA_SIZE.
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
//! @{
typedef enum _NV_EDID_LOCKING_FLAG
{
    NVAPI_EDID_LOCKING_DEFAULT    = 0,         //!< For default use, actual edid locking
    NVAPI_INTERNAL_EDID_LOCKING   = 1,         //!< For an internal client to override Edid Locking
    NVAPI_DDAUTOTEST_EDID_LOCKING = 2,         //!< For DDAutoTest usage only and no other client is supposed to use this value.
} NV_EDID_LOCKING_FLAG;

NVAPI_INTERFACE NvAPI_GPU_SetEDIDInternal(NvU32 displayId, NV_EDID_LOCKING_FLAG flag, NvU8 *pEDID, NvU32 SizeofEDID);

//! @}



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetTargetID
//! \code
//!   DESCRIPTION: Returns the target ID for the specified displayOutputId.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in] hPhysicalGpu		Handle to the physical GPU to which the display is connected. This parameter is ignored
//!									when the displayOutputId is a NvAPI display Id obtained
//!
//! \param [in] displayOutputId		This can either be the connection bit mask or the newer NvAPI display Id. When the legacy
//!									connection bit mask is passed, it should have exactly 1 bit set to indicate a single display
//!
//! \param [out] pTargetId			Pointer to a NvU32 that will receive the targetId output.
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \endcode
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetTargetID(NvPhysicalGpuHandle hPhysicalGpu, NvU32 displayOutputId, NvU32 *pTargetId);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetOutputType
//
//! \fn NvAPI_GPU_GetOutputType(NvPhysicalGpuHandle hPhysicalGpu, NvU32 outputId, NV_GPU_OUTPUT_TYPE *pOutputType)
//!  This function returns the output type for a specific physical GPU handle and outputId (exactly 1 bit set - see \ref handles).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \Version Earliest supported ForceWare version: 82.61
//!
//! \retval     NVAPI_INVALID_ARGUMENT              hPhysicalGpu, outputId, or pOutputsMask is NULL; or outputId has > 1 bit set
//! \retval     NVAPI_OK                           *pOutputType contains a NvGpuOutputType value
//! \retval     NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found
//! \retval     NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
//! used in NvAPI_GPU_GetOutputType()
typedef enum _NV_GPU_OUTPUT_TYPE
{
    NVAPI_GPU_OUTPUT_UNKNOWN  = 0,
    NVAPI_GPU_OUTPUT_CRT      = 1,     //!<  CRT display device
    NVAPI_GPU_OUTPUT_DFP      = 2,     //!<  Digital Flat Panel display device
    NVAPI_GPU_OUTPUT_TV       = 3,     //!<  TV display device
} NV_GPU_OUTPUT_TYPE;




//! \ingroup gpu
NVAPI_INTERFACE NvAPI_GPU_GetOutputType(NvPhysicalGpuHandle hPhysicalGpu, NvU32 outputId, NV_GPU_OUTPUT_TYPE *pOutputType);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetDeviceDisplayMode
//
//! \fn NvAPI_GPU_GetDeviceDisplayMode(NvPhysicalGpuHandle hPhysicalGpu, NvU32 displayId, NV_GPU_DISPLAY_MODE *pDeviceDisplayMode)
//!   DESCRIPTION: For the specified physical GPU handle and single active displayId (exactly 1 bit set), this API
//!                returns the device display mode (see NV_GPU_DISPLAY_MODE) according to hardware (including raster extension). This
//!                includes the backend timing info.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//!  \retval   NVAPI_INVALID_ARGUMENT              hPhysicalGpu, displayId or pOutputsMask is NULL; displayId has > 1 bit set;
//!                                                displayId is not an active display.
//!  \retval   NVAPI_OK                           *pDeviceDisplayMode contains the returned display mode information.
//!  \retval   NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found
//!  \retval   NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
//! Used in NvAPI_GPU_GetDeviceDisplayMode().
typedef struct
{
    NvU32 version;          //!< Structure version
    NvU32 activeWidth;      //!< Number of active horizontal pixels
    NvU32 activeHeight;     //!< Number of active vertical pixels
    NvU32 totalWidth;       //!< Total size of raster width (including blanking)
    NvU32 totalHeight;      //!< Total size of raster height (including blanking)
    NvU32 depth;            //!< Color depth
    NvU32 frequency;        //!< Calculated refresh rate based upon current raster and pixel clock
} NV_GPU_DISPLAY_MODE;

//! \ingroup gpu
#define NV_GPU_DISPLAY_MODE_VER  MAKE_NVAPI_VERSION(NV_GPU_DISPLAY_MODE,1)


//!  \ingroup  gpu
NVAPI_INTERFACE NvAPI_GPU_GetDeviceDisplayMode(NvPhysicalGpuHandle hPhysicalGpu, NvU32 displayId, NV_GPU_DISPLAY_MODE *pDeviceDisplayMode);




//DISPLAYPORT is all private for now. Do not change category until that info is public.
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetFlatPanelInfo
//
//! \fn NvAPI_GPU_GetFlatPanelInfo(NvPhysicalGpuHandle hPhysicalGpu, NvU32 outputId, NV_GPU_FLAT_PANEL_INFO *pFlatPanelInfo)
//!  Given a physical GPU handle and a single display outputId of the flat panel (see \ref handles), this API 
//!  returns the flat panel attributes.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 95
//!
//! \retval  NVAPI_INVALID_ARGUMENT              hPhysicalGpu, outputId, or pFlatPanelInfo is NULL; or outputId has > 1 bit set.
//! \retval  NVAPI_OK                           *pFlatPanelInfo contains the returned flat panel information.
//! \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found.
//! \retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//! \retval  NVAPI_EXPECTED_DIGITAL_FLAT_PANEL   outputId is not associated with digital flat panel.
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
//! Used in NV_GPU_FLAT_PANEL_INFO
typedef enum _NV_GPU_FLATPANEL_SIGNAL_TYPE
{
  NV_GPU_FLATPANEL_SIGNAL_TYPE_TMDS         = 0,
  NV_GPU_FLATPANEL_SIGNAL_TYPE_LVDS         = 1,
  NV_GPU_FLATPANEL_SIGNAL_TYPE_SDI          = 2,
  NV_GPU_FLATPANEL_SIGNAL_TYPE_DISPLAYPORT  = 3,
    
} NV_GPU_FLATPANEL_SIGNAL_TYPE;


//! \ingroup gpu
//! Used in NV_GPU_FLAT_PANEL_INFO
typedef enum _NV_GPU_FLATPANEL_SIGNAL_LINK
{
  NV_GPU_FLATPANEL_SIGNAL_SINGLE_LINK       = 1,
  NV_GPU_FLATPANEL_SIGNAL_DUAL_LINK         = 2,
    
} NV_GPU_FLATPANEL_SIGNAL_LINK;


//! \ingroup gpu
//! Used in NV_GPU_FLAT_PANEL_INFO
typedef enum _NV_GPU_FLATPANEL_SIGNAL_DISPLAYPORT_LANES
{
  NV_GPU_FLATPANEL_SIGNAL_DISPLAYPORT_NONE              = 0,
  NV_GPU_FLATPANEL_SIGNAL_DISPLAYPORT_SINGLE_LANE       = 1,
  NV_GPU_FLATPANEL_SIGNAL_DISPLAYPORT_DUAL_LANE         = 2,
  NV_GPU_FLATPANEL_SIGNAL_DISPLAYPORT_QUAD_LANE         = 3,
    
} NV_GPU_FLATPANEL_SIGNAL_DISPLAYPORT_LANES;


//! \ingroup gpu
//! Used in NV_GPU_FLAT_PANEL_INFO
typedef enum _NV_GPU_FLATPANEL_SIGNAL_COLOR_FLAGS
{
  NV_GPU_FLATPANEL_SIGNAL_COLOR_LIMITED_RANGE           = 0x00000001,   //!< Flatpanel supports limited color range.
  NV_GPU_FLATPANEL_SIGNAL_COLOR_AUTO_CONFIGURE          = 0x00000002,   //!< Flatpanel supports auto-configuring the color range.
  NV_GPU_FLATPANEL_SIGNAL_COLOR_FORMAT_YCBCR422_CAPABLE = 0x00000004,   //!< Flatpanel is YCBCR422 color format capable.
  NV_GPU_FLATPANEL_SIGNAL_COLOR_FORMAT_YCBCR444_CAPABLE = 0x00000008,   //!< Flatpanel is YCBCR444 color format capable.
   
} NV_GPU_FLATPANEL_SIGNAL_COLOR_FLAGS;


//! \ingroup gpu
//! Used in NvAPI_GPU_GetFlatPanelInfo()
typedef struct
{
    NvU32                                       version;                    //!< Structure version
    NV_GPU_FLATPANEL_SIGNAL_TYPE                signalType;                 //!< Flat panel signal type
    NV_GPU_FLATPANEL_SIGNAL_LINK                linkType;                   //!< Link type
    NV_GPU_FLATPANEL_SIGNAL_DISPLAYPORT_LANES   displayPortLanes;           //!< 1, 2 or 4 DisplayPort lanesconnected panel. 
    NvU32                                       colorFlags;                 //!< One or more bits from NV_GPU_FLATPANEL_SIGNAL_COLOR_FLAGS
    NvU32                                       hdmiCapable:1;              //!< HMDI status
    NvU32                                       scalerDisabled:1;           //!< Indicates if GPU scaling is disabled (possible with SLI active on certain GPUs)

    NvU32                                       refreshRateLocked:1;        //!< Flat panel supports 60 Hz only
}
NV_GPU_FLAT_PANEL_INFO;


//! \ingroup gpu
#define NV_GPU_FLAT_PANEL_INFO_VER  MAKE_NVAPI_VERSION(NV_GPU_FLAT_PANEL_INFO,1)


//! \ingroup gpu  
NVAPI_INTERFACE NvAPI_GPU_GetFlatPanelInfo(NvPhysicalGpuHandle hPhysicalGpu, NvU32 outputId, NV_GPU_FLAT_PANEL_INFO *pFlatPanelInfo);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_ValidateOutputCombination
//
//!  This function determines if a set of GPU outputs can be active 
//!  simultaneously.  While a GPU may have <n> outputs, typically they cannot 
//!  all be active at the same time due to internal resource sharing.
//!
//!  Given a physical GPU handle and a mask of candidate outputs, this call
//!  will return NVAPI_OK if all of the specified outputs can be driven
//!  simultaneously.  It will return NVAPI_INVALID_COMBINATION if they cannot.
//!                
//!  Use NvAPI_GPU_GetAllOutputs() to determine which outputs are candidates.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 85
//!
//! \retval  NVAPI_OK                            Combination of outputs in outputsMask are valid (can be active simultaneously).
//! \retval  NVAPI_INVALID_COMBINATION           Combination of outputs in outputsMask are NOT valid.
//! \retval  NVAPI_INVALID_ARGUMENT              hPhysicalGpu or outputsMask does not have at least 2 bits set.
//! \retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//! \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found.
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_ValidateOutputCombination(NvPhysicalGpuHandle hPhysicalGpu, NvU32 outputsMask);




//! \ingroup gpu
//! Used in NvAPI_GPU_GetConnectorState()
typedef struct _NV_CONNECTOR_STATE
{
    NvU32       version;                            //!<  Structure version

    NvU64       isMultiStreamEnabled    : 1;        //!< Specifies if multi stream is enabled on this connector
    NvU64       isStreamCloneEnabled    : 1;        //!< Specifies if stream clone is enabled on this connector
    NvU64       isWronglyConnected      : 1;        //!< Specifies if display is wrongly connected. Currently used for Tiled display only.
                                                    //!< Either monitor's all required connector are not connected or connected across GPU with SLI disabled. 
    NvU64       reserved                : 61;       //!< Reserved. Must be set to ZERO.

} NV_CONNECTOR_STATE_V1;

//! \ingroup gpu
typedef NV_CONNECTOR_STATE_V1 NV_CONNECTOR_STATE;

#define NV_CONNECTOR_STATE_VER1  MAKE_NVAPI_VERSION(NV_CONNECTOR_STATE_V1, 1)
#define NV_CONNECTOR_STATE_VER   NV_CONNECTOR_STATE_VER1 

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetConnectorState
//
//! \fn NvAPI_GPU_GetConnectorState(__in NvU32 displayId, __inout NV_CONNECTOR_STATE *pConnectorState)
//!
//!   Description: This API returns the connector state for a given connector identified by the input
//!                displayId parameter. Note that when the display id represents a device in a multi stream topology,
//!                the state of the physical connector to which the display is rooted to, will be returned. If the 
//!                display is rooted to multiple physical connectors (when connected via a concentrator), the 
//!                output is not guaranteed to be of any connector. In such cases, the user should pass the display id
//!                of the connector specifically.
//!
//! \param[in]     displayId        The displayId of a device connected to the required connector
//! \param[in/out] pConnectorState  Pointer to NV_CONNECTOR_STATE structure that will receive the data
//!
//! SUPPORTED OS:  Windows Vista
//!
//!
//! \return      This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!              specific meaning for this API, they are listed below.
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetConnectorState(__in NvU32 displayId, __inout NV_CONNECTOR_STATE *pConnectorState);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetShortName
//
//!  This function retrieves the GPU short name - for example, "NV40", "G70", etc..
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 85
//!
//! \return  NVAPI_ERROR or NVAPI_OK
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetShortName(NvPhysicalGpuHandle hPhysicalGpu, NvAPI_ShortString szName);

 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetFullName
//
//!  This function retrieves the full GPU name as an ASCII string - for example, "Quadro FX 1400".
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 90
//!
//! \return  NVAPI_ERROR or NVAPI_OK
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetFullName(NvPhysicalGpuHandle hPhysicalGpu, NvAPI_ShortString szName);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetPCIIdentifiers
//
//!  This function returns the PCI identifiers associated with this GPU.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 90
//!
//! \param   DeviceId      The internal PCI device identifier for the GPU.
//! \param   SubSystemId   The internal PCI subsystem identifier for the GPU.
//! \param   RevisionId    The internal PCI device-specific revision identifier for the GPU.
//! \param   ExtDeviceId   The external PCI device identifier for the GPU.
//!
//! \retval  NVAPI_INVALID_ARGUMENT              hPhysicalGpu or an argument is NULL
//! \retval  NVAPI_OK                            Arguments are populated with PCI identifiers
//! \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found
//! \retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetPCIIdentifiers(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pDeviceId,NvU32 *pSubSystemId,NvU32 *pRevisionId,NvU32 *pExtDeviceId);
    



//! \ingroup gpu
//! Used in NvAPI_GPU_GetGPUType().    
typedef enum _NV_GPU_TYPE
{
    NV_SYSTEM_TYPE_GPU_UNKNOWN     = 0, 
    NV_SYSTEM_TYPE_IGPU            = 1, //!< Integrated GPU
    NV_SYSTEM_TYPE_DGPU            = 2, //!< Discrete GPU
    NV_SYSTEM_TYPE_SOCGPU          = 3, //!< SoC GPU
} NV_GPU_TYPE; 


/////////////////////////////////////////////////////////////////////////////// 
// 
// FUNCTION NAME: NvAPI_GPU_GetGPUType 
// 
//!  DESCRIPTION: This function returns the GPU type (integrated or discrete).
//!               See ::NV_GPU_TYPE. 
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 173
//!
//! \retval  NVAPI_INVALID_ARGUMENT              hPhysicalGpu 
//! \retval  NVAPI_OK                           *pGpuType contains the GPU type 
//! \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found 
//! \retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle 
//!
//!  \ingroup gpu 
///////////////////////////////////////////////////////////////////////////////     
NVAPI_INTERFACE NvAPI_GPU_GetGPUType(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_TYPE *pGpuType);




//! \ingroup gpu
//! Used in NvAPI_GPU_GetBusType()
typedef enum _NV_GPU_BUS_TYPE
{
    NVAPI_GPU_BUS_TYPE_UNDEFINED    = 0,
    NVAPI_GPU_BUS_TYPE_PCI          = 1,
    NVAPI_GPU_BUS_TYPE_AGP          = 2,
    NVAPI_GPU_BUS_TYPE_PCI_EXPRESS  = 3,
    NVAPI_GPU_BUS_TYPE_FPCI         = 4,
    NVAPI_GPU_BUS_TYPE_AXI          = 5,
} NV_GPU_BUS_TYPE;
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetBusType
//
//!  This function returns the type of bus associated with this GPU.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 90
//!
//! \return      This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!              specific meaning for this API, they are listed below.
//! \retval      NVAPI_INVALID_ARGUMENT             hPhysicalGpu or pBusType is NULL.
//! \retval      NVAPI_OK                          *pBusType contains bus identifier.
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetBusType(NvPhysicalGpuHandle hPhysicalGpu,NV_GPU_BUS_TYPE *pBusType);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetBusId
//
//!   DESCRIPTION: Returns the ID of the bus associated with this GPU.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 167
//!
//!  \retval  NVAPI_INVALID_ARGUMENT              hPhysicalGpu or pBusId is NULL.
//!  \retval  NVAPI_OK                           *pBusId contains the bus ID.
//!  \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found.
//!  \retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//!
//!  \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetBusId(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pBusId);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetBusSlotId
//
//!   DESCRIPTION: Returns the ID of the bus slot associated with this GPU.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 167
//!
//!  \retval  NVAPI_INVALID_ARGUMENT              hPhysicalGpu or pBusSlotId is NULL.
//!  \retval  NVAPI_OK                           *pBusSlotId contains the bus slot ID.
//!  \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found.
//!  \retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//!
//!  \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetBusSlotId(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pBusSlotId);




//! \ingroup gpu
//! @{
typedef struct
{
    NvU32 version;                //!< (IN)  structure version
    NvU32 speedSwitchErrorCount;  //!< (OUT) Returns the speed switch error count 
    NvU32 widthSwitchErrorCount;  //!< (OUT) Returns the width switch error count                     
} NV_PCIELINK_SWITCH_ERROR_INFO_V1;


typedef NV_PCIELINK_SWITCH_ERROR_INFO_V1    NV_PCIELINK_SWITCH_ERROR_INFO;
#define NV_PCIELINK_SWITCH_ERROR_INFO_VER1  MAKE_NVAPI_VERSION(NV_PCIELINK_SWITCH_ERROR_INFO_V1,1)
#define NV_PCIELINK_SWITCH_ERROR_INFO_VER   NV_PCIELINK_SWITCH_ERROR_INFO_VER1

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetPCIELinkSwitchErrorInfo
//
//!   DESCRIPTION: This API returns the error count of the ASLM switch or Gen1<->Gen2 switch.  
//!
//! \param [in]    hPhysicalGpu           Physical GPU Handle for GPU Selection
//! \param [out]   pSwitchErrorInfo       Switch Error Count information returned by system. 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \return The following are return error codes with specific meaning for this API. In addition, this API can return any of the error codes enumerated in #NvAPI_Status.
//! \retval NVAPI_NVIDIA_DEVICE_NOT_FOUND No NVIDIA GPU driving a display was found
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetPCIELinkSwitchErrorInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_PCIELINK_SWITCH_ERROR_INFO *pSwitchErrorInfo);



//! \ingroup gpu

typedef enum
{
    NV_INTERRUPT_LEGACY_IRQL_TYPE = 0,  //!< legacy line based interrupts
    NV_INTERRUPT_MSI_TYPE = 1,          //!< Message Signaled Interrupts
} NV_INTERRUPT_TYPE;

typedef struct _NV_INTERRUPT_INFO
{
    NvU32 version;                   //!< structure version
    NV_INTERRUPT_TYPE type; //!< one of NV_INTERRUPT_TYPE
    NvU32 IRQ;                        //!< IRQ. It is valid for NV_INTERRUPT_LEGACY_IRQL_TYPE only

}NV_INTERRUPT_INFO_V1;

typedef NV_INTERRUPT_INFO_V1    NV_INTERRUPT_INFO;
#define NV_INTERRUPT_INFO_VER1  MAKE_NVAPI_VERSION(NV_INTERRUPT_INFO_V1,1)
#define NV_INTERRUPT_INFO_VER   NV_INTERRUPT_INFO_VER1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetInterruptInfo
//
//!  This function returns the interrupt info associated with this GPU.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 319
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. 
//!          If there are return error codes with specific meaning for this API, 
//!          they are listed below.
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetInterruptInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_INTERRUPT_INFO *interruptInfo);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetIRQ
//
//!  This function returns the interrupt number associated with this GPU.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 90
//!
//! \retval  NVAPI_INVALID_ARGUMENT              hPhysicalGpu or pIRQ is NULL.
//! \retval  NVAPI_OK                           *pIRQ contains interrupt number.
//! \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found.
//! \retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetIRQ(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pIRQ);
    
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetVbiosRevision
//
//!  This function returns the revision of the video BIOS associated with this GPU.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 90
//!
//! \retval    NVAPI_INVALID_ARGUMENT               hPhysicalGpu or pBiosRevision is NULL.
//! \retval    NVAPI_OK                            *pBiosRevision contains revision number.
//! \retval    NVAPI_NVIDIA_DEVICE_NOT_FOUND        No NVIDIA GPU driving a display was found.
//! \retval    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE   hPhysicalGpu was not a physical GPU handle.
//! \ingroup   gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetVbiosRevision(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pBiosRevision);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetVbiosOEMRevision
//
//!  This function returns the OEM revision of the video BIOS associated with this GPU.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 90
//!
//! \retval    NVAPI_INVALID_ARGUMENT              hPhysicalGpu or pBiosRevision is NULL
//! \retval    NVAPI_OK                           *pBiosRevision contains revision number
//! \retval    NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found
//! \retval    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle
//! \ingroup   gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetVbiosOEMRevision(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pBiosRevision);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetBridgeVersionInfo
//
//! \fn NvAPI_GPU_GetBridgeInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout_ecount_part_opt(*pBridgeCount, *pBridgeCount) NV_BRIDGE_FIRMWARE_INFO *pBridgeFirmwareInfo, __inout NvU32 *pBridgeCount, )
//!     DESCRIPTION: Returns information about the bridge associated with this GPU.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \param [in]     hPhysicalGpu        GPU selection.
//! \param [out]    pBridgeCount        Count of physical bridges.
//! \param [out]    pBridgeFirmwareInfo Structure containing bridge firmware information.
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. 
//!          If there are return error codes with specific meaning for this API, 
//!          they are listed below.
//! \retval  NVAPI_INVALID_ARGUMENT     hPhysicalGpu or pBiosRevision or pOemVersion or pSiliconRevision is NULL.
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
typedef enum _HWBC_RES_TYPE
{
    HWBC_UNKNOWN = 0,   
    HWBC_NVIDIA_MCP55,
    HWBC_NVIDIA_BR03,
    HWBC_NVIDIA_C55,
    HWBC_NVIDIA_MCP65,
    HWBC_NVIDIA_BR04,
    HWBC_NVIDIA_C73,
    HWBC_NVIDIA_MCP79,
    HWBC_PLX_PEX8747
} HWBC_RES_TYPE;

//! \ingroup gpu
typedef struct _NV_BRIDGE_FIRMWARE_INFO_V1
{
    NvU32   version;            //!<structure version
    NvU32   bridgeId;           //!<bridge id assigned by RM
    NvU32   fwVersion;          //!<firmware version of the bridge
    NvU8    oemVersion;         //!<oem version of bridge firmware
    NvU8    siliconRevision;    //!<silicon revision of the bridge chip
    NvU8    bridgeName;         //!<bridge name will be one of enum type HWBC_RES_TYPE
} NV_BRIDGE_FIRMWARE_INFO_V1;

//! \ingroup gpu
typedef struct _NV_BRIDGE_FIRMWARE_INFO_V2
{
    NvU32   version;            //!<structure version
    NvU32   bridgeId;           //!<bridge id assigned by RM
    NvU32   fwVersion;          //!<firmware version of the bridge
    NvU8    oemVersion;         //!<oem version of bridge firmware
    NvU8    siliconRevision;    //!<silicon revision of the bridge chip
    NvU8    bridgeName;         //!<bridge name will be one of enum type HWBC_RES_TYPE
    NvU32   domain;             //!<domain of the physical bridge
    NvU8    bus;                //!<bus number of the physical bridge
    NvU8    device;             //!<device number of the physical bridge
    NvU8    func;               //!<function number of the physical bridge
} NV_BRIDGE_FIRMWARE_INFO_V2;

//! \ingroup gpu
typedef NV_BRIDGE_FIRMWARE_INFO_V2 NV_BRIDGE_FIRMWARE_INFO;

//! \ingroup gpu
//! Macro for constructing the version field of ::NV_BRIDGE_FIRMWARE_INFO
#define NV_BRIDGE_FIRMWARE_INFO_VER_1 MAKE_NVAPI_VERSION(NV_BRIDGE_FIRMWARE_INFO_V1,1)
#define NV_BRIDGE_FIRMWARE_INFO_VER_2 MAKE_NVAPI_VERSION(NV_BRIDGE_FIRMWARE_INFO_V2,2)
#define NV_BRIDGE_FIRMWARE_INFO_VER NV_BRIDGE_FIRMWARE_INFO_VER_2

//! \ingroup gpu
NVAPI_INTERFACE NvAPI_GPU_GetBridgeVersionInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout_ecount_part_opt(*pBridgeCount, *pBridgeCount) NV_BRIDGE_FIRMWARE_INFO *pBridgeFirmwareInfo, __inout NvU32 *pBridgeCount);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetVbiosOemInfo
//
//! \fn NvAPI_GPU_GetVbiosOemInfo(NvPhysicalGpuHandle hPhysicalGpu,NV_VBIOS_OEM_INFO *pVbiosOemInfo)
//! \code
//!   DESCRIPTION: Returns some OEM specific data from the vbios associated this GPU.
//!
//!    PARAMETERS: hPhysicalGpu(IN) - GPU selection.
//!                pVbiosOemInfo(OUT) - Structure containing OEM information retrieved.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! RETURN STATUS: NVAPI_OK: *pVbiosOemInfo contains info
//!                NVAPI_INVALID_ARGUMENT: hPhysicalGpu or pVbiosOemInfo is NULL
//!                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
typedef struct
{
    NvU32              version;        //!<structure version
    NvAPI_ShortString  vendorName;
    NvAPI_ShortString  productName;
    NvAPI_ShortString  productRevision;
} NV_VBIOS_OEM_INFO;

//! \ingroup gpu
//! Macro for constructing the version field of ::NV_VBIOS_OEM_INFO
#define NV_VBIOS_OEM_INFO_VER MAKE_NVAPI_VERSION(NV_VBIOS_OEM_INFO,1)

//! \ingroup gpu
NVAPI_INTERFACE NvAPI_GPU_GetVbiosOemInfo(NvPhysicalGpuHandle hPhysicalGpu,NV_VBIOS_OEM_INFO *pVbiosOemInfo);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetVbiosMxmVersion
//
//!   DESCRIPTION: This API returns the MXM Spec version of the video BIOS associated with the specified GPU.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 180
//!
//! \param [in]  hPhysicalGpu      GPU selection.
//! \param [out] pBiosMxmVersion   MXM Version information retrieved.
//!
//! \retval ::NVAPI_OK                           *pBiosMxmVersion contains version number
//! \retval ::NVAPI_INVALID_ARGUMENT              hPhysicalGpu or pBiosMxmVersion is NULL
//! \retval ::NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle
//! \retval ::NVAPI_NOT_SUPPORTED                 The specified GPU is not MXM form factor
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetVbiosMxmVersion(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pBiosMxmVersion);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetVbiosImage
//
//! \fn NvAPI_GPU_GetVbiosImage(NvPhysicalGpuHandle hPhysicalGpu,NV_VBIOS_IMAGE *pImage)
//!  This function returns the entire video BIOS image associated with this GPU.
//!
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 100
//!
//! \retval  NVAPI_INVALID_ARGUMENT              hPhysicalGpu or pImage is NULL.
//! \retval  NVAPI_OK                           *pImage contains the VBIOS image. (Parsing it is up to the caller)
//! \retval  NVAPI_INCOMPATIBLE_STRUCT_VERSION   NV_VBIOS_IMAGE version is not compatible with driver.
//! \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found.
//! \retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
//! Used in NV_VBIOS_IMAGE 
#define NV_VBIOS_IMAGE_SIZE    (64*1024)   //64KB
#define NV_VBIOS_IMAGE_SIZE_EX (1000*1024) //1MB

//! \ingroup gpu
//! Used in NvAPI_GPU_GetVbiosImage()

typedef struct _NV_VBIOS_IMAGE_V1
{
    NvU32   version;        //!< Structure version
    NvU32   bufferSize;     //!< Please assign the bufferSize value to NV_VBIOS_IMAGE_SIZE
    NvU8    buffer[NV_VBIOS_IMAGE_SIZE];
} NV_VBIOS_IMAGE_V1;

typedef struct _NV_VBIOS_IMAGE_V2
{
    NvU32   version;        //!< Structure version
    NvU32   bufferSize;     //!< Please assign the bufferSize value to NV_VBIOS_IMAGE_SIZE_EX
    NvU8    *buffer;        //!< Please allocate the buffer to NV_VBIOS_IMAGE_SIZE_EX before calling NvAPI_GPU_GetVbiosImage API.
                            //!< If buffer is NULL, API will return the max size in bufferSize variable, to be allocated.
} NV_VBIOS_IMAGE_V2;

typedef NV_VBIOS_IMAGE_V2  NV_VBIOS_IMAGE;

//! \ingroup gpu
#define NV_VBIOS_IMAGE_VER1 MAKE_NVAPI_VERSION(NV_VBIOS_IMAGE_V1,1)
#define NV_VBIOS_IMAGE_VER2 MAKE_NVAPI_VERSION(NV_VBIOS_IMAGE_V2,2)
#define NV_VBIOS_IMAGE_VER  NV_VBIOS_IMAGE_VER2


//! \ingroup gpu
NVAPI_INTERFACE NvAPI_GPU_GetVbiosImage(NvPhysicalGpuHandle hPhysicalGpu,NV_VBIOS_IMAGE *pImage);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetVbiosSecurityInfo
//
//! \fn NvAPI_GPU_GetVbiosSecurityInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_VBIOS_SECURITY_INFO *pVbiosSecurityInfo)
//!  This function returns the VBIOS security information from this GPU.
//!
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 295
//!
//! \retval  NVAPI_INVALID_ARGUMENT              hPhysicalGpu or pImage is NULL.
//! \retval  NVAPI_OK                           *pVbiosSecurityInfo contains the security information
//! \retval  NVAPI_INCOMPATIBLE_STRUCT_VERSION   NV_VBIOS_SECURITY_INFO version is not compatible with driver.
//! \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found.
//! \retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
//! @{
typedef enum
{
    NV_VBIOS_SECURITY_INFO_TYPE_INVALID                   = 0x00,
    NV_VBIOS_SECURITY_INFO_TYPE_UNSIGNED                  = 0x01,
    NV_VBIOS_SECURITY_INFO_TYPE_NVIDIA_DEBUG              = 0x02,
    NV_VBIOS_SECURITY_INFO_TYPE_NVIDIA_RELEASE            = 0x03,
    NV_VBIOS_SECURITY_INFO_TYPE_NVIDIA_AE_DEBUG           = 0x04,
    NV_VBIOS_SECURITY_INFO_TYPE_PARTNER_DEBUG             = 0x05,
    NV_VBIOS_SECURITY_INFO_TYPE_PARTNER                   = 0x06,
} NV_VBIOS_SECURITY_INFO_TYPE;

typedef enum _NV_VBIOS_INFO_STATUS
{    
    NV_VBIOS_INFO_STATUS_OK                                    = 0x00,
    NV_VBIOS_INFO_STATUS_EXPIRED                               = 0x01,
    NV_VBIOS_INFO_STATUS_INVALID                               = 0x02,
    NV_VBIOS_INFO_STATUS_DEVID_MISMATCH                        = 0x03,
    NV_VBIOS_INFO_STATUS_ERR_ROMPACK_OFFSET                    = 0x04,
    NV_VBIOS_INFO_STATUS_INSUFFICIENT_RESOURCES                = 0x05, 
    NV_VBIOS_INFO_STATUS_NBSI_INCOMPLETE                       = 0x06, 
    NV_VBIOS_INFO_STATUS_INVALID_CERT                          = 0x07, 
    NV_VBIOS_INFO_STATUS_INVALID_HASH                          = 0x08, 
    NV_VBIOS_INFO_STATUS_VBIOS_HASH_NOT_STARTED                = 0x09, 
    NV_VBIOS_INFO_STATUS_SECURITY_BLOCK_NOT_FOUND              = 0x0a, 
    NV_VBIOS_INFO_STATUS_FIRST_X509_NOT_FOUND                  = 0x0b, 
    NV_VBIOS_INFO_STATUS_INVALID_PEM_FORMAT                    = 0x0c, 
    NV_VBIOS_INFO_STATUS_UNKNOWN_CERT_TYPE                     = 0x0d, 
    NV_VBIOS_INFO_STATUS_DUPLICATE_VENDOR_CERT_FOUND           = 0x0e, 
    NV_VBIOS_INFO_STATUS_NO_PUBLIC_KEY                         = 0x0f, 
    NV_VBIOS_INFO_STATUS_POINTER_PAST_SECURITY_BLK             = 0x10, 
    NV_VBIOS_INFO_STATUS_INVALID_HASH_HEADER_VERSION           = 0x11, 
    NV_VBIOS_INFO_STATUS_ERR_HASH_HEADER_FLAG_SET              = 0x12, 
    NV_VBIOS_INFO_STATUS_INVALID_SIGNATURE_HEADER_VER          = 0x13, 
    NV_VBIOS_INFO_STATUS_SIG_UNKNOWN_DIGEST_ALGO               = 0x14, 
    NV_VBIOS_INFO_STATUS_SIG_UNKNOWN_FORMAT                    = 0x15, 
    NV_VBIOS_INFO_STATUS_SIG_INVALID_SIZE                      = 0x16, 
    NV_VBIOS_INFO_STATUS_SIG_VERIFICATION_FAILURE              = 0x17, 
    NV_VBIOS_INFO_STATUS_PRESERV_TABLE_HASH_NOT_STARTED        = 0x18, 
    NV_VBIOS_INFO_STATUS_NO_EXPANSION_ROM                      = 0x19, 
    NV_VBIOS_INFO_STATUS_UNKNOWN_HASH_TYPE                     = 0x1a, 
    NV_VBIOS_INFO_STATUS_POINTER_PAST_HASH_BLK                 = 0x1b,
    NV_VBIOS_INFO_STATUS_CERT_VALIDITY_PERIOD_NOT_FOUND        = 0x1c,
    NV_VBIOS_INFO_STATUS_CERT_OEM_NAME_NOT_FOUND               = 0x1d,
    NV_VBIOS_INFO_STATUS_CERT_CHAIN_OF_TRUST_FAILURE           = 0x1e,
    NV_VBIOS_INFO_STATUS_NO_BIT_HEADER                         = 0x1f,
    NV_VBIOS_INFO_STATUS_NO_VBIOS_FOUND                        = 0x20,
    NV_VBIOS_INFO_STATUS_INVALID_PARAMS                        = 0x21,
    NV_VBIOS_INFO_STATUS_NOT_SILICON_OR_EMULATION              = 0x22,
    NV_VBIOS_INFO_STATUS_NV_CONFIG_PCI_NV_20_READ_ERROR        = 0x23,
    NV_VBIOS_INFO_STATUS_INVALID_PCI_ROM_SIG                   = 0x24,
    NV_VBIOS_INFO_STATUS_INVALID_PCI_DATA_SIG                  = 0x25,
    NV_VBIOS_INFO_STATUS_INVALID_PCI_HEADER                    = 0x26,
    NV_VBIOS_INFO_STATUS_INVALID_CHECKSUM                      = 0x27,
    NV_VBIOS_INFO_STATUS_NO_NBSI_BLOCK                         = 0x28,
    NV_VBIOS_INFO_STATUS_CANNOT_MAP_TO_KERNEL_SPACE            = 0x29,
    NV_VBIOS_INFO_STATUS_IMAGE_EXCEEDS_PCIR_SIZE               = 0x2a,
    NV_VBIOS_INFO_STATUS_PCIR_VENDOR_ID_MISMATCH               = 0x2b,
    NV_VBIOS_INFO_STATUS_PCIR_LEN_EXCEEDS_IMAGE                = 0x2c,
    NV_VBIOS_INFO_STATUS_IMAGE_SIZE_OUT_OF_BOUNDS              = 0x2d,
    NV_VBIOS_INFO_STATUS_REGISTRY_NOT_FOUND                    = 0x2e,
    NV_VBIOS_INFO_STATUS_VOLATILE_REGISTRY_NOT_FOUND           = 0x2f,
    NV_VBIOS_INFO_STATUS_GPUMGR_OBJECT_NOT_FOUND               = 0x30,
    NV_VBIOS_INFO_STATUS_GPUMGR_BUFFER_TOO_SMALL               = 0x31,
    NV_VBIOS_INFO_STATUS_INSTANCE_NOT_FOUND                    = 0x32,
    NV_VBIOS_INFO_STATUS_IMAGE_VERIFICATION_FAILURE            = 0x33,
    NV_VBIOS_INFO_STATUS_UNSET                                 = 0x34    
} NV_VBIOS_INFO_STATUS;

typedef struct
{
    NvU32           version;            //!< Structure version
    NvU8            vbiosType;          //!< Vbios type - NV_VBIOS_SECURITY_INFO_TYPE
    NvU8            status;             //!< Vbios status - NV2080_CTRL_BIOS_INFO_SECURITY_STATUS
    NvU8            expirationDay;      //!< Vbios expiration day
    NvU8            expirationMonth;    //!< Vbios expiration month
    NvU16           expirationYear;     //!< Vbios expiration year
    NvU8            bShowInCpl;         //!< Show expiration date in CPL - Deprecated, always 0
    NvU8            bShowInOverlay;     //!< Show expiration date in Overlay - Deprecated, always 0
} NV_VBIOS_SECURITY_INFO_V1;

typedef struct
{
    NvU32           version;            //!< Structure version
    NvU8            vbiosType;          //!< Vbios type - NV_VBIOS_SECURITY_INFO_TYPE
    NvU8            status;             //!< Vbios status - NV2080_CTRL_BIOS_INFO_SECURITY_STATUS
    NvU8            expirationDay;      //!< Vbios expiration day
    NvU8            expirationMonth;    //!< Vbios expiration month
    NvU16           expirationYear;     //!< Vbios expiration year
    NvU8            bShowInCpl;         //!< Show expiration date in CPL - Deprecated, always 0
    NvU8            bShowInOverlay;     //!< Show expiration date in Overlay - Deprecated, always 0
    NvU8            creationDay;        //!< Vbios creation day
    NvU8            creationMonth;      //!< Vbios creation month
    NvU16           creationYear;       //!< Vbios creation year
    NvAPI_String    OEMName;            //!< OEM name
} NV_VBIOS_SECURITY_INFO_V2;

typedef struct
{
    NvU32           version;            //!< Structure version
    NvU8            vbiosType;          //!< Vbios type - NV_VBIOS_SECURITY_INFO_TYPE
    NvU8            status;             //!< Vbios status - NV2080_CTRL_BIOS_INFO_SECURITY_STATUS
    NvU8            expirationDay;      //!< Vbios expiration day
    NvU8            expirationMonth;    //!< Vbios expiration month
    NvU16           expirationYear;     //!< Vbios expiration year
    NvU8            creationDay;        //!< Vbios creation day
    NvU8            creationMonth;      //!< Vbios creation month
    NvU16           creationYear;       //!< Vbios creation year
    NvAPI_String    OEMName;            //!< OEM name
    NvU16           vbiosDevId;         //!< Device ID recorded in VBIOS
    NvU16           calculatedDevId;    //!< Calculated device ID, what is reported usually  
} NV_VBIOS_SECURITY_INFO_V3;


typedef NV_VBIOS_SECURITY_INFO_V3 NV_VBIOS_SECURITY_INFO;

#define NV_VBIOS_SECURITY_INFO_VER_1  MAKE_NVAPI_VERSION(NV_VBIOS_SECURITY_INFO_V1,1)
#define NV_VBIOS_SECURITY_INFO_VER_2  MAKE_NVAPI_VERSION(NV_VBIOS_SECURITY_INFO_V2,2)
#define NV_VBIOS_SECURITY_INFO_VER_3  MAKE_NVAPI_VERSION(NV_VBIOS_SECURITY_INFO_V3,3)
#define NV_VBIOS_SECURITY_INFO_VER    NV_VBIOS_SECURITY_INFO_VER_3


NVAPI_INTERFACE NvAPI_GPU_GetVbiosSecurityInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_VBIOS_SECURITY_INFO *pVbiosSecurityInfo);
//! @}

///////////////////////////////////////////////////////////////////////////////
//! \fn NvAPI_GPU_GetPostTime(NvPhysicalGpuHandle hPhysicalGpu, NV_VBIOS_POST_DATA *pVbiosPostData)
//! \code
//! FUNCTION NAME: NvAPI_GPU_GetPostTime
//!
//!   DESCRIPTION: Return the vbios post time in msec, for secondary gpu it will
//!                return the time spent in devinit execution.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! TCC_SUPPORTED
//!
//! RETURN STATUS: NVAPI_API_NOT_INITIALIZED: nvapi not initialized
//!                 NVAPI_NO_IMPLEMENTATION: OS not supported
//!                 NVAPI_INVALID_ARGUMENT: pVbiosPostData is NULL
//!                 NVAPI_INCOMPATIBLE_STRUCT_VERSION: version mismatch
//!                 NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//!                 NVAPI_NOT_SUPPORTED: vbios doesn't contain POST flag
//!                 NVAPI_ERROR: Either KDA buffer is not present or some unknown error occured
//!                 NVAPI_OK: pVbiosPostData->vbiosPostTime contains valid post time value
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
//! @{
typedef struct
{
    NvU32   version;        //!< structure version
    NvU64   vbiosPostTime;  //!< contains vbios post time
} NV_VBIOS_POST_DATA_V1;

typedef NV_VBIOS_POST_DATA_V1 NV_VBIOS_POST_DATA;
#define NV_VBIOS_POST_DATA_VER1  MAKE_NVAPI_VERSION(NV_VBIOS_POST_DATA_V1,1)
#define NV_VBIOS_POST_DATA_VER    NV_VBIOS_POST_DATA_VER1

NVAPI_INTERFACE NvAPI_GPU_GetPostTime(NvPhysicalGpuHandle hPhysicalGpu, NV_VBIOS_POST_DATA *pVbiosPostData);

//! @}

///////////////////////////////////////////////////////////////////////////////
//! \fn NvAPI_DIAG_GetRcErrorData(NvPhysicalGpuHandle hPhysicalGpu, NV_RC_ERROR_DATA *pRcErrorData)
//!
//! FUNCTION NAME: NvAPI_DIAG_GetRcErrorData
//!
//!   DESCRIPTION: This API either returns the RC error data or resets the error history
//!                depending on the request type.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \retval ::NVAPI_INVALID_USER_PRIVILEGE       - The caller does not have administrative privileges
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
//! @{

typedef struct
{
    NvU32   version;        //!< structure version
    NvU32   resetRcData :1; //!< [IN] Flag to reset the RC data
    NvU32   reserved :31;
    NvU32   rcErrorCount;   //!< [OUT] Contains the RC count
} NV_RC_ERROR_DATA_V1;

typedef NV_RC_ERROR_DATA_V1             NV_RC_ERROR_DATA;
#define NV_RC_ERROR_DATA_VER1           MAKE_NVAPI_VERSION(NV_RC_ERROR_DATA_V1, 1)
#define NV_RC_ERROR_DATA_VER            NV_RC_ERROR_DATA_VER1

NVAPI_INTERFACE NvAPI_DIAG_GetRcErrorData(NvPhysicalGpuHandle hPhysicalGpu, NV_RC_ERROR_DATA *pRcErrorData);

//! @}



///////////////////////////////////////////////////////////////////////////////
// 
// FUNCTION NAME: NvAPI_GPU_GetMXMBlock
//
//! \fn NvAPI_GPU_GetMXMBlock(NvPhysicalGpuHandle hPhysicalGpu, NV_MXM_BLOCK *pMXMBlock)
//! This function returns the MXM information block.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 100
//!
//! \retval   NVAPI_INVALID_ARGUMENT              hPhysicalGpu or pMXMBlock is NULL.
//! \retval   NVAPI_OK                           *pMXMBlock is now set.
//! \retval   NVAPI_INCOMPATIBLE_STRUCT_VERSION   NV_MXM_BLOCK version not compatible with driver.
//! \retval   NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found.
//! \retval   NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//
///////////////////////////////////////////////////////////////////////////////


//! \ingroup gpu
//! Used in NV_MXM_BLOCK
#define NV_MXM_BLOCK_SIZE (64*1024)


//! \ingroup gpu
//! Used in NvAPI_GPU_GetMXMBlock()
typedef struct
{
    NvU32   version;        //!< Structure version
    NvU32   bufferSize;
    NvU8    buffer[NV_MXM_BLOCK_SIZE];
} NV_MXM_BLOCK;

//! \ingroup gpu
#define NV_MXM_BLOCK_VER MAKE_NVAPI_VERSION(NV_MXM_BLOCK,1)



//! \ingroup gpu
NVAPI_INTERFACE NvAPI_GPU_GetMXMBlock(NvPhysicalGpuHandle hPhysicalGpu, NV_MXM_BLOCK *pMXMBlock);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetVbiosVersionString
//
//!  This function returns the full video BIOS version string in the form of xx.xx.xx.xx.yy where
//!  - xx numbers come from NvAPI_GPU_GetVbiosRevision() and 
//!  - yy comes from NvAPI_GPU_GetVbiosOEMRevision().
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 90
//!
//! \retval   NVAPI_INVALID_ARGUMENT              hPhysicalGpu is NULL.
//! \retval   NVAPI_OK                            szBiosRevision contains version string.
//! \retval   NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found.
//! \retval   NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetVbiosVersionString(NvPhysicalGpuHandle hPhysicalGpu,NvAPI_ShortString szBiosRevision);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetAGPAperture
//
//!  This function returns the AGP aperture in megabytes.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 90
//!
//! \retval   NVAPI_INVALID_ARGUMENT              pSize is NULL.
//! \retval   NVAPI_OK                            Call successful.
//! \retval   NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found.
//! \retval   NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetAGPAperture(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pSize);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetCurrentAGPRate
//
//!  This function returns the current AGP Rate (0 = AGP not present, 1 = 1x, 2 = 2x, etc.).
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 90
//!
//! \retval   NVAPI_INVALID_ARGUMENT              pRate is NULL.
//! \retval   NVAPI_OK                            Call successful.
//! \retval   NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found.
//! \retval   NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetCurrentAGPRate(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pRate);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetCurrentPCIEDownstreamWidth
//
//!  This function returns the number of PCIE lanes being used for the PCIE interface 
//!  downstream from the GPU.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 90
//!
//! \retval  NVAPI_INVALID_ARGUMENT              pWidth is NULL.
//! \retval  NVAPI_OK                            Call successful.
//! \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found.
//! \retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetCurrentPCIEDownstreamWidth(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pWidth);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_SetCurrentPCIEWidth
//
//!   DESCRIPTION: This function sets the number of PCIE lanes being used for the PCIE interface.
//!                The corresponding "Get" for this function is:
//!                pInfo->gpu.currentWidth from NvAPI GPU_GetPCIEInfo()
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 165
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \retval ::NVAPI_INVALID_USER_PRIVILEGE       - The caller does not have administrative privileges
//! \retval ::NVAPI_INVALID_ARGUMENT              - newWidth is not a valid PCIE width value for the system.
//!
//!  \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetCurrentPCIEWidth(NvPhysicalGpuHandle hPhysicalGpu,NvU32 newWidth);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_SetCurrentPCIESpeed
//
//!   DESCRIPTION: Sets the PCIE speed in mega-bits per second for the PCIE interface.
//!                Typical PCIE speeds are 2500 Mbps or 5000 Mbps.
//!                The exact corresponding Get for this function is:
//!                    pInfo->gpu.currentSpeed from NvAPI GPU_GetPCIEInfo()
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 173
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \retval ::NVAPI_INVALID_ARGUMENT             - newSpeed is not a valid PCIE speed value for the system.
//! \retval ::NVAPI_INVALID_USER_PRIVILEGE       - the caller does not have administrative privileges.
//!
//!   \ingroup gpu 
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetCurrentPCIESpeed(NvPhysicalGpuHandle hPhysicalGpu, NvU32 newSpeed);




//! \ingroup gpu
//! Used in NV_PCIE_LINK_INFO_V1 and NV_PCIE_LINK_INFO_V1.  
typedef enum
{
    NV_PCIE_ASPM_STATE_DISABLED = 0,
    NV_PCIE_ASPM_STATE_L0S      = 0x1,
    NV_PCIE_ASPM_STATE_L1       = 0x2,
    NV_PCIE_ASPM_STATE_L0S_L1   = 0x3,
} NV_PCIE_ASPM_STATE;


//! \ingroup gpu
//! Used in NV_PCIE_LINK_INFO_V2.
typedef enum
{
    NV_PCIE_GENERATION_GEN_1 = 1,
    NV_PCIE_GENERATION_GEN_2 = 2,
    NV_PCIE_GENERATION_GEN_3 = 3,
    NV_PCIE_GENERATION_GEN_NONE = -1,
} NV_PCIE_GENERATION;


//! \ingroup gpu
//! Used in NV_PCIE_INFO_V1
typedef struct
{
    NvU32 maxSpeed;               //!< In Mega-bits per second
    NvU32 maxWidth;               //!< In lanes
    NvU32 supportedStates;        //!< See NV_PCIE_ASPM_STATE
    NvU32 currentSpeed;           //!< In Mega-bits per second
    NvU32 currentWidth;           //!< In lanes
    NvU32 currentState;           //!< See NV_PCIE_ASPM_STATE
} NV_PCIE_LINK_INFO_V1;
  
//! \ingroup gpu
//! Used in NvAPI_GPU_GetPCIEInfo().
typedef struct 
{
    NvU32 version;

    NV_PCIE_LINK_INFO_V1 root;
    NV_PCIE_LINK_INFO_V1 gpu;
    NV_PCIE_LINK_INFO_V1 upstream;
    NV_PCIE_LINK_INFO_V1 downstream;
    
} NV_PCIE_INFO_V1;   


//! \ingroup gpu
//! Used in NV_PCIE_INFO_V2
typedef struct
{
    NvU32 maxSpeed;                         //!< In Mega-bits per second
    NV_PCIE_GENERATION maxGeneration;       //!< Implemented PCIe Generation
    NvU32 maxWidth;                         //!< Maximum width, in lanes
    NV_PCIE_ASPM_STATE supportedStates;     //!< See ::NV_PCIE_ASPM_STATE
    NvU32 currentSpeed;                     //!< In Mega-bits per second
    NV_PCIE_GENERATION currentGeneration;   //!< Currently negotiated PCIe Generation
    NvU32 currentWidth;                     //!< Current width, in lanes
    NV_PCIE_ASPM_STATE currentState;        //!< See ::NV_PCIE_ASPM_STATE
} NV_PCIE_LINK_INFO_V2;


//! \ingroup gpu
//! Used in NvAPI_GPU_GetPCIEInfo().
typedef struct
{
    NvU32 version;

    NV_PCIE_LINK_INFO_V2 root;
    NV_PCIE_LINK_INFO_V2 gpu;
    NV_PCIE_LINK_INFO_V2 upstream;  //!< Same as board
    NV_PCIE_LINK_INFO_V2 downstream;
    NV_PCIE_LINK_INFO_V2 board;

} NV_PCIE_INFO_V2;

//! \ingroup gpu
typedef NV_PCIE_LINK_INFO_V2 NV_PCIE_LINK_INFO;

//! \ingroup gpu
typedef NV_PCIE_INFO_V2 NV_PCIE_INFO;

//! \ingroup gpu
#define NV_PCIE_INFO_VER_1  MAKE_NVAPI_VERSION(NV_PCIE_INFO_V1,1)

//! \ingroup gpu
#define NV_PCIE_INFO_VER_2  MAKE_NVAPI_VERSION(NV_PCIE_INFO_V2,2)

//! \ingroup gpu
#define NV_PCIE_INFO_VER    NV_PCIE_INFO_VER_2

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetPCIEInfo
//
//!  This function returns the PCIE bus capabilities and current PCIE state both upstream
//!  and downstream from the GPU.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 105
//!
//! \retval  NVAPI_INVALID_ARGUMENT              pInfo is NULL.
//! \retval  NVAPI_OK                            Call successful.
//! \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found.
//! \retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetPCIEInfo(NvPhysicalGpuHandle hPhysicalGpu,NV_PCIE_INFO *pInfo);




//! \ingroup gpu
typedef enum
{
    NV_PCIE_GPU_CYA_ASPM_DISABLED = 0x0,
    NV_PCIE_GPU_CYA_ASPM_L0S      = 0x1,
    NV_PCIE_GPU_CYA_ASPM_L1       = 0x2,
    NV_PCIE_GPU_CYA_ASPM_L0S_L1   = 0x3
} NV_PCIE_GPU_CYA_ASPM;

//! \ingroup gpu
typedef enum
{
    NV_PCIE_GPU_CYA_ASPM_INFO_VALID_NO = 0x0,
    NV_PCIE_GPU_CYA_ASPM_INFO_VALID_YES = 0x1,
}NV_PCIE_GPU_CYA_ASPM_INFO_VALID;

//! \ingroup gpu
typedef struct
{
    NvU32 version;                        //!< structure version
    NvU32 bIsCyaAspmInfoValid;            //!< boolean specifies whether info is valid or not
    NV_PCIE_GPU_CYA_ASPM cyaAspmState;    //!< see ::NV_PCIE_GPU_CYA_ASPM
} NV_PCIE_GPU_CYA_ASPM_INFO;

//! \ingroup gpu
#define NV_PCIE_GPU_CYA_ASPM_INFO_VER  MAKE_NVAPI_VERSION(NV_PCIE_GPU_CYA_ASPM_INFO,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetCyaAspmInfo
//! \code
//!   DESCRIPTION: Returns info about whether GPU ASPM CYA L0s & L1 is enabled or not
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! RETURN STATUS: NVAPI_API_NOT_INTIALIZED: nvapi not initialized
//!                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//!                NVAPI_INVALID_ARGUMENT: pInfo is NULL
//!                NVAPI_OK: call successful
//!                NVAPI_ERROR: If there is some garbage value is read
//! \endcode
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetCyaAspmInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_PCIE_GPU_CYA_ASPM_INFO *pInfo);


//! \ingroup gpu
//! Used in \ref NV_PCIE_LINK_ERROR_INFO.
typedef enum
{
    NV_PCIE_LINK_ERROR_CORR_ERROR       = 0x00000001,
    NV_PCIE_LINK_ERROR_NON_FATAL_ERROR  = 0x00000002,
    NV_PCIE_LINK_ERROR_FATAL_ERROR      = 0x00000004,
    NV_PCIE_LINK_ERROR_UNSUPP_REQUEST   = 0x00000008,
} NV_PCIE_LINK_ERROR;


//! \ingroup gpu
typedef enum
{
    NV_PCIE_LINK_ERROR_FLAG_MASK_KNOWN_CORR_ERROR_ON_RECOVERY = 0x00000001,
} NV_PCIE_LINK_ERROR_FLAG;




//! \ingroup gpu
//! Used in NvAPI_GPU_ClearPCIELinkErrorInfo().
typedef struct 
{
    NvU32 version;

    NvU32 root;     //!< Returns PCIE link error on ROOT (bitfield of NV_PCIE_LINK_ERROR)
    NvU32 gpu;      //!< Returns PCIE link error on GPU  (bitfield of NV_PCIE_LINK_ERROR)

} NV_PCIE_LINK_ERROR_INFO_V1;


//! \ingroup gpu
//! Used in NvAPI_GPU_ClearPCIELinkErrorInfo().
typedef struct
{
    NvU32 version;

    NvU32 root;     //!< Returns PCIE link error on ROOT (bitfield of NV_PCIE_LINK_ERROR)
    NvU32 gpu;      //!< Returns PCIE link error on GPU  (bitfield of NV_PCIE_LINK_ERROR)

    NvU32 flags;    //!< Special options  (bitfield of NV_PCIE_LINK_ERROR_FLAG)

} NV_PCIE_LINK_ERROR_INFO_V2;

//! \ingroup gpu
typedef NV_PCIE_LINK_ERROR_INFO_V2     NV_PCIE_LINK_ERROR_INFO;

//! \ingroup gpu
//! Macro for constructing the version field of NV_PCIE_LINK_ERROR_INFO_V1
#define NV_PCIE_LINK_ERROR_INFO_VER_1  MAKE_NVAPI_VERSION(NV_PCIE_LINK_ERROR_INFO_V1,1)

//! \ingroup gpu
//! Macro for constructing the version field of NV_PCIE_LINK_ERROR_INFO_V2
#define NV_PCIE_LINK_ERROR_INFO_VER_2  MAKE_NVAPI_VERSION(NV_PCIE_LINK_ERROR_INFO_V2,2)

//! \ingroup gpu
#define NV_PCIE_LINK_ERROR_INFO_VER    NV_PCIE_LINK_ERROR_INFO_VER_2
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_ClearPCIELinkErrorInfo
//
//! \fn NvAPI_GPU_ClearPCIELinkErrorInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_PCIE_LINK_ERROR_INFO *pInfo)
//! DESCRIPTION: This function returns and clears PCIE link errors on both the GPU and the root port.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 165
//!
//! \retval  NVAPI_INVALID_ARGUMENT              pInfo is NULL.
//! \retval  NVAPI_OK                            Call successful.
//! \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found.
//! \retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_ClearPCIELinkErrorInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_PCIE_LINK_ERROR_INFO *pInfo);


//! \ingroup gpu
//! Advanced Error Reporting bitfields (see NvAPI_GPU_ClearPCIELinkAERInfo())
typedef enum
{
    NV_PCIE_LINK_AER_UNCORR_TRAINING_ERR      = 0x00000001,
    NV_PCIE_LINK_AER_UNCORR_DLINK_PROTO_ERR   = 0x00000002,
    NV_PCIE_LINK_AER_UNCORR_POISONED_TLP      = 0x00000004,
    NV_PCIE_LINK_AER_UNCORR_FC_PROTO_ERR      = 0x00000008,
    NV_PCIE_LINK_AER_UNCORR_CPL_TIMEOUT       = 0x00000010,
    NV_PCIE_LINK_AER_UNCORR_CPL_ABORT         = 0x00000020,
    NV_PCIE_LINK_AER_UNCORR_UNEXP_CPL         = 0x00000040,
    NV_PCIE_LINK_AER_UNCORR_RCVR_OVERFLOW     = 0x00000080,
    NV_PCIE_LINK_AER_UNCORR_MALFORMED_TLP     = 0x00000100,
    NV_PCIE_LINK_AER_UNCORR_ECRC_ERROR        = 0x00000200,
    NV_PCIE_LINK_AER_UNCORR_UNSUPPORTED_REQ   = 0x00000400,
    NV_PCIE_LINK_AER_CORR_RCV_ERR             = 0x00010000,
    NV_PCIE_LINK_AER_CORR_BAD_TLP             = 0x00020000,
    NV_PCIE_LINK_AER_CORR_BAD_DLLP            = 0x00040000,
    NV_PCIE_LINK_AER_CORR_RPLY_ROLLOVER       = 0x00080000,
    NV_PCIE_LINK_AER_CORR_RPLY_TIMEOUT        = 0x00100000,
    NV_PCIE_LINK_AER_CORR_ADVISORY_NONFATAL   = 0x00200000,
} NV_PCIE_LINK_AER;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_ClearPCIELinkAERInfo
//
//!   DESCRIPTION: This function returns and clears PCIE link errors using Advanced Error Reporting (AER).
//!                pInfo is a ::NV_PCIE_LINK_AER bitfield.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 177
//!
//!   \retval   NVAPI_INVALID_ARGUMENT              pInfo is NULL
//!   \retval   NVAPI_OK                            Call successful
//!   \retval   NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found
//!   \retval   NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle
//!
//!   \ingroup  gpu 
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_ClearPCIELinkAERInfo(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pInfo);

//! \ingroup gpu
//! Frame buffer calibration lock failure counts - used in NvAPI_GPU_GetFrameBufferCalibrationLockFailures().  
typedef struct
{
    NvU32 version;

    NvU32 driveStrengthRiseCount;             //!< Failure count for drive strength rising
    NvU32 driveStrengthFallCount;             //!< Failure count for drive strength falling
    NvU32 driveStrengthTermCount;             //!< Failure count for drive strength termination
    NvU32 slewStrengthRiseCount;              //!< Failure count for slew strength rising
    NvU32 slewStrengthFallCount;              //!< Failure count for slew strength falling
} NV_GPU_FRAMEBUFFER_CALIBRATION_LOCK_FAILURES_INFO;


//! \ingroup gpu
//! Used in NV_GPU_FRAMEBUFFER_CALIBRATION_LOCK_FAILURES_INFO.
#define NV_GPU_FRAMEBUFFER_CALIBRATION_LOCK_FAILURES_INFO_VER  MAKE_NVAPI_VERSION(NV_GPU_FRAMEBUFFER_CALIBRATION_LOCK_FAILURES_INFO,1)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetFrameBufferCalibrationLockFailures
//
//!   DESCRIPTION: This function returns the number of various types of frame buffer calibration lock failures.
//!
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 177
//!
//!   \retval   NVAPI_INVALID_ARGUMENT              pParams is NULL
//!   \retval   NVAPI_OK                            Call successful
//!   \retval   NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found
//!   \retval   NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle
//!   \retval   NVAPI_NOT_SUPPORTED                 Frame buffer calibration lock failure detection is not supported on this GPU.
//!   \retval   NVAPI_INCOMPATIBLE_STRUCT_VERSION   The version of the INFO struct is not supported
//!
//!   \ingroup  gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetFrameBufferCalibrationLockFailures(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_FRAMEBUFFER_CALIBRATION_LOCK_FAILURES_INFO *pParams);


//! \ingroup gpu
//! Used in NvAPI_GPU_SetDisplayUnderflowMode().
typedef enum _NV_DISPLAY_UNDERFLOW_MODE
{
    NV_DISPLAY_UNDERFLOW_MODE_DISABLED,  //!< Underflow checking is disabled.
    NV_DISPLAY_UNDERFLOW_MODE_REPEAT,    //!< Checking is enabled, but periodically the underflow is cleared automatically.
    NV_DISPLAY_UNDERFLOW_MODE_STICKY,    //!< Underflow bit is sticky until explicitly cleared. 
} NV_DISPLAY_UNDERFLOW_MODE;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_SetDisplayUnderflowMode
//
//! DESCRIPTION:    This function sets the current HW handling on display underflow for testing and debugging.
//!
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 177
//!
//! \retval ::NVAPI_INVALID_HANDLE
//! \retval ::NVAPI_INVALID_ARGUMENT
//! \retval ::NVAPI_OK
//! \retval ::NVAPI_NOT_SUPPORTED
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetDisplayUnderflowMode(NvDisplayHandle hNvDisplay, NV_DISPLAY_UNDERFLOW_MODE mode);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetDisplayUnderflowStatus
//
//! DESCRIPTION:    This function returns the underflow status bit, which is set when the GPU was unable to keep up with display output. 
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 177
//!
//! \param [in]    hNvDisplay           NVIDIA display selection
//! \param [in]    clearUnderflow       If set, the underflow status bit will be cleared after the result is returned.
//! \param [out]   pUnderflowDetected   Display underflow status
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetDisplayUnderflowStatus(NvDisplayHandle hNvDisplay, NvU32 clearUnderflow, NvU32 *pUnderflowDetected);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetPhysicalFrameBufferSize
//
//!   This function returns the physical size of framebuffer in KB.  This does NOT include any
//!   system RAM that may be dedicated for use by the GPU.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 90
//!
//! \retval  NVAPI_INVALID_ARGUMENT              pSize is NULL
//! \retval  NVAPI_OK                            Call successful
//! \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found
//! \retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetPhysicalFrameBufferSize(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pSize);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetVirtualFrameBufferSize
//
//!  This function returns the virtual size of framebuffer in KB.  This includes the physical RAM plus any
//!  system RAM that has been dedicated for use by the GPU.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 90
//!
//! \retval  NVAPI_INVALID_ARGUMENT              pSize is NULL.
//! \retval  NVAPI_OK                            Call successful.
//! \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found.
//! \retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetVirtualFrameBufferSize(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pSize);


 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetBarInfo
//
//! \fn NvAPI_GPU_GetBarInfo(NvPhysicalGpuHandle hPhysicalGpu,NV_GPU_BAR_INFO *pInfo)
//!  DESCRIPTION: This function retrieves information on all GPU base-address-registers.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 105
//!
//! \retval  NVAPI_INVALID_ARGUMENT              pInfo is NULL.
//! \retval  NVAPI_OK                           *pInfo is set (count gives the # of BARs populated in the array).
//! \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found.
//! \retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle.
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
#define NV_GPU_MAX_BAR_COUNT 8

//! Used in NvAPI_GPU_GetBarInfo().
//! \ingroup gpu
typedef struct
{
    NvU32   version;        //!< Structure version
    NvU8    count;
    struct
    {
        NvU32 flags;        // For future use (no flags yet defined)
        NvU32 barSize;
        NvU64 barOffset;
    } barInfo[NV_GPU_MAX_BAR_COUNT];
} NV_GPU_BAR_INFO;

//! \ingroup gpu
#define NV_GPU_BAR_INFO_VER         MAKE_NVAPI_VERSION(NV_GPU_BAR_INFO,1)


//! \ingroup gpu
NVAPI_INTERFACE NvAPI_GPU_GetBarInfo(NvPhysicalGpuHandle hPhysicalGpu,NV_GPU_BAR_INFO *pInfo);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetQuadroStatus
//
//!  This function retrieves the Quadro status for the GPU (1 if Quadro, 0 if GeForce)
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 80
//!
//! \return  NVAPI_ERROR or NVAPI_OK
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetQuadroStatus(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pStatus); 


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetPSFloorSweepStatus
//                NvAPI_GPU_GetVSFloorSweepStatus                  
//
//@{
//!  This function retrieves floorsweeping information for the vertex and pixel
//!  shader units.  Bit field for each, unified architectures will
//!  return the same value for both VS and PS. 
//!
//!  <b> NEVER TO BE EXPOSED!!!!!</b>
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 80
//!
//! \return  NVAPI_ERROR or NVAPI_OK
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
NVAPI_INTERFACE NvAPI_GPU_GetPSFloorSweepStatus(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pReturn);

//! \addtogroup gpu
//! SUPPORTED OS:  Windows XP and higher
//!
NVAPI_INTERFACE NvAPI_GPU_GetVSFloorSweepStatus(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pReturn);
//@}


 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetSerialNumber
//
//!  This function retrieves a unique serial number from the specified GPU
//!  The format may vary from GPU to GPU, but is within 64-bits
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 95
//!
//! \return  NVAPI_ERROR or NVAPI_OK
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetSerialNumber(NvPhysicalGpuHandle hPhysicalGpu, NvU64 *pSerialNum);

#define NVAPI_GPU_MAX_PRODUCT_PART_NUMBER_LENGTH  0x00000014
typedef struct _NV_BOARD_INFO_V2
{
    NvU32 version;                   //!< structure version
    NvU8 BoardNum[16];               //!< Board Serial Number
    NvU8 productPartNumber[NVAPI_GPU_MAX_PRODUCT_PART_NUMBER_LENGTH];
    NvU8 boardRevision[3];
    NvU8 boardType;
}NV_BOARD_INFO_V2;
#define NV_BOARD_INFO_VER2  MAKE_NVAPI_VERSION(NV_BOARD_INFO_V2,2)
typedef NV_BOARD_INFO_V2    NV_BOARD_INFO;
#define NV_BOARD_INFO_VER   NV_BOARD_INFO_VER2



//! \ingroup gpu
typedef struct _NV_BOARD_INFO
{
    NvU32 version;                   //!< structure version
    NvU8 BoardNum[16];               //!< Board Serial Number

}NV_BOARD_INFO_V1;

#define NV_BOARD_INFO_VER1  MAKE_NVAPI_VERSION(NV_BOARD_INFO_V1,1)
#ifndef NV_BOARD_INFO_VER
//! \ingroup gpu
typedef NV_BOARD_INFO_V1    NV_BOARD_INFO;
//! \ingroup gpu
//! \ingroup gpu
#define NV_BOARD_INFO_VER   NV_BOARD_INFO_VER1
#endif

//! SUPPORTED OS:  Windows XP and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetBoardInfo
//
//!   DESCRIPTION: This API Retrieves the Board information (a unique GPU Board Serial Number) stored in the InfoROM.
//!
//! \param [in]      hPhysicalGpu       Physical GPU Handle.
//! \param [in,out]  NV_BOARD_INFO      Board Information.
//!
//! TCC_SUPPORTED
//!
//! \retval ::NVAPI_OK                     completed request
//! \retval ::NVAPI_ERROR                  miscellaneous error occurred
//! \retval ::NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  handle passed is not a physical GPU handle
//! \retval ::NVAPI_API_NOT_INTIALIZED            NVAPI not initialized
//! \retval ::NVAPI_INVALID_POINTER               pBoardInfo is NULL
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION   the version of the INFO struct is not supported
//! 
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetBoardInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_BOARD_INFO *pBoardInfo);





///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_ManufacturingInfo
//
//! \fn NvAPI_GPU_ManufacturingInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_MANUFACTURING_INFO *info)
//! \code
//!   DESCRIPTION: Retrieves a unique serial number from the specified GPU
//!                The format may vary from GPU to GPU, but is within 128-bits
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
typedef struct _NV_MANUFACTURING_INFO_V1
{
    NvU32 version;
    NvU64 ecid[2];
}NV_MANUFACTURING_INFO_V1;

//! \ingroup gpu
typedef NV_MANUFACTURING_INFO_V1    NV_MANUFACTURING_INFO;

//! Macro for constructing the version field of ::NV_MANUFACTURING_INFO
#define NV_MANUFACTURING_INFO_VER1  MAKE_NVAPI_VERSION(NV_MANUFACTURING_INFO_V1,1)
#define NV_MANUFACTURING_INFO_VER   NV_MANUFACTURING_INFO_VER1

//! \ingroup gpu
NVAPI_INTERFACE NvAPI_GPU_ManufacturingInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_MANUFACTURING_INFO *info);





//! \ingroup gpu
//! Used in NvAPI_GPU_GetRamType()
typedef enum
{
    NV_GPU_RAM_TYPE_UNKNOWN = 0,
    NV_GPU_RAM_TYPE_SDRAM   = 1,
    NV_GPU_RAM_TYPE_DDR1    = 2,
    NV_GPU_RAM_TYPE_DDR2    = 3,
    NV_GPU_RAM_TYPE_GDDR2   = 4,
    NV_GPU_RAM_TYPE_GDDR3   = 5,
    NV_GPU_RAM_TYPE_GDDR4   = 6,
    NV_GPU_RAM_TYPE_DDR3    = 7,
    NV_GPU_RAM_TYPE_GDDR5   = 8,
    NV_GPU_RAM_TYPE_LPDDR2  = 9
} NV_GPU_RAM_TYPE;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetRamType
//
//! This function retrieves the type of VRAM associated with this GPU
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 95
//!
//! \return NVAPI_ERROR or NVAPI_OK
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetRamType(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_RAM_TYPE *pRamType);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetRamVendorID
//
//! \fn NvAPI_GPU_GetRamVendorID(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_RAM_VENDOR_ID *pVendorID)
//! \code
//!   DESCRIPTION: Retrieves an ID for the Vendor of VRAM associated with this GPU.
//!                The value comes from the Memory Information Table in the VBIOS
//!                See enum NV_GPU_RAM_VENDOR_ID.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! RETURN STATUS: 
//!    NVAPI_OK: all ok, value returned (may be NV_GPU_RAM_VENDOR_ID_UNKNOWN)
//!    NVAPI_API_NOT_INTIALIZED: NVAPI not initialized
//!    NVAPI_ERROR: miscellaneous error occurred
//!    NVAPI_INVALID_ARGUMENT: pVendorID is NULL
//!    NVAPI_HANDLE_INVALIDATED: handle passed has been invalidated (see user guide)
//!    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: handle passed is not a physical GPU handle
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu 
typedef enum
{
    NV_GPU_RAM_VENDOR_ID_UNKNOWN     = 0,
    NV_GPU_RAM_VENDOR_ID_SAMSUNG     = 1,
    NV_GPU_RAM_VENDOR_ID_QIMONDA     = 2,
    NV_GPU_RAM_VENDOR_ID_ELPIDA      = 3,
    NV_GPU_RAM_VENDOR_ID_ETRON       = 4,
    NV_GPU_RAM_VENDOR_ID_NANYA       = 5,
    NV_GPU_RAM_VENDOR_ID_HYNIX       = 6,
    NV_GPU_RAM_VENDOR_ID_MOSEL       = 7,
    NV_GPU_RAM_VENDOR_ID_WINBOND     = 8,
    NV_GPU_RAM_VENDOR_ID_ESMT        = 9,
    NV_GPU_RAM_VENDOR_ID_MICRON      = 10
} NV_GPU_RAM_VENDOR_ID;

//! \ingroup gpu
NVAPI_INTERFACE NvAPI_GPU_GetRamVendorID(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_RAM_VENDOR_ID *pVendorID);

 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetRamConfigStrap
//
//! This function retrieves a 32-bit value that indicates (indirectly) the type of 
//! RAM configuration associated with the GPU.
//!  
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 95
//!              
//! \return NVAPI_ERROR or NVAPI_OK
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetRamConfigStrap(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pRamConfigStrap);


 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetRamBusWidth
//
//!  This function returns the width of the GPU's RAM memory bus.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 100                 
//!
//!  \return NVAPI_ERROR or NVAPI_OK
//!  \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetRamBusWidth(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pBusWidth);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetFBWidthAndLocation
//
//! \fn NvAPI_GPU_GetFBWidthAndLocation(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pBusWidth, NV_GPU_FB_LOCATION *pFBLocation)
//!   DESCRIPTION: This API returns the width and location of the GPU's RAM memory bus.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 185
//!
//! \return ::NVAPI_ERROR or ::NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////


//! \ingroup gpu
//! Used in NvAPI_GPU_GetFBWidthAndLocation().
typedef enum _NV_GPU_FB_LOCATION
{
    NV_GPU_FB_RAM_LOCATION_UNKNOWN       = 0,
    NV_GPU_FB_RAM_LOCATION_GPU_DEDICATED = 1,
    NV_GPU_FB_RAM_LOCATION_SYS_SHARED    = 2,
    NV_GPU_FB_RAM_LOCATION_SYS_DEDICATED = 3,
} NV_GPU_FB_LOCATION;

//! \ingroup gpu
NVAPI_INTERFACE NvAPI_GPU_GetFBWidthAndLocation(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pBusWidth, NV_GPU_FB_LOCATION *pFBLocation);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetRamBankCount
//
//!  This function returns the number of banks of RAM associated with the GPU.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 100                 
//!
//!  \return NVAPI_ERROR or NVAPI_OK
//!  \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetRamBankCount(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pBankCount);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetArchInfo
//
//! \fn NvAPI_GPU_GetArchInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_ARCH_INFO *pGpuArchInfo)
//!  This function retrieves the architecture, implementation and chip revision for the specified GPU .
//!
//!  <b>INTERNAL USE ONLY!</b>
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED       // This needs to be changed to Tag
//! \since Release: 85
//!
//! \return NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
//! Used in NvAPI_GPU_GetArchInfo()
typedef struct 
{
    NvU32 version;

    NvU32 architecture;
    NvU32 implementation;
    NvU32 revision;
    
} NV_GPU_ARCH_INFO_V1;   

//! NV_GPU_ARCH_INFO() values to identify Architecture level for the GPU. 
typedef enum _NV_GPU_ARCHITECTURE_ID 
{ 

    NV_GPU_ARCHITECTURE_T2X   = 0xE0000020, 
    NV_GPU_ARCHITECTURE_T3X   = 0xE0000030, 
    NV_GPU_ARCHITECTURE_T4X   = 0xE0000040,
    NV_GPU_ARCHITECTURE_T12X  = 0xE0000040,
    NV_GPU_ARCHITECTURE_NV40  = 0x00000040, 
    NV_GPU_ARCHITECTURE_NV50  = 0x00000050, 
    NV_GPU_ARCHITECTURE_G78   = 0x00000060, 
    NV_GPU_ARCHITECTURE_G80   = 0x00000080, 
    NV_GPU_ARCHITECTURE_G90   = 0x00000090, 
    NV_GPU_ARCHITECTURE_GT200 = 0x000000A0, 
    NV_GPU_ARCHITECTURE_GF100 = 0x000000C0, 
    NV_GPU_ARCHITECTURE_GF110 = 0x000000D0, 
    NV_GPU_ARCHITECTURE_GK100 = 0x000000E0, 
    NV_GPU_ARCHITECTURE_GK110 = 0x000000F0, 
    NV_GPU_ARCHITECTURE_GK200 = 0x00000100, 
    NV_GPU_ARCHITECTURE_GM000 = 0x00000110,
    NV_GPU_ARCHITECTURE_GM200 = 0x00000120,

}NV_GPU_ARCHITECTURE_ID; 

//! NV_GPU_ARCH_INFO() values to identify GPU Architecture Implementation. 
typedef enum _NV_GPU_ARCH_IMPLEMENTATION_ID 
{

    NV_GPU_ARCH_IMPLEMENTATION_T20	  = 0x00000000,

    NV_GPU_ARCH_IMPLEMENTATION_T30    = 0x00000000,
    NV_GPU_ARCH_IMPLEMENTATION_T35    = 0x00000005,

    NV_GPU_ARCH_IMPLEMENTATION_T40    = 0x00000000,
    NV_GPU_ARCH_IMPLEMENTATION_T124   = 0x00000000,

    NV_GPU_ARCH_IMPLEMENTATION_NV40   = 0x00000000,	
    NV_GPU_ARCH_IMPLEMENTATION_NV41   = 0x00000001,
    NV_GPU_ARCH_IMPLEMENTATION_NV42   = 0x00000002,
    NV_GPU_ARCH_IMPLEMENTATION_NV43   = 0x00000003,
    NV_GPU_ARCH_IMPLEMENTATION_NV44   = 0x00000004,
    NV_GPU_ARCH_IMPLEMENTATION_NV44A  = 0x0000000A,
    NV_GPU_ARCH_IMPLEMENTATION_NV46   = 0x00000006,
    NV_GPU_ARCH_IMPLEMENTATION_NV47   = 0x00000007,
    NV_GPU_ARCH_IMPLEMENTATION_NV49   = 0x00000009,
    NV_GPU_ARCH_IMPLEMENTATION_NV4B   = 0x0000000B,
    NV_GPU_ARCH_IMPLEMENTATION_NV4C   = 0x0000000C,
    NV_GPU_ARCH_IMPLEMENTATION_NV4E   = 0x0000000E,

    NV_GPU_ARCH_IMPLEMENTATION_NV50   = 0x00000000,

    NV_GPU_ARCH_IMPLEMENTATION_NV63   = 0x00000003,
    NV_GPU_ARCH_IMPLEMENTATION_NV67   = 0x00000007,

    NV_GPU_ARCH_IMPLEMENTATION_G84    = 0x00000004,
    NV_GPU_ARCH_IMPLEMENTATION_G86    = 0x00000006,

    NV_GPU_ARCH_IMPLEMENTATION_G92    = 0x00000002,
    NV_GPU_ARCH_IMPLEMENTATION_G94    = 0x00000004,
    NV_GPU_ARCH_IMPLEMENTATION_G96    = 0x00000006,
    NV_GPU_ARCH_IMPLEMENTATION_G98    = 0x00000008,

    NV_GPU_ARCH_IMPLEMENTATION_GT200  = 0x00000000,
    NV_GPU_ARCH_IMPLEMENTATION_GT212  = 0x00000002,
    NV_GPU_ARCH_IMPLEMENTATION_GT214  = 0x00000004,
    NV_GPU_ARCH_IMPLEMENTATION_GT215  = 0x00000003,
    NV_GPU_ARCH_IMPLEMENTATION_GT216  = 0x00000005,
    NV_GPU_ARCH_IMPLEMENTATION_GT218  = 0x00000008,
    NV_GPU_ARCH_IMPLEMENTATION_MCP77  = 0x0000000A,
    NV_GPU_ARCH_IMPLEMENTATION_GT21C  = 0x0000000B,
    NV_GPU_ARCH_IMPLEMENTATION_MCP79  = 0x0000000C,
    NV_GPU_ARCH_IMPLEMENTATION_GT21A  = 0x0000000D,
    NV_GPU_ARCH_IMPLEMENTATION_MCP89  = 0x0000000F,

    NV_GPU_ARCH_IMPLEMENTATION_GF100  = 0x00000000,
    NV_GPU_ARCH_IMPLEMENTATION_GF100B = 0x00000008,
    NV_GPU_ARCH_IMPLEMENTATION_GF104  = 0x00000004,
    NV_GPU_ARCH_IMPLEMENTATION_GF104B = 0x0000000E,
    NV_GPU_ARCH_IMPLEMENTATION_GF106  = 0x00000003,
    NV_GPU_ARCH_IMPLEMENTATION_GF106B = 0x0000000F,
    NV_GPU_ARCH_IMPLEMENTATION_GF108  = 0x00000001,

    NV_GPU_ARCH_IMPLEMENTATION_GF110  = 0x00000000,
    NV_GPU_ARCH_IMPLEMENTATION_GF112  = 0x00000002,
    NV_GPU_ARCH_IMPLEMENTATION_GF116  = 0x00000006,
    NV_GPU_ARCH_IMPLEMENTATION_GF117  = 0x00000007,
    NV_GPU_ARCH_IMPLEMENTATION_GF118  = 0x00000008,
    NV_GPU_ARCH_IMPLEMENTATION_GF119  = 0x00000009,

    NV_GPU_ARCH_IMPLEMENTATION_GK100  = 0x00000000,
    NV_GPU_ARCH_IMPLEMENTATION_GK104  = 0x00000004,
    NV_GPU_ARCH_IMPLEMENTATION_GK106  = 0x00000006,
    NV_GPU_ARCH_IMPLEMENTATION_GK107  = 0x00000007,
    NV_GPU_ARCH_IMPLEMENTATION_GK20A  = 0x0000000A,
    NV_GPU_ARCH_IMPLEMENTATION_GK110  = 0x00000000,

    NV_GPU_ARCH_IMPLEMENTATION_GK208  = 0x00000008,

    NV_GPU_ARCH_IMPLEMENTATION_GM000  = 0x00000000,	
    NV_GPU_ARCH_IMPLEMENTATION_GM204  = 0x00000004,
    NV_GPU_ARCH_IMPLEMENTATION_GM206  = 0x00000006,
    NV_GPU_ARCH_IMPLEMENTATION_GM20B  = 0x0000000B,
    NV_GPU_ARCH_IMPLEMENTATION_GM20C  = 0x0000000C,
    NV_GPU_ARCH_IMPLEMENTATION_GM20D  = 0x0000000D,
}NV_GPU_ARCH_IMPLEMENTATION_ID;

typedef enum _NV_GPU_CHIP_REVISION
{
    NV_GPU_CHIP_REV_EMULATION_QT		= 0x00000000,	//!< QT chip
    NV_GPU_CHIP_REV_EMULATION_FPGA		= 0x00000001,	//!< FPGA implementation of the chipset
    NV_GPU_CHIP_REV_A01					= 0x00000011,	//!< First silicon chipset revision
    NV_GPU_CHIP_REV_A02					= 0x00000012,	//!< Second Silicon chipset revision
    NV_GPU_CHIP_REV_A03					= 0x00000013,	//!< Third Silicon chipset revision
    NV_GPU_CHIP_REV_UNKNOWN				= 0xffffffff,	//!< Unknown chip revision
}NV_GPU_CHIP_REVISION;

//! \ingroup gpu
//! Used in NvAPI_GPU_GetArchInfo()
typedef struct 
{
    NvU32 version;

    union
    {
        NvU32							architecture;		//!< architecture and architecture_id are the same. The former is NvU32 while the latter is an enum made for readability.
        NV_GPU_ARCHITECTURE_ID			architecture_id;    //!< specifies the architecture level for the GPU.
    };
    union
    {
        NvU32							implementation;		//!< implementation and implementation_id are the same. The former is NvU32 while the latter is an enum made for readability.
        NV_GPU_ARCH_IMPLEMENTATION_ID	implementation_id;  //!< specifies the implementation of the architecture for the GPU.
    };
    union
    {
        NvU32							revision;			//!< revision and revision_id are the same. The former is NvU32 while the latter is an enum made for readability.
        NV_GPU_CHIP_REVISION			revision_id;        //!< specifies the architecture revision of the GPU.
    };
    
} NV_GPU_ARCH_INFO_V2;

//! \ingroup gpu
typedef NV_GPU_ARCH_INFO_V2 NV_GPU_ARCH_INFO; 

//! \ingroup gpu
#define NV_GPU_ARCH_INFO_VER_1  MAKE_NVAPI_VERSION(NV_GPU_ARCH_INFO_V1,1)
#define NV_GPU_ARCH_INFO_VER_2  MAKE_NVAPI_VERSION(NV_GPU_ARCH_INFO_V2,2)
#define NV_GPU_ARCH_INFO_VER    NV_GPU_ARCH_INFO_VER_2


//! \ingroup gpu
NVAPI_INTERFACE NvAPI_GPU_GetArchInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_ARCH_INFO *pGpuArchInfo);


 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetExtendedMinorRevision
//
//!   This function retrieves the extended minor revision for the specified GPU.
//!
//!   <b>INTERNAL USE ONLY!</b>
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 158
//! 
//! \return NVAPI_ERROR or NVAPI_OK \n
//!         NVAPI_NOT_SUPPORTED if the value is not available on this GPU
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetExtendedMinorRevision(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pValue);

 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_GPU_GetSampleType
//
//! \fn NvAPI_GPU_GetSampleType(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_SAMPLE_TYPE *pValue)
//!  This function retrieves the type of sample for the specified GPU.
//!
//! INTERNAL USE ONLY!
//!  
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 158
//!
//! \return NVAPI_ERROR or NVAPI_OK \n
//!         NVAPI_NOT_SUPPORTED if the value is not available on this GPU
//
///////////////////////////////////////////////////////////////////////////////


//! \ingroup gpu
//! Used in NvAPI_GPU_GetSampleType()
typedef enum _NV_GPU_SAMPLE_TYPE
{
    NV_GPU_SAMPLE_NONE       = 0,    //!< The GPU is not a sample, it's a production part.
    NV_GPU_SAMPLE_ES         = 1,    //!< The GPU is an engineering sample. (ES)
    NV_GPU_SAMPLE_QS         = 2,    //!< The GPU is a qualification sample. (QS)
    NV_GPU_SAMPLE_PS         = 3,    //!< The GPU is a production sample. (PS)
    NV_GPU_SAMPLE_QS_PS_PROD = 4,    //!< The GPU is QS, PS, or a production part, but NOT an ES.
} NV_GPU_SAMPLE_TYPE;


 

//! \ingroup gpu
NVAPI_INTERFACE NvAPI_GPU_GetSampleType(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_SAMPLE_TYPE *pValue);


 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetHardwareQualType
//
//! \fn NvAPI_GPU_GetHardwareQualType(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_HW_QUAL_TYPE *pValue)
//!  This function retrieves the hardware qualification type for the specified GPU.
//!  INTERNAL USE ONLY!
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 158
//!
//!  \return NVAPI_ERROR or NVAPI_OK \n
//!          NVAPI_NOT_SUPPORTED if the value is not available on this GPU
//
///////////////////////////////////////////////////////////////////////////////


//! \ingroup gpu
//! Used in NvAPI_GPU_GetHardwareQualType()
typedef enum _NV_GPU_HW_QUAL_TYPE
{
    NV_GPU_HW_QUAL_TYPE_NONE          = 0,    //!< The GPU is not a HW Qual part, there is no HW qual type
    NV_GPU_HW_QUAL_TYPE_NOMINAL       = 1,
    NV_GPU_HW_QUAL_TYPE_SLOW          = 2,
    NV_GPU_HW_QUAL_TYPE_FAST          = 3,
    NV_GPU_HW_QUAL_TYPE_HIGH_LEAKAGE  = 4,
} NV_GPU_HW_QUAL_TYPE;



//!  \ingroup gpu
NVAPI_INTERFACE NvAPI_GPU_GetHardwareQualType(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_HW_QUAL_TYPE *pValue);


///////////////////////////////////////////////////////////////////////////////
//
//  GPU Clock Control
//
//  These APIs allow the user to get and set individual clock domains
//  on a per-GPU basis.
//
///////////////////////////////////////////////////////////////////////////////


//! \ingroup gpuclock
//! @{
#define NVAPI_MAX_GPU_CLOCKS 32
#define NVAPI_MAX_GPU_PUBLIC_CLOCKS     32
#define NVAPI_MAX_GPU_PERF_CLOCKS       32
#define NVAPI_MAX_GPU_PERF_VOLTAGES     16
#define NVAPI_MAX_GPU_PERF_PSTATES      16
//! @}

//! \ingroup gpuclock
//!  NV_GPU_CLOCK_INFO_DOMAIN_ID is obsolete.  Use ::NV_GPU_PUBLIC_CLOCK_ID.
//!  Remove after ::NV_GPU_PUBLIC_CLOCK_ID propagates and all applications are updated.
typedef enum _NV_GPU_CLOCK_INFO_DOMAIN_ID
{
    NVAPI_GPU_CLOCK_INFO_DOMAIN_NV      = 0,
    NVAPI_GPU_CLOCK_INFO_DOMAIN_M       = 4,
    NVAPI_GPU_CLOCK_INFO_DOMAIN_HOTCLK  = 7,
    NVAPI_GPU_CLOCK_INFO_DOMAIN_UNDEFINED = NVAPI_MAX_GPU_CLOCKS,
} NV_GPU_CLOCK_INFO_DOMAIN_ID;


//! \ingroup gpuclock
//!  NV_GPU_PERF_CLOCK_DOMAIN_ID is obsolete.  Use ::NV_GPU_PUBLIC_CLOCK_ID.
//!  Remove after ::NV_GPU_PUBLIC_CLOCK_ID propagates and all applications are updated.
typedef enum _NV_GPU_PERF_CLOCK_DOMAIN_ID
{
    NVAPI_GPU_PERF_CLOCK_DOMAIN_GRAPHICS_CLK  = 0,
    NVAPI_GPU_PERF_CLOCK_DOMAIN_MEMORY_CLK    = 4,   
    NVAPI_GPU_PERF_CLOCK_DOMAIN_PROCESSOR_CLK = 7, 
} NV_GPU_PERF_CLOCK_DOMAIN_ID;


//! \ingroup gpuclock
typedef enum _NV_GPU_PUBLIC_CLOCK_ID
{
    NVAPI_GPU_PUBLIC_CLOCK_GRAPHICS  = 0,
    NVAPI_GPU_PUBLIC_CLOCK_MEMORY    = 4,
    NVAPI_GPU_PUBLIC_CLOCK_PROCESSOR = 7,
    NVAPI_GPU_PUBLIC_CLOCK_VIDEO     = 8,
    NVAPI_GPU_PUBLIC_CLOCK_UNDEFINED = NVAPI_MAX_GPU_PUBLIC_CLOCKS,
} NV_GPU_PUBLIC_CLOCK_ID;


//! \ingroup gpuclock
typedef enum _NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID
{
    NVAPI_GPU_PERF_VOLTAGE_INFO_DOMAIN_CORE      = 0,
    NVAPI_GPU_PERF_VOLTAGE_INFO_DOMAIN_UNDEFINED = NVAPI_MAX_GPU_PERF_VOLTAGES,
} NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID;




//! \ingroup gpuclock
//! Used in #NV_GPU_CLOCK_INFO to identify the relevant domain. 
typedef enum _NV_GPU_CLOCK_DOMAIN_ID
{
    NVAPI_GPU_CLOCK_DOMAIN_NV      = 0,
    NVAPI_GPU_CLOCK_DOMAIN_G       = 1,
    NVAPI_GPU_CLOCK_DOMAIN_S       = 2,
    NVAPI_GPU_CLOCK_DOMAIN_R       = 3,
    NVAPI_GPU_CLOCK_DOMAIN_M       = 4,
    NVAPI_GPU_CLOCK_DOMAIN_HOST    = 5,
    NVAPI_GPU_CLOCK_DOMAIN_DISP    = 6,
    NVAPI_GPU_CLOCK_DOMAIN_HOTCLK  = 7,
    NVAPI_GPU_CLOCK_DOMAIN_PCLK0   = 8,
    NVAPI_GPU_CLOCK_DOMAIN_PCLK1   = 9,
    NVAPI_GPU_CLOCK_DOMAIN_BYPCLK  = 10,
    NVAPI_GPU_CLOCK_DOMAIN_XCLK    = 11,
    NVAPI_GPU_CLOCK_DOMAIN_VPV     = 12,
    NVAPI_GPU_CLOCK_DOMAIN_VPS     = 13,
    NVAPI_GPU_CLOCK_DOMAIN_GPUCACHECLK     = 14,
    NVAPI_GPU_CLOCK_DOMAIN_GPC2    = 15,
    NVAPI_GPU_CLOCK_DOMAIN_XBAR2   = 16,
    NVAPI_GPU_CLOCK_DOMAIN_SYS2    = 17,
    NVAPI_GPU_CLOCK_DOMAIN_HUB2    = 18,
    NVAPI_GPU_CLOCK_DOMAIN_LEG     = 19,
    NVAPI_GPU_CLOCK_DOMAIN_PWR     = 20,
    NVAPI_GPU_CLOCK_DOMAIN_MSD     = 21,
    NVAPI_GPU_CLOCK_DOMAIN_UTILS   = 22,
    NVAPI_GPU_CLOCK_DOMAIN_COLD_NV     = 23,
    NVAPI_GPU_CLOCK_DOMAIN_COLD_HOTCLK = 24,
    NVAPI_GPU_CLOCK_DOMAIN_LTC2    = 25,
    NVAPI_GPU_CLOCK_DOMAIN_2D      = 26,    //! 2D graphics clock domain
    NVAPI_GPU_CLOCK_DOMAIN_3D      = 27,    //! 3D graphics clock domain
    NVAPI_GPU_CLOCK_DOMAIN_HOST1X    = 28,  //! host1x clock domain
    NVAPI_GPU_CLOCK_DOMAIN_DISP0     = 29,  //! display clock domain for display controller 0
    NVAPI_GPU_CLOCK_DOMAIN_DISP1     = 30,  //! display clock domain for display controller 1
    NVAPI_GPU_CLOCK_DOMAIN_UNDEFINED = NVAPI_MAX_GPU_CLOCKS,
} NV_GPU_CLOCK_DOMAIN_ID;


//! \ingroup gpuclock
typedef enum _NV_GPU_PERF_VOLTAGE_DOMAIN_ID
{
    NVAPI_GPU_PERF_VOLTAGE_DOMAIN_CORE         = 0,
    NVAPI_GPU_PERF_VOLTAGE_DOMAIN_FB           = 1,
    NVAPI_GPU_PERF_VOLTAGE_DOMAIN_COLD_CORE    = 2,
    NVAPI_GPU_PERF_VOLTAGE_DOMAIN_CORE_NOMINAL = 3,    
    NVAPI_GPU_PERF_VOLTAGE_DOMAIN_UNDEFINED = NVAPI_MAX_GPU_PERF_VOLTAGES,

} NV_GPU_PERF_VOLTAGE_DOMAIN_ID;




//! \ingroup gpuclock
//! Used in NV_GPU_CLOCK_INFO.
typedef enum
{
    NV_GPU_CLOCK_PSTATE_USAGE_FIXED     = 0x0,
    NV_GPU_CLOCK_PSTATE_USAGE_PSTATE    = 0x1,
    NV_GPU_CLOCK_PSTATE_USAGE_DECOUPLED = 0x2,
    NV_GPU_CLOCK_PSTATE_USAGE_RATIO     = 0x3,
} NV_GPU_CLOCK_INFO_DOMAIN_PSTATE_USAGE;

//! \ingroup gpuclock
//! Used in NV_GPU_CLOCK_INFO.
typedef struct
{
        NvU32                  frequency;       //!< Clock frequency (kHz)
        
        NvU32                  bIsPresent:1;    //!< Set if this domain is present on this GPU (for NvAPI_GPU_GetAllClocks() only).
        NvU32                  bDrivingDDR:1;   //!< Set if clock is driving DDR memory (for NvAPI_GPU_GetAllClocks() only)).
        NvU32                  bSetClock:1;     //!< If set during the NvAPI_GPU_SetClocks() call, this domain will be set.
        NvU32                  pstateUsage:2;   //!< One of NV_GPU_CLOCK_INFO_DOMAIN_PSTATE_USAGE (for NvAPI_GPU_GetAllClocks() only).
        NvU32                  reserved:27;     //!< These bits are reserved for future use.
} NV_GPU_CLOCK_INFO_DOMAIN;

//! \ingroup gpuclock
//! Used in NvAPI_GPU_GetAllClocks() and NvAPI_GPU_SetClocks()
typedef struct 
{
    NvU32                  version;         //!<  Structure version
    NV_GPU_CLOCK_INFO_DOMAIN domain[NVAPI_MAX_GPU_CLOCKS];
} NV_GPU_CLOCK_INFO_V1;

//! \ingroup gpuclock
typedef struct 
{
    NvU32                  version;                     //!< Structure version
    NV_GPU_CLOCK_INFO_DOMAIN domain[NVAPI_MAX_GPU_CLOCKS];
//! below struct extendedDomain is not supported on ARM(Tegra) so ignore those variables
    struct 
    {
        NvU32                   effectiveFrequency;     //!< == domain[i].frequency unless there is some slowdown (i.e. thermal)
        NV_GPU_CLOCK_DOMAIN_ID  ratioDomain;
        NvU32                   ratio;
        NvU32                   reserved[4];            //!< Reserved for binary compatibility in future API extensions.
    } extendedDomain[NVAPI_MAX_GPU_CLOCKS];             //!< Used in NvAPI_GPU_GetAllClocks() to retrieve thermal slowdown frequency values.
} NV_GPU_CLOCK_INFO_V2;


//! \ingroup gpuclock
typedef NV_GPU_CLOCK_INFO_V2 NV_GPU_CLOCK_INFO;


//! \addtogroup gpuclock
//! @{
#define NV_GPU_CLOCK_INFO_VER_1  MAKE_NVAPI_VERSION(NV_GPU_CLOCK_INFO_V1,1)
#define NV_GPU_CLOCK_INFO_VER_2  MAKE_NVAPI_VERSION(NV_GPU_CLOCK_INFO_V2,2)
#define NV_GPU_CLOCK_INFO_VER    NV_GPU_CLOCK_INFO_VER_2
//! @}

 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetAllClocks
//
//!   This function retrieves the NV_GPU_CLOCK_INFO structure for the specified physical GPU.
//!
//!   For each clock domain:
//!      - bIsPresent is set for each domain that is present on the GPU
//!      - bDrivingDDR is set if that clock is driving dual-data-rate RAM
//!        frequency is the rate (in kHz) of the clock at the time of the call
//!
//!   Each domain's info is indexed in the array.  For example:
//!   clkInfo.domain[NVAPI_GPU_CLOCK_DOMAIN_M] holds the info for the 'M' domain.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 85
//!
//! \retval   NVAPI_OK                            Completed request
//! \retval   NVAPI_ERROR                         Miscellaneous error occurred.
//! \retval   NVAPI_INVALID_ARGUMENT              pClkInfo is NULL.
//! \retval   NVAPI_HANDLE_INVALIDATED            Handle passed has been invalidated (see user guide).
//! \retval   NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle.
//! \retval   NVAPI_INCOMPATIBLE_STRUCT_VERSION   The version of the INFO struct is not supported.
//! \ingroup gpuclock
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetAllClocks(NvPhysicalGpuHandle hPhysicalGPU, NV_GPU_CLOCK_INFO *pClkInfo);


//! \ingroup gpuclock
//! Used in NvAPI_GPU_GetAllClockFrequencies()
typedef struct 
{
    NvU32   version;    //!< Structure version
    NvU32   reserved;   //!< These bits are reserved for future use.
    struct
    {
        NvU32 bIsPresent:1;         //!< Set if this domain is present on this GPU
        NvU32 reserved:31;          //!< These bits are reserved for future use.
        NvU32 frequency;            //!< Clock frequency (kHz)
    }domain[NVAPI_MAX_GPU_PUBLIC_CLOCKS];
} NV_GPU_CLOCK_FREQUENCIES_V1;

//! \ingroup gpuclock
//! Used in NvAPI_GPU_GetAllClockFrequencies()
typedef enum
{
    NV_GPU_CLOCK_FREQUENCIES_CURRENT_FREQ =   0,
    NV_GPU_CLOCK_FREQUENCIES_BASE_CLOCK   =   1,
    NV_GPU_CLOCK_FREQUENCIES_BOOST_CLOCK  =   2,
    NV_GPU_CLOCK_FREQUENCIES_CLOCK_TYPE_NUM = 3
}   NV_GPU_CLOCK_FREQUENCIES_CLOCK_TYPE;

//! \ingroup gpuclock
//! Used in NvAPI_GPU_GetAllClockFrequencies()
typedef struct 
{
    NvU32   version;        //!< Structure version
    NvU32   ClockType:2;    //!< One of NV_GPU_CLOCK_FREQUENCIES_CLOCK_TYPE. Used to specify the type of clock to be returned.
    NvU32   reserved:22;    //!< These bits are reserved for future use. Must be set to 0.
    NvU32   reserved1:8;    //!< These bits are reserved.
    struct
    {
        NvU32 bIsPresent:1;         //!< Set if this domain is present on this GPU
        NvU32 reserved:31;          //!< These bits are reserved for future use.
        NvU32 frequency;            //!< Clock frequency (kHz)
    }domain[NVAPI_MAX_GPU_PUBLIC_CLOCKS];
} NV_GPU_CLOCK_FREQUENCIES_V2;

//! \ingroup gpuclock
//! Used in NvAPI_GPU_GetAllClockFrequencies()
typedef NV_GPU_CLOCK_FREQUENCIES_V2 NV_GPU_CLOCK_FREQUENCIES;

//! \addtogroup gpuclock
//! @{
#define NV_GPU_CLOCK_FREQUENCIES_VER_1    MAKE_NVAPI_VERSION(NV_GPU_CLOCK_FREQUENCIES_V1,1)
#define NV_GPU_CLOCK_FREQUENCIES_VER_2    MAKE_NVAPI_VERSION(NV_GPU_CLOCK_FREQUENCIES_V2,2)
#define NV_GPU_CLOCK_FREQUENCIES_VER_3    MAKE_NVAPI_VERSION(NV_GPU_CLOCK_FREQUENCIES_V2,3)
#define NV_GPU_CLOCK_FREQUENCIES_VER	  NV_GPU_CLOCK_FREQUENCIES_VER_3
//! @}
 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetAllClockFrequencies
//
//!   This function retrieves the NV_GPU_CLOCK_FREQUENCIES structure for the specified physical GPU.
//!
//!   For each clock domain:
//!      - bIsPresent is set for each domain that is present on the GPU
//!      - frequency is the domain's clock freq in kHz
//!
//!   Each domain's info is indexed in the array.  For example:
//!   clkFreqs.domain[NVAPI_GPU_PUBLIC_CLOCK_MEMORY] holds the info for the MEMORY domain.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 295
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. 
//!          If there are return error codes with specific meaning for this API, 
//!          they are listed below.
//! \retval  NVAPI_INVALID_ARGUMENT     pClkFreqs is NULL.
//! \ingroup gpuclock
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetAllClockFrequencies(__in NvPhysicalGpuHandle hPhysicalGPU, __inout NV_GPU_CLOCK_FREQUENCIES *pClkFreqs);


//! \ingroup gpuclock
//! Used in NV_GPU_PUBLIC_CLOCK_INFO.
typedef enum
{
    NV_GPU_PUBLIC_CLOCK_DOMAIN_PROGRAMMABLE     = 0x00000001,
} NV_GPU_PUBLIC_CLOCK_INFO_DOMAINS_FLAGS;
//! \ingroup gpuclock
//! Used in NvAPI_GPU_GetPublicClockInfo().
typedef struct
{
    NvU32   version;
    NvU32   flags;
    struct
    {
        NV_GPU_CLOCK_DOMAIN_ID clkId;
        NvU32 flags;                        //!< Mask of ::NV_GPU_PUBLIC_CLOCK_INFO_DOMAINS_FLAGS
        NvU32 frequencyAdjustPercent;
    }domains[NVAPI_MAX_GPU_PUBLIC_CLOCKS];
   
}NV_GPU_PUBLIC_CLOCK_INFO;
//! \ingroup gpuclock
//! Macro for constructing the version field of NV_GPU_PUBLIC_CLOCK_INFO
#define NV_GPU_PUBLIC_CLOCK_INFO_VER1  MAKE_NVAPI_VERSION(NV_GPU_PUBLIC_CLOCK_INFO,1)
#define NV_GPU_PUBLIC_CLOCK_INFO_VER2  MAKE_NVAPI_VERSION(NV_GPU_PUBLIC_CLOCK_INFO,2)
#define NV_GPU_PUBLIC_CLOCK_INFO_VER   NV_GPU_PUBLIC_CLOCK_INFO_VER2
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetPublicClockInfo
//
//!   DESCRIPTION: This API retrieves information on the clock domains that are
//!                exposed to the public.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! \param [in]   hPhysicalGPU       GPU selection
//! \param [out]  pPublicClockInfo   Retrieved information concerning
//!               all clock domains exposed to the public, detailed as follows:
//!                    - flags is reserved for future use.
//!                    - domains contains each domain's info indexed in the 
//!                    array. For example: publicClockInfo.domains[NVAPI_GPU
//!                    _PUBLIC_CLOCK_MEMORY] holds the information for the 
//!                    memory clock domain.
//!                    - clkId is the internal clock domain that the public 
//!                      domain is mapped to.
//!                    - flags
//!                      bit 0 indicates the programmability of the domain.
//!                    - frequencyAdjustPercent is the frequency ratio between
//!                      the public and internal clock domain in percentage.
//!                      For example: if clkId = NVAPI_GPU_CLOCK_DOMAIN_GPC2 
//!                     and frequencyAdjustPercent = 50 in domains[NVAPI_GPU
//!                      _PUBLIC_CLOCK_GRAPHICS], it means that the graphics
//!                      clock frequency = the GPC2 clock frequency x 50%.
//!
//! \retval ::NVAPI_OK 
//! \retval ::NVAPI_ERROR 
//! \retval ::NVAPI_INVALID_ARGUMENT              pPublicClockInfo is NULL
//! \retval ::NVAPI_HANDLE_INVALIDATED 
//! \retval ::NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE 
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION   the version of the NV_GPU_PUBLIC_CLOCK_INFO struct is not supported
//!
//! \ingroup gpuclock
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetPublicClockInfo(NvPhysicalGpuHandle hPhysicalGPU, NV_GPU_PUBLIC_CLOCK_INFO *pPublicClockInfo);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_SetClocks
//
//!    This function allows the caller to set one or more GPU clock domains with one call.
//!    Depending on the architecture, some domains MUST be changed in conjunction with other domains.
//!    The caller must be familiar with the requirements and take the appropriate action.
//!
//!    If bSetDeferred is set, the clocks will be changed with the next modeset event.
//!    Otherwise, the clocks will be set at the time of the call.
//!      
//!    Only domains in the array with bSetClock set will be affected. Due to PLL
//!    programming constraints, the actual value set may vary slightly from the 
//!    requested frequency.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 85
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \retval ::NVAPI_INVALID_USER_PRIVILEGE       - The caller does not have administrative privileges
//! \ingroup gpuclock
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetClocks(NvPhysicalGpuHandle hPhysicalGPU, NvU32 bSetDeferred, NV_GPU_CLOCK_INFO *pClkInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_SetClocksShmoo
//
//!   DESCRIPTION: This allows the caller to shmoo all clocks that share the same PLL as the given clock. 
//!                The caller must supply the target clocks and target PLL frequency.
//!
//!                This API is designed to support shmooing derivative clocks that share the same PLL.
//!                All other clocks will not be supported by this API.
//!
//!                Due to PLL programming constraints, the actual value set 
//!                may vary slightly from the requested frequency.
//!
//!                Fermi only.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \retval ::NVAPI_INVALID_USER_PRIVILEGE  - The caller does not have administrative privileges
//! \retval ::NVAPI_NOT_SUPPORTED           - Shmooing is not supported on this GPU for the given clock.
//!
//! \ingroup gpuclock
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetClocksShmoo(NvPhysicalGpuHandle hPhysicalGPU, NV_GPU_CLOCK_INFO *pClkInfo);

//! \ingroup gpupower
//! @{

typedef struct
{
    NvU32 tickCnt;
    NvU64 timens;
} NV_GPU_CLOCK_COUNTER_SAMPLE;

typedef struct
{
    NvU32 version;

    NV_GPU_CLOCK_DOMAIN_ID      clkDomain;
    NV_GPU_CLOCK_COUNTER_SAMPLE sample;
    NvU32 freqkHz;
} NV_GPU_CLOCK_COUNTER_MEASURE_AVG_FREQ_PARAMS_V1;

#define NV_GPU_CLOCK_COUNTER_MEASURE_AVG_FREQ_PARAMS_VER_1   MAKE_NVAPI_VERSION(NV_GPU_CLOCK_COUNTER_MEASURE_AVG_FREQ_PARAMS_V1,1)
#define NV_GPU_CLOCK_COUNTER_MEASURE_AVG_FREQ_PARAMS_VER     NV_GPU_CLOCK_COUNTER_MEASURE_AVG_FREQ_PARAMS_VER_1

#define NV_GPU_CLOCK_COUNTER_MEASURE_AVG_FREQ_PARAMS NV_GPU_CLOCK_COUNTER_MEASURE_AVG_FREQ_PARAMS_V1

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_ClockCounterMeasureAvgFreq
//
//! DESCRIPTION:
//!
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version:  337.41
//!
//! \param [in]      hPhysicalGPU   GPU selection
//! \param [in/out]  pSample        Structure containing the counter counter
//!                                 sample and average effective frequency.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gpuclock
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_ClockCounterMeasureAvgFreq(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_CLOCK_COUNTER_MEASURE_AVG_FREQ_PARAMS *pMeasure);



//! \addtogroup gpuclock
//! @{
//! @name Performance flags for the HybridMode APIs.
// @{
#define NV_PERF_CLOCK_GPU_HYBRID_MODE_SUPPORTED       0x00000001 //!< Hybrid mode available on the selected GPU
#define NV_PERF_CLOCK_GPU_HYBRID_MODE_ENABLE          0x00000002 //!< Enable Hybrid Mode
#define NV_PERF_CLOCK_GPU_HYBRID_MODE_DISABLE         0x00000004 //!< Disable Hybrid Mode
#define NV_PERF_CLOCK_GPU_HYBRID_MODE_ACTIVE          0x00000008 //!< Hybrid Mode enabled and active with higher voltage
#define NV_PERF_CLOCK_GPU_HYBRID_MODE_INACTIVE        0x00000010 //!< Hybrid Mode enabled but inactive with no gpu demand or default clocks.
// @}
//! @}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_SetPerfHybridMode
//
//!  This function enables or disables the performance overclocking Hybrid Mode. 
//!  On NVAPI_OK the perf tables should be re-queried with NvAPI_GPU_GetPerfClocks.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 90
//!
//! \param [in]      hPhysicalGPU   GPU selection.
//! \param [in]      gpuPerfFlags   Hybrid mode selection set to NV_PERF_CLOCK_GPU_HYBRID_MODE_ENABLE or DISABLE.
//!
//! \retval   NVAPI_OK                             Completed request
//! \retval   NVAPI_ERROR                          Miscellaneous error occurred.
//! \retval   NVAPI_HANDLE_INVALIDATED             Handle passed has been invalidated (see user guide).
//! \retval   NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE   Handle passed is not a physical GPU handle.
//! \retval   NVAPI_NOT_SUPPORTED                  HybridMode is not supported on this GPU.
//! \ingroup  gpuclock
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetPerfHybridMode(NvPhysicalGpuHandle hPhysicalGpu, NvU32 gpuPerfFlags);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetPerfHybridMode
//
//!  This function queries the performance overclocking Hybrid Mode status.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 90
//!
//! \param [in]      hPhysicalGPU   GPU selection.
//! \param [out]     pgpuPerfFlags  Hybrid mode status. One or more flags from NV_PERF_CLOCK_GPU_HYBRID_MODE.
//!
//! \retval   NVAPI_OK                             Completed request
//! \retval   NVAPI_ERROR                          Miscellaneous error occurred.
//! \retval   NVAPI_HANDLE_INVALIDATED             Handle passed has been invalidated (see user guide).
//! \retval   NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE   Handle passed is not a physical GPU handle.
//! \retval   NVAPI_INVALID_ARGUMENT               pGpuPerfFlags is NULL.
//! \retval   NVAPI_NOT_SUPPORTED                  HybridMode is not supported on this GPU.
//! \ingroup  gpuclock
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetPerfHybridMode(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pGpuPerfFlags);

 

//Performance table overclocking 


//! \addtogroup gpuclock 
//! @{

#define NVAPI_MAX_PERF_CLOCK_LEVELS     12
#define NVAPI_TARGET_ALL_PERF_LEVELS    0xffffffff

#define NV_PERF_CLOCK_LEVEL_STATE_DEFAULT                   0x00000000 //!< Level is in its default state
#define NV_PERF_CLOCK_LEVEL_STATE_OVERCLOCKED               0x00000001 //!< Level is overclocked
#define NV_PERF_CLOCK_LEVEL_STATE_DESKTOP                   0x00000002 //!< 2D Desktop perf level
#define NV_PERF_CLOCK_LEVEL_STATE_PERFORMANCE               0x00000004 //!< 3D applications perf level
#define NV_PERF_CLOCK_LEVEL_STATE_TEST                      0x00000008 //!< Test the new clocks for this level. Does not apply.
#define NV_PERF_CLOCK_LEVEL_STATE_TEST_SUCCESS              0x00000010 //!< Test result
      
#define NV_PERF_CLOCK_GPU_STATE_DEFAULT                     0x00000000 //!< Default state
#define NV_PERF_CLOCK_GPU_STATE_DYNAMIC_SUPPORTED           0x00000001 //!< GPU supports dynamic performance level transitions
#define NV_PERF_CLOCK_GPU_STATE_DESKTOP                     0x00000002 //!< GPU in desktop level
#define NV_PERF_CLOCK_GPU_STATE_PERFORMANCE                 0x00000004 //!< GPU in performance level
#define NV_PERF_CLOCK_GPU_STATE_ACTIVE_CLOCKING_SUPPORTED   0x00000008 //!< Active clocking supported
#define NV_PERF_CLOCK_GPU_STATE_ACTIVE_CLOCKING_ENABLE      0x00000010 //!< Enable active clocking
#define NV_PERF_CLOCK_GPU_STATE_ACTIVE_CLOCKING_DISABLE     0x00000020 //!< Disable active clocking
#define NV_PERF_CLOCK_GPU_STATE_MEMCLK_CONTROL_DISABLED     0x00000040 //!< Memory clock control disabled
#define NV_PERF_CLOCK_GPU_STATE_GFXCLK_CONTROL_DISABLED     0x00000080 //!< Core clock control disabled
#define NV_PERF_CLOCK_GPU_STATE_SET_DEFERRED                0x00000100 //!< No immediate perf transitions. Deferred until perf triggers kick in.
#define NV_PERF_CLOCK_GPU_STATE_TESTING_CLOCKS_SUPPORTED    0x00000200 //!< Testing clocks supported
//! @}


//! \ingroup  gpuclock 
//! Used in NvAPI_GPU_GetPerfClocks() and NvAPI_GPU_GetPerfClocks() 
typedef struct
{
    NvU32   version;                                //!< IN perf clock table version
    NvU32   levelCount;                             //!< number of the performance levels. count increases everytime a level is overclocked
    NvU32   gpuPerflevel;                           //!< OUT the current perf level. This is a dynamic level which can possibly change on every call
    NvU32   domainCount;                            //!< IN/OUT number of domains
    NvU32   gpuPerfFlags;                           //!< IN/OUT gpu flags - one of the flags defined in NV_PERF_CLOCK_GPU_STATE
    struct
    {
        NvU32   level;                              //!< IN/OUT performance level indicator, range 0 to levelCount - 1.
        NvU32   flags;                              //!< IN/OUT per level flags - one of more flags defined in NV_PERF_CLOCK_LEVEL_STATE 
        struct
        {
            NV_GPU_PUBLIC_CLOCK_ID      domainId;       //!< IN/OUT current domain indicator - one of the ids from NV_GPU_PUBLIC_CLOCK_ID
            NvU32                       domainFlags;    //!< reserved unused domain flags 
            NvU32                       currentFreq;    //!< IN/OUT current clock kHz
            NvU32                       defaultFreq;    //!< default clock kHz
            NvU32                       minFreq;        //!< min kHz
            NvU32                       maxFreq;        //!< max kHz
            NvU32                       bSetClock:1;    //!< IN if set during NvAPI_GPU_SetPerfClocks call, this domain currentFreq will be applied
        } domain[NVAPI_MAX_GPU_PERF_CLOCKS];
    } perfLevel[NVAPI_MAX_PERF_CLOCK_LEVELS];
    
} NV_GPU_PERF_CLOCK_TABLE;

//! \ingroup  gpuclock 
#define NV_GPU_PERF_CLOCK_TABLE_VER1  MAKE_NVAPI_VERSION(NV_GPU_PERF_CLOCK_TABLE,1)
#define NV_GPU_PERF_CLOCK_TABLE_VER2  MAKE_NVAPI_VERSION(NV_GPU_PERF_CLOCK_TABLE,2)
#define NV_GPU_PERF_CLOCK_TABLE_VER   NV_GPU_PERF_CLOCK_TABLE_VER2

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetPerfClocks
//
//!  This function retrieves the performance clock table information for one or all the supported levels.
//!                  NOTE: This call will return 0 for system memory.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 85
//!
//! \param [in]     hPhysicalGPU    GPU selection.
//! \param [in]     level           Specific level selection. Zero for all levels. Number of levels increases with overclocking of the levels.
//! \param [out]    pPerfClkTable   Table of performance levels retrieved.
//!
//! \retval   NVAPI_OK                             Completed request
//! \retval   NVAPI_ERROR                          Miscellaneous error occurred
//! \retval   NVAPI_HANDLE_INVALIDATED             Handle passed has been invalidated (see user guide)
//! \retval   NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE   Handle passed is not a physical GPU handle
//! \retval   NVAPI_INCOMPATIBLE_STRUCT_VERSION    The version of the PERF_CLOCK_TABLE struct is not supported
//! \ingroup  gpuclock 
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetPerfClocks(NvPhysicalGpuHandle hPhysicalGpu, NvU32 level, NV_GPU_PERF_CLOCK_TABLE *pPerfClkTable);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_SetPerfClocks
//
//!  This function sets the Overclock to a specific level in the performance table or overclocks all levels with bSetClock set.
//! \note           The clocks represented by NV_GPU_PUBLIC_CLOCK_ID are interlocked on some GPU families. 
//!                 The API will fail to set the clocks if the interlocking ratios are violated.
//!                 For the Fermi family : PROCESSOR_CLK = 2 x GRAPHICS_CLK
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 85
//!
//! \param [in]      hPhysicalGPU    GPU selection.
//! \param [in]      level           Specific level selection. Zero for all levels. Number of levels increases with overclocking of the levels.
//! \param [in]      pPerfClkTable   Table of performance levels to set.
//!                                  Any other than DEFAULT for GPU and Level flags - gpuPerfFlags and level flags gets applied.
//!                                  If bSetClock is set, currentFreq gets applied.
//!                                  Overclocking DOMAIN_NV requires simulteneous overclocking of DOMAIN_M, else overclocking will fail.
//!
//!  \retval   NVAPI_OK                            Completed request
//!  \retval   NVAPI_ERROR                         Miscellaneous error occurred
//!  \retval   NVAPI_HANDLE_INVALIDATED            Handle passed has been invalidated (see user guide)
//!  \retval   NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle
//!  \retval   NVAPI_INCOMPATIBLE_STRUCT_VERSION   The version of the PERF_CLOCK_TABLE struct is not supported
//!  \retval   NVAPI_TESTING_CLOCKS_NOT_SUPPORTED  Testing clocks not supported
//!
//!  \ingroup  gpuclock
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetPerfClocks(NvPhysicalGpuHandle hPhysicalGpu, NvU32 level, NV_GPU_PERF_CLOCK_TABLE *pPerfClkTable);

 
///////////////////////////////////////////////////////////////////////////////////
//  GPU Cooler Controls
//  Provides ability to Get and Set the fan level or equivalent cooler levels for various target devices associated with the GPU


//! \addtogroup gpucooler
//! @{

#define NVAPI_MAX_COOLERS_PER_GPU_VER1  3
#define NVAPI_MAX_COOLERS_PER_GPU_VER2  20
#define NVAPI_MAX_COOLERS_PER_GPU_VER3  NVAPI_MAX_COOLERS_PER_GPU_VER2
#define NVAPI_MAX_COOLERS_PER_GPU_VER4  NVAPI_MAX_COOLERS_PER_GPU_VER2

#define NVAPI_MAX_COOLERS_PER_GPU       NVAPI_MAX_COOLERS_PER_GPU_VER3
#define NVAPI_MIN_COOLER_LEVEL      0
#define NVAPI_MAX_COOLER_LEVEL      100
#define NVAPI_MAX_COOLER_LEVELS 24

//! Used in NV_GPU_GETCOOLER_SETTINGS_V1 and NV_GPU_GETCOOLER_SETTINGS_V2
typedef enum 
{
    NVAPI_COOLER_TYPE_NONE = 0,
    NVAPI_COOLER_TYPE_FAN,
    NVAPI_COOLER_TYPE_WATER,
    NVAPI_COOLER_TYPE_LIQUID_NO2,
} NV_COOLER_TYPE;


//! Used in NV_GPU_GETCOOLER_SETTINGS_V1 and NV_GPU_GETCOOLER_SETTINGS_V2
typedef enum 
{
    NVAPI_COOLER_CONTROLLER_NONE = 0,
    NVAPI_COOLER_CONTROLLER_ADI,
    NVAPI_COOLER_CONTROLLER_INTERNAL,
} NV_COOLER_CONTROLLER;

//! Used in NV_GPU_GETCOOLER_SETTINGS_V1 and NV_GPU_GETCOOLER_SETTINGS_V2
typedef enum
{
    NVAPI_COOLER_POLICY_NONE                      = 0x00000000,
    NVAPI_COOLER_POLICY_MANUAL                    = 0x00000001, //!<Manual adjustment of cooler level. Gets applied right away independent of temperature or performance level.
    NVAPI_COOLER_POLICY_PERF                      = 0x00000002, //!<GPU performance controls the cooler level.
    NVAPI_COOLER_POLICY_TEMPERATURE_DISCRETE      = 0x00000004, //!<Discrete thermal levels control the cooler level.
    NVAPI_COOLER_POLICY_TEMPERATURE_CONTINUOUS    = 0x00000008, //!<Cooler level adjusted at continuous thermal levels by HW.
    NVAPI_COOLER_POLICY_TEMPERATURE_CONTINUOUS_SW = 0x00000010, //!<Cooler level adjusted at continuous thermal levels by SW.
    NVAPI_COOLER_POLICY_DEFAULT                   = 0x00000020, //!<Default is used to allowe system to chose system's default policy.
} NV_COOLER_POLICY;

//! Used in NV_GPU_GETCOOLER_SETTINGS_V1 and NV_GPU_GETCOOLER_SETTINGS_V2
typedef enum
{
    NVAPI_COOLER_TARGET_NONE = 0,
    NVAPI_COOLER_TARGET_GPU,                //!< GPU cooler requires NvPhysicalGpuHandle
    NVAPI_COOLER_TARGET_MEMORY,             //!< GPU memory cooler requires NvPhysicalGpuHandle
    NVAPI_COOLER_TARGET_POWER_SUPPLY = 4,   //!< GPU power supply cooler requires NvPhysicalGpuHandle
    NVAPI_COOLER_TARGET_ALL = 7,            //!< This cooler cools all of the components related to its target GPU.
    NVAPI_COOLER_TARGET_VCD_COOLER1 = 8,    //!< Visual Computing Device cooler 1; Requires NvVisualComputingDeviceHandle
    NVAPI_COOLER_TARGET_VCD_COOLER2,    //!< Visual Computing Device cooler 2; Requires NvVisualComputingDeviceHandle        
    NVAPI_COOLER_TARGET_VCD_COOLER3,    //!< Visual Computing Device cooler 3; Requires NvVisualComputingDeviceHandle
    NVAPI_COOLER_TARGET_VCD_COOLER4,    //!< Visual Computing Device cooler 4; Requires NvVisualComputingDeviceHandle
    NVAPI_COOLER_TARGET_VCD_COOLER5,    //!< Visual Computing Device cooler 5; Requires NvVisualComputingDeviceHandle
    NVAPI_COOLER_TARGET_VCD_COOLER6,    //!< Visual Computing Device cooler 6; Requires NvVisualComputingDeviceHandle
    NVAPI_COOLER_TARGET_VCD_COOLER7,    //!< Visual Computing Device cooler 7; Requires NvVisualComputingDeviceHandle
    NVAPI_COOLER_TARGET_VCD_COOLER8,    //!< Visual Computing Device cooler 8; Requires NvVisualComputingDeviceHandle
    NVAPI_COOLER_TARGET_VCD_COOLER9,    //!< Visual Computing Device cooler 9; Requires NvVisualComputingDeviceHandle
    NVAPI_COOLER_TARGET_VCD_COOLER10,    //!< Visual Computing Device cooler 10; Requires NvVisualComputingDeviceHandle
    NVAPI_COOLER_TARGET_VCD_COOLER11,    //!< Visual Computing Device cooler 11; Requires NvVisualComputingDeviceHandle
    NVAPI_COOLER_TARGET_VCD_COOLER12,    //!< Visual Computing Device cooler 12; Requires NvVisualComputingDeviceHandle
    NVAPI_COOLER_TARGET_VCD_COOLER13,    //!< Visual Computing Device cooler 13; Requires NvVisualComputingDeviceHandle
    NVAPI_COOLER_TARGET_VCD_COOLER14,    //!< Visual Computing Device cooler 14; Requires NvVisualComputingDeviceHandle
    NVAPI_COOLER_TARGET_VCD_COOLER15,    //!< Visual Computing Device cooler 15; Requires NvVisualComputingDeviceHandle
    NVAPI_COOLER_TARGET_VCD_COOLER16,    //!< Visual Computing Device cooler 16; Requires NvVisualComputingDeviceHandle
    NVAPI_COOLER_TARGET_VCD_COOLER17,    //!< Visual Computing Device cooler 17; Requires NvVisualComputingDeviceHandle
    NVAPI_COOLER_TARGET_VCD_COOLER18,    //!< Visual Computing Device cooler 18; Requires NvVisualComputingDeviceHandle
    NVAPI_COOLER_TARGET_VCD_COOLER19,    //!< Visual Computing Device cooler 19; Requires NvVisualComputingDeviceHandle
    NVAPI_COOLER_TARGET_VCD_COOLER20,    //!< Visual Computing Device cooler 20; Requires NvVisualComputingDeviceHandle

} NV_COOLER_TARGET;

//! Used in NV_GPU_GETCOOLER_SETTINGS_V1 and NV_GPU_GETCOOLER_SETTINGS_V2
typedef enum
{
    NVAPI_COOLER_CONTROL_NONE = 0,
    NVAPI_COOLER_CONTROL_TOGGLE,                   //!< ON/OFF
    NVAPI_COOLER_CONTROL_VARIABLE,                 //!< Supports variable control.
} NV_COOLER_CONTROL;

//! Used in NV_GPU_GETCOOLER_SETTINGS_V1 and NV_GPU_GETCOOLER_SETTINGS_V2
typedef enum
{
    NVAPI_INACTIVE = 0,             //!< Inactive or unsupported
    NVAPI_ACTIVE = 1,               //!< Active and spinning (in the case of a fan)
} NV_COOLER_ACTIVITY_LEVEL;


//! Used in NV_GPU_GETCOOLER_SETTINGS_V3.
typedef struct
{
    NvU32   speedRPM;       //!< current tachometer reading in RPM
    NvU8    bSupported;     //!< cooler supports tach function?
    NvU32   maxSpeedRPM;    //!< Maximum RPM corresponding to 100% defaultMaxLevel
    NvU32   minSpeedRPM;    //!< Minimum RPM corresponding to 100% defaultMinLevel
} NV_COOLER_TACHOMETER;


//! Used in NvAPI_GPU_GetCoolerSettings()
typedef struct
{
    NvU32   version;                //!< Structure version 
    NvU32   count;                  //!< Number of associated coolers with the selected GPU
    struct 
    {
        NV_COOLER_TYPE              type;               //!< Type of cooler - FAN, WATER, LIQUID_NO2...
        NV_COOLER_CONTROLLER        controller;         //!< Internal, ADI...
        NvU32                       defaultMinLevel;    //!< The min default value % of the cooler
        NvU32                       defaultMaxLevel;    //!< The max default value % of the cooler
        NvU32                       currentMinLevel;    //!< The current allowed min value % of the cooler
        NvU32                       currentMaxLevel;    //!< The current allowed max value % of the cooler
        NvU32                       currentLevel;       //!< The current value % of the cooler
        NV_COOLER_POLICY            defaultPolicy;      //!< Cooler control policy - auto-perf, auto-thermal, manual, hybrid...
        NV_COOLER_POLICY            currentPolicy;      //!< Cooler control policy - auto-perf, auto-thermal, manual, hybrid...
        NV_COOLER_TARGET            target;             //!< Cooling target - GPU, memory, chipset, powersupply, canoas...
        NV_COOLER_CONTROL           controlType;        //!< Toggle or variable
        NV_COOLER_ACTIVITY_LEVEL    active;             //!< Is the cooler active - fan spinning...
    } cooler[NVAPI_MAX_COOLERS_PER_GPU_VER1];
} NV_GPU_GETCOOLER_SETTINGS_V1;

//! Used in NvAPI_GPU_GetCoolerSettings()
//! In Version 2, the NVAPI_MAX_COOLERS_PER_GPU changed from 3 to 20 to account for 20 fans on VCD.
typedef struct
{
    NvU32   version;                //!< structure version
    NvU32   count;                  //!< number of associated coolers with the selected GPU
    struct
    {
        NV_COOLER_TYPE              type;               //!< Type of cooler - FAN, WATER, LIQUID_NO2...
        NV_COOLER_CONTROLLER        controller;         //!< Internal, ADI...
        NvU32                       defaultMinLevel;    //!< The min default value % of the cooler
        NvU32                       defaultMaxLevel;    //!< The max default value % of the cooler
        NvU32                       currentMinLevel;    //!< The current allowed min value % of the cooler
        NvU32                       currentMaxLevel;    //!< The current allowed max value % of the cooler
        NvU32                       currentLevel;       //!< The current value % of the cooler
        NV_COOLER_POLICY            defaultPolicy;      //!< Cooler control policy - auto-perf, auto-thermal, manual, hybrid...
        NV_COOLER_POLICY            currentPolicy;      //!< Cooler control policy - auto-perf, auto-thermal, manual, hybrid...
        NV_COOLER_TARGET            target;             //!< Cooling target - GPU, memory, chipset, powersupply, Visual Computing Device...
        NV_COOLER_CONTROL           controlType;        //!< Toggle or variable
        NV_COOLER_ACTIVITY_LEVEL    active;             //!< Is the cooler active - fan spinning...
    } cooler[NVAPI_MAX_COOLERS_PER_GPU_VER2];
} NV_GPU_GETCOOLER_SETTINGS_V2;


typedef struct
{
    NvU32   version;                //!< structure version
    NvU32   count;                  //!< number of associated coolers with the selected GPU
    struct
    {
        NV_COOLER_TYPE              type;               //!< type of cooler - FAN, WATER, LIQUID_NO2...
        NV_COOLER_CONTROLLER        controller;         //!< internal, ADI...
        NvU32                       defaultMinLevel;    //!< the min default value % of the cooler
        NvU32                       defaultMaxLevel;    //!< the max default value % of the cooler
        NvU32                       currentMinLevel;    //!< the current allowed min value % of the cooler
        NvU32                       currentMaxLevel;    //!< the current allowed max value % of the cooler
        NvU32                       currentLevel;       //!< the current value % of the cooler
        NV_COOLER_POLICY            defaultPolicy;      //!< cooler control policy - auto-perf, auto-thermal, manual, hybrid...
        NV_COOLER_POLICY            currentPolicy;      //!< cooler control policy - auto-perf, auto-thermal, manual, hybrid...
        NV_COOLER_TARGET            target;             //!< cooling target - GPU, memory, chipset, powersupply, Visual Computing Device...
        NV_COOLER_CONTROL           controlType;        //!< toggle or variable
        NV_COOLER_ACTIVITY_LEVEL    active;             //!< is the cooler active - fan spinning...
        NV_COOLER_TACHOMETER        tachometer;         //!< cooler tachometer info
    } cooler[NVAPI_MAX_COOLERS_PER_GPU_VER3];
} NV_GPU_GETCOOLER_SETTINGS_V3;

typedef struct
{
    NvU32   version;                //!< structure version
    NvU32   count;                  //!< number of associated coolers with the selected GPU
    struct
    {
        NV_COOLER_TYPE              type;               //!< type of cooler - FAN, WATER, LIQUID_NO2...
        NV_COOLER_CONTROLLER        controller;         //!< internal, ADI...
        NvU32                       defaultMinLevel;    //!< the min default value % of the cooler
        NvU32                       defaultMaxLevel;    //!< the max default value % of the cooler
        NvU32                       currentMinLevel;    //!< the current allowed min value % of the cooler
        NvU32                       currentMaxLevel;    //!< the current allowed max value % of the cooler
        NvU32                       currentLevel;       //!< the current value % of the cooler
        NV_COOLER_POLICY            defaultPolicy;      //!< cooler control policy - auto-perf, auto-thermal, manual, hybrid...
        NV_COOLER_POLICY            currentPolicy;      //!< cooler control policy - auto-perf, auto-thermal, manual, hybrid...
        NV_COOLER_TARGET            target;             //!< cooling target - GPU, memory, chipset, powersupply, Visual Computing Device...
        NV_COOLER_CONTROL           controlType;        //!< toggle or variable
        NV_COOLER_ACTIVITY_LEVEL    active;             //!< is the cooler active - fan spinning...
        NV_COOLER_TACHOMETER        tachometer;         //!< cooler tachometer info
        NvU32                       supportedPolicies;  //!< supported cooler policies.    
    } cooler[NVAPI_MAX_COOLERS_PER_GPU_VER4];
} NV_GPU_GETCOOLER_SETTINGS_V4;


//!#Between ver1 and ver2 the NVAPI_MAX_COOLERS_PER_GPU changed from 3 to 20 to account for 20 fans on VCD

#define NV_GPU_GETCOOLER_SETTINGS           NV_GPU_GETCOOLER_SETTINGS_V4

#define NV_GPU_GETCOOLER_SETTINGS_VER1      MAKE_NVAPI_VERSION(NV_GPU_GETCOOLER_SETTINGS_V1,1)
#define NV_GPU_GETCOOLER_SETTINGS_VER2A     MAKE_NVAPI_VERSION(NV_GPU_GETCOOLER_SETTINGS_V2,1)  //!< For shipped R180 compatibility
#define NV_GPU_GETCOOLER_SETTINGS_VER2      MAKE_NVAPI_VERSION(NV_GPU_GETCOOLER_SETTINGS_V2,2)
#define NV_GPU_GETCOOLER_SETTINGS_VER3      MAKE_NVAPI_VERSION(NV_GPU_GETCOOLER_SETTINGS_V3,3)
#define NV_GPU_GETCOOLER_SETTINGS_VER4      MAKE_NVAPI_VERSION(NV_GPU_GETCOOLER_SETTINGS_V4,4)

#define NV_GPU_GETCOOLER_SETTINGS_VER       NV_GPU_GETCOOLER_SETTINGS_VER4


//! Used in NvAPI_GPU_SetCoolerLevels()
typedef struct 
{
    NvU32   version;        //!< Structure version 
    struct 
    {
        NvU32               currentLevel;           //!< The new value % of the cooler
        NV_COOLER_POLICY    currentPolicy;          //!< The new cooler control policy - auto-perf, auto-thermal, manual, hybrid...
    } cooler[NVAPI_MAX_COOLERS_PER_GPU_VER1];

} NV_GPU_SETCOOLER_LEVEL_V1;


//! Used in NvAPI_GPU_SetCoolerLevels()
typedef struct
{
    NvU32   version;        //structure version
    struct
    {
        NvU32               currentLevel;           //!< The new value % of the cooler
        NV_COOLER_POLICY    currentPolicy;          //!< The new cooler control policy - auto-perf, auto-thermal, manual, hybrid...
    } cooler[NVAPI_MAX_COOLERS_PER_GPU_VER2];
} NV_GPU_SETCOOLER_LEVEL_V2;

#define NV_GPU_SETCOOLER_LEVEL          NV_GPU_SETCOOLER_LEVEL_V2


#define NV_GPU_SETCOOLER_LEVEL_VER1     MAKE_NVAPI_VERSION(NV_GPU_SETCOOLER_LEVEL_V1,1)
#define NV_GPU_SETCOOLER_LEVEL_VER2     MAKE_NVAPI_VERSION(NV_GPU_SETCOOLER_LEVEL_V2,1)

#define NV_GPU_SETCOOLER_LEVEL_VER      NV_GPU_SETCOOLER_LEVEL_VER2


//! Used in NvAPI_GPU_GetCoolerPolicyTable()
typedef struct
{
    NvU32               version;        //!< Structure version
    NV_COOLER_POLICY    policy;         //!< selected policy to update the cooler levels for, example NVAPI_COOLER_POLICY_PERF
    struct 
    {
        NvU32 levelId;      //!< Level indicator for a policy
        NvU32 currentLevel; //!< New cooler level for the selected policy level indicator
        NvU32 defaultLevel; //!< Default cooler level for the selected policy level indicator
    } policyCoolerLevel[NVAPI_MAX_COOLER_LEVELS];
} NV_GPU_COOLER_POLICY_TABLE;

#define NV_GPU_COOLER_POLICY_TABLE_VER MAKE_NVAPI_VERSION(NV_GPU_COOLER_POLICY_TABLE,1)

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetCoolerSettings
//
//!  This function retrieves the cooler information of all coolers or a specific cooler associated with the selected GPU.
//!  Coolers are indexed 0 to NVAPI_MAX_COOLERS_PER_GPU-1.
//!  - To retrieve specific cooler info, set the coolerIndex to the appropriate cooler index. 
//!  - To retrieve info for all coolers, set coolerIndex to NVAPI_COOLER_TARGET_ALL. 
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 85
//!
//! \param [in]     hPhysicalGPU    GPU selection.
//! \param [in]     coolerIndex     Explicit cooler index selection. 
//! \param [out]    pCoolerInfo     Array of cooler settings.
//!
//! \retval   NVAPI_OK                             Completed request
//! \retval   NVAPI_ERROR                          Miscellaneous error occurred.
//! \retval   NVAPI_INVALID_ARGUMENT               pCoolerInfo is NULL.
//! \retval   NVAPI_HANDLE_INVALIDATED             Handle passed has been invalidated (see user guide).
//! \retval   NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE   Handle passed is not a physical GPU handle.
//! \retval   NVAPI_INCOMPATIBLE_STRUCT_VERSION    The version of the INFO struct is not supported.
//! \ingroup  gpucooler
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetCoolerSettings(NvPhysicalGpuHandle hPhysicalGpu, NvU32 coolerIndex, NV_GPU_GETCOOLER_SETTINGS *pCoolerInfo);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_SetCoolerLevels
//
//!  This function sets the cooler levels for all coolers or a specific cooler associated with the selected GPU.
//!  Coolers are indexed 0 to NVAPI_MAX_COOLERS_PER_GPU-1. Every cooler level with non-zero currentpolicy gets applied.          
//!  The new level should be in the range of minlevel and maxlevel retrieved from GetCoolerSettings API or between 
//!  and NVAPI_MIN_COOLER_LEVEL to MAX_COOLER_LEVEL.
//!  - To set level for a specific cooler, set the coolerIndex to the appropriate cooler index. 
//!  - To set level for all coolers, set coolerIndex to NVAPI_COOLER_TARGET_ALL. 
//!
//! \note      To lock the fan speed independent of the temperature or performance changes, set the cooler currentPolicy to 
//!            NVAPI_COOLER_POLICY_MANUAL, else set it to the current policy retrieved from the GetCoolerSettings API.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 85
//! 
//! \param [in]       hPhysicalGPU    GPU selection.
//! \param [in]       coolerIndex     Explicit cooler index selection.
//! \param [in]       pCoolerLevels   Updated cooler level and cooler policy.
//!
//! \retval   NVAPI_OK                            Completed request
//! \retval   NVAPI_ERROR                         Miscellaneous error occurred.
//! \retval   NVAPI_INVALID_ARGUMENT              pCoolerLevels is NULL.
//! \retval   NVAPI_HANDLE_INVALIDATED            Handle passed has been invalidated (see user guide).
//! \retval   NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle.
//! \retval   NVAPI_INCOMPATIBLE_STRUCT_VERSION   The version of the INFO struct is not supported.
//! \ingroup  gpucooler
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetCoolerLevels(NvPhysicalGpuHandle hPhysicalGpu, NvU32 coolerIndex, NV_GPU_SETCOOLER_LEVEL *pCoolerLevels);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_RestoreCoolerSettings
//
//!  This function restores the modified cooler settings to NVIDIA defaults.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 85
//!
//! \param [in]       hPhysicalGPU     GPU selection.
//! \param [in]       pCoolerIndex     Array containing absolute cooler indexes to restore. Pass NULL restore all coolers.
//! \param            CoolerCount      Number of coolers to restore.
//!
//! \retval   NVAPI_OK                            Completed request
//! \retval   NVAPI_ERROR                         Miscellaneous error occurred.
//! \retval   NVAPI_HANDLE_INVALIDATED            Handle passed has been invalidated (see user guide).
//! \retval   NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle.
//! \retval   NVAPI_INCOMPATIBLE_STRUCT_VERSION   The version of the INFO struct is not supported.
//! \ingroup  gpucooler
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_RestoreCoolerSettings(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pCoolerIndex, NvU32 coolerCount);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetCoolerPolicyTable
//
//!  This function retrieves the table of cooler and policy levels for the selected policy.
//!  Supported only for NVAPI_COOLER_POLICY_PERF.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 85
//!
//! \param [in]     hPhysicalGPU       GPU selection.
//! \param [in]     coolerIndex        Cooler index selection.
//! \param [out]    pCoolerTable       Table of policy levels and associated cooler levels.
//! \param [out]    count              Count of the number of valid levels for the selected policy.
//!
//! \retval   NVAPI_OK                            Completed request
//! \retval   NVAPI_ERROR                         Miscellaneous error occurred.
//! \retval   NVAPI_HANDLE_INVALIDATED            Handle passed has been invalidated (see user guide).
//! \retval   NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle.
//! \retval   NVAPI_INCOMPATIBLE_STRUCT_VERSION   The version of the INFO struct is not supported.
//! \ingroup  gpucooler
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetCoolerPolicyTable(NvPhysicalGpuHandle hPhysicalGpu, NvU32 coolerIndex, NV_GPU_COOLER_POLICY_TABLE *pCoolerTable, NvU32 *count);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_SetCoolerPolicyTable
//
// DESCRIPTION:     Restore the modified cooler settings to NVIDIA defaults. Supported only for NVAPI_COOLER_POLICY_PERF.
//
//!  This function restores the modified cooler settings to NVIDIA defaults. Supported only for NVAPI_COOLER_POLICY_PERF.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 85
//!
//! \param [in]     hPhysicalGPU  GPU selection.
//! \param [in]     coolerIndex   Cooler index selection.
//! \param [in]     pCoolerTable  Updated table of policy levels and associated cooler levels. Every non-zero policy level gets updated.
//! \param [in]     count         Number of valid levels in the policy table.
//!
//! \retval   NVAPI_OK                            Completed request
//! \retval   NVAPI_ERROR                         Miscellaneous error occurred.
//! \retval   NVAPI_HANDLE_INVALIDATED            Handle passed has been invalidated (see user guide).
//! \retval   NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle.
//! \retval   NVAPI_INCOMPATIBLE_STRUCT_VERSION   The version of the INFO struct is not supported.
//! \ingroup  gpucooler
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetCoolerPolicyTable(NvPhysicalGpuHandle hPhysicalGpu, NvU32 coolerIndex, NV_GPU_COOLER_POLICY_TABLE *pCoolerTable, NvU32 count);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_RestoreCoolerPolicyTable
//
//! DESCRIPTION:    This function restores the perf table policy levels to the defaults.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 85
//!
//! \param [in]   hPhysicalGPU   GPU selection.
//! \param [in]   coolerIndex    Cooler index selection.
//! \param [in]   pCoolerIndex   Array containing absolute cooler indexes to restore. Pass NULL restore all coolers.
//! \param        coolerCount    Number of coolers to restore.
//! \param        policy         Restore for the selected policy
//!
//! \retval   NVAPI_OK                           Completed request
//! \retval   NVAPI_ERROR                        Miscellaneous error occurred.
//! \retval   NVAPI_HANDLE_INVALIDATED           Handle passed has been invalidated (see user guide).
//! \retval   NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE Handle passed is not a physical GPU handle.
//! \ingroup  gpucooler
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_RestoreCoolerPolicyTable(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pCoolerIndex, NvU32 coolerCount, NV_COOLER_POLICY policy);




//! addtogroup gputhermal
//! @{

#define NV_GPU_PMU_FAN_PRIVATE_DATA_HEADER_REVISION_MAJOR_REVISION            7:4
#define NV_GPU_PMU_FAN_PRIVATE_DATA_HEADER_REVISION_MAJOR_REVISION_1X  0x00000001
#define NV_GPU_PMU_FAN_PRIVATE_DATA_HEADER_REVISION_MINOR_REVISION            3:0
#define NV_GPU_PMU_FAN_PRIVATE_DATA_HEADER_REVISION_MINOR_REVISION_0   0x00000000

typedef struct
{
    NvU8  revision;  //!< The private data revision
    NvU8  size;      //!< The private data size

} NV_GPU_PMU_FAN_PRIVATE_DATA_HEADER;

#define NV_GPU_PMU_FAN_PRIVATE_DATA_1X_CONTROL_FIELD_ENABLE                    0:0
#define NV_GPU_PMU_FAN_PRIVATE_DATA_1X_CONTROL_FIELD_ENABLE_DISABLED  (0x00000000)
#define NV_GPU_PMU_FAN_PRIVATE_DATA_1X_CONTROL_FIELD_ENABLE_ENABLED   (0x00000001)
#define NV_GPU_PMU_FAN_PRIVATE_DATA_1X_CONTROL_FIELD_MODE                      2:1
#define NV_GPU_PMU_FAN_PRIVATE_DATA_1X_CONTROL_FIELD_MODE_AUTOMATIC   (0x00000000)
#define NV_GPU_PMU_FAN_PRIVATE_DATA_1X_CONTROL_FIELD_MODE_MANUAL      (0x00000001)
#define NV_GPU_PMU_FAN_PRIVATE_DATA_1X_CONTROL_FIELD_GEMINI                    4:3
#define NV_GPU_PMU_FAN_PRIVATE_DATA_1X_CONTROL_FIELD_GEMINI_DISABLED  (0x00000000)
#define NV_GPU_PMU_FAN_PRIVATE_DATA_1X_CONTROL_FIELD_GEMINI_MASTER    (0x00000001)
#define NV_GPU_PMU_FAN_PRIVATE_DATA_1X_CONTROL_FIELD_GEMINI_SLAVE     (0x00000002)
#define NV_GPU_PMU_FAN_PRIVATE_DATA_1X_CONTROL_FIELD_GEMINI_SHARING   (0x00000003)
#define NV_GPU_PMU_FAN_PRIVATE_DATA_1X_CONTROL_FIELD_ALGORITHM                7:5
#define NV_GPU_PMU_FAN_PRIVATE_DATA_1X_CONTROL_FIELD_ALGORITHM_LINEAR (0x00000000)
#define NV_GPU_PMU_FAN_PRIVATE_DATA_1X_CONTROL_FIELD_ALGORITHM_2_SEG  (0x00000001)

typedef struct
{
    //Configuration fields
    NvS16 m;              //!< Fixed point M - FXP8.8 converts temperature/100 C to PWM fraction
    NvS16 b;              //!< Fixed point B - FXP8.8 typically m=1...3 and b=0..-0.5
    NvS16 accelGain;      //!< Fan acceleration gain - FXP8.8 typically +2...-0.9
    NvS16 midpointGain;   //!< Gain to use in history - FXP8.8
    NvU8  historyCount;   //!< Number of second samples to keep - unsigned units
    NvU8  lookback;       //!< Number of samples for lookback smoothing for accleration - maximum of 10
    NvU16 controlField;   //!< Bit field for various PMU control bits - see macros above
    NvS16 slopeLimit0;    //!< Minimum slope of EF line segment, typically 1 - FXP8.8
    NvS16 slope1;         //!< Fixed slope of FG line segment, typically 2 - FXP8.8
    NvS16 gravity;        //!< Gravity to add to Fx at every iteration - FXP11.5

} NV_GPU_PMU_FAN_PRIVATE_DATA_1X;

typedef struct
{
    NvU32                              version;   //!< NVAPI structure version
    NV_GPU_PMU_FAN_PRIVATE_DATA_HEADER header;
    NV_GPU_PMU_FAN_PRIVATE_DATA_1X     pvtData1X; //!< Private data revision 1.X

} NV_GPU_PMU_FAN_PRIVATE_DATA_V1;

#define NV_GPU_PMU_FAN_PRIVATE_DATA_VER1     MAKE_NVAPI_VERSION(NV_GPU_PMU_FAN_PRIVATE_DATA_V1,1)
#define NV_GPU_PMU_FAN_PRIVATE_DATA_VER      NV_GPU_PMU_FAN_PRIVATE_DATA_VER1

typedef NV_GPU_PMU_FAN_PRIVATE_DATA_V1       NV_GPU_PMU_FAN_PRIVATE_DATA;

#define NV_GPU_PMU_FAN_PWM_SOURCE                      2:0
#define NV_GPU_PMU_FAN_PWM_SOURCE_INVALID       0x00000000 //!< Default return value in all error cases (when PWM source expected).
#define NV_GPU_PMU_FAN_PWM_SOURCE_PMGR_FAN      0x00000001 //!< PWM source is PMGR "FAN" that allows OVERTEMP override.
#define NV_GPU_PMU_FAN_PWM_SOURCE_PMGR_PWM      0x00000002 //!< PWM source is PMGR "PWM".
#define NV_GPU_PMU_FAN_PWM_SOURCE_THERM_PWM     0x00000003 //!< PWM source belongs to OBJTHERM (GF11x+)
#define NV_GPU_PMU_FAN_PWM_INVERT                      3:3
#define NV_GPU_PMU_FAN_PWM_INVERT_DISABLED      0x00000000
#define NV_GPU_PMU_FAN_PWM_INVERT_ENABLED       0x00000001

#define NV_GPU_PMU_FAN_RAMP_SLOPE_NOT_USED 0

typedef struct
{
    NvU32 version;          //!< NVAPI structure version
    NvU8  pwmPctMin;        //!< Minimum permitted fan percent 0..100, typically 0..40%
    NvU8  pwmPctMax;        //!< Maximum permitted fan percent 0..100, typically TDPMAX+10% 90..100
    NvU8  pwmPctManual;     //!< Raw duty cycle for PWM, used in manual mode, typically less than 16 bits
    NvU8  pwmSource;        //!< The PWM source which is driving the GPIO - used to determine which registers to write.
    NvS16 pwmScaleSlope;    //!< The slope/m for scaling electrical pwm % -> electrical pwm duty cycle - FXP4.12
    NvS16 pwmScaleOffset;   //!< The offset/b for scaling electrical pwm % -> electrical pwm duty cycle - FXP4.12
    NvU32 pwmRawPeriod;     //!< Raw period for PWM, typically less than 16 bits
    NvU16 pwmRampUpSlope;   //!< Ramp up slope in ms / %    - This is an *optional* parameter
    NvU16 pwmRampDownSlope; //!< Ramp down slope in ms / %  - This is an *optional* parameter

} NV_GPU_PMU_FAN_FAN_DESCRIPTION_V1;

#define NV_GPU_PMU_FAN_FAN_DESCRIPTION_VER1     MAKE_NVAPI_VERSION(NV_GPU_PMU_FAN_FAN_DESCRIPTION_V1,1)
#define NV_GPU_PMU_FAN_FAN_DESCRIPTION_VER      NV_GPU_PMU_FAN_FAN_DESCRIPTION_VER1

typedef NV_GPU_PMU_FAN_FAN_DESCRIPTION_V1       NV_GPU_PMU_FAN_FAN_DESCRIPTION;

typedef struct
{
    NvU32   version;        //!< NVAPI structure version
    struct
    {
        NV_GPU_PMU_FAN_FAN_DESCRIPTION_V1 fanDesc;
        NV_GPU_PMU_FAN_PRIVATE_DATA_V1    pvtData;

    } ctrlBlk;

} NV_GPU_PMU_FAN_CONTROL_BLOCK_V1;

#define NV_GPU_PMU_FAN_CONTROL_BLOCK_VER1     MAKE_NVAPI_VERSION(NV_GPU_PMU_FAN_CONTROL_BLOCK_V1,1)
#define NV_GPU_PMU_FAN_CONTROL_BLOCK_VER      NV_GPU_PMU_FAN_CONTROL_BLOCK_VER1

typedef NV_GPU_PMU_FAN_CONTROL_BLOCK_V1       NV_GPU_PMU_FAN_CONTROL_BLOCK;

//! @}



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetPmuFanControlBlock
//
//! DESCRIPTION:     This API returns current the PMU fan control block.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \param [in]     hPhysicalGPU          GPU selection.
//! \param [in]     coolerIndex           cooler index selection.
//! \param [out]    pPmuFanControlBlock   Current PMU fan control block.
//!
//! \retval ::NVAPI_OK                 completed request
//! \retval ::NVAPI_NOT_SUPPORTED      PMU fan control is not supported on this setup
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION   The version of the NV_GPU_PMU_FAN_CONTROL_BLOCK struct is not supported
//!
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetPmuFanControlBlock(NvPhysicalGpuHandle hPhysicalGpu, NvU32 coolerIndex, NV_GPU_PMU_FAN_CONTROL_BLOCK *pPmuFanControlBlock);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_SetPmuFanControlBlock
//
//! DESCRIPTION:     This API sets current the PMU fan control block.
//!                  Clients must set major and minor revision in NV_GPU_PMU_FAN_PRIVATE_DATA_HEADER
//!                  before calling this API.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \param [in]       hPhysicalGPU          GPU selection.
//! \param [in]       coolerIndex)          cooler index selection.
//! \param [in]       pPmuFanControlBlock   Client supplied PMU fan control block.
//
// RETURN STATUS:
//! \retval ::NVAPI_OK - completed request
//! \retval ::NVAPI_NOT_SUPPORTED - pmu fan control is not supported on this setup
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the NV_GPU_PMU_FAN_CONTROL_BLOCK struct is not supported
//!
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetPmuFanControlBlock(NvPhysicalGpuHandle hPhysicalGpu, NvU32 coolerIndex, NV_GPU_PMU_FAN_CONTROL_BLOCK *pPmuFanControlBlock);



//! \addtogroup gpupstate
//! @{

#define NV_GPU_PERF_SET_FORCE_PSTATE_FLAGS_ASYNC    0x00000001 


#define NV_GPU_PERF_INPUT_FLAGS_DEFAULT_SETTINGS         0x00000001
#define NV_GPU_PERF_INPUT_FLAGS_MAX_CLOCK_FREQ           0x00000002
#define NV_GPU_PERF_INPUT_FLAGS_MIN_CLOCK_FREQ           0x00000004

#define NV_GPU_PERF_PSTATES_FLAGS_PERFMON_ENABLED        0x00000001 
#define NV_GPU_PERF_PSTATES_FLAGS_DYN_PSTATES_CAPABLE    0x00000002 
#define NV_GPU_PERF_PSTATES_FLAGS_DYNAMIC_PSTATE_ENABLED 0x00000004 
#define NV_GPU_PERF_PSTATES_FLAGS_MODE_INTERNAL_TEST     0x00000008 

#define NV_GPU_PERF_PSTATE_FLAGS_PCIELIMIT_GEN1       0x00000001 
#define NV_GPU_PERF_PSTATE_FLAGS_OVERCLOCKED_TRUE     0x00000002 
#define NV_GPU_PERF_PSTATE_FLAGS_OVERCLOCKABLE        0x00000004 

#define NV_GPU_PERF_PSTATE_CLOCK_FLAGS_OVERCLOCKABLE  0x00000001 

#define NV_GPU_PERF_PSTATE_CLOCK_INTERNAL_FLAGS_FORCE_PLL      0x00000001
#define NV_GPU_PERF_PSTATE_CLOCK_INTERNAL_FLAGS_FORCE_BYPASS   0x00000002

#define NV_GPU_PERF_PSTATE_VOLTAGE_FLAGS_VDT          0x00000001

//! @}

//! \addtogroup gpupstate
//! @{

typedef enum _NV_GPU_PERF_PSTATE_ID
{
    NVAPI_GPU_PERF_PSTATE_P0 = 0,
    NVAPI_GPU_PERF_PSTATE_P1,
    NVAPI_GPU_PERF_PSTATE_P2,
    NVAPI_GPU_PERF_PSTATE_P3,
    NVAPI_GPU_PERF_PSTATE_P4,
    NVAPI_GPU_PERF_PSTATE_P5,
    NVAPI_GPU_PERF_PSTATE_P6,
    NVAPI_GPU_PERF_PSTATE_P7,
    NVAPI_GPU_PERF_PSTATE_P8,
    NVAPI_GPU_PERF_PSTATE_P9,
    NVAPI_GPU_PERF_PSTATE_P10,
    NVAPI_GPU_PERF_PSTATE_P11,
    NVAPI_GPU_PERF_PSTATE_P12,
    NVAPI_GPU_PERF_PSTATE_P13,
    NVAPI_GPU_PERF_PSTATE_P14,
    NVAPI_GPU_PERF_PSTATE_P15,
    NVAPI_GPU_PERF_PSTATE_UNDEFINED = NVAPI_MAX_GPU_PERF_PSTATES,
    NVAPI_GPU_PERF_PSTATE_ALL,

} NV_GPU_PERF_PSTATE_ID;

//! @}



//! \addtogroup gpupstate
//! @{

//! Used in NvAPI_GPU_GetPstates().
typedef enum _NV_GPU_PERF_PSTATE_FALLBACK
{
    NVAPI_GPU_PERF_PSTATE_FALLBACK_RETURN_ERROR = 0,
    NVAPI_GPU_PERF_PSTATE_FALLBACK_HIGHER_PERF  = 1,
    NVAPI_GPU_PERF_PSTATE_FALLBACK_LOWER_PERF   = 2,

} NV_GPU_PERF_PSTATE_FALLBACK;



//! Used in NvAPI_GPU_GetPstates(), NvAPI_GPU_GetPstatesEx(), and NvAPI_GPU_SetPstates().
typedef struct
{
    NvU32   version;     //!< Structure version
    NvU32   flags;       //!< - bit 0 indicates if perfmon is enabled or not
                         //!< - bit 1 indicates if dynamic Pstate is capable or not
                         //!< - bit 2 indicates if dynamic Pstate is enable or not
                         //!< - set bit 3 if the call is for internal test mode
                         //!< - all other bits must be set to 0
    NvU32   numPstates;  //!< The number of available P-States
    NvU32   numClocks;   //!< The number of clock domains supported by each P-State
    NvU32   numVoltages; //!< The number of voltage domains supported by each P-State

    //! ID of the P-State, with valid index range of 0 to numPstates-1 
    struct
    {
        NV_GPU_PERF_PSTATE_ID   pstateId; //!<  ID of the P-State
        NvU32                   flags;    //!<  - bit 0 indicates if the PCIE limit is GEN1 or GEN2
                                          //!<  - bit 1 indicates if the Pstate is overclocked or not
                                          //!<  - bit 2 indicates if the Pstate is overclockable or not
                                          //!<  - all other bits must be set to 0

        //! Valid index range of 0 to numClocks-1
        struct
        {
            NV_GPU_CLOCK_DOMAIN_ID domainId;
            NvU32                                flags:2;       //!< - bit 0 indicates that clock is forced to source from PLL
                                                                //!< - bit 1 indicates that clock is forced to source from bypass
            NvU32                                reserved:29;   //!< Reserved for future use. Must be set to 0
            NvU32                                bApplyRatio:1; //!< Apply freq to other ratio clocks
            NvU32                                freq;          //!< Clock frequency in kHz

        } clocks[NVAPI_MAX_GPU_PERF_CLOCKS];
        
        //! Valid index range of 0 to numVoltages-1
        struct
        {
            NV_GPU_PERF_VOLTAGE_DOMAIN_ID domainId;  //!< ID of the voltage domain
            NvU32                       flags;       //!< -  bit 0 indicates that mvolt is evaluated from VDT
                                                     //!< -  all other bits must be set to 0
            NvU32                       mvolt;       //!< Voltage level in mV. 

        } voltages[NVAPI_MAX_GPU_PERF_VOLTAGES];

    } pstates[NVAPI_MAX_GPU_PERF_PSTATES];
    
} NV_GPU_PERF_PSTATES_V1;

typedef  NV_GPU_PERF_PSTATES_V1  NV_GPU_PERF_PSTATES;


//! Used in NvAPI_GPU_GetPstates().
#define NV_GPU_PERF_PSTATES_VER1  MAKE_NVAPI_VERSION(NV_GPU_PERF_PSTATES_V1,1)
#define NV_GPU_PERF_PSTATES_VER   NV_GPU_PERF_PSTATES_VER1

//! @}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetPstates
//
//! DESCRIPTION:     This function retrieves all performance states (P-States) information.
//!                  This API is defined for internal usage.  A similar API NvAPI_GPU_GetPstatesInfo() is 
//!                  provided for NDA users with restricted functions.
//!
//!                  P-States are GPU active/executing performance capability and power consumption states. \n
//!                  P-States range from P0 to P15, with P0 being the highest performance/power state, and
//!                  P15 being the lowest performance/power state. Each P-State maps to a
//!                  performance level. Not all P-States are available on a given system. The definition
//!                  of each P-States are currently as follows:
//!                  - P0/P1 - Maximum 3D performance
//!                  - P2/P3 - Balanced 3D performance-power
//!                  - P8 - Basic HD video playback
//!                  - P10 - DVD playback
//!                  - P12 - Minimum idle power consumption
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 165
//!
//!  \param [in]  hPhysicalGPU  GPU selection.
//!  \param [out] pPerfPstates  P-States information retrieved. See \ref NV_GPU_PERF_PSTATES.
//!
//!  \retval    NVAPI_OK                            Completed request.
//!  \retval    NVAPI_ERROR                         Miscellaneous error occurred.
//!  \retval    NVAPI_HANDLE_INVALIDATED            Handle passed has been invalidated (see user guide).
//!  \retval    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle.
//!  \retval    NVAPI_INCOMPATIBLE_STRUCT_VERSION   The version of the NV_GPU_PERF_PSTATES struct is not supported.
//!
//!  \ingroup   gpupstate
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetPstates(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_PERF_PSTATES *pPerfPstates);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetPstatesEx
//
//! DESCRIPTION:     This function retrieves all performance states (P-States) information.
//!                  This is the same as NvAPI_GPU_GetPstates(), but supports an input flag
//!                  for various options.
//!
//!                  P-States are GPU active/executing performance capability and power consumption states. \n
//!                  P-States range from P0 to P15, with P0 being the highest performance/power state, and
//!                  P15 being the lowest performance/power state. Each P-State maps to a
//!                  performance level. Not all P-States are available on a given system. The definition
//!                  of each P-States are currently as follows:
//!                  - P0/P1 - Maximum 3D performance
//!                  - P2/P3 - Balanced 3D performance-power
//!                  - P8 - Basic HD video playback
//!                  - P10 - DVD playback
//!                  - P12 - Minimum idle power consumption
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//!  \param [in]  hPhysicalGPU  GPU selection.
//!  \param [out] pPerfPstates  P-States information retrieved. See \ref NV_GPU_PERF_PSTATES.
//!  \param [in]  inputFlags    This can be used to select various options:
//!                  - if bit 0 is set, pPerfPstates would contain the default settings
//!                    instead of the current, possibily overclocked settings.
//!                  - if bit 1 is set, pPerfPstates would contain the maximum clock 
//!                    frequencies instead of the nominal frequencies.
//!                  - if bit 2 is set, pPerfPstates would contain the minimum clock 
//!                    frequencies instead of the nominal frequencies.
//!                  - all other bits must be set to 0.
//!
//!  \retval    NVAPI_OK                            Completed request.
//!  \retval    NVAPI_ERROR                         Miscellaneous error occurred.
//!  \retval    NVAPI_HANDLE_INVALIDATED            Handle passed has been invalidated (see user guide).
//!  \retval    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle.
//!  \retval    NVAPI_INCOMPATIBLE_STRUCT_VERSION   The version of the NV_GPU_PERF_PSTATES struct is not supported.
//!
//!  \ingroup   gpupstate
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetPstatesEx(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_PERF_PSTATES *pPerfPstates, NvU32 inputFlags);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_SetPstates
//
//! \code
//! DESCRIPTION:     Sets a subset (from 1 to all) of all performance states (P-States) information.  This 
//!                  API is defined for NDA usage.
//!
//!                  P-States are GPU active/executing performance capability and power consumption states.
//!                  P-States ranges from P0 to P15, with P0 being the highest performance/power state, and
//!                  P15 being the lowest performance/power state. Each P-State, if available, maps to a
//!                  performance level. Not all P-States are available on a given system. The definition
//!                  of each P-States are currently as follow:
//!                    P0/P1 - Maximum 3D performance
//!                    P2/P3 - Balanced 3D performance-power
//!                    P8 - Basic HD video playback
//!                    P10 - DVD playback
//!                    P12 - Minimum idle power consumption
//!
//!                  The changes this API makes are *not* persistent across a driver unload or reboot.  
//!                  Client applications must handle enforcing persistence.  However, client apps should
//!                  also be careful not to persist bad pstate configurations across reboots (i.e. if the
//!                  bad pstate configuration hangs the chip and the client application always applies that
//!                  configuration on boot, the user will never be able to boot and revert those changes
//!                  without booting to safe mode).
//!
//!                  Some important caveats for this API, we will keep this information internal only for 
//!                  the present:
//!                    a) At present, we can only override the P0 pstate with this function.  For more
//!                       information about unlocking this for other pstate (for internal testing only!) 
//!                       see documentation of NV2080_CTRL_CMD_PERF_SET_PSTATE_INFO.  Any attempt to 
//!                       override pstates below P0 will silently fail: everything will return okay but no
//!                       changes will be made.
//!                    b) We are unable to change the pstate voltage on pre-Fermi boards.  To enable this
//!                       on Tesla dGPUs (for internal testing only!) see documentation of 
//!                       NV2080_CTRL_CMD_PERF_SET_PSTATE_INFO.  Any attempt to change the voltage will 
//!                       silently fail.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! PARAMETERS:      hPhysicalGPU(IN)  - GPU selection.
//!                  pPerfPstates(IN) - P-States information retrieved, as detailed below:
//!                  - flags is reserved for future use
//!                  - numPstates the number of p-states specified
//!                  - numClocks is the number of clock domains specified in each p-state.
//!                  - numVoltages is the number of voltage domains specified in each p-State
//!                  - pstates has valid index range from 0 to numPstates - 1
//!                  - pstates[i].pstateId is the ID of the P-State,
//!                      containing the following info:
//!                    - pstates[i].flags is reserved for future use
//!                    - pstates[i].clocks has valid index range from 0 to numClocks -1
//!                    - pstates[i].clocks[j].domainId is the ID of the clock domain,
//!                        containing the following info:
//!                      - pstates[i].clocks[j].flags is reserved for future use.
//!                      - pstates[i].clocks[j].freq is the clock frequency in kHz
//!                    - pstates[i].voltages has valid index range from 0 to numVoltages - 1
//!                    - pstates[i].voltages[j].domainId is the ID of the voltage domain,
//!                        containing the following info:
//!                      - pstates[j].voltages[j].flags is reserved for future use.
//!                      - pstates[j].voltages[j].mvolt is the voltage level in milli-volt
//!
//! RETURN STATUS:
//!    NVAPI_OK - completed request
//!    NVAPI_ERROR - miscellaneous error occurred
//!    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//!    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//!    NVAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the NV_GPU_PERF_PSTATES struct is not supported
//! \endcode
//! \ingroup gpupstate
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetPstates(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_PERF_PSTATES *pPerfPstates);



//! \ingroup gpupstate
//! Used in NvAPI_GPU_GetPstatesInfoEx()
//! Used in NvAPI_GPU_GetPstatesInfo() and NvAPI_GPU_SetPstatesInfo().
typedef struct
{
    NvU32   version;
    NvU32   flags;           //!< - bit 0 indicates if perfmon is enabled or not
                             //!< - bit 1 indicates if dynamic Pstate is capable or not
                             //!< - bit 2 indicates if dynamic Pstate is enable or not
                             //!< - all other bits must be set to 0
    NvU32   numPstates;      //!< The number of available p-states 
    NvU32   numClocks;       //!< The number of clock domains supported by each P-State
    struct
    {
        NV_GPU_PERF_PSTATE_ID   pstateId; //!< ID of the p-state.  
        NvU32                   flags;    //!< - bit 0 indicates if the PCIE limit is GEN1 or GEN2
                                          //!< - bit 1 indicates if the Pstate is overclocked or not
                                          //!< - bit 2 indicates if the Pstate is overclockable or not
                                          //!< - all other bits must be set to 0
        struct
        {
            NV_GPU_PUBLIC_CLOCK_ID           domainId;  //!< ID of the clock domain   
            NvU32                               flags;  //!< Reserved. Must be set to 0
            NvU32                                freq;  //!< Clock frequency in kHz

        } clocks[NVAPI_MAX_GPU_PERF_CLOCKS];
    } pstates[NVAPI_MAX_GPU_PERF_PSTATES];

} NV_GPU_PERF_PSTATES_INFO_V1;


//! \ingroup gpupstate
typedef struct
{
    NvU32   version;
    NvU32   flags;             //!< - bit 0 indicates if perfmon is enabled or not
                               //!< - bit 1 indicates if dynamic Pstate is capable or not
                               //!< - bit 2 indicates if dynamic Pstate is enable or not
                               //!< - all other bits must be set to 0
    NvU32   numPstates;        //!< The number of available p-states 
    NvU32   numClocks;         //!< The number of clock domains supported by each P-State   
    NvU32   numVoltages; 
    struct
    {
        NV_GPU_PERF_PSTATE_ID   pstateId;  //!< ID of the p-state. 
        NvU32                   flags;     //!< - bit 0 indicates if the PCIE limit is GEN1 or GEN2
                                           //!< - bit 1 indicates if the Pstate is overclocked or not
                                           //!< - bit 2 indicates if the Pstate is overclockable or not
                                           //!< - all other bits must be set to 0
        struct
        {
            NV_GPU_PUBLIC_CLOCK_ID            domainId;       
            NvU32                                flags; //!< bit 0 indicates if this clock is overclockable
                                                        //!< all other bits must be set to 0
            NvU32                                 freq;

        } clocks[NVAPI_MAX_GPU_PERF_CLOCKS];
        struct
        {
            NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID domainId; //!< ID of the voltage domain, containing flags and mvolt info 
            NvU32                       flags;           //!< Reserved for future use. Must be set to 0
            NvU32                       mvolt;           //!< Voltage in mV  

        } voltages[NVAPI_MAX_GPU_PERF_VOLTAGES];

    } pstates[NVAPI_MAX_GPU_PERF_PSTATES];  //!< Valid index range is 0 to numVoltages-1

} NV_GPU_PERF_PSTATES_INFO_V2;

//! \ingroup gpupstate
typedef  NV_GPU_PERF_PSTATES_INFO_V2 NV_GPU_PERF_PSTATES_INFO;


//! \ingroup gpupstate
//! @{

//! Macro for constructing the version field of NV_GPU_PERF_PSTATES_INFO_V1 
#define NV_GPU_PERF_PSTATES_INFO_VER1  MAKE_NVAPI_VERSION(NV_GPU_PERF_PSTATES_INFO_V1,1)

//! Macro for constructing the version field of NV_GPU_PERF_PSTATES_INFO_V2 
#define NV_GPU_PERF_PSTATES_INFO_VER2  MAKE_NVAPI_VERSION(NV_GPU_PERF_PSTATES_INFO_V2,2)

//! Macro for constructing the version field of NV_GPU_PERF_PSTATES_INFO_V2 
#define NV_GPU_PERF_PSTATES_INFO_VER3  MAKE_NVAPI_VERSION(NV_GPU_PERF_PSTATES_INFO_V2,3)

//! Macro for constructing the version field of NV_GPU_PERF_PSTATES_INFO 
#define NV_GPU_PERF_PSTATES_INFO_VER   NV_GPU_PERF_PSTATES_INFO_VER3

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetPstatesInfo
//
//! DESCRIPTION:     This API retrieves all performance states (P-States) information.
//!
//!                  P-States are GPU active/executing performance capability and power consumption states.
//!                  P-States range from P0 to P15, with P0 being the highest performance/power state, and
//!                  P15 being the lowest performance/power state. Each P-State, if available, maps to a
//!                  performance level. Not all P-States are available on a given system. The definition
//!                  of each P-States are currently as follow:
//!                  - P0/P1 - Maximum 3D performance
//!                  - P2/P3 - Balanced 3D performance-power
//!                  - P8 - Basic HD video playback
//!                  - P10 - DVD playback
//!                  - P12 - Minimum idle power consumption
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 185
//!
//! \param [in]   hPhysicalGPU   GPU selection.
//! \param [out]  pPerfPstates   P-States information retrieved, as detailed below:
//!
//! \retval ::NVAPI_OK 
//! \retval ::NVAPI_ERROR 
//! \retval ::NVAPI_HANDLE_INVALIDATED 
//! \retval ::NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE 
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION  The version of the NV_GPU_PERF_PSTATES struct is not supported
//!
//! \ingroup gpupstate
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetPstatesInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_PERF_PSTATES_INFO *pPerfPstatesInfo);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetPstatesInfoEx
//
//! DESCRIPTION:     This API retrieves all performance states (P-States) information. This is the same as
//!                  NvAPI_GPU_GetPstatesInfo(), but supports an input flag for various options.
//!
//!                  P-States are GPU active/executing performance capability and power consumption states.
//!
//!                  P-States ranges from P0 to P15, with P0 being the highest performance/power state, and
//!                  P15 being the lowest performance/power state. Each P-State, if available, maps to a
//!                  performance level. Not all P-States are available on a given system. The definitions
//!                  of each P-State are currently as follows: \n
//!                  - P0/P1 - Maximum 3D performance
//!                  - P2/P3 - Balanced 3D performance-power
//!                  - P8 - Basic HD video playback
//!                  - P10 - DVD playback
//!                  - P12 - Minimum idle power consumption
//!
//! \deprecated  Do not use this function - it is deprecated in release 304. Instead, use NvAPI_GPU_GetPstates20.
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \param [in]     hPhysicalGPU       GPU selection.
//! \param [out]    pPerfPstatesInfo   P-States information retrieved, as detailed below: \n
//!                  - flags is reserved for future use.
//!                  - numPstates is the number of available P-States
//!                  - numClocks is the number of clock domains supported by each P-State
//!                  - pstates has valid index range from 0 to numPstates - 1
//!                  - pstates[i].pstateId is the ID of the P-State,
//!                      containing the following info:
//!                    - pstates[i].flags containing the following info:
//!                        - bit 0 indicates if the PCIE limit is GEN1 or GEN2
//!                        - bit 1 indicates if the Pstate is overclocked or not
//!                        - bit 2 indicates if the Pstate is overclockable or not
//!                    - pstates[i].clocks has valid index range from 0 to numClocks -1
//!                    - pstates[i].clocks[j].domainId is the public ID of the clock domain,
//!                        containing the following info:
//!                      - pstates[i].clocks[j].flags containing the following info:
//!                          bit 0 indicates if the clock domain is overclockable or not
//!                      - pstates[i].clocks[j].freq is the clock frequency in kHz
//!                    - pstates[i].voltages has a valid index range from 0 to numVoltages - 1
//!                    - pstates[i].voltages[j].domainId is the ID of the voltage domain,
//!                        containing the following info:
//!                      - pstates[i].voltages[j].flags is reserved for future use.
//!                      - pstates[i].voltages[j].mvolt is the voltage in mV
//!                  inputFlags(IN)   - This can be used to select various options:
//!                    - if bit 0 is set, pPerfPstatesInfo would contain the default settings
//!                        instead of the current, possibily overclocked settings.
//!                    - if bit 1 is set, pPerfPstatesInfo would contain the maximum clock 
//!                        frequencies instead of the nominal frequencies.
//!                    - if bit 2 is set, pPerfPstatesInfo would contain the minimum clock 
//!                        frequencies instead of the nominal frequencies.
//!                    - all other bits must be set to 0.
//!
//! \retval ::NVAPI_OK                            Completed request
//! \retval ::NVAPI_ERROR                         Miscellaneous error occurred
//! \retval ::NVAPI_HANDLE_INVALIDATED            Handle passed has been invalidated (see user guide)
//! \retval ::NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION   The version of the NV_GPU_PERF_PSTATES struct is not supported
//!
//! \ingroup gpupstate 
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 304. Instead, use NvAPI_GPU_GetPstates20.")
NVAPI_INTERFACE NvAPI_GPU_GetPstatesInfoEx(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_PERF_PSTATES_INFO *pPerfPstatesInfo, NvU32 inputFlags);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_SetPstatesInfo
//
//! DESCRIPTION:     This API set the performance states (P-States) of the specified GPU.
//!
//!                  P-States are GPU active/executing performance capability and power consumption states.
//!                  P-States ranges from P0 to P15, with P0 being the highest performance/power state, and
//!                  P15 being the lowest performance/power state. Each P-State, if available, maps to a
//!                  performance level. Not all P-States are available on a given system. The definition
//!                  of each P-States are currently as follow:
//!                    - P0/P1 - Maximum 3D performance
//!                    - P2/P3 - Balanced 3D performance-power
//!                    - P8 - Basic HD video playback
//!                    - P10 - DVD playback
//!                    - P12 - Minimum idle power consumption
//!
//!                  The changes this API makes are *not* persistent across a driver unload or reboot.  
//!                  Client applications must handle enforcing persistence.  However, client apps should
//!                  also be careful not to persist bad pstate configurations across reboots (i.e. if the
//!                  bad pstate configuration hangs the chip and the client application always applies that
//!                  configuration on boot, the user will never be able to boot and revert those changes
//!                  without booting to safe mode).
//!
//!                  NOTE: This API was introduced starting with NV_GPU_PERF_PSTATES_INFO structure version 
//!                  NV_GPU_PERF_PSTATES_INFO_VER2.  This API must be called with structure version 
//!                  >= NV_GPU_PERF_PSTATES_INFO_VER2.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \param [in]      hPhysicalGPU   GPU selection.
//! \param [in]      pPerfPstates   P-States information retrieved, as detailed below:
//!                  - flags is reserved for future use.
//!                  - numPstates the number of p-states specified
//!                  - numClocks is the number of clock domains specified in each p-state.
//!                  - numVoltages is the number of voltage domains specified in each p-State
//!                  - pstates has valid index range from 0 to numPstates - 1
//!                  - pstates[i].pstateId is the ID of the P-State,
//!                      containing the following info:
//!                    - pstates[i].flags is reserved for future use
//!                    - pstates[i].clocks has valid index range from 0 to numClocks -1
//!                    - pstates[i].clocks[j].domainId is the public ID of the clock domain,
//!                        containing the following info:
//!                      - pstates[i].clocks[j].flags is reserved for future use.
//!                      - pstates[i].clocks[j].freq is the clock frequency in kHz
//!                    - pstates[i].voltages has a valid index range from 0 to numVoltages - 1
//!                    - pstates[i].voltages[j].domainId is the ID of the voltage domain,
//!                        containing the following info:
//!                      - pstates[i].voltages[j].flags is reserved for future use.
//!                      - pstates[i].voltages[j].mvolt is the voltage in mV
//!
//! \retval ::NVAPI_OK - completed request
//! \retval ::NVAPI_ERROR - miscellaneous error occurred
//! \retval ::NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//! \retval ::NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the NV_GPU_PERF_PSTATES struct is not supported
//!
//! \ingroup gpupstate
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetPstatesInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_PERF_PSTATES_INFO *pPerfPstatesInfo);


//! \addtogroup gpupstate
//! @{

#define NVAPI_MAX_GPU_PSTATE20_PSTATES          16
#define NVAPI_MAX_GPU_PSTATE20_CLOCKS           8
#define NVAPI_MAX_GPU_PSTATE20_BASE_VOLTAGES    4

//! Used to identify clock type
typedef enum
{
    //! Clock domains that use single frequency value within given pstate
    NVAPI_GPU_PERF_PSTATE20_CLOCK_TYPE_SINGLE = 0,

    //! Clock domains that allow range of frequency values within given pstate
    NVAPI_GPU_PERF_PSTATE20_CLOCK_TYPE_RANGE,
} NV_GPU_PERF_PSTATE20_CLOCK_TYPE_ID;

//! Used to describe both voltage and frequency deltas
//! Fields marked with [SET] must be populated when making NvAPI_GPU_SetPstates20() call.
typedef struct
{
    //! [SET] 
    //! Value of parameter delta (in respective units [kHz, uV])
    NvS32       value;

    struct
    {
        //! Min value allowed for parameter delta (in respective units [kHz, uV])
        NvS32   min;

        //! Max value allowed for parameter delta (in respective units [kHz, uV])
        NvS32   max;
    } valueRange;
} NV_GPU_PERF_PSTATES20_PARAM_DELTA;

//! Used to describe single clock entry
//! Fields marked with [SET] must be populated when making NvAPI_GPU_SetPstates20() call.
typedef struct
{
    //! [SET] 
    //! ID of the clock domain
    NV_GPU_PUBLIC_CLOCK_ID                      domainId;

    //! Clock type ID
    NV_GPU_PERF_PSTATE20_CLOCK_TYPE_ID          typeId;
    //! Set if this clock domain can be modified using NvAPI_GPU_SetPstates20() call,
    //! otherwise it is cleared
    NvU32                                       bIsEditable:1;

    //! These bits are reserved for future use (must be always 0)
    NvU32                                       reserved:31;

    //! [SET] 
    //! Current frequency delta from nominal settings in (kHz)
    NV_GPU_PERF_PSTATES20_PARAM_DELTA           freqDelta_kHz;

    //! Clock domain type dependant information
    union
    {
        struct
        {
            //! Clock frequency within given pstate in (kHz)
            NvU32                               freq_kHz;
        } single;

        struct
        {
            //! Min clock frequency within given pstate in (kHz)
            NvU32                               minFreq_kHz;

            //! Max clock frequency within given pstate in (kHz)
            NvU32                               maxFreq_kHz;

            //! Voltage domain ID and value range in (uV) required for this clock
            NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID  domainId;
            NvU32                               minVoltage_uV;
            NvU32                               maxVoltage_uV;
        } range;
    } data;
} NV_GPU_PSTATE20_CLOCK_ENTRY_V1;

//! Used to describe single base voltage entry
//! Fields marked with [SET] must be populated when making NvAPI_GPU_SetPstates20() call.
typedef struct
{
    //! [SET] 
    //! ID of the voltage domain
    NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID  domainId;
    //! Set if this voltage domain can be modified using NvAPI_GPU_SetPstates20() call,
    //! otherwise it is cleared
    NvU32                               bIsEditable:1;

    //! These bits are reserved for future use (must be always 0)
    NvU32                               reserved:31;

    //! Current base voltage settings in [uV]
    NvU32                               volt_uV;

    //! [SET] 
    NV_GPU_PERF_PSTATES20_PARAM_DELTA   voltDelta_uV; // Current base voltage delta from nominal settings in [uV]
} NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1;

//! Used in NvAPI_GPU_GetPstates20() interface call.
//! Structure is used to retrieve/modify current clock and voltage pstate settings.
//! Fields marked with [SET] must be populated when making NvAPI_GPU_SetPstates20() call.

typedef struct
{
    //! [SET] 
    //! Version info of the structure (NV_GPU_PERF_PSTATES20_INFO_VER<n>)
    NvU32   version; 

    //! Set if at least one pstate parameter (clock and/or voltage) on this GPU
    //! can be modified using NvAPI_GPU_SetPstates20() call, otherwise it is cleared
    NvU32   bIsEditable:1;

    //! These bits are reserved for future use (must be always 0)
    NvU32   reserved:31;

    //! [SET] 
    //! Number of populated pstates
    NvU32   numPstates;

    //! [SET] 
    //! Number of populated clocks (per pstate)
    NvU32   numClocks;

    //! [SET] 
    //! Number of populated base voltages (per pstate)
    NvU32   numBaseVoltages;

    //! Performance state (P-State) settings
    //! Valid index range is 0 to numPstates-1
    struct
    {
    //! [SET] 
    //! ID of the P-State
        NV_GPU_PERF_PSTATE_ID                   pstateId;

        //! Set if at least one parameter (clock and/or voltage) within this pstate
        //! can be modified using NvAPI_GPU_SetPstates20() call, otherwise it is cleared
        NvU32                                   bIsEditable:1;

        //! These bits are reserved for future use (must be always 0)
        NvU32                                   reserved:31;

        //! Array of clock entries
        //! Valid index range is 0 to numClocks-1
        NV_GPU_PSTATE20_CLOCK_ENTRY_V1          clocks[NVAPI_MAX_GPU_PSTATE20_CLOCKS];

        //! Array of baseVoltage entries
        //! Valid index range is 0 to numBaseVoltages-1
        NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1   baseVoltages[NVAPI_MAX_GPU_PSTATE20_BASE_VOLTAGES];
    } pstates[NVAPI_MAX_GPU_PSTATE20_PSTATES];
} NV_GPU_PERF_PSTATES20_INFO_V1;

//! Used in NvAPI_GPU_GetPstates20() interface call.
//! Structure is used to retrieve/modify current clock and voltage pstate settings.
//! Fields marked with [SET] must be populated when making NvAPI_GPU_SetPstates20() call.

typedef struct _NV_GPU_PERF_PSTATES20_INFO_V2
{
    //! [SET] 
    //! Version info of the structure (NV_GPU_PERF_PSTATES20_INFO_VER<n>)
    NvU32   version; 

    //! Set if at least one pstate parameter (clock and/or voltage) on this GPU
    //! can be modified using NvAPI_GPU_SetPstates20() call, otherwise it is cleared
    NvU32   bIsEditable:1;

    //! These bits are reserved for future use (must be always 0)
    NvU32   reserved:31;

    //! [SET] 
    //! Number of populated pstates
    NvU32   numPstates;

    //! [SET] 
    //! Number of populated clocks (per pstate)
    NvU32   numClocks;

    //! [SET] 
    //! Number of populated base voltages (per pstate)
    NvU32   numBaseVoltages;

    //! Performance state (P-State) settings
    //! Valid index range is 0 to numPstates-1
    struct
    {
    //! [SET] 
    //! ID of the P-State
        NV_GPU_PERF_PSTATE_ID                   pstateId;

        //! Set if at least one parameter (clock and/or voltage) within this pstate
        //! can be modified using NvAPI_GPU_SetPstates20() call, otherwise it is cleared
        NvU32                                   bIsEditable:1;

        //! These bits are reserved for future use (must be always 0)
        NvU32                                   reserved:31;

        //! Array of clock entries
        //! Valid index range is 0 to numClocks-1
        NV_GPU_PSTATE20_CLOCK_ENTRY_V1          clocks[NVAPI_MAX_GPU_PSTATE20_CLOCKS];

        //! Array of baseVoltage entries
        //! Valid index range is 0 to numBaseVoltages-1
        NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1   baseVoltages[NVAPI_MAX_GPU_PSTATE20_BASE_VOLTAGES];
    } pstates[NVAPI_MAX_GPU_PSTATE20_PSTATES];

    //! OV settings - Please refer to NVIDIA over-volting recommendation to understand impact of this functionality
    //! Valid index range is 0 to numVoltages-1
    struct
    {
        //! [SET] 
        //! Number of populated voltages
        NvU32                                 numVoltages;

        //! Array of voltage entries
        //! Valid index range is 0 to numVoltages-1
        NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1 voltages[NVAPI_MAX_GPU_PSTATE20_BASE_VOLTAGES];
    } ov;
} NV_GPU_PERF_PSTATES20_INFO_V2;

typedef NV_GPU_PERF_PSTATES20_INFO_V2   NV_GPU_PERF_PSTATES20_INFO;

//! Macro for constructing the version field of NV_GPU_PERF_PSTATES20_INFO_V1
#define NV_GPU_PERF_PSTATES20_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_PSTATES20_INFO_V1,1)

//! Macro for constructing the version field of NV_GPU_PERF_PSTATES20_INFO_V2
#define NV_GPU_PERF_PSTATES20_INFO_VER2 MAKE_NVAPI_VERSION(NV_GPU_PERF_PSTATES20_INFO_V2,2)

//! Macro for constructing the version field of NV_GPU_PERF_PSTATES20_INFO_V2
#define NV_GPU_PERF_PSTATES20_INFO_VER3 MAKE_NVAPI_VERSION(NV_GPU_PERF_PSTATES20_INFO_V2,3)

//! Macro for constructing the version field of NV_GPU_PERF_PSTATES20_INFO
#define NV_GPU_PERF_PSTATES20_INFO_VER  NV_GPU_PERF_PSTATES20_INFO_VER3

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetPstates20
//
//! DESCRIPTION:    This API retrieves all performance states (P-States) 2.0 information.
//!
//!                 P-States are GPU active/executing performance capability states.
//!                 They range from P0 to P15, with P0 being the highest performance state,
//!                 and P15 being the lowest performance state. Each P-State, if available,
//!                 maps to a performance level. Not all P-States are available on a given system.
//!                 The definition of each P-States are currently as follow:
//!                 - P0/P1 - Maximum 3D performance
//!                 - P2/P3 - Balanced 3D performance-power
//!                 - P8 - Basic HD video playback
//!                 - P10 - DVD playback
//!                 - P12 - Minimum idle power consumption
//!
//! TCC_SUPPORTED
//!
//! \since Release: 295
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   hPhysicalGPU  GPU selection
//! \param [out]  pPstatesInfo  P-States information retrieved, as documented in declaration above
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. 
//!          If there are return error codes with specific meaning for this API, 
//!          they are listed below.
//!
//! \ingroup gpupstate
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetPstates20(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_PERF_PSTATES20_INFO *pPstatesInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_SetPstates20
//
//! DESCRIPTION:    This API sets the performance states (P-States) 2.0 information.
//!                 This API can modify only parameters (frequencies/voltages) that
//!                 support overrides by specifying delta offset to the parameter's nominal
//!                 value (as advertized in the flags of given parameter).
//!                 It replaces existing deprecated API calls NvAPI_GPU_SetPstatesInfo().
//!
//!                 Note: Only fields marked as [SET] are required to be populated within
//!                       the NV_GPU_PERF_PSTATES20_INFO structure before calling this API.
//!                 Note: Call expects correctly populated structure, and obsolete voltage
//!                       and/or clock entries can be ignored providing _UNDEFINDED ID-s
//!                       (NVAPI_GPU_PERF_VOLTAGE_INFO_DOMAIN_UNDEFINED or
//!                        NVAPI_GPU_PUBLIC_CLOCK_UNDEFINED respectively)
//!
//!                 P-States are GPU active/executing performance capability states.
//!                 They range from P0 to P15, with P0 being the highest performance state,
//!                 and P15 being the lowest performance state. Each P-State, if available,
//!                 maps to a performance level. Not all P-States are available on a given system.
//!                 The definition of each P-States are currently as follow:
//!                 - P0/P1 - Maximum 3D performance
//!                 - P2/P3 - Balanced 3D performance-power
//!                 - P8 - Basic HD video playback
//!                 - P10 - DVD playback
//!                 - P12 - Minimum idle power consumption
//!
//! \since Release: 295
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   hPhysicalGPU  GPU selection
//! \param [out]  pPstatesInfo  P-States information to be applied
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. 
//!          If there are return error codes with specific meaning for this API, 
//!          they are listed below.
//! \retval  NVAPI_NOT_SUPPORTED            at least one requested parameter cannot be modified as requested
//! \retval  NVAPI_INVALID_USER_PRIVILEGE   the caller does not have administrative privileges
//!
//! \ingroup gpupstate
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetPstates20(__in NvPhysicalGpuHandle hPhysicalGpu, __in NV_GPU_PERF_PSTATES20_INFO *pPstatesInfo);




//! \addtogroup gpupstate
//! @{

#define NVAPI_MAX_GPU_PSTATE20_CLOCKS_PRIVATE       16
#define NVAPI_MAX_GPU_PSTATE20_VOLTAGES_PRIVATE      8

//! Used to describe single private clock entry
//! Fields marked with [SET] must be populated when making NvAPI_GPU_SetPstates20Private() call.
typedef struct
{
    //! [SET] ID of the clock domain
    NV_GPU_CLOCK_DOMAIN_ID                      domainId;

    //! Clock usage ID
    NV_GPU_CLOCK_INFO_DOMAIN_PSTATE_USAGE       usage;

    //! Set if this clock domain can be modified using NvAPI_GPU_SetPstates20Private() call,
    //! otherwise it is cleared
    NvU32                                       bIsEditable:1;

    //! These bits are reserved for future use (must be always 0)
    NvU32                                       reserved:31;

    //! [SET] Current frequency delta from nominal settings in [kHz]
    NV_GPU_PERF_PSTATES20_PARAM_DELTA           freqDelta_kHz;

    //! Clock usage dependant information
    union
    {
        struct
        {
            //! Clock frequency in (kHz)
            NvU32                               freq_kHz;
        } fixed;

        struct
        {
            //! Clock frequency within given pstate in (kHz)
            NvU32                               freq_kHz;
        } pstate;

        struct
        {
            //! Min clock frequency withing given pstate in (kHz)
            NvU32                               minFreq_kHz;

            //! Max clock frequency withing given pstate in (kHz)
            NvU32                               maxFreq_kHz;

            //! Voltage domain ID and value range in (uV) required for this clock
            NV_GPU_PERF_VOLTAGE_DOMAIN_ID       domainId;
            NvU32                               minVoltage_uV;
            NvU32                               maxVoltage_uV;
        } decoupled;

        struct
        {
            //! Min clock frequency withing given pstate in (kHz)
            NvU32                               minFreq_kHz;

            //! Max clock frequency withing given pstate in (kHz)
            NvU32                               maxFreq_kHz;
        } ratio;
    } data;
} NV_GPU_PSTATE20_PRIVATE_CLOCK_ENTRY_V1;

typedef enum _NV_GPU_PSTATE20_VOLTAGE_ENTRY_TYPE
{
    NV_GPU_PSTATE20_VOLTAGE_ENTRY_TYPE_LOGICAL    = 0x0,
    NV_GPU_PSTATE20_VOLTAGE_ENTRY_TYPE_VDT        = 0x1,
    NV_GPU_PSTATE20_VOLTAGE_ENTRY_TYPE_DELTA_ONLY = 0x2,
} NV_GPU_PSTATE20_VOLTAGE_ENTRY_TYPE;

//! Used to describe single private voltage entry
//! Fields marked with [SET] must be populated when making NvAPI_GPU_SetPstates20Private() call.
typedef struct
{
    //! [SET] ID of the voltage domain
    NV_GPU_PERF_VOLTAGE_DOMAIN_ID       domainId;

    //! [SET] Votage type ID
    NV_GPU_PSTATE20_VOLTAGE_ENTRY_TYPE  type;

    //! Set if this voltage domain can be modified using NvAPI_GPU_SetPstates20Private() call,
    //! otherwise it is cleared
    NvU32                               bIsEditable:1;

    //! These bits are reserved for future use (must be always 0)
    NvU32                               reserved:31;

    //! Current voltage settings, evaluated in [uV]
    NvU32                               volt_uV;

    //! [SET] Current voltage delta from nominal settings in [uV]
    NV_GPU_PERF_PSTATES20_PARAM_DELTA   voltDelta_uV;

    //! Voltage type dependant information
    union
    {
        struct
        {
            //! [SET] Nominal voltage settings in [uV]
            NvU32                       nominal_uV;
        } logical;

        struct
        {
            //! [SET] Nominal voltage settings as index to VDT
            NvU8                        vdtIndex;
        } vdt;

        //! Voltage type _DELTA_ONLY does not require additional information
    } data;
} NV_GPU_PSTATE20_VOLTAGE_ENTRY_V1;

//! Used in NvAPI_GPU_GetPstates20Private()/NvAPI_GPU_SetPstates20Private() interface calls.
//! Structure is used to retrieve/modify current clock and voltage pstate settings.
//! Fields marked with [SET] must be populated when making NvAPI_GPU_SetPstates20Private() call.
typedef struct
{
    //! [SET] Version info of the structure (NV_GPU_PERF_PSTATES20_PRIVATE_INFO_VER<n>)
    NvU32   version;

    //! Set if at least one pstate parameter (clock and/or voltage) on this GPU
    //! can be modified using NvAPI_GPU_SetPstates20Private() call, otherwise it is cleared
    NvU32   bIsEditable:1;

    //! These bits are reserved for future use (must be always 0)
    NvU32   reserved:31;

    //! [SET] Number of populated pstates
    NvU32   numPstates;

    //! [SET] Number of populated clocks (per pstate)
    NvU32   numClocks;

    //! [SET] Number of populated voltages (per pstate)
    NvU32   numVoltages;

    //! Performance state (P-State) settings
    //! Valid index range is 0 to numPstates-1
    struct
    {
        //! [SET] ID of the P-State
        NV_GPU_PERF_PSTATE_ID                   pstateId;

        //! Set if at least one parameter (clock and/or voltage) within this pstate can be
        //! modified using NvAPI_GPU_SetPstates20Private() call, otherwise it is cleared
        NvU32                                   bIsEditable:1;

        //! These bits are reserved for future use (must be always 0)
        NvU32                                   reserved:31;

        //! Array of clock entries
        //! Valid index range is 0 to numClocks-1
        NV_GPU_PSTATE20_PRIVATE_CLOCK_ENTRY_V1  clocks[NVAPI_MAX_GPU_PSTATE20_CLOCKS_PRIVATE];

        //! Array of voltage entries
        //! Valid index range is 0 to numVoltages-1
        NV_GPU_PSTATE20_VOLTAGE_ENTRY_V1        voltages[NVAPI_MAX_GPU_PSTATE20_VOLTAGES_PRIVATE];
    } pstates[NVAPI_MAX_GPU_PSTATE20_PSTATES];
} NV_GPU_PERF_PSTATES20_PRIVATE_INFO_V1;

//! Used in NvAPI_GPU_GetPstates20Private()/NvAPI_GPU_SetPstates20Private() interface calls.
//! Structure is used to retrieve/modify current clock and voltage pstate settings.
//! Fields marked with [SET] must be populated when making NvAPI_GPU_SetPstates20Private() call.
typedef struct _NV_GPU_PERF_PSTATES20_PRIVATE_INFO_V2
{
    //! [SET] Version info of the structure (NV_GPU_PERF_PSTATES20_PRIVATE_INFO_VER<n>)
    NvU32   version;

    //! Set if at least one pstate parameter (clock and/or voltage) on this GPU
    //! can be modified using NvAPI_GPU_SetPstates20Private() call, otherwise it is cleared
    NvU32   bIsEditable:1;

    //! Pass the internal test flag to RM.
    NvU32   bSetPStates20InternalTestFlag:1;

    //! These bits are reserved for future use (must be always 0)
    NvU32   reserved:30;

    //! [SET] Number of populated pstates
    NvU32   numPstates;

    //! [SET] Number of populated clocks (per pstate)
    NvU32   numClocks;

    //! [SET] Number of populated voltages (per pstate)
    NvU32   numVoltages;

    //! Performance state (P-State) settings
    //! Valid index range is 0 to numPstates-1
    struct
    {
        //! [SET] ID of the P-State
        NV_GPU_PERF_PSTATE_ID                   pstateId;

        //! Set if at least one parameter (clock and/or voltage) within this pstate can be
        //! modified using NvAPI_GPU_SetPstates20Private() call, otherwise it is cleared
        NvU32                                   bIsEditable:1;

        //! These bits are reserved for future use (must be always 0)
        NvU32                                   reserved:31;

        //! Array of clock entries
        //! Valid index range is 0 to numClocks-1
        NV_GPU_PSTATE20_PRIVATE_CLOCK_ENTRY_V1  clocks[NVAPI_MAX_GPU_PSTATE20_CLOCKS_PRIVATE];

        //! Array of voltage entries
        //! Valid index range is 0 to numVoltages-1
        NV_GPU_PSTATE20_VOLTAGE_ENTRY_V1        voltages[NVAPI_MAX_GPU_PSTATE20_VOLTAGES_PRIVATE];
    } pstates[NVAPI_MAX_GPU_PSTATE20_PSTATES];

    //! OV settings
    //! Valid index range is 0 to numVoltages-1
    struct
    {
        //! [SET] Number of populated voltages
        NvU32                            numVoltages;

        //! Array of voltage entries
        //! Valid index range is 0 to numVoltages-1
        NV_GPU_PSTATE20_VOLTAGE_ENTRY_V1 voltages[NVAPI_MAX_GPU_PSTATE20_VOLTAGES_PRIVATE];
    } ov;
} NV_GPU_PERF_PSTATES20_PRIVATE_INFO_V2;

typedef NV_GPU_PERF_PSTATES20_PRIVATE_INFO_V2   NV_GPU_PERF_PSTATES20_PRIVATE_INFO;

//! Macro for constructing the version field of NV_GPU_PERF_PSTATES20_PRIVATE_INFO_V1
#define NV_GPU_PERF_PSTATES20_PRIVATE_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_PSTATES20_PRIVATE_INFO_V1,1)

//! Macro for constructing the version field of NV_GPU_PERF_PSTATES20_PRIVATE_INFO_V2
#define NV_GPU_PERF_PSTATES20_PRIVATE_INFO_VER2 MAKE_NVAPI_VERSION(NV_GPU_PERF_PSTATES20_PRIVATE_INFO_V2,2)

//! Macro for constructing the version field of NV_GPU_PERF_PSTATES20_PRIVATE_INFO
#define NV_GPU_PERF_PSTATES20_PRIVATE_INFO_VER  NV_GPU_PERF_PSTATES20_PRIVATE_INFO_VER2

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetPstates20Private
//
//! DESCRIPTION:    This API retrieves all performance states (P-States) 2.0 information,
//!                 as internal/enhanced version of NvAPI_GPU_GetPstates20() NDA call.
//!                 It replaces existing deprecated API calls NvAPI_GPU_GetPstates()
//!                 and NvAPI_GPU_GetPstatesEx().
//!
//!                 P-States are GPU active/executing performance capability states.
//!                 They range from P0 to P15, with P0 being the highest performance state,
//!                 and P15 being the lowest performance state. Each P-State, if available,
//!                 maps to a performance level. Not all P-States are available on a given system.
//!                 The definition of each P-States are currently as follow:
//!                 - P0/P1 - Maximum 3D performance
//!                 - P2/P3 - Balanced 3D performance-power
//!                 - P8 - Basic HD video playback
//!                 - P10 - DVD playback
//!                 - P12 - Minimum idle power consumption
//!
//! \since Release: 295
//!
//! TCC_SUPPORTED
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   hPhysicalGPU  GPU selection
//! \param [out]  pPstatesInfo  P-States information retrieved, as documented in declaration above
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. 
//!          If there are return error codes with specific meaning for this API, 
//!          they are listed below.
//!
//! \ingroup gpupstate
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetPstates20Private(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_PERF_PSTATES20_PRIVATE_INFO *pPstatesInfo);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_SetPstates20Private
//
//! DESCRIPTION:    This API sets the performance states (P-States) 2.0 information,
//!                 as internal/enhanced version of NvAPI_GPU_SetPstates20() NDA call.
//!                 This API can modify only parameters (frequencies/voltages) that
//!                 support overrides by specifying delta offset to the parameter's nominal
//!                 value (as advertized in the flags of given parameter).
//!                 It replaces existing deprecated API calls NvAPI_GPU_SetPstates().
//!
//!                 Note: Only fields marked as [SET] are required to be populated within the
//!                       NV_GPU_PERF_PSTATES20_PRIVATE_INFO structure before calling this API.
//!                 Note: Call expects correctly populated structure, and obsolete voltage
//!                       and/or clock entries can be ignored providing _UNDEFINDED ID-s
//!                       (NVAPI_GPU_PERF_VOLTAGE_INFO_DOMAIN_UNDEFINED or
//!                        NVAPI_GPU_PUBLIC_CLOCK_UNDEFINED respectively)
//!
//!                 P-States are GPU active/executing performance capability states.
//!                 They range from P0 to P15, with P0 being the highest performance state,
//!                 and P15 being the lowest performance state. Each P-State, if available,
//!                 maps to a performance level. Not all P-States are available on a given system.
//!                 The definition of each P-States are currently as follow:
//!                 - P0/P1 - Maximum 3D performance
//!                 - P2/P3 - Balanced 3D performance-power
//!                 - P8 - Basic HD video playback
//!                 - P10 - DVD playback
//!                 - P12 - Minimum idle power consumption
//!
//! \since Release: 295
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   hPhysicalGPU  GPU selection
//! \param [out]  pPstatesInfo  P-States information to be applied
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. 
//!          If there are return error codes with specific meaning for this API, 
//!          they are listed below.
//!
//! \retval ::NVAPI_NOT_SUPPORTED           - at least one requested parameter cannot be modified as requested
//! \retval ::NVAPI_INVALID_USER_PRIVILEGE  - the caller does not have administrative privileges
//!
//! \ingroup gpupstate
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetPstates20Private(__in NvPhysicalGpuHandle hPhysicalGpu, __in NV_GPU_PERF_PSTATES20_PRIVATE_INFO *pPstatesInfo);



//! \ingroup gpupstate
//! @{

//! Used in \ref NV_GPU_PERF_VF_TABLES_V1.  Describes a VF Indexes Table
//! entry, specifying a range of VF Entries Table entries for a given clock
//! domain and pstate.
#define NV_GPU_PERF_VF_INDEXES_TABLE_MAX_ENTRIES_V1                           64
typedef struct
{
    /*!
     * Pstate for this VF Indexes Table entry.  NVAPI_GPU_PERF_PSTATE_ALL
     * applies to all pstates not otherwise specified for the given clock
     * domain.
     */
    NV_GPU_PERF_PSTATE_ID   pstateId;
    /*!
     * Clock domain for this VF Indexes Table entry.
     */
    NV_GPU_CLOCK_DOMAIN_ID  domainId;
    /*!
     * First index into the VF Entries Table for this pstate and clock domain.
     */
    NvU32                   entryIndexFirst;
    /*!
     * Last index into the VF Entries Table for this pstate and clock domain.
     */
    NvU32                   entryIndexLast;
} NV_GPU_PERF_VF_INDEXES_TABLE_ENTRY_V1;

//! Used in \ref NV_GPU_PERF_VF_TABLES_V1.  Describes a VF Entries Table
//! entry, correlating a maximum frequency point to its required minimum
//! voltage.
#define NV_GPU_PERF_VF_ENTRIES_TABLE_MAX_ENTRIES_V1                           64
#define NV_GPU_PERF_VF_ENTRIES_TABLE_MAX_ENTRIES_V2                          128
#define NV_GPU_PERF_VF_ENTRIES_TABLE_STEP_SIZE_NONE                            0
#define NV_GPU_PERF_VF_ENTRIES_TABLE_STEP_SIZE_ALL                             1
typedef struct
{
    /*!
     * Maximum supported frequency in (KHz) for this VF Entries Table entry.
     */
    NvU32                   maxFreqKHz;
    /*!
     * Step size to use for values below this maximum frequency while still
     * applying this entry.  Note special values
     * NV_GPU_PERF_VF_ENTRIES_TABLE_STEP_SIZE_NONE and
     * NV_GPU_PERF_VF_ENTRIES_TABLE_STEP_SIZE_ALL, which correspond to no steps
     * below and and infinite steps below, respectively.
     */
    NvU32                   freqStepSizeKHz;
    /*!
     * Flags bit field.
     */
    NvU32                   bForcePll:1;       //!< - Clock is forced to source from PLL
    NvU32					bForceBypass:1;    //!< - Clock is forced to source from bypass
    NvU32                   flags:30;		   //!< - Currently unused/reserved. Must be set to 0
    /*!
     * Minimum required voltage for this VF Entries Table entry.
     */
    struct
    {
        NV_GPU_PERF_VOLTAGE_DOMAIN_ID domainId;  //!< ID of the voltage domain
        NvU32                       flags;       //!< -  bit 0 indicates that mvolt is evaluated from VDT
        NvU32                       mvolt;       //!< Voltage level in mV. 
    } voltage;
} NV_GPU_PERF_VF_ENTRIES_TABLE_ENTRY_V1;

//! Used in \ref NvAPI_GPU_PerfVfTablesGetInfo().
typedef struct
{
    /*!
     * Version of this structure.  Must always be first element in this structure.
     */
    NvU32 version;

    /*!
     * Number of VF Indexes Table entries in the indexes array.
     */
    NvU32 numIndexes;
    /*!
     * Array of VF Indexes Table entries.  This array has a valid index range of
     * 0 to numIndexes - 1.
     */
    NV_GPU_PERF_VF_INDEXES_TABLE_ENTRY_V1 indexes[NV_GPU_PERF_VF_INDEXES_TABLE_MAX_ENTRIES_V1];

    /*!
     * Number of VF Entires Table entries in the entries array.
     */
    NvU32 numEntries;
    /*!
     * Array of VF Entries Table entries.  This array has a valid index range of
     * 0 to numEntries - 1.
     */
    NV_GPU_PERF_VF_ENTRIES_TABLE_ENTRY_V1 entries[NV_GPU_PERF_VF_ENTRIES_TABLE_MAX_ENTRIES_V1];
} NV_GPU_PERF_VF_TABLES_V1;

//! Used in \ref NvAPI_GPU_PerfVfTablesGetInfo().
typedef struct _NV_GPU_PERF_VF_TABLES_V2
{
    NvU32 version;           //!< Version of this structure.  Must always be first element in this structure.

    NvU32 numIndexes;        //!< Number of VF Indexes Table entries in the indexes array.
    NV_GPU_PERF_VF_INDEXES_TABLE_ENTRY_V1 indexes[NV_GPU_PERF_VF_INDEXES_TABLE_MAX_ENTRIES_V1]; 
                             //!< Array of VF Indexes Table entries.  This array has a valid index range of 0 to numIndexes - 1.
    NvU32 numEntries;        //!< Number of VF Entires Table entries in the entries array.
    NV_GPU_PERF_VF_ENTRIES_TABLE_ENTRY_V1 entries[NV_GPU_PERF_VF_ENTRIES_TABLE_MAX_ENTRIES_V2]; 
                             //!< Array of VF Entries Table entries.  This array has a valid index range of 0 to numEntries - 1.
} NV_GPU_PERF_VF_TABLES_V2;

typedef NV_GPU_PERF_VF_TABLES_V2 NV_GPU_PERF_VF_TABLES;

//! Macro for constructing the version field of NV_GPU_PERF_VF_TABLES_V1
#define NV_GPU_PERF_VF_TABLES_VER1  MAKE_NVAPI_VERSION(NV_GPU_PERF_VF_TABLES_V1,1)
#define NV_GPU_PERF_VF_TABLES_VER2  MAKE_NVAPI_VERSION(NV_GPU_PERF_VF_TABLES_V2,2)

//! Macro for constructing the version field of NV_GPU_PERF_VF_TABLES
#define NV_GPU_PERF_VF_TABLES_VER   NV_GPU_PERF_VF_TABLES_VER2

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    NvAPI_GPU_PerfVfTablesGetInfo
//
//! DESCRIPTION:     This function retrieves the Voltage Frequency (VF) Tables
//!                  which describe various clocks' relationship between voltage
//!                  and frequency across various pstates.
//!
//!                  The Voltage Frequency Indexes Table provides the range of
//!                  indexes into the Voltage Frequency Entries Table for a
//!                  given clock domain in a given pstate.
//!
//!                  The Voltage Frequncy Entries Table provides the mapping
//!                  between various maximum frequency points and the voltages
//!                  required to sustain them.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 285
//!
//! \param [in]      hPhysicalGPU      GPU selection
//! \param [out]     pPerfVfTablesInfo Structure containing the description of the VF tables.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup   gpupstate
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_PerfVfTablesGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_PERF_VF_TABLES *pPerfVfTablesInfo);



//! \ingroup gpupstate
//! @{

/*!
 * Structure for static information describing the  RATED_TDP functionality.
 */
typedef struct
{
    /*!
     * Version of this structure.  Must always be first element in this structure.
     */
    NvU32 version;

    /*!
     * Boolean describing whether the RATED_TDP feature is supported on this
     * GPU.
     */
    NvU8  bSupported;
} NV_GPU_PERF_RATED_TDP_INFO_V1;

typedef NV_GPU_PERF_RATED_TDP_INFO_V1 NV_GPU_PERF_RATED_TDP_INFO;

//! Macro for constructing the version field of NV_GPU_PERF_RATED_TDP_INFO_V1
#define NV_GPU_PERF_RATED_TDP_INFO_VER1  MAKE_NVAPI_VERSION(NV_GPU_PERF_RATED_TDP_INFO_V1,1)

//! Macro for constructing the version field of NV_GPU_PERF_RATED_INFO
#define NV_GPU_PERF_RATED_TDP_INFO_VER   NV_GPU_PERF_RATED_TDP_INFO_VER1

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    NvAPI_GPU_PerfRatedTdpGetInfo
//
//! DESCRIPTION:     This command returns the static state describing the
//!                  RATED_TDP power/perf control capabilities on this GPU per the
//!                  clock/pstate/vpstate POR.
//!
//!                  The RATED_TDP point, specified per the VPstate Table, is
//!                  the maximum sustainable clock and voltage point w.r.t.
//!                  thermal/power for the given TDP app/workload - i.e. the
//!                  highest guaranteed clocks with respect to the various power
//!                  controllers.
//!
//!                  The RM's RATED_TDP functionality exposes the ability for
//!                  various clients to expose or limit VF points above
//!                  RATED_TDP - effectively limiting power-/thermal-aware boost
//!                  (GPUBoost, etc.).  This functionality can be useful to help
//!                  eliminate performance variation for profiling or for
//!                  synchronized workloads.
//!
//!                  https://wiki.nvidia.com/engwiki/index.php/Resman/PState/Data_Tables/VPState_Table
//!                  https://wiki.nvidia.com/engwiki/index.php/Resman/PState/Data_Tables/VPState_Table/1.0_Spec
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release:  313
//!
//! \param [in]      hPhysicalGPU      GPU selection
//! \param [out]     pInfo             Structure containing the description of the RATED_TDP feature.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup   gpupstate
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_PerfRatedTdpGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_PERF_RATED_TDP_INFO *pInfo);



//! \ingroup gpupstate
//! @{

/*!
 * Enumeration of the RATED_TDP arbitration clients which make requests to force
 * enable/disable VF points above the RATED_TDP point.
 *
 * These clients are sorted in descending priority - the RM will arbitrate
 * between all clients in order of priority, taking as output the first client
 * whose input action != @ref NV_GPU_PERF_RATED_TDP_ACTION_DEFAULT.
 */
typedef enum
{
    /*!
     * Internal RM client corresponding to the RM's internal state and features.
     * The RM client will either allow default behavior (@ref
     * NV_GPU_PERF_RATED_TDP_ACTION_DEFAULT) or will limit to RATED_TDP
     * (@ref NV_GPU_PERF_RATED_TDP_ACTION_FORCE_LIMIT) when no power
     * controllers are active.
     */
    NV_GPU_PERF_RATED_TDP_CLIENT_RM          = 0x0,
    /*!
     * Global client request.  This client is expected to be used by a global
     * switch functionality in an end-user tool, such as EVGA Precision, to
     * either force enabling boost above RATED_TDP (@ref
     * NV_GPU_PERF_RATED_TDP_ACTION_FORCE_EXCEED) or to force limiting to
     * RATED_TDP (@ref NV_GPU_PERF_RATED_TDP_ACTION_FORCE_LIMIT) across the
     * board, regardless of any app-profie settings.
     */
    NV_GPU_PERF_RATED_TDP_CLIENT_GLOBAL,
    /*!
     * Operating system request.  This client is expected to be used by the
     * operating system to set @ref NV_GPU_PERF_RATED_TDP_ACTION_FORCE_LOCK
     * for performance profiling.
     */
    NV_GPU_PERF_RATED_TDP_CLIENT_OS,
    /*!
     * App profile client requests.  This client is expected to be used by the
     * app-profile settings to either default to whatever was requested by
     * higher-priority clients (@ref NV_GPU_PERF_RATED_TDP_ACTION_DEFAULT)
     * or to limit to RATED_TDP (@ref
     * NV_GPU_PERF_RATED_TDP_ACTION_FORCE_LIMIT) for apps which have shown
     * bad behavior when boosting.
     */
    NV_GPU_PERF_RATED_TDP_CLIENT_PROFILE,
    /*!
     * Number of supported clients.
     *
     * @Note MUST ALWAY BE LAST!
     */
    NV_GPU_PERF_RATED_TDP_CLIENT_NUM_CLIENTS,
} NV_GPU_PERF_RATED_TDP_CLIENT;


/*!
 * Enumeration RATED_TDP actions - these are the requested actions clients can
 * make to change the behavior of the RATED_TDP functionality.
 */
typedef enum
{
    /*!
     * The default action - meaning no explicit request from the client other
     * than to take the default behavior (allowing boosting above RATED_TDP) or
     * any explicit actions from lower priority clients.
     */
    NV_GPU_PERF_RATED_TDP_ACTION_DEFAULT       = 0x0,
    /*!
     * Force allow boosting above RATED_TDP - this action explicitly requests
     * boosting above RATED_TDP, preventing lower priority clients to limit to
     * RATED_TDP.
     */
    NV_GPU_PERF_RATED_TDP_ACTION_FORCE_EXCEED,
    /*!
     * Force to limit above RATED_TDP - this action explicitly requests to limit
     * to RATED_TDP.  This is the opposite of the default behavior to allow
     * boosting above RATED_TDP.  Clients specify this action when they
     * explicitly need boost to be disabled (e.g. eliminating perf variation,
     * special apps which exhibit bad behavior, etc.).
     */
    NV_GPU_PERF_RATED_TDP_ACTION_FORCE_LIMIT,
    /*!
     * Lock to RATED_TDP - this action requests the clocks to be fixed at the
     * RATED_TDP.  Used for acheiving stable clocks required for profiling.
     */
    NV_GPU_PERF_RATED_TDP_ACTION_FORCE_LOCK,
} NV_GPU_PERF_RATED_TDP_ACTION;

/*!
 * Structure describing dynamic state of the RATED_TDP feature.
 */
typedef struct
{
    /*!
     * Version of this structure.  Must always be first element in this structure.
     */
    NvU32 version;

    /*!
     * Structure of internal RM state - these values are used to determine the
     * behavior of NV_GPU_PERF_RATED_TDP_CLIENT_RM per the RM's @ref
     * perfPwrRatedTdpLimitRegisterClientActive() interface.
     */
    struct
    {
        /*!
         * Mask of active client controllers (@ref PERF_PWR_RATED_TDP_CLIENT)
         * which are currently regulating TDP.  When this mask is zero,
         * NV_GPU_PERF_RATED_TDP_CLIENT_RM will request
         * NV_GPU_PERF_RATED_TDP_ACTION_FORCE_LIMIT.
         */
        NvU32 clientActiveMask;
        /*!
         * Boolean indicating that user has requested locking to RATED_TDP
         * vPstate via corresponding regkey NV_REG_STR_RM_PERF_RATED_TDP_LIMIT.
         * When the boolean value is true, NV_GPU_PERF_RATED_TDP_CLIENT_RM
         * will request NV_GPU_PERF_RATED_TDP_ACTION_FORCE_LIMIT.
         */
        NvU8  bRegkeyLimitRatedTdp;
    } rm;

    /*!
     * Arbitrated output action of all client requests (@ref inputs).  This is
     * the current state of the RATED_TDP feature.  Will only be @ref
     * NV_GPU_PERF_RATED_TDP_ACTION_FORCE_EXCEED, @ref
     * NV_GPU_PERF_RATED_TDP_ACTION_FORCE_LIMIT, or @ref
     * NV_GPU_PERF_RATED_TDP_ACTION_FORCE_LOCK.
     */
    NV_GPU_PERF_RATED_TDP_ACTION output;
    /*!
     * Array of input client request actions, indexed via @ref
     * NV_GPU_PERF_RATED_TDP_CLIENT_<xyz>.  RM will arbitrate between these
     * requests, choosing the highest priority request != @ref
     * NV_GPU_PERF_RATED_TDP_ACTION_DEFAULT or fallback to choosing @ref
     * NV_GPU_PERF_RATED_TDP_ACTION_FORCE_EXCEED.
     */
    NV_GPU_PERF_RATED_TDP_ACTION
        inputs[NV_GPU_PERF_RATED_TDP_CLIENT_NUM_CLIENTS];
} NV_GPU_PERF_RATED_TDP_STATUS_V1;

typedef NV_GPU_PERF_RATED_TDP_STATUS_V1 NV_GPU_PERF_RATED_TDP_STATUS;

//! Macro for constructing the version field of NV_GPU_PERF_RATED_TDP_STATUS_V1
#define NV_GPU_PERF_RATED_TDP_STATUS_VER1  MAKE_NVAPI_VERSION(NV_GPU_PERF_RATED_TDP_STATUS_V1,1)

//! Macro for constructing the version field of NV_GPU_PERF_RATED_STATUS
#define NV_GPU_PERF_RATED_TDP_STATUS_VER   NV_GPU_PERF_RATED_TDP_STATUS_VER1

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    NvAPI_GPU_PerfRatedTdpGetStatus
//
//! DESCRIPTION:     This command returns the dynamic state of the RATED_TDP
//!                  power/perf control feature of this GPU.  This includes
//!                  dumping all client requests for boosting above or limiting
//!                  to RATED_TDP, as well as the current output action for
//!                  boost/limit.
//!
//!                  This command is useful for debugging the state of the
//!                  RATED_TDP feature to figure out which component are
//!                  limiting to RATED_TDP.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release:  313
//!
//! \param [in]      hPhysicalGPU      GPU selection
//! \param [out]     pStatus           Structure containing the dynnamic status of the RATED_TDP feature.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup   gpupstate
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_PerfRatedTdpGetStatus(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_PERF_RATED_TDP_STATUS *pStatus);



//! \ingroup gpupstate
//! @{

/*!
 * Structure containing the requested action for a RATED_TDP client (@ref
 * NV_GPU_PERF_RATED_TDP_CLIENT).
 */
typedef struct
{
    /*!
     * Version of this structure.  Must always be first element in this structure.
     */
    NvU32 version;

    /*!
     * Specified client for request.
     */
    NV_GPU_PERF_RATED_TDP_CLIENT client;
    /*!
     * Client's requested action.
     */
    NV_GPU_PERF_RATED_TDP_ACTION input;
} NV_GPU_PERF_RATED_TDP_CONTROL_V1;

typedef NV_GPU_PERF_RATED_TDP_CONTROL_V1 NV_GPU_PERF_RATED_TDP_CONTROL;

//! Macro for constructing the version field of NV_GPU_PERF_RATED_TDP_INFO_V1
#define NV_GPU_PERF_RATED_TDP_CONTROL_VER1  MAKE_NVAPI_VERSION(NV_GPU_PERF_RATED_TDP_CONTROL_V1,1)

//! Macro for constructing the version field of NV_GPU_PERF_RATED_INFO
#define NV_GPU_PERF_RATED_TDP_CONTROL_VER   NV_GPU_PERF_RATED_TDP_CONTROL_VER1

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    NvAPI_GPU_PerfRatedTdpGetControl
//
//! DESCRIPTION:     This command retrieves the current requested RATED_TDP
//!                  action corresponding to the specified client.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release:  313
//!
//! \param [in]      hPhysicalGPU      GPU selection
//! \param [out]     pControl          Structure containing the control values for the specified client.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup   gpupstate
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_PerfRatedTdpGetControl(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_PERF_RATED_TDP_CONTROL *pControl);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    NvAPI_GPU_PerfRatedTdpSetControl
//
//! DESCRIPTION:     This command sets the requested RATED_TDP action
//!                  corresponding to the specified client.  @Note, however,
//!                  that this command is unable to set @ref NV_GPU_PERF_RATED_TDP_CLIENT_RM.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release:  313
//!
//! \param [in]      hPhysicalGPU      GPU selection
//! \param [out]     pControl          Structure containing the control values for the specified client.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup   gpupstate
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_PerfRatedTdpSetControl(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_PERF_RATED_TDP_CONTROL *pControl);




//! \ingroup gpupstate
//! @{

/*!
 * NV_GPU_VDT_INFO_V1 represents version one of the Voltage Descriptor Table Header.
 * The VDT Header stores some general information about the table and some hardware
 * parameter information.
 */
typedef struct
{
    /*!
     * Version of this structure.  Must always be first element in this structure.
     */
    NvU32                           version;

    /*!
     * Cached HW SPEEDO fuse.  Used in VDT/CVB calculations to calculate target
     * voltage.
     */
    NvU32                           hwSpeedo;

    /*!
     * Cached HW SPEEDO version fuse.  Compared against the VDT speedo version
     * value to confirm the units of the SPEEDO fuse match the expectation for
     * the VDT/CVB calculations.
     */
    NvU32                           hwSpeedoVersion;

    /*!
     * SPEEDO version to be used for this table.  Will be compared against a HW
     * fuse to confirm the units of the SPEEDO fuse match the expectation for
     * the VDT/CVB calculations.
     */
    NvU32                           speedoVersion;

    /*!
     * Polling period for re-evaluating any temperature-based requested
     * voltages.
     */
    NvU16                           tempPollingPeriodms;

    /*!
     * Number of VDT entries in the table.
     */
    NvU8                            numEntries;

    /*!
     * Original/nominal P0 voltage before voltage tuning.  This is a legacy
     * feature from GF100 voltage tuning to increase yields due to fabric
     * issues.
     */
    NvU8                            nominalP0VdtEntry;

    /*!
     * Voltage Reliability Limit entry - index into table for entry specifying
     * the maximum reliability limit of the silicon.
     * VOLTAGE_DESCRIPTOR_TABLE_ENTRY_INVALID/0xFF = none.
     */
    NvU8                            reliabilityLimitEntry;

    /*!
     * User Over-Voltage Limit entry - index into table for entry specifying
     * the maximum user over-voltage limit.
     * VOLTAGE_DESCRIPTOR_TABLE_ENTRY_INVALID/0xFF = none.
     */
    NvU8                            overVoltageLimitEntry;

    /*!
     * Voltage Tuning Entry - index into table for entry reserved for tuning
     * voltage with a delta value.
     * VOLTAGE_DESCRIPTOR_TABLE_ENTRY_INVALID/0xFF = none.
     */
    NvU8                            voltageTuningEntry;
} NV_GPU_VDT_INFO_V1;

typedef NV_GPU_VDT_INFO_V1 NV_GPU_VDT_INFO;

//! Macro for constructing the version field of NV_GPU_VDT_INFO_V1
#define NV_GPU_VDT_INFO_VER1  MAKE_NVAPI_VERSION(NV_GPU_VDT_INFO_V1,1)

//! Macro for constructing the version field of NV_GPU_VDT_INFO
#define NV_GPU_VDT_INFO_VER   NV_GPU_VDT_INFO_VER1

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    NvAPI_GPU_VdtGetInfo
//
//! DESCRIPTION:     This function retrieves the Voltage Descriptor Table Header
//!                  which provides general settings for the voltage calculation
//!                  based on Voltage Descriptor Table.
//!
//!                  Voltage Descriptor Table provides information on the number
//!                  of VDT Entries, voltage limits, hardware parameter infomation,
//!                  polling period, and Voltage Tuning Entry.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version: 295.xx
//!
//! \param [in]      hPhysicalGPU      GPU selection
//! \param [out]     pVdtInfo          Structure containing the description of 
//!                                    VDT Header.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup   gpupstate
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_VdtGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_VDT_INFO *pVdtInfo);

//! \ingroup gpupstate
//! @{

#define NV_GPU_VDT_ENTRY_INFO_MAX_ENTRIES_V1                                 128

typedef enum
{
    NV_GPU_VDT_ENTRY_TYPE_CVB10 = 0x0,
    NV_GPU_VDT_ENTRY_TYPE_CVB20,
    NV_GPU_VDT_ENTRY_TYPE_CVB10_DPA,
    NV_GPU_VDT_ENTRY_TYPE_MAX,
    NV_GPU_VDT_ENTRY_TYPE_UNKNOWN = 0xFFFFFFFF
} NV_GPU_VDT_ENTRY_TYPE;

//! This structure contains CVB10 specific coefficients
typedef struct
{
    /*!
     * Signed 32-bit coefficient0 (0.1 uV).  Stored as signed 64-bit to expedite
     * 64-bit calculations.
     */
    NvS64     coefficient0;
    /*!
     * Signed 32-bit coefficient1 (0.1 uV).  Stored as signed 64-bit to expedite
     * 64-bit calculations.
     */
    NvS64     coefficient1;
    /*!
     * Signed 32-bit coefficient2 (0.00001 uV).  Stored as signed 64-bit to
     * expedite 64-bit calculations.
     */
    NvS64     coefficient2;
} NV_GPU_VDT_ENTRY_INFO_DATA_CVB10;

//! This structure contains CVB20 specific coefficients
typedef struct
{
    /*!
     * Second-order Coefficient 5 (V / C^2_adj, F8.24 signed)
     *
     * term5 = coefficient5 * tjSqAdj
     */
    NvS32     coefficient5;

    /*!
     * Second-order Coefficient 4 (V, F8.24 signed)
     *
     * term4 = coefficient4 * speedoSqAdj
     */
    NvS32     coefficient4;

    /*!
     * First-order Coefficient 3 (V / C, F16.16 signed)
     *
     * term3 = coefficient3 * tj * speedo
     */
    NvS32    coefficient3;

    /*!
     * First-order Coefficient 2 (V / C, F16.16 signed)
     *
     * term2 = coefficient2 * tj
     */
    NvS32    coefficient2;

    /*!
     * First-order Coefficient 1 (V, F8.24 signed)
     *
     * term1 = coefficient1 * speedo
     */
    NvS32     coefficient1;

    /*!
     * Constant Term Coefficient 0 (V, F8.24 signed)
     *
     * term= coefficient0
     */
    NvS32     coefficient0;
} NV_GPU_VDT_ENTRY_INFO_DATA_CVB20;

//! This structure contains CVB10 Double-Precision Adjustment specific coefficients
typedef struct _NV_GPU_VDT_ENTRY_INFO_DATA_CVB10_DPA
{
    /*!
     * Signed 32-bit coefficient0 (0.1 uV).  Stored as signed 64-bit to expedite
     * 64-bit calculations.
     */
    NvS64     coefficient0;
    /*!
     * Signed 32-bit coefficient1 (0.1 uV).  Stored as signed 64-bit to expedite
     * 64-bit calculations.
     */
    NvS64     coefficient1;
    /*!
     * Signed 32-bit coefficient2 (0.00001 uV).  Stored as signed 64-bit to
     * expedite 64-bit calculations.
     */
    NvS64     coefficient2;
} NV_GPU_VDT_ENTRY_INFO_DATA_CVB10_DPA;

//! This structure contains VDT MAX class indexes
typedef struct _NV_GPU_VDT_ENTRY_INFO_DATA_MAX
{
    /*!
     * Represents the first VDT entry index evaluated by VDT class MAX.
     * Bits 7:0 of coefficient0
     */
    NvU8 index0;

    /*!
     * Represents the second  VDT entry index evaluated by VDT class MAX.
     * Bits 15:8 of coefficient0
     */
    NvU8 index1;
} NV_GPU_VDT_ENTRY_INFO_DATA_MAX;

typedef union
{
    NV_GPU_VDT_ENTRY_INFO_DATA_CVB10     cvb10;
    NV_GPU_VDT_ENTRY_INFO_DATA_CVB20     cvb20;
    NV_GPU_VDT_ENTRY_INFO_DATA_CVB10_DPA cvb10Dpa;
    NV_GPU_VDT_ENTRY_INFO_DATA_MAX       vdtMax;
} NV_GPU_VDT_ENTRY_INFO_DATA;

/*!
 * This structure represent version one of a single Voltage Descriptor Table
 * entry. It contains necessary information for calculating a voltage.
 */
typedef struct
{
    /*!
     * VDT table entry index
     */

    NvU8   index;
    /*!
     * The voltage calculated based this VDT entry and all the ones
     * linked to it.
     * This value is bounded to what the voltage regulator can support,
     * and will be bound to 0 if it's negative.
     */
    NvU32  currTargetVoltageuV;

    /*!
     * The voltage calculated based only on the current VDT entry.
     * This value is unbounded, so it could be a negative value.
     */
    NvS32  localUnboundVoltageuV;

    /*!
     * Pointer to the next entry in the linked list to evaluate.
     */
    NvU8  nextEntry;

    /*!
     * Minimum voltage (uV) to bound the output of this entry
     */
    NvS32 voltageMinuV;

    /*!
     * Maximum voltage (uV) to bound the output of this entry
     */
    NvS32 voltageMaxuV;

    /*!
     * CVB Table Type, currently there are only CVB10 and CVB20
     */
    NV_GPU_VDT_ENTRY_TYPE type;

    /*!
     * Union of CVB10 and CVB20 coefficients
     */
    NV_GPU_VDT_ENTRY_INFO_DATA data;
} NV_GPU_VDT_ENTRY_INFO_V1;

typedef struct
{
    /*!
     * Version of this structure.  Must always be first element in this structure.
     */
    NvU32 version;

    /*!
     * Number of entries to the client wants to access.
     * 0 means all available entries.
     */
    NvU32 numEntries;

    /*!
     * Array of VDT table entries
     */
    NV_GPU_VDT_ENTRY_INFO_V1 entries[NV_GPU_VDT_ENTRY_INFO_MAX_ENTRIES_V1];
} NV_GPU_VDT_ENTRIES_INFO_V1;

typedef NV_GPU_VDT_ENTRIES_INFO_V1 NV_GPU_VDT_ENTRIES_INFO;

//! Macro for constructing the version field of NV_GPU_VDT_ENTRIES_INFO_V1
#define NV_GPU_VDT_ENTRIES_INFO_VER1  MAKE_NVAPI_VERSION(NV_GPU_VDT_ENTRIES_INFO_V1,1)

//! Macro for constructing the version field of NV_GPU_VDT_ENTRIES_INFO
#define NV_GPU_VDT_ENTRIES_INFO_VER   NV_GPU_VDT_ENTRIES_INFO_VER1

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    NvAPI_GPU_VdtEntriesGetInfo
//
//! DESCRIPTION:     This function retrieves the Voltage Descriptor Table Entries
//!                  which provide coefficients and min/max limits for calculating
//!                  voltage, as well as pointer to the VDT entry in the linked list.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version: 295.xx
//!
//! \param [in]      hPhysicalGPU      GPU selection
//! \param [out]     pVdtEntriesInfo   Structure that describes the VDT Entries
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup   gpupstate
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_VdtEntriesGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_VDT_ENTRIES_INFO *pVdtEntriesInfo);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    NvAPI_GPU_VdtEntriesSetInfo
//
//! DESCRIPTION:     This function mutates the VDT Entries based on the
//!                  client's input VDT Entries.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version: 295.xx
//!
//! \param [in]      hPhysicalGPU      GPU selection
//! \param [out]     pPerfVfTablesInfo Structure containing the description of the VF tables.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup   gpupstate
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_VdtEntriesSetInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __in NV_GPU_VDT_ENTRIES_INFO *pVdtEntriesInfo);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetCurrentPstate
//
//! DESCRIPTION:     This function retrieves the current performance state (P-State).
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 165
//!
//! TCC_SUPPORTED
//!
//! \param [in]      hPhysicalGPU     GPU selection
//! \param [out]     pCurrentPstate   The ID of the current P-State of the GPU - see \ref NV_GPU_PERF_PSTATES.
//!
//! \retval    NVAPI_OK                             Completed request
//! \retval    NVAPI_ERROR                          Miscellaneous error occurred.
//! \retval    NVAPI_HANDLE_INVALIDATED             Handle passed has been invalidated (see user guide).
//! \retval    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE   Handle passed is not a physical GPU handle.
//! \retval    NVAPI_NOT_SUPPORTED                  P-States is not supported on this setup.
//!
//! \ingroup   gpupstate
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetCurrentPstate(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_PERF_PSTATE_ID *pCurrentPstate);



//! \ingroup gpupstate
//! Used in NvAPI_GPU_GetPstateClientLimits().
typedef enum _NV_PERF_PSTATE_CLIENT_LIMIT_ID
{
    NVAPI_PERF_PSTATE_CLIENT_LIMIT_HARD                 = 0x00000001,       //!< P-States Hard limit 
    NVAPI_PERF_PSTATE_CLIENT_LIMIT_SOFT                 = 0x00000002,       //!< P-States Soft limit 
    NVAPI_PERF_PSTATE_CLIENT_LIMIT_BOTH                 = 0x00000003        //!< For both hard and soft P-States limits
} NV_GPU_PERF_PSTATE_CLIENT_LIMIT_ID;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetPstateClientLimits
//
//! DESCRIPTION:     This API gets the soft or hard performance state (P-State) limit
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 185
//! 
//! \param [in]    hPhysicalGPU   GPU selection.
//! \param [in]    limitId        Indicates hard limit or soft limit 
//! \param [out]   PstateLimit    The ID of the P-State that is the current limit
//!
//! \retval ::NVAPI_OK 
//! \retval ::NVAPI_ERROR 
//! \retval ::NVAPI_HANDLE_INVALIDATED 
//! \retval ::NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE 
//! \retval ::NVAPI_INVALID_ARGUMENT 
//! \retval ::NVAPI_NOT_SUPPORTED P-States is not supported on this setup
//!
//! \ingroup gpupstate
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetPstateClientLimits(NvPhysicalGpuHandle hPhysicalGpu,
                                                NV_GPU_PERF_PSTATE_CLIENT_LIMIT_ID limitId,
                                                NV_GPU_PERF_PSTATE_ID* PstateLimit);
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_SetPstateClientLimits
//
//! DESCRIPTION:     This API sets the soft or hard performance state (P-State) limit.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 185
//!
//! \param [in]     hPhysicalGPU    GPU selection.
//! \param [in]     limitId         To indicate hard limit, soft limit or both
//! \param [in]     PstateLimit     The ID of the P-State to be the new limit
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \retval ::NVAPI_INVALID_USER_PRIVILEGE       - The caller does not have administrative privileges
//!
//! \ingroup gpupstate
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetPstateClientLimits(NvPhysicalGpuHandle hPhysicalGpu,
                                                NV_GPU_PERF_PSTATE_CLIENT_LIMIT_ID limitId,
                                                NV_GPU_PERF_PSTATE_ID PstateLimit);


//! \addtogroup gpupstate
//! @{

/*!
 * The software performance policy. Each policy could request to set
 * performance in software. 
 */
typedef enum
{
    /*!
     * Power. Indicating perf is limited by total power limit.
     */
    NV_GPU_PERF_POLICY_ID_SW_POWER = 0,
    /*!
     * Thermal. Indicating perf is limited by temperature limit.
     */
    NV_GPU_PERF_POLICY_ID_SW_THERMAL,
    /*!
     * Reliability. Indicating perf is limited by reliability voltage.
     */
    NV_GPU_PERF_POLICY_ID_SW_RELIABILITY,
    /*!
     * Operating. Indicating perf is limited by max operating voltage.
     */
    NV_GPU_PERF_POLICY_ID_SW_OPERATING,
    /*!
     * Utilization. Indicating perf is limited by GPU utilization.
     */
    NV_GPU_PERF_POLICY_ID_SW_UTILIZATION,
    /*!
     * SLI GPUBoost Synchronization.
     */
    NV_GPU_PERF_POLICY_ID_SW_SLI_GPU_BOOST_SYNC,
} NV_GPU_PERF_POLICY_ID_SW;
#define NV_GPU_PERF_POLICY_ID_SW_NUM_V1       12

/*!
 * The performance point. Each perf point represents a specific upper limit
 * of performance.
 */
typedef enum
{
    /*!
     * Max clock. Indicating the request is to set GPC2CLK below maximum clock.
     */
    NV_GPU_PERF_POINT_ID_MAX_CLOCK   = 0,
    /*!
     * Turbo Boost. Indicating the request is to set GPC2CLK below Tubo Boost clock.
     */
    NV_GPU_PERF_POINT_ID_BOOST_CLOCK,
    /*!
     * Rated TDP. Indicating the request is to set GPC2CLK below Rated TDP,
     * aka base clock.
     */
    NV_GPU_PERF_POINT_ID_BASE_CLOCK,
} NV_GPU_PERF_POINT_ID;
#define NV_GPU_PERF_POINT_ID_NUM_V1           6

/*!
 * Structure to store perf policies info.
 * Used in NvAPI_GPU_PerfPoliciesGetInfo().
 */
typedef struct
{
    /*!
     * Version of this structure.  Must always be first element in this structure.
     */
    NvU32   version;
    /*!
     * Output: Mask of supported perf points.
     */
    NvU32   supportedPointMask;
    /*!
     * Output: Mask of supported perf policies.
     */
    NvU32   supportedPolicyMask;
    /*!
     * Reserved space for future use.
     */
    NvU32   rsvd[16];
} NV_GPU_PERF_POLICIES_INFO_PARAMS_V1;

#define NV_GPU_PERF_POLICIES_INFO_PARAMS_VER_1    MAKE_NVAPI_VERSION(NV_GPU_PERF_POLICIES_INFO_PARAMS_V1, 1)
#define NV_GPU_PERF_POLICIES_INFO_PARAMS_VER      NV_GPU_PERF_POLICIES_INFO_PARAMS_VER_1 

typedef NV_GPU_PERF_POLICIES_INFO_PARAMS_V1       NV_GPU_PERF_POLICIES_INFO_PARAMS;

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_PerfPoliciesGetInfo()
//
//! DESCRIPTION:    Returns perf limiting policies information, including supported performance points
//!                 and supported performance policies. Values are returned in bitmasks.
//!                 Application should call this API to obtain info before calling to the 
//!                 @ref NvAPI_GPU_PerfPoliciesGetStatus() API.
//!
//! \since Release: 313
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//! \param [in]     hPhysicalGPU        - GPU selection.
//! \param [inout]  pPerfPoliciesInfo   - Returned performance policies info structure.
//!
//! \return         This API can return any of the error codes enumerated in #NvAPI_Status. 
//!                 If there are return error codes with specific meaning for this API, 
//!                 they are listed below.
//! \retval:        NVAPI_INVALID_POINTER: if pPerfPoliciesInfo is invalid pointer
//!
//! \ingroup gpupstate
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_PerfPoliciesGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_PERF_POLICIES_INFO_PARAMS *pPerfPoliciesInfo);

//! \addtogroup gpupstate
//! @{

/*!
 * Structure representing one perf policy's status.
 */
typedef struct
{
    /*!
     * Output: mask of perf points that are currently violated.
     */
    NvU32   perfPointMask;
    /*!
     * Output: violation time for each perf point. Units in nanoseconds.
     */
    NvU64   perfPointTimeNs[NV_GPU_PERF_POINT_ID_NUM_V1];
    /*!
     * Reserved space for future use.
     */
    NvU32   rsvd[8];
} NV_GPU_PERF_POLICY_STATUS_V1;

/*!
 * Structure to hold perf policy's status data
 * Used in NvAPI_GPU_PerfPoliciesGetStatus().
 */
typedef struct
{
    /*!
     * Version of this structure.  Must always be first element in this structure.
     */
    NvU32                             version;
    /*!
     * Input: Requested policies mask by user. Will only retrieve status for
     * designated policies.
     */
    NvU32                             requestedPolicyMask;
    /*!
     * Output: reference timer's output. Units in nano-seconds.
     */
    NvU64                             referenceTimeNs;
    /*!
     * Output: mask of current limiting SW perf policies.
     */
    NvU32                             limitingPoliciesMask;
    /*!
     * Output: system's global status and violation time for each perf point. 
     */
    NV_GPU_PERF_POLICY_STATUS_V1      global;
    /*!
     * Output: Each SW policy's current status and violation time for each perf
     * point.
     */
    NV_GPU_PERF_POLICY_STATUS_V1      policies[NV_GPU_PERF_POLICY_ID_SW_NUM_V1];
    /*!
     * Reserved space for future use.
     */
    NvU32                             rsvd[48];
} NV_GPU_PERF_POLICIES_STATUS_PARAMS_V1;

#define NV_GPU_PERF_POLICIES_STATUS_PARAMS_VER_1  MAKE_NVAPI_VERSION(NV_GPU_PERF_POLICIES_STATUS_PARAMS_V1, 1)
#define NV_GPU_PERF_POLICIES_STATUS_PARAMS_VER    NV_GPU_PERF_POLICIES_STATUS_PARAMS_VER_1

typedef NV_GPU_PERF_POLICIES_STATUS_PARAMS_V1     NV_GPU_PERF_POLICIES_STATUS_PARAMS;

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_PerfPoliciesGetStatus()
//
//! DESCRIPTION:    Returns @ref NV_GPU_PERF_POLICIES_STATUS_PARAMS structure.
//!                 The global status is the result of all currently engaged policies.
//!                 The per-policy status contains information specific to a policy.
//!                 For parameter detail, see @ref NV_GPU_PERF_POLICIES_STATUS_PARAMS_V1.
//!
//! \since Release: 313
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//! \param [in]     hPhysicalGPU        - GPU selection.
//! \param [out]    pPerfPoliciesStatus - Returned performance reason status.
//!
//! \return         This API can return any of the error codes enumerated in #NvAPI_Status. 
//!                 If there are return error codes with specific meaning for this API, 
//!                 they are listed below.
//! \retval:        NVAPI_INVALID_POINTER: if pPerfPoliciesStatus is invalid pointer
//!
//! \ingroup gpupstate
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_PerfPoliciesGetStatus(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_PERF_POLICIES_STATUS_PARAMS *pPerfPoliciesStatus);

///////////////////////////////////////////////////////////////////////////////
//! \fn NvAPI_GPU_SetPerfLimit
//! \code
//! FUNCTION NAME:   NvAPI_GPU_SetPerfLimit
//!
//! DESCRIPTION:     This API sets the new fine-grained performance limit.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! PARAMETERS:      hPhysicalGPU(IN)  - GPU selection.
//!                  limit(IN)         - The target fine-grained performance limit.
//!                                      Setting NV_GPU_PERF_LIMIT_MAX is the
//!                                      same as clearing the limit.
//!                  flags(IN/OUT)     - Reserved for future use.
//!
//! RETURN STATUS:
//!    NVAPI_OK - completed request
//!    NVAPI_ERROR - miscellaneous error occurred
//!    NVAPI_API_NOT_INITIALIZED - nvapi not initialized
//!    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//!    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//!    NVAPI_INVALID_HANDLE - physical GPU handle is invalid
//!    NVAPI_INVALID_POINTER - the pointer argument is NULL
//!    NVAPI_NOT_SUPPORTED - fine-grained performance limit is not supported on this setup
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpupstate
//! @{
#define NV_GPU_PERF_LIMIT_MAX (0xff)

NVAPI_INTERFACE NvAPI_GPU_SetPerfLimit(NvPhysicalGpuHandle hPhysicalGpu,
                                       NvU8 limit,
                                       NvU32 *flags);
//! @}

///////////////////////////////////////////////////////////////////////////////
//! \code
//! FUNCTION NAME:   NvAPI_GPU_GetPerfLimit
//!
//! DESCRIPTION:     This API gets the current fine-grained performance limit.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! PARAMETERS:      hPhysicalGPU(IN)  - GPU selection.
//!                  limit(OUT)        - The current actual fine-grained performance limit. 
//!                                      NV_GPU_PERF_LIMIT_MAX is same as not having a limit.
//!                  flags(IN/OUT)     - Reserved for future use.
//!
//! RETURN STATUS:
//!    NVAPI_OK - completed request
//!    NVAPI_ERROR - miscellaneous error occurred
//!    NVAPI_API_NOT_INITIALIZED - nvapi not initialized
//!    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//!    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//!    NVAPI_INVALID_HANDLE - physical GPU handle is invalid
//!    NVAPI_INVALID_POINTER - the pointer argument is NULL
//!    NVAPI_NOT_SUPPORTED - fine-grained performance limit is not supported on this setup
//! \endcode
//! \ingroup gpupstate
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetPerfLimit(NvPhysicalGpuHandle hPhysicalGpu,
                                       NvU8 *limit,
                                       NvU32 *flags);


///////////////////////////////////////////////////////////////////////////////
//! \fn NvAPI_GPU_SetPerfPwmPeriod
//! \code
//! FUNCTION NAME:   NvAPI_GPU_SetPerfPwmPeriod
//!
//! DESCRIPTION:     This API sets the PWM period used for fine-grained performance.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! PARAMETERS:      hPhysicalGPU(IN)  - GPU selection.
//!                  periodUs(IN)      - The new PWM period used for fine-grained 
//!                                      performance in microseconds. If this is set 
//!                                      to NV_GPU_PERF_PWM_PERIOD_AUTO, the period 
//!                                      will be set adaptively in runtime.
//!                  flags(IN/OUT)     - Reserved for future use.
//!
//! RETURN STATUS:
//!    NVAPI_OK - completed request
//!    NVAPI_ERROR - miscellaneous error occurred
//!    NVAPI_API_NOT_INITIALIZED - nvapi not initialized
//!    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//!    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//!    NVAPI_INVALID_HANDLE - physical GPU handle is invalid
//!    NVAPI_INVALID_POINTER - the pointer argument is NULL
//!    NVAPI_NOT_SUPPORTED - fine-grained performance PWM is not supported on this setup
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpupstate
//! @{
#define NV_GPU_PERF_PWM_PERIOD_AUTO (0x00000000)

NVAPI_INTERFACE NvAPI_GPU_SetPerfPwmPeriod(NvPhysicalGpuHandle hPhysicalGpu,
                                           NvU32 periodUs,
                                           NvU32 *flags);
//! @}

//! \ingroup gpupstate
typedef struct
{
    NvU32       version;        //!< Structure version
    NvU32       flags;          //!< Reserved for future use
    NvU32       bEnabled;       //!< Boolean: Set if VPS is enabled
    NvU32       bRunning;       //!< Boolean: Set if VPS is running
    NvU32       bStateHigh;     //!< Boolean: Set if currently on high Pstate
    NvU32       highPstate;     //!< The high (fast) Pstate to alternate
    NvU32       lowPstate;      //!< lowPstate = highPstate - 1
    NvU32       highUs;         //!< Time spent (microseconds) in high Pstate within each cycle
    NvU32       lowUs;          //!< lowUs = periodUs - highUs
} NV_GPU_PERF_PWM_INFO;



///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GPU_PerfGetFstate
//
//! DESCRIPTION:     This API sets gets the current and max f-state.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param[in]      hPhysicalGPU(IN)  - GPU selection.
//! \param[out]     current(OUT)      - The current f-state.
//! \param[out]     max(OUT)          - Maximum f-state available.
//! \param[out]     flags(INOUT)      - Reserved for future use.  Pass in 0 now.
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//! \ingroup gpupstate
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetPerfFstate(NvPhysicalGpuHandle hPhysicalGpu,
                                           NvU32 *current,
                                           NvU32 *max,
                                           NvU32 *flags);


//! \ingroup gpupstate
#define NV_GPU_PERF_PWM_INFO_VER MAKE_NVAPI_VERSION(NV_GPU_PERF_PWM_INFO,1)

///////////////////////////////////////////////////////////////////////////////
//! \code
//! FUNCTION NAME:   NvAPI_GPU_GetPerfPwmInfo
//!
//! DESCRIPTION:     This API acquires the PWM period information.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:      hPhysicalGPU(IN)     - GPU selection.
//!                  pPerfPwmInfo(IN/OUT) - The NV_GPU_PERF_PWM_INFO struct to retrieve
//!
//! RETURN STATUS:
//!    NVAPI_OK - completed request
//!    NVAPI_ERROR - miscellaneous error occurred
//!    NVAPI_API_NOT_INITIALIZED - nvapi not initialized
//!    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//!    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//!    NVAPI_INVALID_HANDLE - physical GPU handle is invalid
//!    NVAPI_INVALID_POINTER - the pointer argument is NULL
//!    NVAPI_NOT_SUPPORTED - fine-grained performance PWM is not supported on this setup
//! \endcode
//! \ingroup gpupstate
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetPerfPwmInfo(NvPhysicalGpuHandle hPhysicalGpu,
                                         NV_GPU_PERF_PWM_INFO *pPerfPwmInfo);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_EnableOverclockedPstates
//
//! DESCRIPTION:     This API allows overclocked P-states. 
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 185
//!
//! \param [in]     hPhysicalGP    GPU selection
//! \param [in]     bEnable        (Boolean) Enables or disables overclocked P-states 
//!
//! \retval ::NVAPI_OK 
//! \retval ::NVAPI_ERROR 
//! \retval ::NVAPI_HANDLE_INVALIDATED 
//! \retval ::NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE 
//! \retval ::NVAPI_INVALID_ARGUMENT 
//! \retval ::NVAPI_NOT_SUPPORTED  P-States or overclocked P-states is not supported on this setup
//!
//! \ingroup gpupstate
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_EnableOverclockedPstates(NvPhysicalGpuHandle hPhysicalGpu,
                                                   NvU8 bEnable);
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_EnableDynamicPstates
//
//! DESCRIPTION:     This API enables or disables dynamic P-states 
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 185
//!
//! \param [in]     hPhysicalGPU   GPU selection.
//! \param [in]     bEnable        (Boolean) Enables or disables dynamic P-states 
//!
//! \retval ::NVAPI_OK 
//! \retval ::NVAPI_ERROR 
//! \retval ::NVAPI_HANDLE_INVALIDATED 
//! \retval ::NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE 
//! \retval ::NVAPI_INVALID_ARGUMENT 
//! \retval ::NVAPI_NOT_SUPPORTED  P-States is not supported on this setup
//!
//! \ingroup gpupstate
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_EnableDynamicPstates(NvPhysicalGpuHandle hPhysicalGpu,
                                               NvU8 bEnable);





//! \addtogroup gpupstate
//! @{

//! Used in NV_GPU_DYNAMIC_PSTATES_INFO.
#define NVAPI_MAX_GPU_UTILIZATIONS 8


//! Used in NV_GPU_DYNAMIC_PSTATES_INFO -> utilization[].
typedef enum _NV_GPU_UTILIZATION_DOMAIN_ID
{
    NVAPI_GPU_UTILIZATION_DOMAIN_GPU    = 0, //!< Graphics engine domain
    NVAPI_GPU_UTILIZATION_DOMAIN_FB     = 1, //!< Frame buffer domain
    NVAPI_GPU_UTILIZATION_DOMAIN_VID    = 2, //!< Video engine domain
    NVAPI_GPU_UTILIZATION_DOMAIN_BUS    = 3, //!< Bus interface domain
} NV_GPU_UTILIZATION_DOMAIN_ID;

//! @}


//! \addtogroup gpupstate
//! @{

//! Used in NvAPI_GPU_GetDynamicPstatesInfo().
typedef struct 
{
    NvU32       version;        //!< Structure version
    NvU32       flags;          //!< Reserved for future use
    struct
    {
        NvU32   bIsPresent:1;   //!< Set if this utilization domain is present on this GPU        
        NvU32   percentage;     //!< Percentage of time where the domain is considered busy in the last 1-second interval
        NvU32   incThreshold;   //!< Utilization threshold that can trigger a perf-increasing P-State change when crossed
        NvU32   decThreshold;   //!< Utilization threshold that can trigger a perf-decreasing P-State change when crossed
    } utilization[NVAPI_MAX_GPU_UTILIZATIONS];
} NV_GPU_DYNAMIC_PSTATES_INFO;



//! Used in NV_GPU_DYNAMIC_PSTATES_INFO.
#define NV_GPU_DYNAMIC_PSTATES_INFO_VER MAKE_NVAPI_VERSION(NV_GPU_DYNAMIC_PSTATES_INFO,1)

//! @}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetDynamicPstatesInfo
//
//! DESCRIPTION:   This retrieves the NV_GPU_DYNAMIC_PSTATES_INFO structure for the specified physical GPU. \n
//!                flags is reserved for future use. \n
//!                For each utilization domain:
//!                   - bIsPresent is set for each domain that is present on the GPU.
//!                   - percentage is the percentage of time where the domain is considered busy in the last 1 second interval.
//!                   - incThreshold is utilization threshold that can trigger a perf-increasing P-State change when crossed.
//!                   - decThreshold is utilization threshold that can trigger a perf-decreasing P-State change when crossed.
//!
//!                Each domain's info is indexed in the array.  For example: 
//!                    pDynamicPstatesInfo->utilization[NVAPI_GPU_UTILIZATION_DOMAIN_GPU] holds the info for the GPU domain. \n
//!                There are currently 4 domains, for which GPU utilization and dynamic P-State thresholds can be retrieved - 
//!                    graphic engine (GPU), frame buffer (FB), video engine (VID), and bus interface (BUS).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 173
//! 
//! TCC_SUPPORTED
//!
//!  \retval    NVAPI_OK                            completed request
//!  \retval    NVAPI_ERROR                         miscellaneous error occurred
//!  \retval    NVAPI_INVALID_ARGUMENT              pDynamicPstatesInfo is NULL
//!  \retval    NVAPI_HANDLE_INVALIDATED            handle passed has been invalidated (see user guide)
//!  \retval    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  handle passed is not a physical GPU handle
//!  \retval    NVAPI_INCOMPATIBLE_STRUCT_VERSION   the version of the INFO struct is not supported
//!
//!  \ingroup gpupstate
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetDynamicPstatesInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_DYNAMIC_PSTATES_INFO *pDynamicPstatesInfo);





//! \ingroup gpupstate
#define NVAPI_MAX_GPU_UTILIZATIONS 8



//! \ingroup gpupstate
//! Used in NvAPI_GPU_GetDynamicPstatesInfoEx().
typedef struct
{
    NvU32       version;        //!< Structure version
    NvU32       flags;          //!< bit 0 indicates if the dynamic Pstate is enabled or not
    struct
    {
        NvU32   bIsPresent:1;   //!< Set if this utilization domain is present on this GPU
        NvU32   percentage;     //!< Percentage of time where the domain is considered busy in the last 1 second interval
    } utilization[NVAPI_MAX_GPU_UTILIZATIONS];
} NV_GPU_DYNAMIC_PSTATES_INFO_EX;

//! \ingroup gpupstate
//! Macro for constructing the version field of NV_GPU_DYNAMIC_PSTATES_INFO_EX
#define NV_GPU_DYNAMIC_PSTATES_INFO_EX_VER MAKE_NVAPI_VERSION(NV_GPU_DYNAMIC_PSTATES_INFO_EX,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetDynamicPstatesInfoEx
//
//! DESCRIPTION:   This API retrieves the NV_GPU_DYNAMIC_PSTATES_INFO_EX structure for the specified physical GPU.
//!                Each domain's info is indexed in the array.  For example: 
//!                - pDynamicPstatesInfo->utilization[NVAPI_GPU_UTILIZATION_DOMAIN_GPU] holds the info for the GPU domain. \p
//!                There are currently 4 domains for which GPU utilization and dynamic P-State thresholds can be retrieved:
//!                   graphic engine (GPU), frame buffer (FB), video engine (VID), and bus interface (BUS).
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 185
//! 
//! \retval ::NVAPI_OK 
//! \retval ::NVAPI_ERROR 
//! \retval ::NVAPI_INVALID_ARGUMENT  pDynamicPstatesInfo is NULL
//! \retval ::NVAPI_HANDLE_INVALIDATED 
//! \retval ::NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE 
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION The version of the INFO struct is not supported
//!
//! \ingroup gpupstate
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetDynamicPstatesInfoEx(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_DYNAMIC_PSTATES_INFO_EX *pDynamicPstatesInfoEx);




//! \ingroup gpupstate
#define NVAPI_MAX_GPU_PERF_DOMAIN_VOLTAGES   128

//! \ingroup gpupstate
typedef struct
{
    NvU32   version;
    NvU32   flags;       //!< Currently unsupported
    NvU32   numDomains;  //!< The number of voltage domains supported on the board

    struct
    {
        NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID domainId;     //!< Domain ID
        NvU32                              flags;        //!< Currently unsupported
        NvU32                              numVoltages;  //!< The number of voltage levels defined for this domain
        struct
        {
            NvU32                       flags;           //!< Currently unsupported  
            NvU32                       mvolt;           //!< Voltage in mV
        } voltages[NVAPI_MAX_GPU_PERF_DOMAIN_VOLTAGES];  //!< Valid index range from 0 to domains[i].numVoltages - 1
    } domains[NVAPI_MAX_GPU_PERF_VOLTAGES];              //!< Valid index range from 0 to numDomains-1

} NV_GPU_PERF_VOLTAGES;  

//! \ingroup gpupstate
//! Macro for contructing the version field of NV_GPU_PERF_VOLTAGES
#define NV_GPU_PERF_VOLTAGES_VER  MAKE_NVAPI_VERSION(NV_GPU_PERF_VOLTAGES,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetVoltages
//
//! DESCRIPTION:     This API returns the supported voltage levels for each supported voltage domain on the board.
//!                  These are the valid voltage levels which can be used for NvAPI_GPU_SetPstates() and
//!                  NvAPI_GPU_SetPstatesInfo().
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \param [in]      hPhysicalGPU    GPU selection.
//! \param [out]     pPerfVoltages   Voltage information retrieved, as detailed below:
//!                  - flags - currently unsupported
//!                  - numDomains - the number of voltage domains supported on the board
//!                  - domains - valid index range from 0 to numDomains - 1
//!                    - domains[i].domainId - the ID of the voltage domain
//!                    - domains[i].flags - currently unsupported
//!                    - domains[i].numVoltages - number of voltage levels defined for this domain
//!                    - domains[i].voltages -  valid index range from 0 to domains[i].numVoltages - 1
//!                      - domains[i].voltages[j].flags - currently unsupported
//!                      - domains[i].voltages[j].mvolt - voltage in mV
//!
//! \retval ::NVAPI_OK - completed request
//! \retval ::NVAPI_ERROR - miscellaneous error occurred
//! \retval ::NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//! \retval ::NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the NV_GPU_PERF_PSTATES struct is not supported
//!
//! \ingroup gpupstate
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetVoltages(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_PERF_VOLTAGES *pPerfVoltages);




//! \ingroup gpuvoltage
#define NV_GPU_VOLTAGES_FLAGS_INTERNAL     0x00000001

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetVoltagesInternal
//
//! \code
//! DESCRIPTION:     Returns all the supported voltage levels for each supported voltage domain on the board,
//!                  ignoring board overvoltage-ability and board reliability max.
//!                  These are the valid voltage levels which can be used for NvAPI_GPU_SetPstates().
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! TCC_SUPPORTED
//!
//! PARAMETERS:      hPhysicalGPU(IN)  - GPU selection.
//!                  flags(IN)
//!                    bit 0 indicates whether we need to get all the voltage levels supported by the board,
//!                    ignoring board overvoltage-ability and board reliability max. 
//!                  pPerfVoltages(OUT) - Voltage information retrieved, as detailed below:
//!                  - flags - currently unsupported
//!                  - numDomains - the number of voltage domains supported on the board
//!                  - domains - valid index range from 0 to numDomains - 1
//!                    - domains[i].domainId - the ID of the voltage domain
//!                    - domains[i].flags - currently unsupported
//!                    - domains[i].numVoltages - number of voltage levels defined for this domain
//!                    - domains[i].voltages -  valid index range from 0 to domains[i].numVoltages - 1
//!                      - domains[i].voltages[j].flags - currently unsupported
//!                      - domains[i].voltages[j].mvolt - voltage in mV
//!
//! RETURN STATUS:
//!    NVAPI_OK - completed request
//!    NVAPI_ERROR - miscellaneous error occurred
//!    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//!    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//!    NVAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the NV_GPU_PERF_PSTATES struct is not supported
//! \endcode
//! \ingroup gpuvoltages
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetVoltagesInternal(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_PERF_VOLTAGES *pPerfVoltages, NvU32 flags);







 
///////////////////////////////////////////////////////////////////////////////////
//  Thermal API
//  Provides ability to get temperature levels from the various thermal sensors associated with the GPU

//! \ingroup gputhermal
#define NVAPI_MAX_THERMAL_SENSORS_PER_GPU 3

//! \ingroup gputhermal
//! Used in NV_GPU_THERMAL_SETTINGS
typedef enum 
{
    NVAPI_THERMAL_TARGET_NONE          = 0,
    NVAPI_THERMAL_TARGET_GPU           = 1,     //!< GPU core temperature requires NvPhysicalGpuHandle
    NVAPI_THERMAL_TARGET_MEMORY        = 2,     //!< GPU memory temperature requires NvPhysicalGpuHandle
    NVAPI_THERMAL_TARGET_POWER_SUPPLY  = 4,     //!< GPU power supply temperature requires NvPhysicalGpuHandle
    NVAPI_THERMAL_TARGET_BOARD         = 8,     //!< GPU board ambient temperature requires NvPhysicalGpuHandle
    NVAPI_THERMAL_TARGET_VCD_BOARD     = 9,     //!< Visual Computing Device Board temperature requires NvVisualComputingDeviceHandle
    NVAPI_THERMAL_TARGET_VCD_INLET     = 10,    //!< Visual Computing Device Inlet temperature requires NvVisualComputingDeviceHandle
    NVAPI_THERMAL_TARGET_VCD_OUTLET    = 11,    //!< Visual Computing Device Outlet temperature requires NvVisualComputingDeviceHandle

    NVAPI_THERMAL_TARGET_ALL           = 15,
    NVAPI_THERMAL_TARGET_UNKNOWN       = -1,
} NV_THERMAL_TARGET;

//! \ingroup gputhermal
//! Used in NV_GPU_THERMAL_SETTINGS
typedef enum
{
    NVAPI_THERMAL_CONTROLLER_NONE = 0,
    NVAPI_THERMAL_CONTROLLER_GPU_INTERNAL,  
    NVAPI_THERMAL_CONTROLLER_ADM1032,
    NVAPI_THERMAL_CONTROLLER_MAX6649,       
    NVAPI_THERMAL_CONTROLLER_MAX1617,      
    NVAPI_THERMAL_CONTROLLER_LM99,      
    NVAPI_THERMAL_CONTROLLER_LM89,         
    NVAPI_THERMAL_CONTROLLER_LM64,         
    NVAPI_THERMAL_CONTROLLER_ADT7473,
    NVAPI_THERMAL_CONTROLLER_SBMAX6649,
    NVAPI_THERMAL_CONTROLLER_VBIOSEVT,  
    NVAPI_THERMAL_CONTROLLER_OS,    
    NVAPI_THERMAL_CONTROLLER_UNKNOWN = -1,
} NV_THERMAL_CONTROLLER;

//! \ingroup gputhermal
//! Used in NvAPI_GPU_GetThermalSettings()
typedef struct
{
    NvU32   version;                //!< structure version 
    NvU32   count;                  //!< number of associated thermal sensors
    struct 
    {
        NV_THERMAL_CONTROLLER       controller;        //!< internal, ADM1032, MAX6649...
        NvU32                       defaultMinTemp;    //!< The min default temperature value of the thermal sensor in degree Celsius 
        NvU32                       defaultMaxTemp;    //!< The max default temperature value of the thermal sensor in degree Celsius 
        NvU32                       currentTemp;       //!< The current temperature value of the thermal sensor in degree Celsius 
        NV_THERMAL_TARGET           target;            //!< Thermal sensor targeted @ GPU, memory, chipset, powersupply, Visual Computing Device, etc.
    } sensor[NVAPI_MAX_THERMAL_SENSORS_PER_GPU];

} NV_GPU_THERMAL_SETTINGS_V1;

//! \ingroup gputhermal
typedef struct
{
    NvU32   version;                //!< structure version
    NvU32   count;                  //!< number of associated thermal sensors
    struct
    {
        NV_THERMAL_CONTROLLER       controller;         //!< internal, ADM1032, MAX6649...
        NvS32                       defaultMinTemp;     //!< Minimum default temperature value of the thermal sensor in degree Celsius
        NvS32                       defaultMaxTemp;     //!< Maximum default temperature value of the thermal sensor in degree Celsius
        NvS32                       currentTemp;        //!< Current temperature value of the thermal sensor in degree Celsius
        NV_THERMAL_TARGET           target;             //!< Thermal sensor targeted - GPU, memory, chipset, powersupply, Visual Computing Device, etc
    } sensor[NVAPI_MAX_THERMAL_SENSORS_PER_GPU];

} NV_GPU_THERMAL_SETTINGS_V2;

//! \ingroup gputhermal
typedef NV_GPU_THERMAL_SETTINGS_V2  NV_GPU_THERMAL_SETTINGS;

//! \ingroup gputhermal
//! @{

//! Macro for constructing the version field of NV_GPU_THERMAL_SETTINGS_V1
#define NV_GPU_THERMAL_SETTINGS_VER_1   MAKE_NVAPI_VERSION(NV_GPU_THERMAL_SETTINGS_V1,1)

//! Macro for constructing the version field of NV_GPU_THERMAL_SETTINGS_V2
#define NV_GPU_THERMAL_SETTINGS_VER_2   MAKE_NVAPI_VERSION(NV_GPU_THERMAL_SETTINGS_V2,2)

//! Macro for constructing the version field of NV_GPU_THERMAL_SETTINGS
#define NV_GPU_THERMAL_SETTINGS_VER     NV_GPU_THERMAL_SETTINGS_VER_2
//! @}




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetThermalSettings
//
//!  This function retrieves the thermal information of all thermal sensors or specific thermal sensor associated with the selected GPU.
//!  Thermal sensors are indexed 0 to NVAPI_MAX_THERMAL_SENSORS_PER_GPU-1.
//!
//!  - To retrieve specific thermal sensor info, set the sensorIndex to the required thermal sensor index. 
//!  - To retrieve info for all sensors, set sensorIndex to NVAPI_THERMAL_TARGET_ALL. 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 85
//!
//! \param [in]   hPhysicalGPU      GPU selection.
//! \param [in]   sensorIndex       Explicit thermal sensor index selection. 
//! \param [out]  pThermalSettings  Array of thermal settings.
//!
//! \retval   NVAPI_OK                           Completed request
//! \retval   NVAPI_ERROR                        Miscellaneous error occurred.
//! \retval   NVAPI_INVALID_ARGUMENT             pThermalInfo is NULL.
//! \retval   NVAPI_HANDLE_INVALIDATED           Handle passed has been invalidated (see user guide).
//! \retval   NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE Handle passed is not a physical GPU handle.
//! \retval   NVAPI_INCOMPATIBLE_STRUCT_VERSION  The version of the INFO struct is not supported.
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetThermalSettings(NvPhysicalGpuHandle hPhysicalGpu, NvU32 sensorIndex, NV_GPU_THERMAL_SETTINGS *pThermalSettings);



// ====================================================
// Thermal slowdown status
// ====================================================

//! \ingroup gputhermal
//! Thermal slowdown options - used in NvAPI_GPU_SetThermalSlowdownState() 
typedef enum
{
    NVAPI_GPU_THERMAL_SLOWDOWN_ENABLED                = 0x0000,         //!< Thermal slowdown mechanisms enabled
    NVAPI_GPU_THERMAL_SLOWDOWN_DISABLED_ALL           = 0xFFFF,         //!< All thermal slowdown mechanisms disabled (HW, SW, Pstate)
} NV_GPU_THERMAL_SLOWDOWN;



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_SetThermalSlowdownState
//
//! DESCRIPTION:    This function disables/enables thermal slowdown for the specified GPU.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 177
//!
//! \param [in]   hPhysicalGpu   The handle for the physical GPU  
//! \param [in]   slowdownState  Slowdown state, currently NONE/ALL. See #NV_GPU_THERMAL_SLOWDOWN.
//!
//! \retval ::NVAPI_OK 
//! \retval ::NVAPI_ERROR 
//! \retval ::NVAPI_INVALID_ARGUMENT 
//! \retval ::NVAPI_HANDLE_INVALIDATED 
//! \retval ::NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE 
//!
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetThermalSlowdownState(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_THERMAL_SLOWDOWN slowdownState);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetThermalSlowdownState
//
//! DESCRIPTION:    This function retreives the thermal slowdown information for the specified GPU.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 177
//!
//! \param [in]    hPhysicalGpu   The handle for the physical GPU  
//! \param [out]   slowdownState  Slowdown state, currently NONE/ALL. See #NV_GPU_THERMAL_SLOWDOWN.
//!
//! \retval ::NVAPI_OK 
//! \retval ::NVAPI_ERROR 
//! \retval ::NVAPI_INVALID_ARGUMENT 
//! \retval ::NVAPI_HANDLE_INVALIDATED 
//! \retval ::NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE 
//!
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetThermalSlowdownState(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_THERMAL_SLOWDOWN *slowdownState);



// ====================================================
// Thermal simulation mode
// ====================================================

//! \ingroup gputhermal
//! Used in NvAPI_GPU_GetThermalSimulationMode() and NvAPI_GPU_SetThermalSimulationMode().
typedef enum
{
    NVAPI_GPU_THERMAL_SIMULATION_DISABLED               = 0x0000,
    NVAPI_GPU_THERMAL_SIMULATION_ENABLED                = 0x0001,
} NV_GPU_THERMAL_SIMULATION_MODE;


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_SetThermalSimulationMode
//
//!                 This NvAPI call lets you simulate the temperature for an existing
//!                 thermal sensor. Once thermal simulation mode is enabled,
//!                 the readings from that particular sensor will be a constant value
//!                 (simulated temperature). Disabling this feature returns
//!                 the thermal sensor to its original state.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 180
//!
//! \param [in] sensor         Target sensor
//! \param [in] tempSimMode    Enable/disable thermal simulation mode
//! \param [in] temperature    Simulated temperature (0 <= temp <= 255 deg Celsius)
//!                           (unused if tempSimMode is _DISABLED)
//!
//! \retval  ::NVAPI_OK                              Completed request
//! \retval  ::NVAPI_ERROR                           Miscellaneous error occurred
//! \retval  ::NVAPI_INVALID_ARGUMENT                Invalid mode selected, or temperature is out of range
//! \retval  ::NVAPI_HANDLE_INVALIDATED              Handle passed has been invalidated (see user guide)
//! \retval  ::NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE    Handle passed is not a physical GPU handle
//! \retval  ::NVAPI_NOT_SUPPORTED                   Thermal simulation is not supported
//!
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetThermalSimulationMode(NvPhysicalGpuHandle hPhysicalGpu, NvU32 sensor, NV_GPU_THERMAL_SIMULATION_MODE tempSimMode, NvU32 temperature);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_SetExtendedThermalSimulationMode
//
//! \code
//! DESCRIPTION:     Disables/enables extended thermal simulation mode.
//!                  This NvAPI call basicaly provides same functionality as
//!                  previous call (NvAPI_GPU_SetThermalSimulationMode())
//!                  with difference that it allows simulation of negative
//!                  temperatures on GPUs that suppors that.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! PARAMETERS :     sensor(IN) - affected sensor
//!                  tempSimMode(IN) - turning ON/OFF temp. simulation mode
//!                  temperature(IN) - simulated temperature
//!                                    (check NvAPI_GPU_GetThermalSettings() for allowed range)
//!                                    (unused if tempSimMode is _DISABLED)
//!
//! RETURN STATUS:
//!    NVAPI_OK - completed request
//!    NVAPI_ERROR - miscellaneous error occurred
//!    NVAPI_INVALID_ARGUMENT - invalid mode selected
//!    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//!    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//!    NVAPI_NOT_SUPPORTED - Thermal simulation is not supported
//! \endcode
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetExtendedThermalSimulationMode(NvPhysicalGpuHandle hPhysicalGpu, NvU32 sensor, NV_GPU_THERMAL_SIMULATION_MODE tempSimMode, NvS32 temperature);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetThermalSimulationMode
//
//! DESCRIPTION:     This API retreives the thermal simulation mode. See NvAPI_GPU_SetThermalSimulationMode().
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 180
//!
//! \param [in]  sensor       Target sensor
//! \param [out] tempSimMode  The temperature simulation mode
//!
//! \retval  ::NVAPI_OK                              Completed request
//! \retval  ::NVAPI_ERROR                           Miscellaneous error occurred
//! \retval  ::NVAPI_INVALID_ARGUMENT                NULL pointer passed (tempSimMode)
//! \retval  ::NVAPI_HANDLE_INVALIDATED              Hhandle passed has been invalidated (see user guide)
//! \retval  ::NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE    Handle passed is not a physical GPU handle
//! \retval  ::NVAPI_NOT_SUPPORTED                   Thermal simulation is not supported
//!
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetThermalSimulationMode(NvPhysicalGpuHandle hPhysicalGpu, NvU32 sensor, NV_GPU_THERMAL_SIMULATION_MODE *tempSimMode);



//! \ingroup gputhermal
typedef struct
{
    NvU32   version;                //!< Structure version
    NvU32   sensorIndex;            //!< Index of requested internal thermal sensor

    NvU32   rawReading;             //!< Thermal sensor's RAW reading
    NvS32   slope;                  //!< Slope parameter for temperature calculation
                                    //!< Fixed point value with 16 decimal bits
    NvS32   offset;                 //!< Offset parameter for temperature calculation
                                    //!< Fixed point value with 16 decimal bits
    //!< Current temperature can be calculated using following formula:
    //!< T [C] = (slope * rawReading + offset) >> 16

} NV_DIAG_INTERNAL_THERMAL_SENSOR_INFO_V1;

//! \ingroup gputhermal
typedef NV_DIAG_INTERNAL_THERMAL_SENSOR_INFO_V1      NV_DIAG_INTERNAL_THERMAL_SENSOR_INFO;

//! \ingroup gputhermal
#define NV_DIAG_INTERNAL_THERMAL_SENSOR_VER_1   MAKE_NVAPI_VERSION(NV_DIAG_INTERNAL_THERMAL_SENSOR_INFO_V1,1)

//! \ingroup gputhermal
#define NV_DIAG_INTERNAL_THERMAL_SENSOR_VER     NV_DIAG_INTERNAL_THERMAL_SENSOR_VER_1


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Diag_GetInternalThermalSensorInfo
//
//! \code
//! DESCRIPTION:     Retreives the internal thermal sensor diagnostic information.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS :     pDiagData(IN/OUT) - internal thermal sensor diagnostic data
//!
//! RETURN STATUS:
//!    NVAPI_OK - completed request
//!    NVAPI_ERROR - miscellaneous error occurred
//!    NVAPI_INVALID_ARGUMENT - NULL pointer passed (pDiagData)
//!    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//!    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//!    NVAPI_NOT_SUPPORTED - internal thermal sensor diagnotic call is not supported
//!    NVAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the INFO struct is not supported
//! \endcode
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Diag_GetInternalThermalSensorInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_DIAG_INTERNAL_THERMAL_SENSOR_INFO *pDiagData);



//! \ingroup gputhermal
//! @{

#define NV_GPU_THERMAL_POLICY_MAX_POLICIES_V1                               16

/*!
 * Enumeration of Thermal Policy types. Different types implement the
 * Thermal Policy functionality via different mechanisms. Also, specifies how
 * to interpret the policy type data union.
 */
typedef enum _NV_GPU_THERMAL_POLICY_TYPE
{
    NV_GPU_THERMAL_POLICY_TYPE_DTC_VPSTATE = 0x00000001,
    NV_GPU_THERMAL_POLICY_TYPE_DTC_VF,
    NV_GPU_THERMAL_POLICY_TYPE_DTC_VOLT,

    /*!
     * The following are virtual Thermal Policy classes/types. They are
     * interface types with other Thermal Policy classes will implement.
     */
    NV_GPU_THERMAL_POLICY_TYPE_DTC    = 0xFFFFFFFD,
    NV_GPU_THERMAL_POLICY_TYPE_DOMGRP = 0xFFFFFFFE,

    /*!
     * Unknown/unsupported type via NVAPI. Should always be last.
     */
    NV_GPU_THERMAL_POLICY_TYPE_UNKNOWN = 0xFFFFFFFF,
} NV_GPU_THERMAL_POLICY_TYPE;

/*!
 * Used in \ref NV_GPU_THERMAL_POLICY_INFO_V1. Structure representing the
 * static data found in the VPSTATE domain group controller.
 */
typedef struct _NV_GPU_THERMAL_POLICY_INFO_DTC_VPSTATE_V1
{
    /*!
     * Number of virtual P-states.
     */
    NvU32 vpstateNum;

    /*!
     * Virtual P-states that contains the rated TDP clocks.
     */
    NvU32 vpstateTdp;
} NV_GPU_THERMAL_POLICY_INFO_DTC_VPSTATE_V1;

/*!
 * Used in \ref NV_GPU_THERMAL_POLICY_INFO_V1. Structure representing the
 * static data found in the VF domain group controller.
 */
typedef struct _NV_GPU_THERMAL_POLICY_INFO_DTC_VF_V1
{
    /*!
     * Maximum frequency used by the controller for the GPC2CLK limit.
     */
    NvU32 limitFreqMaxKHz;

    /*!
     * Minimum frequency used by the controller for the GPC2CLK limit.
     */
    NvU32 limitFreqMinKHz;

    /*!
     * Rated TDP frequency.
     */
    NvU32 ratedTdpFreqKHz;
} NV_GPU_THERMAL_POLICY_INFO_DTC_VF_V1;

/*!
 * Used in \ref NV_GPU_THERMAL_POLICY_INFO_V1. Structure representing the
 * static data found in the VOLT domain group controller.
 */
typedef struct _NV_GPU_THERMAL_POLICY_INFO_DTC_VOLT_V1
{
    /*!
     * Rated TDP frequency.
     */
    NvU32 ratedTdpFreqKHz;

    /*!
     * Rated TDP P-state index.
     */
    NvU32 pstateIdxTdp;

    /*!
     * Maximum voltage value to limit. Limiting to this voltage will cause the
     * GPU to be perf. limited the least.
     */
    NvU32 voltageMaxuV;

    /*!
     * Minimum voltage value to limit. Limiting to this voltage will cause the
     * GPU to be perf. limited the most.
     */
    NvU32 voltageMinuV;

    /*!
     * The size of the voltage limit step.
     */
    NvU32 voltageStepuV;
} NV_GPU_THERMAL_POLICY_INFO_DTC_VOLT_V1;

/*!
 * Used in \ref NV_GPU_THERMAL_POLICY_INFO_PARAMS_V1. Structure of static
 * information describing a Thermal Policy, which specifies a thermal policy/
 * limit to enforce on the GPU.
 */
typedef struct _NV_GPU_THERMAL_POLICY_INFO_V1
{
    /*!
     * NV_GPU_THERMAL_POLICY_TYPE_<xyz>
     */
    NV_GPU_THERMAL_POLICY_TYPE type;

    /*!
     * Index into Thermal Channel Table for input channel.
     */
    NvU8 chIdx;

    /*!
     * Minimum allowed limit value. Signed number of 1/256 degree Celsius.
     */
    NvS32 limitMin;

    /*!
     * Rated/default limit value. Signed number of 1/256 degree Celsius.
     */
    NvS32 limitRated;

    /*!
     * Maximum allowed limit value. Signed number of 1/256 degree Celsius.
     */
    NvS32 limitMax;

    /*!
     * Type-specific information.
     */
    union
    {
        NV_GPU_THERMAL_POLICY_INFO_DTC_VPSTATE_V1   dtcVpstate;
        NV_GPU_THERMAL_POLICY_INFO_DTC_VF_V1        dtcVf;
        NV_GPU_THERMAL_POLICY_INFO_DTC_VOLT_V1      dtcVolt;
        /*!
         * Reserving 32 bytes of space so we can add new types without
         * needing to add a new version.
         */
        NvU8 rsvd[32];
    } data;
} NV_GPU_THERMAL_POLICY_INFO_V1;

/*!
 * Used in \ref NvAPI_GPU_ThermalPolicyGetInfo. Structure representing the
 * static state information associated with the GPU's Thermal Policy
 * functionality.
 */
typedef struct _NV_GPU_THERMAL_POLICY_INFO_PARAMS_V1
{
    /*!
     * Version of structure. Must always be first.
     */
    NvU32 version;

    /*!
     * Mask of Thermal Policy entries specified on this GPU.
     */
    NvU32 policyMask;

    /*!
     * Thermal Policy Table index for the policy controlling the GPS
     * temperature controller.
     */
    NvU8 gpsPolicyIdx;

    /*!
     * Thermal Policy Table index for the policy controlling acoustics.
     */
    NvU8 acousticPolicyIdx;

    /*!
     * Array of Thermal Policy entries. Has valid indexes corresponding to the
     * bits in \ref policyMask.
     */
    NV_GPU_THERMAL_POLICY_INFO_V1 policies[NV_GPU_THERMAL_POLICY_MAX_POLICIES_V1];
} NV_GPU_THERMAL_POLICY_INFO_PARAMS_V1;

#define NV_GPU_THERMAL_POLICY_INFO_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_THERMAL_POLICY_INFO_PARAMS_V1,1)
#define NV_GPU_THERMAL_POLICY_INFO_PARAMS_VER   NV_GPU_THERMAL_POLICY_INFO_PARAMS_VER_1

#define NV_GPU_THERMAL_POLICY_INFO_PARAMS       NV_GPU_THERMAL_POLICY_INFO_PARAMS_V1

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_ThermalPolicyGetInfo()
//
//! DESCRIPTION:    Retrieves information about the Thermal Policy support on
//!                 the GPU.
//!
//!                 Thermal Policy entries are limits (in temperature) which
//!                 the RM/PMU Thermal Policy functionality must try to enforce
//!                 via a specified mechanism.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version: 328.00
//!
//! \param [in]     hPhysicalGpu    GPU selection
//! \param [in,out] pPolicyInfo
//!     Structure containing the description of Thermal Policies.
//!
//! \return This API can return any of the error codes enumerated in
//!         #NvAPI_Status. If there are return error codes with specific
//!         meaning for this API, they are listed below.
//!
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_ThermalPolicyGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_THERMAL_POLICY_INFO_PARAMS *pPolicyInfo);

//! \ingroup gputhermal
//! @{

#define NV_GPU_THERMAL_POLICY_DOMAIN_GROUPS_LIMITS_MAX_DOMAIN_GROUPS          3
#define NV_GPU_THERMAL_POLICY_DOMAIN_GROUP_LIMIT_VALUE_DISABLED      0xFFFFFFFF

/*!
 * Used in \ref NV_GPU_THERMAL_POLICY_STATUS_DTC_VPSTATE, \ref
 * NV_GPU_THERMAL_POLICY_STATUS_DTC_VF, and \ref
 * NV_GPU_THERMAL_POLICY_STATUS_DTC_VOLT. Structure representing the dynamic
 * status of a particular domain group controller.
 */
typedef struct _NV_GPU_THERMAL_POLICY_STATUS_DOMGRP
{
    /*!
     * Limits imposed by the controller.
     */
    NvU32 limits[NV_GPU_THERMAL_POLICY_DOMAIN_GROUPS_LIMITS_MAX_DOMAIN_GROUPS];
} NV_GPU_THERMAL_POLICY_STATUS_DOMGRP;

/*!
 * Used in \ref NV_GPU_THERMAL_POLICY_STATUS_DTC_VPSTATE, \ref
 * NV_GPU_THERMAL_POLICY_STATUS_DTC_VF, and \ref
 * NV_GPU_THERMAL_POLICY_STATUS_DTC_VOLT. Structure representing the dynamic
 * status of a particular domain group controller.
 */
typedef struct _NV_GPU_THERMAL_POLICY_STATUS_DTC
{
    /*!
     * Keeps track of the number of samples taken for the current threshold
     * range. If the number of samples exceeds the sample threshold, the
     * algorithm will alter its behavior.
     */
    NvU8 sampleCount;
} NV_GPU_THERMAL_POLICY_STATUS_DTC;

/*!
 * Used in \ref NV_GPU_THERMAL_POLICY_STATUS_V1. Structure representing the
 * current dynamic status of a particular VPSTATE domain group controller.
 */
typedef struct _NV_GPU_THERMAL_POLICY_STATUS_DTC_VPSTATE
{
    /*!
     * Domain Group dynamic data. Must always be first.
     */
    NV_GPU_THERMAL_POLICY_STATUS_DOMGRP domgrp;

    /*!
     * DTC controller dynamic data.
     */
    NV_GPU_THERMAL_POLICY_STATUS_DTC dtc;

    /*!
     * Current virtual P-state used as the controller's limit.
     */
    NvU32 vpstateLimitCurr;
} NV_GPU_THERMAL_POLICY_STATUS_DTC_VPSTATE;

/*!
 * Used in \ref NV_GPU_THERMAL_POLICY_STATUS_V1. Structure representing the
 * current dynamic status of a particular VF domain group controller.
 */
typedef struct _NV_GPU_THERMAL_POLICY_STATUS_DTC_VF
{
    /*!
     * Domain Group dynamic data. Must always be first.
     */
    NV_GPU_THERMAL_POLICY_STATUS_DOMGRP domgrp;

    /*!
     * DTC controller dynamic data.
     */
    NV_GPU_THERMAL_POLICY_STATUS_DTC dtc;
} NV_GPU_THERMAL_POLICY_STATUS_DTC_VF;

/*!
 *
 */
typedef struct _NV_GPU_THERMAL_POLICY_STATUS_DTC_VOLT
{
    /*!
     * Domain Group dynamic data. Must always be first.
     */
    NV_GPU_THERMAL_POLICY_STATUS_DOMGRP domgrp;

    /*!
     * DTC controller dynamic data.
     */
    NV_GPU_THERMAL_POLICY_STATUS_DTC dtc;
} NV_GPU_THERMAL_POLICY_STATUS_DTC_VOLT;

/*!
 * Used in \ref NV_GPU_THERMAL_POLICY_STATUS_PARAMS_V1. Structure representing
 * the dynamic state associated with a Thermal Policy entry.
 */
typedef struct _NV_GPU_THERMAL_POLICY_STATUS_V1
{
    /*!
     * NV_GPU_THERMAL_POLICY_TYPE_<xyz>
     */
    NV_GPU_THERMAL_POLICY_TYPE type;

    /*!
     * Current value retrieved from the monitored Thermal Channel. Stored as 1/256 degree Celsius.
     */
    NvS32 valueCurr;

    /*!
     * Reserving 16 bytes for future use w/o needing to add new structure
     * version.
     */
    NvU8 rsvd[16];

    /*!
     * Type-specific dynamic state.
     */
    union
    {
        NV_GPU_THERMAL_POLICY_STATUS_DOMGRP         domGrp;
        NV_GPU_THERMAL_POLICY_STATUS_DTC_VPSTATE    dtcVpstate;
        NV_GPU_THERMAL_POLICY_STATUS_DTC_VF         dtcVf;
        NV_GPU_THERMAL_POLICY_STATUS_DTC_VOLT       dtcVolt;
    } data;
} NV_GPU_THERMAL_POLICY_STATUS_V1;

/*!
 * Used in \ref NvAPI_GPU_ThermalPolicyGetStatus. Structure representing the
 * dynamic status information associated with a set of Thermal Policies within
 * the GPU's Thermal Policy functionality.
 */
typedef struct _NV_GPU_THERMAL_POLICY_STATUS_PARAMS_V1
{
    /*!
     * Version of structure. Must always be first.
     */
    NvU32 version;

    /*!
     * Mask of Thermal Policy entries requested by the client.
     */
    NvU32 policyMask;

    /*!
     * Reserving 16 bytes for future use w/o needing to add new structure
     * version.
     */
    NvU8 rsvd[16];

    /*!
     * Array of Thermal Policy entries. Has valid indexes corresponding to
     * the bits set in \ref policyMask.
     */
    NV_GPU_THERMAL_POLICY_STATUS_V1 policies[NV_GPU_THERMAL_POLICY_MAX_POLICIES_V1];
} NV_GPU_THERMAL_POLICY_STATUS_PARAMS_V1;

#define NV_GPU_THERMAL_POLICY_STATUS_PARAMS_VER_1   MAKE_NVAPI_VERSION(NV_GPU_THERMAL_POLICY_STATUS_PARAMS_V1,1)
#define NV_GPU_THERMAL_POLICY_STATUS_PARAMS_VER     NV_GPU_THERMAL_POLICY_STATUS_PARAMS_VER_1

#define NV_GPU_THERMAL_POLICY_STATUS_PARAMS         NV_GPU_THERMAL_POLICY_STATUS_PARAMS_V1

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_ThermalPolicyGetStatus()
//
//! DESCRIPTION:    Retrieves the current dynamic state of a set of Thermal
//!                 Policy entries on the GPU.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version: 328.00
//!
//! \param [in]     hPhysicalGpu    GPU selection
//! \param [in/out] pPolicyStatus
//!     Structure containing the state of a set of Thermal Policies.
//!
//! \return This API can return any of the error codes enumerated in
//!         #NvAPI_Status. If there are return error codes with specific
//!         meaning for this API, they are listed below.
//!
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_ThermalPolicyGetStatus(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_THERMAL_POLICY_STATUS_PARAMS *pPolicyStatus);



//! \ingroup gputhermal
//! @{

/*!
 * Used in \ref NV_GPU_THERMAL_POLICY_DTC_CONTROL,
 * \ref NV_GPU_THERMAL_POLICY_DTC_VPSTATE_CONTROL, and
 * \ref NV_GPU_THERMAL_POLICY_DTC_VOLT_CONTROL. Structure representing the
 * domain group controller.
 */
typedef struct _NV_GPU_THERMAL_POLICY_DOMGRP_CONTROL_V1
{
    /*!
     * A boolean flag to indicate the controller shall not impose a perf.
     * limit that would cause the clocks to fall below the Rated TDP VPstate.
     */
    NvU8 hasRatedTdpVpstateFloor:1;
    NvU8 rsvd:7;
} NV_GPU_THERMAL_POLICY_DOMGRP_CONTROL_V1;

/*!
 * Used in \ref NV_GPU_THERMAL_POLICY_DTC_CONTROL,
 * \ref NV_GPU_THERMAL_POLICY_DTC_VPSTATE_CONTROL, and
 * \ref NV_GPU_THERMAL_POLICY_DTC_VOLT_CONTROL. Structure representing the
 * control parameters of the DTC algorithm.
 */
typedef struct _NV_GPU_THERMAL_POLICY_DTC_CONTROL_V1
{
    /*!
     * The number of levels the controller will step when the temperature lies
     * in the aggressive range.
     */
    NvU8 aggressiveStep;

    /*!
     * The number of levels the controller will step when the temperature lies
     * in the release range.
     */
    NvU8 releaseStep;

    /*!
     * The number of contiguous samples the controller must have in the hold
     * range before increasing the perf. by one controller level. A value of
     * 0xFF specifies the controller will not increase perf. while in the hold
     * range.
     */
    NvU8 holdSampleThreshold;

    /*!
     * The number of contiguous samples the controller must have in the
     * aggressive, moderate, or release range before holding the perf. level,
     * allowing any temperature lag to catch up.
     */
    NvU8 stepSampleThreshold;

    /*!
     * Critical temperature threshold. Value is stored as signed 1/256 degree Celsius.
     */
    NvS32 thresholdCritical;

    /*!
     * Aggressive temperature threshold. Value is stored as signed 1/256 degree Celsius.
     */
    NvS32 thresholdAggressive;

    /*!
     * Moderate temperature threshold. Value is stored as signed 1/256 degree Celsius.
     */
    NvS32 thresholdModerate;

    /*!
     * Release temperature threshold. Value is stored as signed 1/256 degree Celsius.
     */
    NvS32 thresholdRelease;

    /*!
     * Disengage temperature threshold. Value is stored as signed 1/256 degree Celsius.
     */
    NvS32 thresholdDisengage;
} NV_GPU_THERMAL_POLICY_DTC_CONTROL_V1;

/*!
 * Used in \ref NV_GPU_THERMAL_POLICY_CONTROL_V1. Structure representing the
 * DTC temperature controller that uses virtual P-states as its limits.
 */
typedef struct _NV_GPU_THERMAL_POLICY_DTC_VPSTATE_CONTROL_V1
{
    /*!
     * Domain group controller control parameters. Must always be first!
     */
    NV_GPU_THERMAL_POLICY_DOMGRP_CONTROL_V1 super;

    /*!
     * DTC control algorithm control parameters.
     */
    NV_GPU_THERMAL_POLICY_DTC_CONTROL_V1 dtc;
} NV_GPU_THERMAL_POLICY_DTC_VPSTATE_CONTROL_V1;

/*!
 * Used in \ref NV_GPU_THERMAL_POLICY_CONTROL_V1. Structure representing the
 * DTC temperature controller that uses VF points as its limits.
 */
typedef struct _NV_GPU_THERMAL_POLICY_DTC_VF_CONTROL_V1
{
    /*!
     * Domain group controller control parameters. Must always be first!
     */
    NV_GPU_THERMAL_POLICY_DOMGRP_CONTROL_V1 super;

    /*!
     * DTC control algorithm control parameters.
     */
    NV_GPU_THERMAL_POLICY_DTC_CONTROL_V1 dtc;
} NV_GPU_THERMAL_POLICY_DTC_VF_CONTROL_V1;

/*!
 * Used in \ref NV_GPU_THERMAL_POLICY_CONTROL_V1. Structure representing the
 * DTC temperature controller that uses voltage as its limits.
 */
typedef struct _NV_GPU_THERMAL_POLICY_DTC_VOLT_CONTROL_V1
{
    /*!
     * Domain group controller control parameters. Must always be first!
     */
    NV_GPU_THERMAL_POLICY_DOMGRP_CONTROL_V1 super;

    /*!
     * DTC control algorithm control parameters.
     */
    NV_GPU_THERMAL_POLICY_DTC_CONTROL_V1 dtc;
} NV_GPU_THERMAL_POLICY_DTC_VOLT_CONTROL_V1;

/*!
 * Used in \ref NV_GPU_THERMAL_POLICY_CONTROL_PARAMS_V1. Structure representing
 * the control/policy parameters of a Thermal Policy entry.
 */
typedef struct _NV_GPU_THERMAL_POLICY_CONTROL_V1
{
    /*!
     * NV_GPU_THERMAL_POLICY_TYPE_<xyz>
     */
    NV_GPU_THERMAL_POLICY_TYPE type;

    /*!
     * Current limit value to enforce as requested by a client. Must always be
     * within range of [\ref NV_GPU_THERMAL_POLICY_INFO_V1::limitMin, \ref
     * NV_GPU_THERMAL_POLICY_INFO_V1::limitMax].
     */
    NvS32 limitCurr;

    /*!
     * Current polling period of the thermal policy. A value of 0 indicates
     * the policy does not actively poll the thermal channel it is monitoring.
     * Units are in microseconds.
     */
    NvU32 pollingPeriodms;

    /*!
     * Reserving 16 bytes for future use w/o needing to add new structure
     * version.
     */
    NvU8 rsvd[16];

    /*!
     * Type-specific data.
     */
    union
    {
        NV_GPU_THERMAL_POLICY_DTC_VPSTATE_CONTROL_V1    dtcVpstate;
        NV_GPU_THERMAL_POLICY_DTC_VF_CONTROL_V1         dtcVf;
        NV_GPU_THERMAL_POLICY_DTC_VOLT_CONTROL_V1       dtcVolt;
        /*!
         * Reserving 32 bytes for future use w/o needing to add new structure
         * version.
         */
        NvU8 rsvd[32];
    } data;
} NV_GPU_THERMAL_POLICY_CONTROL_V1;
/*!
 * Used in \ref NvAPI_GPU_ThermalPolicyGetControl, \ref NvAPI_GPU_ThermalPolicySetControl.
 * Structure representing the control/policy parameters associated with a set
 * of Thermal Policy entries in the GPU's thermal policy functionality.
 */
typedef struct
{
    /*!
     * Version of structure. Must always be first.
     */
    NvU32 version;

    /*!
     * Mask of Thermal Policy entries requested by the client.
     */
    NvU32 policyMask;

    /*!
     * Reserving 16 bytes for future use w/o needing to add new structure
     * version.
     */
    NvU8 rsvd[16];

    /*!
     * Array of Thermal Policy entries. Has valid indexes corresponding to the
     * bits set in \ref policyMask.
     */
    NV_GPU_THERMAL_POLICY_CONTROL_V1 policies[NV_GPU_THERMAL_POLICY_MAX_POLICIES_V1];
} NV_GPU_THERMAL_POLICY_CONTROL_PARAMS_V1;

#define NV_GPU_THERMAL_POLICY_CONTROL_PARAMS_VER_1  MAKE_NVAPI_VERSION(NV_GPU_THERMAL_POLICY_CONTROL_PARAMS_V1,1)
#define NV_GPU_THERMAL_POLICY_CONTROL_PARAMS_VER    NV_GPU_THERMAL_POLICY_CONTROL_PARAMS_VER_1

#define NV_GPU_THERMAL_POLICY_CONTROL_PARAMS        NV_GPU_THERMAL_POLICY_CONTROL_PARAMS_V1

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_ThermalPolicyGetControl()
//
//! DESCRIPTION:    This function retrieves the current control/policy of a
//!                 set of thermal policy entries in the RM/PMU's Thermal
//!                 Policy functionality.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version: 238.00
//!
//! \param [in]     hPhysicalGpu    GPU selection
//! \param [in/out] pPolicyControl
//!     Structure containing the current control/policy of a set of Thermal
//!     Policy entries.
//!
//! \return This API can return any of the error codes enumerated in
//!         #NvAPI_Status. If there are return error codes with specific
//!         meaning for this API, they are listed below.
//!
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_ThermalPolicyGetControl(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_THERMAL_POLICY_CONTROL_PARAMS *pPolicyControl);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_ThermalPolicySetControl()
//
//! DESCRIPTION:    This function requests the control/policy of a set of
//!                 thermal policy entries in the RM/PMU's Thermal Policy
//!                 functionality.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version: 328.00
//!
//! \param [in]     hPhysicalGpu    GPU selection
//! \param [in]     hPolicyControl
//!     Structure containing the requested control/policy of a set of Thermal
//!     Policy entries.
//!
//! \return This API can return any of the error codes enumerated in
//!         #NvAPI_Status. If there are return error codes with specific
//!         meaning for this API, they are listed below.
//!
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_ThermalPolicySetControl(__in NvPhysicalGpuHandle hPhysicalGpu, __in NV_GPU_THERMAL_POLICY_CONTROL_PARAMS *pPolicyControl);



//! \addtogroup gputhermal
//! @{

/*!
 * Enumeration of Thermal Policies.  Unique identifiers for different Thermal
 * Policies being enforced on the GPU.
 */
typedef enum
{
    NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_GPS,
    NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_ACOUSTIC,
} NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_ID;

/*!
 * Enumeration of thermal readings.  Specifies the type of temperature reading
 * that is driving the Thermal Policy.
 */
typedef enum
{
    NV_GPU_CLIENT_THERMAL_READING_ID_GPU_AVG,
    NV_GPU_CLIENT_THERMAL_READING_ID_GPU_MAX,
    NV_GPU_CLIENT_THERMAL_READING_ID_BOARD,
    NV_GPU_CLIENT_THERMAL_READING_ID_MEMORY,
    NV_GPU_CLIENT_THERMAL_READING_ID_PWR_SUPPLY
} NV_GPU_CLIENT_THERMAL_READING_ID;

#define NV_GPU_CLIENT_THERMAL_POLICIES_NUM_POLICIES_MAX      4

/*!
 * Used in \ref NV_GPU_CLIENT_THERMAL_POLICIES_INFO_V1.
 */
typedef struct
{
    /*!
     * Policy ID.  Unique identifier for a policy.
     */
    NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_ID policyId;

    /*!
     * Thermal reading ID driving this thermal policy.
     */
    NV_GPU_CLIENT_THERMAL_READING_ID channelId;

    /*!
     * Minimum allowed thermal policy limit.
     */
    NvS32 thermalLimitMin;

    /*!
     * Default thermal policy limit.
     */
    NvS32 thermalLimitDefault;

    /*!
     * Maximum allowed thermal policy limit.
     */
    NvS32 thermalLimitMax;

} NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_INFO_V1;

/*!
 * Used in \ref NV_GPU_CLIENT_THERMAL_POLICIES_INFO_V2.
 */
typedef struct
{
    /*!
     * Policy ID.  Unique identifier for a policy.
     */
    NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_ID policyId;

    /*!
     * Thermal reading ID driving this thermal policy.
     */
    NV_GPU_CLIENT_THERMAL_READING_ID channelId;

    /*!
     * Minimum allowed thermal policy limit.
     */
    NvS32 thermalLimitMin;

    /*!
     * Default thermal policy limit.
     */
    NvS32 thermalLimitDefault;

    /*!
     * Maximum allowed thermal policy limit.
     */
    NvS32 thermalLimitMax;

    /*!
     * Specifies whether or not the thermal policy can impose greater
     * performance restrictions to maintain acoustic levels.
     */
    NvU8 acousticPreferenceAvailable:1;
    NvU8 reserved                   :7;

} NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_INFO_V2;

/*!
 * Used in \ref NV_GPU_CLIENT_THERMAL_POLICIES_INFO_V1.
 *
 * Describes the set of Thermal Policies which are controlling GPU temperature.
 */
typedef struct
{
    /*!
     * Version of structure.  Must always be first.
     */
    NvU32 version;

    /*!
     * Indicates that this GPU support Client Thermal Policy Interfaces.
     */
    NvU8 isSupported:1;
    NvU8 reserved   :7;

    /*!
     * Number of Thermal Policies this GPU supports.
     */
    NvU8 numPolicies;

    /*
     * Array of static information for each Thermal Policy.  Array has a valid
     * index ranging from 0 to numPolicies - 1.
     */
    NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_INFO_V1
        policies[NV_GPU_CLIENT_THERMAL_POLICIES_NUM_POLICIES_MAX];

} NV_GPU_CLIENT_THERMAL_POLICIES_INFO_V1;

/*!
 * Used in \ref NV_GPU_CLIENT_THERMAL_POLICIES_INFO_V2.
 *
 * Describes the set of Thermal Policies which are controlling GPU temperature.
 */
typedef struct _NV_GPU_CLIENT_THERMAL_POLICIES_INFO_V2
{
    /*!
     * Version of structure.  Must always be first.
     */
    NvU32 version;

    /*!
     * Indicates that this GPU support Client Thermal Policy Interfaces.
     */
    NvU8 isSupported:1;
    NvU8 reserved   :7;

    /*!
     * Number of Thermal Policies this GPU supports.
     */
    NvU8 numPolicies;

    /*
     * Array of static information for each Thermal Policy.  Array has a valid
     * index ranging from 0 to numPolicies - 1.
     */
    NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_INFO_V2
        policies[NV_GPU_CLIENT_THERMAL_POLICIES_NUM_POLICIES_MAX];

} NV_GPU_CLIENT_THERMAL_POLICIES_INFO_V2;

#define NV_GPU_CLIENT_THERMAL_POLICIES_INFO_VER_1 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_THERMAL_POLICIES_INFO_V1,1)
#define NV_GPU_CLIENT_THERMAL_POLICIES_INFO_VER_2 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_THERMAL_POLICIES_INFO_V2,2)
#define NV_GPU_CLIENT_THERMAL_POLICIES_INFO_VER   NV_GPU_CLIENT_THERMAL_POLICIES_INFO_VER_2

typedef NV_GPU_CLIENT_THERMAL_POLICIES_INFO_V2    NV_GPU_CLIENT_THERMAL_POLICIES_INFO;

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_ClientThermalPoliciesGetInfo
//
//! DESCRIPTION: Accessor for static information describing the public GPU
//!              thermal policies which are controlling GPU temperature.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 310
//!
//! \param [in]  hPhysicalGpu               GPU selection
//! \param [out] pClientThermalPoliciesInfo Structure containing the description
//!                  of the GPU thermal policies.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_ClientThermalPoliciesGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_CLIENT_THERMAL_POLICIES_INFO *pClientThermalPoliciesInfo);



//! \addtogroup gputhermal
//! @{

/*!
 * Used in \ref NV_GPU_CLIENT_THERMAL_POLICIES_STATUS_V1.
 */
typedef struct
{
    /*!
     * Policy ID.  Unique identifier for a policy.
     */
    NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_ID policyId;

    /*!
     * Current thermal policy limit.
     */
    NvS32 thermalLimit;
} NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_STATUS_V1;

/*!
 * Used in \ref NV_GPU_CLIENT_THERMAL_POLICIES_STATUS_V2.
 */
typedef struct _NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_STATUS_V2
{
    /*!
     * Policy ID.  Unique identifier for a policy.
     */
    NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_ID policyId;

    /*!
     * Current thermal policy limit.
     */
    NvS32 thermalLimit;

    /*!
     * Specifies the calling is willing to sacrifice performance to maintain
     * acoustics.
     */
    NvU8 preferAcoustics:1;
    NvU8 reserved       :7;

} NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_STATUS_V2;

/*!
 * Used in \ref NV_GPU_CLIENT_THERMAL_POLICIES_STATUS_V1.
 *
 * Describes/specifies the current settings of a set of Thermal Policies which
 * are controlling GPU temperature.
 */
typedef struct
{
    /*!
     * Version of structure.  Must always be first.
     */
    NvU32 version;

    /*!
     * Number of Thermal Policies specified in the policies array.  Caller sets
     * this value to 0 to specify that all policies should be queried.
     */
    NvU8 numPolicies;

    /*!
     * Array of current settings for each specified Thermal Policy.  This array
     * has a valid index ranging from 0 to numPolicies - 1.
     */
    NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_STATUS_V1
        policies[NV_GPU_CLIENT_THERMAL_POLICIES_NUM_POLICIES_MAX];

} NV_GPU_CLIENT_THERMAL_POLICIES_STATUS_V1;

/*!
 * Used in \ref NV_GPU_CLIENT_THERMAL_POLICIES_STATUS_V2.
 *
 * Describes/specifies the current settings of a set of Thermal Policies which
 * are controlling GPU temperature.
 */
typedef struct _NV_GPU_CLIENT_THERMAL_POLICIES_STATUS_V2
{
    /*!
     * Version of structure.  Must always be first.
     */
    NvU32 version;

    /*!
     * Number of Thermal Policies specified in the policies array.  Caller sets
     * this value to 0 to specify that all policies should be queried.
     */
    NvU8 numPolicies;

    /*!
     * Array of current settings for each specified Thermal Policy.  This array
     * has a valid index ranging from 0 to numPolicies - 1.
     */
    NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_STATUS_V2
        policies[NV_GPU_CLIENT_THERMAL_POLICIES_NUM_POLICIES_MAX];

} NV_GPU_CLIENT_THERMAL_POLICIES_STATUS_V2;

#define NV_GPU_CLIENT_THERMAL_POLICIES_STATUS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_THERMAL_POLICIES_STATUS_V1,1)
#define NV_GPU_CLIENT_THERMAL_POLICIES_STATUS_VER_2 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_THERMAL_POLICIES_STATUS_V2,2)
#define NV_GPU_CLIENT_THERMAL_POLICIES_STATUS_VER   NV_GPU_CLIENT_THERMAL_POLICIES_STATUS_VER_2

typedef NV_GPU_CLIENT_THERMAL_POLICIES_STATUS_V2    NV_GPU_CLIENT_THERMAL_POLICIES_STATUS;

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_ClientThermalPoliciesGetStatus
//
// !DESCRIPTION: Accessor for current state of the public GPU thermal
//!              policies which are controlling GPU temperature.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 310
//!
//! \param [in]  hPhysicalGpu                 GPU selection
//! \param [out] pClientThermalPoliciesStatus Structure containing the current
//!                  state of a set of GPU thermal policies.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_ClientThermalPoliciesGetStatus(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_CLIENT_THERMAL_POLICIES_STATUS *pClientThermalPoliciesStatus);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_ClientThermalPoliciesSetStatus
//
//! DESCRIPTION: Mutator for state of the public GPU thermal policies which
//!              are controlling GPU temperature.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 310
//!
//! \param [in] hPhysicalGpu                 GPU selection
//! \param [in] pClientThermalPoliciesStatus Structure containing the requested
//!                 state of a set of GPU thermal policies.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_ClientThermalPoliciesSetStatus(__in NvPhysicalGpuHandle hPhysicalGpu, __in NV_GPU_CLIENT_THERMAL_POLICIES_STATUS *pClientThermalPoliciesStatus);





//! \ingroup gpu
//! Used in NvAPI_GPU_SetDitherControl(). 
typedef enum _NVAPI_DITHER_TYPE
{
    NVAPI_DITHER_TYPE_DEFAULT = 0,  //!< enable/disable based on the default behavior
    NVAPI_DITHER_TYPE_ENABLE  = 1,  //!< enable dithering
    NVAPI_DITHER_TYPE_DISABLE = 2,  //!< disable dithering
} NVAPI_DITHER_TYPE;


//! \ingroup gpu
//! Used in NvAPI_GPU_SetDitherControl().
typedef enum _NVAPI_DITHER_BITS
{
    NVAPI_DITHER_BITS_6BITS = 0,
    NVAPI_DITHER_BITS_8BITS = 1,
    NVAPI_DITHER_BITS_10BITS = 2,
} NVAPI_DITHER_BITS;


//! \ingroup gpu
//! Used in NvAPI_GPU_SetDitherControl().
typedef enum _NVAPI_DITHER_MODE
{
    NVAPI_DITHER_MODE_DYNAMIC_ERR_ACC = 0,
    NVAPI_DITHER_MODE_STATIC_ERR_ACC  = 1,
    NVAPI_DITHER_MODE_DYNAMIC_2X2     = 2,
    NVAPI_DITHER_MODE_STATIC_2X2      = 3,
    NVAPI_DITHER_MODE_TEMPORAL        = 4,
} NVAPI_DITHER_MODE;


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_SetDitherControl
//
//! DESCRIPTION: This API sets display related hardware dither controls (for example, dithering a higher bpp framebuffer to a lower bpp display).
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]  outputId     One of the selected outputId retrieved from NvAPI_GPU_GetActiveOutputs() or
//!                           NvAPI_GetView(), to identify the targeted TV.
//! \param [in]  type         The dithering mode to apply (default, enable, or disable)
//! \param [in]  bits         The bits to dither to
//! \param [in]  mode         The dither mode
//!
//! \retval ::NVAPI_OK                             Dither controls successfully set.
//! \retval ::NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE   Handle passed is not a physical GPU handle.
//! \retval ::NVAPI_INVALID_ARGUMENT               Parameters passed do not match the hardware implementation.
//! \retval ::NVAPI_NOT_SUPPORTED                  Dither control feature is not supported on the selected GPU.
//! \retval ::NVAPI_NO_IMPLEMENTATION              No implementation for dither controls implemented for this GPU.
//! \retval ::NVAPI_ERROR                          Dither controls were not successfully propogated
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetDitherControl(NvPhysicalGpuHandle hPhysicalGpu,
                                           NvU32 outputId,
                                           NVAPI_DITHER_TYPE type,
                                           NVAPI_DITHER_BITS bits,
                                           NVAPI_DITHER_MODE mode);



//! \ingroup gpu
//! @{

typedef enum _NVAPI_DITHER_CONTROL_CAP_MODE
{
    NVAPI_DITHER_CONTROL_CAP_MODE_DYNAMIC_ERR_ACC     = NV_BIT(NVAPI_DITHER_MODE_DYNAMIC_ERR_ACC),
    NVAPI_DITHER_CONTROL_CAP_MODE_STATIC_ERR_ACC      = NV_BIT(NVAPI_DITHER_MODE_STATIC_ERR_ACC),
    NVAPI_DITHER_CONTROL_CAP_MODE_DYNAMIC_2X2         = NV_BIT(NVAPI_DITHER_MODE_DYNAMIC_2X2),
    NVAPI_DITHER_CONTROL_CAP_MODE_STATIC_2X2          = NV_BIT(NVAPI_DITHER_MODE_STATIC_2X2),
    NVAPI_DITHER_CONTROL_CAP_MODE_TEMPORAL            = NV_BIT(NVAPI_DITHER_MODE_TEMPORAL),
} NVAPI_DITHER_CONTROL_CAP_MODE;

typedef enum _NVAPI_DITHER_CONTROL_CAP_BITS
{
    NVAPI_DITHER_CONTROL_CAP_BITS_6BITS               = NV_BIT(NVAPI_DITHER_BITS_6BITS),
    NVAPI_DITHER_CONTROL_CAP_BITS_8BITS               = NV_BIT(NVAPI_DITHER_BITS_8BITS),
    NVAPI_DITHER_CONTROL_CAP_BITS_10BITS              = NV_BIT(NVAPI_DITHER_BITS_10BITS),
} NVAPI_DITHER_CONTROL_CAP_BITS;

typedef struct _NV_GPU_DITHER_CONTROL_V1
{
    NvU32               version;            //!< Structure version

    NVAPI_DITHER_TYPE   ditherEnable;       //!< The dithering mode to apply (default, enable, or disable)
    NVAPI_DITHER_BITS   ditherBitDepth;     //!< The bits per component of the output
    NVAPI_DITHER_MODE   ditherMode;         //!< The dither mode

    NvU32               ditherBitDepths;    //!< Bitfield of supported NVAPI_DITHER_CONTROL_CAP_MODEs
    NvU32               ditherModes;        //!< Bitfield of supported NVAPI_DITHER_CONTROL_CAP_BITS


} NV_GPU_DITHER_CONTROL_V1;

typedef NV_GPU_DITHER_CONTROL_V1           NV_GPU_DITHER_CONTROL;

#define NV_GPU_DITHER_CONTROL_VER1         MAKE_NVAPI_VERSION(NV_GPU_DITHER_CONTROL_V1,1)
#define NV_GPU_DITHER_CONTROL_VER          NV_GPU_DITHER_CONTROL_VER1

//! @}



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetDitherControl
//
//! DESCRIPTION: This API returns display-related GPU dither controls. 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]    displayId     Address of target active GPU output
//! \param [out]   pDitherData   Struct containing dithering state information
//!
//! \retval ::NVAPI_OK                            Dither controls successfully received.
//! \retval ::NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle.
//! \retval ::NVAPI_INVALID_ARGUMENT              Parameters passed do not match the hardware implementation
//! \retval ::NVAPI_NOT_SUPPORTED                 Dither control feature is not supported on the selected GPU
//! \retval ::NVAPI_NO_IMPLEMENTATION             No implementation for dither controls implemented for this GPU
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetDitherControl(NvU32 displayId, 
                                           NV_GPU_DITHER_CONTROL *pDitherData);


//! \ingroup gpucsc  
//! @{

#define NVAPI_CSC_MATRIX_WIDTH 3
#define NVAPI_CSC_MATRIX_HEIGHT 4

//! Colorspace conversion
typedef struct _NVAPI_CSC_MATRIX
{
    NvU32   useCustomMatrix : 1;                                           //!< If this value is 0, aCSCCoeff values are ignored.
    NvU32   reserved        : 31;                                          //!< Reserved for future expansion
    float   aCSCCoeff [NVAPI_CSC_MATRIX_WIDTH][NVAPI_CSC_MATRIX_HEIGHT];   //!< 3x4 matrix of CSC coefficients
} NVAPI_CSC_MATRIX;

//! Enum of predefined colorspaces that are supported
typedef enum _NV_STANDARD_COLORSPACE
{
    NV_STANDARD_COLORSPACE_DISABLED            = 0,                             //!< CSC disabled, user matrices ignored
    NV_STANDARD_COLORSPACE_AUTOSELECT          = 1,                             //!< Source colorspace is sRGB, output colorspace is defined by display EDID colorimetry info, plus user matrices if indicated
    NV_STANDARD_COLORSPACE_sRGB                = 2,                             //!< sRGB colorspace, plus user matrices if indicated
    NV_STANDARD_COLORSPACE_MONITOR_RGB         = 3,                             //!< Colorspace is defined by display EDID colorimetry info, plus user matrices if indicated
    NV_STANDARD_COLORSPACE_ADOBE_RGB           = 4,                             //!< Adobe RGB colorspace, plus user matrices if indicated
    NV_STANDARD_COLORSPACE_ADOBE_WIDE_GAMUT    = 5,                             //!< Adobe Wide Gamut RGB colorspace, plus user matrices if indicated
    NV_STANDARD_COLORSPACE_APPLE               = 6,                             //!< Apple RGB colorspace, plus user matrices if indicated
    NV_STANDARD_COLORSPACE_NTSC                = 7,                             //!< NTSC RGB colorspace, plus user matrices if indicated
    NV_STANDARD_COLORSPACE_HDTV                = 8,                             //!< HDTV Rec709 RGB colorspace, plus user matrices if indicated
    NV_STANDARD_COLORSPACE_PAL                 = 9,                             //!< PAL/SECAM RGB colorspace, plus user matrices if indicated
    NV_STANDARD_COLORSPACE_DCIP3               = 10,                            //!< DCI-P3 (SMPTE-431-2) RGB colorspace, plus user matrices if indicated
    NV_STANDARD_COLORSPACE_BT2020              = 11,                            //!< BT2020 (ITU-R BT2020) RGB colorspace, plus user matrices if indicated
    NV_STANDARD_COLORSPACE_BT2020_PQ           = 12,                            //!< BT2020 (ITU-R BT2020) RGB colorspace with PQ (SMPTE 2084) gamma, plus user matrices if indicated

    NV_STANDARD_COLORSPACE_MAX                                                  //!< Max valid value +1, for range checking
} NV_STANDARD_COLORSPACE;

//! Enum of colorspace status flags
typedef enum _NV_COLORSPACE_CONVERSION_STATUS_FLAG
{
    NV_COLORSPACE_CONVERSION_STATUS_FLAG_USER_MATRIX_RANGE_CLAMPED = NV_BIT(0),  //!< If User Matrix coefficients were out of range, this flag means some values were automatically clamped to range
    NV_COLORSPACE_CONVERSION_STATUS_FLAG_SW_EMULATION              = NV_BIT(1),  //!< If present, CSC is performed by pixel shaders.  Otherwise, CSC is done in dedicated hardware
    NV_COLORSPACE_CONVERSION_STATUS_FLAG_INFOFRAME_EXT_COLORIMETRY = NV_BIT(2),  //!< If present, extended colorimetry bits have been set in AVI InfoFrame colorimetry data block
} NV_COLORSPACE_CONVERSION_STATUS_FLAG;




//! Param struct used by SetCSC and GetCSC
typedef struct _NV_GPU_COLORSPACE_CONVERSION_V1
{   
    NvU32                    version;                            //!<  Structure version

    NV_STANDARD_COLORSPACE   sourceColorSpace;                   //!<  Specify a predefined colorspace configuration that represents the source material
    NV_STANDARD_COLORSPACE   outputColorSpace;                   //!<  Specify a predefined colorspace configuration to output
    NvU32                    flags;                              //!<  Combination of NV_COLORSPACE_CONVERSION_STATUS_FLAGs
    NvU32                    clientID;                           //!<  Deprecated

    NVAPI_CSC_MATRIX         MatrixPre;                          //!<  Custom CSC Matrix, applied in preorder to colorspace config transform
    NVAPI_CSC_MATRIX         MatrixPost;                         //!<  Custom CSC Matrix, applied in postorder to colorspace config transform
} NV_GPU_COLORSPACE_CONVERSION_V1;

#define NV_GPU_COLORSPACE_CONVERSION_VER1   MAKE_NVAPI_VERSION(NV_GPU_COLORSPACE_CONVERSION_V1,1)

#define NVAPI_CSC_LUT_SIZE 1024

typedef struct _NV_COLOR_RGB
{
    float Red;
    float Green;
    float Blue;

} NV_COLOR_RGB;

//! Param struct V2 used by SetCSC and GetCSC
typedef struct _NV_GPU_COLORSPACE_CONVERSION_V2
{   
    NvU32                    version;                            //!<  Structure version

    NV_STANDARD_COLORSPACE   sourceColorSpace;                   //!<  Specify a predefined colorspace configuration that represents the source material
    NV_STANDARD_COLORSPACE   outputColorSpace;                   //!<  Specify a predefined colorspace configuration to output
    NvU32                    flags;                              //!<  Combination of NV_COLORSPACE_CONVERSION_STATUS_FLAGs
    NvU32                    clientID;                           //!<  Deprecated

    NVAPI_CSC_MATRIX         MatrixPre;                          //!<  Custom CSC Matrix, applied in preorder to colorspace config transform
    NVAPI_CSC_MATRIX         MatrixPost;                         //!<  Custom CSC Matrix, applied in postorder to colorspace config transform

    NV_COLOR_RGB*            pDeGammaLut;                        //!<  Optional de-gamma LUT data for RGB channels
    NV_COLOR_RGB*            pReGammaLut;                        //!<  Optional re-gamma LUT data for RGB channels

    void*                    pLutData;                           //!<  Pointer to combined LUTs data buffer
    NvU32                    lutDataSize;                        //!<  Size of the LUTs data buffer

} NV_GPU_COLORSPACE_CONVERSION_V2;

typedef NV_GPU_COLORSPACE_CONVERSION_V2    NV_GPU_COLORSPACE_CONVERSION;

#define NV_GPU_COLORSPACE_CONVERSION_VER2  MAKE_NVAPI_VERSION(NV_GPU_COLORSPACE_CONVERSION_V2, 2)
#define NV_GPU_COLORSPACE_CONVERSION_VER   NV_GPU_COLORSPACE_CONVERSION_VER2

//! @}



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetColorSpaceConversion
//
//
//! DESCRIPTION:   Returns the colorspace conversion configuration currently applied by the GPU
//!
//! USAGE:         Sequence of calls which caller should make to get the information.
//!                1. First call NvAPI_GPU_GetColorSpaceConversion() with NV_GPU_COLORSPACE_CONVERSION::lutDataSize set to zero to get the size of the optional LUTs data buffer.
//!                2. Allocate memory for LUTs data buffer in NV_GPU_COLORSPACE_CONVERSION::pLutData depending on the returned data buffer size in lutDataSize field.
//!                3. Call NvAPI_GPU_GetColorSpaceConversion() again with the valid pointer to the allocated LUTs data buffer to get LUTs arrays
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]    displayId     Address of target active GPU output
//! \param [out]   pColorData    Current color space conversion configuration data
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, 
//!         they are listed below.          
//!
//! \ingroup gpucsc
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetColorSpaceConversion(NvU32 displayId, 
                                                  NV_GPU_COLORSPACE_CONVERSION *pColorData);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_SetColorSpaceConversion
//
//
//! DESCRIPTION: Sets the colorspace conversion matrix 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]   displayId      Address of target active GPU output
//! \param [in]   colorData      New color space conversion data
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, 
//!         they are listed below.          
//! 
//! \ingropup gpucsc
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetColorSpaceConversion(NvU32 displayId, 
                                                  NV_GPU_COLORSPACE_CONVERSION *pColorData);




//! \ingroup gpulicense
//! @{
//! Enable License Commands
typedef enum _NVAPI_SYS_ENABLE_LICENSE_COMMAND
{
    NVAPI_SYS_ENABLE_LICENSE_CMD_CHALLENGE = 0x01,
    NVAPI_SYS_ENABLE_LICENSE_CMD_RESPONSE  = 0x02,
} NVAPI_SYS_ENABLE_LICENSE_COMMAND;
//! @} 

//! \ingroup gpulicense
//! @{
//! Enable License Constant: Expected Size in bytes of Challenge value
#define NVAPI_SYS_ENABLE_LICENSE_CHALLENGE_SIZE     16
//! Enable License Constant: Expected Size in bytes of Response value
#define NVAPI_SYS_ENABLE_LICENSE_RESPONSE_SIZE      20
//! @} 

//! \ingroup gpulicense
//! @{
//! Parameter data structure for the NVAPI_SYS_ENABLE_LICENSE_CMD_CHALLENGE command - 
//! This command requests a random challenge from driver.
//! It must be invoked before the NVAPI_SYS_ENABLE_LICENSE_CMD_RESPONSE command.
typedef struct _NVAPI_SYS_ENABLE_LICENSE_CHALLENGE_PARAMS
{
    NvU8  challenge[NVAPI_SYS_ENABLE_LICENSE_CHALLENGE_SIZE];    //!< random challenge from driver (OUT)
} NVAPI_SYS_ENABLE_LICENSE_CHALLENGE_PARAMS;

//
//! Parameter data structure for the NVAPI_SYS_ENABLE_LICENSE_CMD_RESPONSE command
//!
//! The response is calculated as HMAC(vendorKEY, (vendorGUID || challenge))
//! where HMAC is the Keyed-Hash Message Authentication Code using SHA-1 as the
//! underlying hash function. See FIPS Publication 198 for details of the algorithm.
typedef struct _NVAPI_SYS_ENABLE_LICENSE_RESPONSE_PARAMS
{
    NvU8   response[NVAPI_SYS_ENABLE_LICENSE_RESPONSE_SIZE];    //!< response from the app (IN/OUT)
} NVAPI_SYS_ENABLE_LICENSE_RESPONSE_PARAMS;

typedef struct _NVAPI_SYS_ENABLE_LICENSE
{
    NvU32  version;                                //!< structure version (IN)
    NVAPI_SYS_ENABLE_LICENSE_COMMAND dwCommand;    //!< command (IN)
    NvGUID vendorGUID;                             //!< vendor GUID from app (IN)
    union
    {
        NVAPI_SYS_ENABLE_LICENSE_CHALLENGE_PARAMS   ChallengeParams;
        NVAPI_SYS_ENABLE_LICENSE_RESPONSE_PARAMS    ResponseParams;
        NvU32                                       ClientID;
    };
} NVAPI_SYS_ENABLE_LICENSE_V1;
//! @} 

//! \ingroup gpulicense
//! @{
typedef NVAPI_SYS_ENABLE_LICENSE_V1      NVAPI_SYS_ENABLE_LICENSE;
#define NVAPI_SYS_ENABLE_LICENSE_VER1    MAKE_NVAPI_VERSION(NVAPI_SYS_ENABLE_LICENSE_V1, 1)
#define NVAPI_SYS_ENABLE_LICENSE_VER     NVAPI_SYS_ENABLE_LICENSE_VER1
//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION_NAME: NvAPI_SYS_EnableLicense
//
//!   DESCRIPTION:   This API allows an approved application to enable an ISV client 
//!    to access a specific feature for which a license is required.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, 
//!         they are listed below.          
//!
//! \ingroup gpulicense
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_EnableLicense(__inout NVAPI_SYS_ENABLE_LICENSE *pEnableLicenseParams);



///////////////////////////////////////////////////////////////////////////////////
//  GPU topology reconfiguration APIs.
//  Provides ability to define one or more SLI devices and standalone GPU topology.
//
//  NV_GPU_TOPOLOGY - this structure defines a set of all GPUs present in a system.  All GPUs with
//  the same parentNdx value describe a single logical GPU.  GPUs that have a unique parentNdx
//  represent standalone GPUs. 
//
//  The values returned in parentNdx are arbitrary.  They are only used to determine which
//  physical GPUs will belong to the same logical-GPU.
//   

//! \addtogroup gputopology
//! @{

//! Used in NV_GPU_TOPOLOGY
typedef enum
{ 
    NV_GPU_TOPOLOGY_STATUS_OK                                   = 0x00000000,//!< SLI is capable, topology "status" field indicates this state.
    NV_GPU_TOPOLOGY_STATUS_INVALID_GPU_COUNT                    = 0x00000001,//!< SLI is NOT capable, "pStatus" param in NvAPI_GetValidGpuTopologies() indicates these states.
    NV_GPU_TOPOLOGY_STATUS_OS_NOT_SUPPORTED                     = 0x00000002,
    NV_GPU_TOPOLOGY_STATUS_OS_ERROR                             = 0x00000004,
    NV_GPU_TOPOLOGY_STATUS_NO_VIDLINK                           = 0x00000008,
    NV_GPU_TOPOLOGY_STATUS_INSUFFICIENT_LINK_WIDTH              = 0x00000010,
    NV_GPU_TOPOLOGY_STATUS_CPU_NOT_SUPPORTED                    = 0x00000020,
    NV_GPU_TOPOLOGY_STATUS_GPU_NOT_SUPPORTED                    = 0x00000040,
    NV_GPU_TOPOLOGY_STATUS_BUS_NOT_SUPPORTED                    = 0x00000080,
    NV_GPU_TOPOLOGY_STATUS_NON_APPROVED_CHIPSET                 = 0x00000100,
    NV_GPU_TOPOLOGY_STATUS_VBIOS_NOT_SUPPORTED                  = 0x00000200,
    NV_GPU_TOPOLOGY_STATUS_GPU_MISMATCH                         = 0x00000400,
    NV_GPU_TOPOLOGY_STATUS_ARCH_MISMATCH                        = 0x00000800,
    NV_GPU_TOPOLOGY_STATUS_IMPL_MISMATCH                        = 0x00001000,
    NV_GPU_TOPOLOGY_STATUS_SLI_WITH_TCC_NOT_SUPPORTED           = 0x00002000,
    NV_GPU_TOPOLOGY_STATUS_NON_PCIE_BUS                         = 0x00004000,
    NV_GPU_TOPOLOGY_STATUS_FB_MISMATCH                          = 0x00008000,
    NV_GPU_TOPOLOGY_STATUS_VBIOS_MISMATCH                       = 0x00010000,
    NV_GPU_TOPOLOGY_STATUS_QUADRO_MISMATCH                      = 0x00020000,
    NV_GPU_TOPOLOGY_STATUS_BUS_TOPOLOGY_ERROR                   = 0x00040000,
    NV_GPU_TOPOLOGY_STATUS_PCI_ID_MISMATCH                      = 0x00080000,
    NV_GPU_TOPOLOGY_STATUS_CONFIGSPACE_ACCESS_ERROR             = 0x00100000,
    NV_GPU_TOPOLOGY_STATUS_INCONSISTENT_CONFIG_SPACE            = 0x00200000,
    NV_GPU_TOPOLOGY_STATUS_CONFIG_NOT_SUPPORTED                 = 0x00400000,
    NV_GPU_TOPOLOGY_STATUS_RM_NOT_SUPPORTED                     = 0x00800000,
    NV_GPU_TOPOLOGY_STATUS_TOPOLOGY_NOT_ALLOWED                 = 0x01000000,
    NV_GPU_TOPOLOGY_STATUS_MOBILE_MISMATCH                      = 0x02000000,//!< The system has a mix of notebook and desktop GPUs.
    NV_GPU_TOPOLOGY_STATUS_NO_TOPOLOGIES_IN_HYBRID_POWER_MODE   = 0x04000000,
    NV_GPU_TOPOLOGY_STATUS_INSUFFICIENT_FB                      = 0x08000000,
    NV_GPU_TOPOLOGY_STATUS_ECC_MISMATCH                         = 0x10000000,//!< The ECC state of the GPUs in the topology is mismatched
    NV_GPU_TOPOLOGY_STATUS_SLI_COOKIE_NOT_PRESENT               = 0x20000000, //!< The required SLI cookie has not been found
    NV_GPU_TOPOLOGY_STATUS_SLI_FINGER_NOT_SUPPORTED             = 0x40000000, //!< The SLI bridge is connected on the wrong finger
    NV_GPU_TOPOLOGY_STATUS_SLI_WITH_ECC_NOT_SUPPORTED           = 0x80000000 //!< SLI + ECC is not supported on Quadro
} NV_GPU_TOPOLOGY_STATUS_FLAGS;

//! Used in NvAPI_SetGpuTopologies()
typedef enum
{ 
    NV_SET_GPU_TOPOLOGY_DEFER_APPLY                 = 0x00000001,//!< Calling application controls the reload of the display driver
    NV_SET_GPU_TOPOLOGY_DEFER_3D_APP_SHUTDOWN       = 0x00000002,//!< Calling application will control the shutdown of 3d applications holding hw resources
    NV_SET_GPU_TOPOLOGY_DEFER_DISPLAY_RECONFIG      = 0x00000004,//!< Calling application will control the display configuration required for the settopology to work
    NV_SET_GPU_TOPOLOGY_RELOAD_DRIVER               = 0x80000000,//!< Calling application requesting force reload given correct topology.
    NV_SET_GPU_TOPOLOGY_DEFER_DISPLAY_REAPPLY       = 0x00000008,//!< Calling application will control the display configuration after the settopology returns.
} NV_SET_GPU_TOPOLOGY_FLAGS;


//! Used in NV_GPU_TOPOLOGY.
//! All of these flags are read-only unless otherwise noted in NvAPI_SetGpuTopologies().
typedef enum
{
    NV_GPU_TOPOLOGY_ACTIVE                          = 0x00000001,//!< This topology is currently active.
    NV_GPU_TOPOLOGY_VIDLINK_PRESENT                 = 0x00000002,//!< Video link betweem all GPUs is present (physically bridged).
    NV_GPU_TOPOLOGY_MULTIGPU                        = 0x00000004,//!< This is a "multi-GPU" labelled topology. 
    NV_GPU_TOPOLOGY_GX2_BOARD                       = 0x00000008,//!< GPUs comprising this topology are "Dagwoods".
    NV_GPU_TOPOLOGY_DYNAMIC_NOT_ALLOWED             = 0x00000010,//!< Dynamically switching to SLI is not allowed, but requires a reboot.
    NV_GPU_TOPOLOGY_ACTIVE_IMPLICIT                 = 0x00000020,//!< Implicit read only SLI is ACTIVE on this topology of GPU. NvAPI_SetHybridMode() can be used to disable this topology.
    
    NV_GPU_TOPOLOGY_ENABLE_SLI_BY_DEFAULT           = 0x00000040,//!< SLI must be enabled by default, otherwise SLI is optional
    NV_GPU_TOPOLOGY_ENABLE_CORELOGIC_BROADCAST      = 0x00000080,//!< Broadcast mode is enabled in the core logic chipset.
    NV_GPU_TOPOLOGY_BROADCAST                       = 0x00000100,//!< Broadcast mode is enabled
    NV_GPU_TOPOLOGY_UNICAST                         = 0x00000200,//!< Unicast mode enabled
    NV_GPU_TOPOLOGY_4_WAY_SLI                       = 0x00000400,//!< This is a "4-Way-SLI"-labeled topology.
    NV_GPU_TOPOLOGY_COMPUTE                         = 0x00010000,//!< GPUs in this topology are for SLI compute.
                                                                 //!< All GPUs of this SLI compute group can be enumerated using NvAPI_GPU_CudaEnumComputeCapableGpus().
    NV_GPU_TOPOLOGY_SLIMULTIMON                     = 0x00020000,//!< This topology allows multi-display SLI output. 
    NV_GPU_TOPOLOGY_VIDLINK_CONNECTOR_PRESENT       = 0x00040000,//!< Video link connectors on all GPUs are present (but not necessarily connected).
    NV_GPU_TOPOLOGY_VIEW_CAN_SPAN_GPUS              = 0x00080000,//!< This topology allows multi-display SLI output across GPUs.
    NV_GPU_TOPOLOGY_DRIVER_RELOADING                = 0x00100000,//!< The display driver for this topology is currently being reloaded.
    NV_GPU_TOPOLOGY_BASE_MOSAIC                     = 0x00200000,//!< This topology is only for Base Mosaic mode.
    NV_GPU_TOPOLOGY_ALLOW_SLI_MOSAIC                = 0x00400000,//!< This topology will allow SLI Mosaic mode.
    NV_GPU_TOPOLOGY_ALLOW_SLI_MOSAIC_ONLY           = 0x00800000,//!< This topology will allow SLI Mosaic Only. Also, SLI without mosaic is not available.
} NV_GPU_TOPOLOGY_FLAGS;



typedef enum
{
    NV_SLI_GROUP_ACTIVE                          = 0x00000001,//!< This SLI group is currently active.
} NV_SLI_GROUP_FLAGS;



//! Used in NV_GPU_TOPOLOGIES. 
//! This structure defines a set of all GPUs present in a system.  All GPUs with
//! the same parentNdx value describe a single logical GPU.  GPUs that have a unique parentNdx
//! represent standalone GPUs. \n
//! The values returned in parentNdx are arbitrary.  They are only used to determine which
//! physical GPUs belong to the same logical-GPU.
typedef struct
{
    NvU32                   version;                                    //!< Structure version
    NvU32                   gpuCount;                                   //!< Count of GPUs in this topology
    NvPhysicalGpuHandle     hPhysicalGpu[NVAPI_MAX_GPU_PER_TOPOLOGY];   //!< Array of GPU handles
    NvU32                   displayGpuIndex;                            //!< Index of the display GPU owner in the GPU array
    NvU32                   displayOutputTargetMask;                    //!< Target device mask
    NvU32                   flags;                                      //!< One or more topology flags from NV_GPU_TOPOLOGY_FLAGS
    NvU32                   status;                                     //!< Indicates one of the flags in NV_GPU_TOPOLOGY_STATUS_FLAGS
} NV_GPU_TOPOLOGY_V1;


//! Macro for constructing the version field of NV_GPU_TOPOLOGY_V1
#define NV_GPU_TOPOLOGY_VER_1  MAKE_NVAPI_VERSION(NV_GPU_TOPOLOGY_V1,1)

//! Used in NV_GPU_TOPOLOGIES. 
//! This structure defines a set of all GPUs present in a system.  All GPUs with
//! the same parentNdx value describe a single logical GPU.  GPUs that have a unique parentNdx
//! represent standalone GPUs. \n
//! The values returned in parentNdx are arbitrary.  They are only used to determine which
//! physical GPUs belong to the same logical-GPU.
typedef struct
{
    NvU32                   version;                                    //!< Structure version
    NvU32                   gpuCount;                                   //!< Count of GPUs in this topology
    NvPhysicalGpuHandle     hPhysicalGpu[NVAPI_MAX_GPU_PER_TOPOLOGY];   //!< Array of GPU handles
    NvU32                   displayGpuIndex;                            //!< Index of the display GPU owner in the GPU array
    union {
        NvU32               displayOutputTargetMask;                    //!< Target device mask
        NvU32               displayId;                                  //!< Target displayId
    };         
    NvU32                   noDisplayGpuMask;                           //!< Index mask in the hPhysicalGpu[] array pointing to GPUs that cannot display when SLI is enabled
    NvU32                   flags;                                      //!< One or more topology flags from NV_GPU_TOPOLOGY_FLAGS
    NvU32                   status;                                     //!< Indicates one or more of the flags defined in NV_GPU_TOPOLOGY_STATUS_FLAGS
} NV_GPU_TOPOLOGY_V2;

//! Macro for constructing the version field of NV_GPU_TOPOLOGY_V2
#define NV_GPU_TOPOLOGY_VER_2  MAKE_NVAPI_VERSION(NV_GPU_TOPOLOGY_V2,2)

#define NV_GPU_TOPOLOGY        NV_GPU_TOPOLOGY_V2
#define NV_GPU_TOPOLOGY_VER    NV_GPU_TOPOLOGY_VER_2


typedef struct
{
    NvU32                   version;                                    //!< Structure version
    NvU64                   topologyMask;                               //!< Mask of indexes in gpuTopo
    NvU32                   flags;                                      //!< One or more SLI group flags from NV_GPU_SLI_GROUP_FLAGS
} NV_SLI_GROUP;


//! Macro for constucting the version field of NV_SLI_GROUP
#define NV_GPU_SLI_GROUP_VER  MAKE_NVAPI_VERSION(NV_SLI_GROUP,1)


//! First version of NV_GPU_TOPOLOGIES
typedef struct
{
    NvU32                   version;                                    //!< Structure version
    NvU32                   gpuTopoCount;                               //!< Count of valid topologies
    NV_GPU_TOPOLOGY_V1      gpuTopo[NVAPI_MAX_AVAILABLE_GPU_TOPOLOGIES];//!< Maximum number of GPU topologies
} NV_GPU_TOPOLOGIES_V1;


//! Macro for constructing the version field of NV_GPU_TOPOLOGIES_V1
#define NV_GPU_TOPOLOGIES_VER_1  MAKE_NVAPI_VERSION(NV_GPU_TOPOLOGIES_V1,1)


//! Second version of NV_GPU_TOPOLOGIES
typedef struct
{
    NvU32                   version;                                    //!< Structure version
    NvU32                   gpuTopoCount;                               //!< Count of valid topologies
    NV_GPU_TOPOLOGY_V1      gpuTopo[NVAPI_MAX_AVAILABLE_GPU_TOPOLOGIES];//!< Maximum gputopologies
    NvU32                   sliGroupCount;                              //!< Count of valid SLI groups
    NV_SLI_GROUP            sliGroup[NVAPI_MAX_AVAILABLE_SLI_GROUPS];   //!< Maximum SLI groups
} NV_GPU_TOPOLOGIES_V2;

//! Macro for constructing the version field of NV_GPU_TOPOLOGIES_V2
#define NV_GPU_TOPOLOGIES_VER_2  MAKE_NVAPI_VERSION(NV_GPU_TOPOLOGIES_V2,2)




//! Used in NvAPI_GetValidGpuTopologies() and NvAPI_SetGpuTopologies()
typedef struct 
{
    NvU32                   version;                                    //!< Structure version
    NvU32                   gpuTopoCount;                               //!< Count of valid topologies
    NV_GPU_TOPOLOGY         gpuTopo[NVAPI_MAX_AVAILABLE_GPU_TOPOLOGIES];//!< Maximum number of GPU topologies
    NvU32                   sliGroupCount;                              //!< Count of valid SLI groups
    NV_SLI_GROUP            sliGroup[NVAPI_MAX_AVAILABLE_SLI_GROUPS];   //!< Maximum number of SLI groups
} NV_GPU_TOPOLOGIES;

//! Macro for constructing the version field of NV_GPU_TOPOLOGIES
#define NV_GPU_TOPOLOGIES_VER  MAKE_NVAPI_VERSION(NV_GPU_TOPOLOGIES,3)

#define NV_GPU_VALID_GPU_TOPOLOGIES NV_GPU_TOPOLOGIES
#define NV_GPU_INVALID_GPU_TOPOLOGIES NV_GPU_TOPOLOGIES
#define NV_GPU_VALID_GPU_TOPOLOGIES_VER  NV_GPU_TOPOLOGIES_VER
#define NV_GPU_INVALID_GPU_TOPOLOGIES_VER  NV_GPU_TOPOLOGIES_VER
#define NV_GPU_VALID_GPU_TOPOLOGIES_V1 NV_GPU_TOPOLOGIES_V1
#define NV_GPU_INVALID_GPU_TOPOLOGIES_V1 NV_GPU_TOPOLOGIES_V1
#define NV_GPU_VALID_GPU_TOPOLOGIES_VER_1  NV_GPU_TOPOLOGIES_VER_1
#define NV_GPU_INVALID_GPU_TOPOLOGIES_VER_1  NV_GPU_TOPOLOGIES_VER_1
#define NV_GPU_VALID_GPU_TOPOLOGIES_V2 NV_GPU_TOPOLOGIES_V2
#define NV_GPU_INVALID_GPU_TOPOLOGIES_V2 NV_GPU_TOPOLOGIES_V2
#define NV_GPU_VALID_GPU_TOPOLOGIES_VER_2  NV_GPU_TOPOLOGIES_VER_2
#define NV_GPU_INVALID_GPU_TOPOLOGIES_VER_2  NV_GPU_TOPOLOGIES_VER_2


//! @}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GetValidGpuTopologies
//
//!  This function returns all valid GPU topologies that can be used to configure the physical GPUs 
//!  using the NvAPI_SetGpuTopologies API. It also returns the current active topologies.
//! 
//!  This call returns an array of NV_GPU_TOPOLOGY structs; one for each valid configuration 
//!  of GPUs present in the system.  Note that this list is constant as long as GPUs remain in the 
//!  same slots in the system.  It is not affected by which GPUs are presently in use.
//!  NV_GPU_TOPOLOGY.displayGpuIndex returned will match the boot GPU if it exists as an active topology.  
//!  If it not an active topology, it points to the "first" GPU that has a display monitor connected.
//!
//!  This call also returns an array of NV_SLI_GROUP, describing the list of topology combinations 
//!  that can be enabled at the same time.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 85
//!
//! \param [out]      ptopology  An array of *pCount (OUT) topology structures. Use NvAPI_SetGpuTopologies() to set up
//!                              one or several of these GPU topologies.
//! \param [out]      sliGroup   An array of *sliGroupCount (OUT) SLI goup structures, describing which topologies
//!                              can be set up concurrently.
//! \param [out]      pStatus    Any system status returned in case zero topology is retrieved.
//!                              System status is one or more flags in ::NV_GPU_TOPOLOGY_STATUS_FLAGS when SLI is NOT capable.
//!
//! \retval    ::NVAPI_OK                       Call succeeded; If SLI is supported then one or more GPU topologies are returned; else zero topologies are returned.
//! \retval    ::NVAPI_INVALID_ARGUMENT         One or more arguments are invalid.
//! \retval    ::NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found.
//! \retval    ::NVAPI_ERROR                    Miscellaneous Error.
//!
//! \ingroup    gputopology
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetValidGpuTopologies(NV_GPU_VALID_GPU_TOPOLOGIES *pTopology, NvU32 *pStatus);


///////////////////////////////////////////////////////////////////////////////////
//  I2C API
//  Provides ability to read or write data using I2C protocol.
//  These APIs allow I2C access only to DDC monitors


//! \addtogroup i2capi
//! @{
#define NVAPI_MAX_SIZEOF_I2C_DATA_BUFFER    4096
#define NVAPI_MAX_SIZEOF_I2C_REG_ADDRESS       4
#define NVAPI_DISPLAY_DEVICE_MASK_MAX         24
#define NVAPI_I2C_SPEED_DEPRECATED        0xFFFF

typedef enum
{
    NVAPI_I2C_SPEED_DEFAULT,    //!< Set i2cSpeedKhz to I2C_SPEED_DEFAULT if default I2C speed is to be chosen, ie.use the current frequency setting.
    NVAPI_I2C_SPEED_3KHZ,
    NVAPI_I2C_SPEED_10KHZ,
    NVAPI_I2C_SPEED_33KHZ,
    NVAPI_I2C_SPEED_100KHZ,
    NVAPI_I2C_SPEED_200KHZ,
    NVAPI_I2C_SPEED_400KHZ,
} NV_I2C_SPEED;

//! Used in NvAPI_I2CRead() and NvAPI_I2CWrite()
typedef struct
{
    NvU32                   version;            //!< The structure version.
    NvU32                   displayMask;        //!< The Display Mask of the concerned display.
    NvU8                    bIsDDCPort;         //!< This flag indicates either the DDC port (TRUE) or the communication port
                                                //!< (FALSE) of the concerned display.
    NvU8                    i2cDevAddress;      //!< The address of the I2C slave.  The address should be shifted left by one.  For
                                                //!< example, the I2C address 0x50, often used for reading EDIDs, would be stored
                                                //!< here as 0xA0.  This matches the position within the byte sent by the master, as
                                                //!< the last bit is reserved to specify the read or write direction.
    NvU8*                   pbI2cRegAddress;    //!< The I2C target register address.  May be NULL, which indicates no register
                                                //!< address should be sent.
    NvU32                   regAddrSize;        //!< The size in bytes of target register address.  If pbI2cRegAddress is NULL, this
                                                //!< field must be 0.
    NvU8*                   pbData;             //!< The buffer of data which is to be read or written (depending on the command).
    NvU32                   cbSize;             //!< The size of the data buffer, pbData, to be read or written.
    NvU32                   i2cSpeed;           //!< The target speed of the transaction (between 28Kbps to 40Kbps; not guaranteed).
} NV_I2C_INFO_V1;

//! Used in NvAPI_I2CRead() and NvAPI_I2CWrite()
typedef struct
{
    NvU32                   version;            //!< The structure version.
    NvU32                   displayMask;        //!< The Display Mask of the concerned display.
    NvU8                    bIsDDCPort;         //!< This flag indicates either the DDC port (TRUE) or the communication port
                                                //!< (FALSE) of the concerned display.
    NvU8                    i2cDevAddress;      //!< The address of the I2C slave.  The address should be shifted left by one.  For
                                                //!< example, the I2C address 0x50, often used for reading EDIDs, would be stored
                                                //!< here as 0xA0.  This matches the position within the byte sent by the master, as
                                                //!< the last bit is reserved to specify the read or write direction.
    NvU8*                   pbI2cRegAddress;    //!< The I2C target register address.  May be NULL, which indicates no register
                                                //!< address should be sent.
    NvU32                   regAddrSize;        //!< The size in bytes of target register address.  If pbI2cRegAddress is NULL, this
                                                //!< field must be 0.
    NvU8*                   pbData;             //!< The buffer of data which is to be read or written (depending on the command).
    NvU32                   cbSize;             //!< The size of the data buffer, pbData, to be read or written.
    NvU32                   i2cSpeed;           //!< Deprecated, Must be set to NVAPI_I2C_SPEED_DEPRECATED.
    NV_I2C_SPEED            i2cSpeedKhz;        //!< The target speed of the transaction in (kHz) (Chosen from the enum NV_I2C_SPEED).
} NV_I2C_INFO_V2;

//! Used in NvAPI_I2CRead() and NvAPI_I2CWrite()
typedef struct
{
    NvU32                   version;            //!< The structure version.
    NvU32                   displayMask;        //!< The Display Mask of the concerned display.
    NvU8                    bIsDDCPort;         //!< This flag indicates either the DDC port (TRUE) or the communication port
                                                //!< (FALSE) of the concerned display.
    NvU8                    i2cDevAddress;      //!< The address of the I2C slave.  The address should be shifted left by one.  For
                                                //!< example, the I2C address 0x50, often used for reading EDIDs, would be stored
                                                //!< here as 0xA0.  This matches the position within the byte sent by the master, as
                                                //!< the last bit is reserved to specify the read or write direction.
    NvU8*                   pbI2cRegAddress;    //!< The I2C target register address.  May be NULL, which indicates no register
                                                //!< address should be sent.
    NvU32                   regAddrSize;        //!< The size in bytes of target register address.  If pbI2cRegAddress is NULL, this
                                                //!< field must be 0.
    NvU8*                   pbData;             //!< The buffer of data which is to be read or written (depending on the command).
    NvU32                   cbSize;             //!< The size of the data buffer, pbData, to be read or written.
    NvU32                   i2cSpeed;           //!< Deprecated, Must be set to NVAPI_I2C_SPEED_DEPRECATED.
    NV_I2C_SPEED            i2cSpeedKhz;        //!< The target speed of the transaction in (kHz) (Chosen from the enum NV_I2C_SPEED).
    NvU8                    portId;             //!< The portid on which device is connected (remember to set bIsPortIdSet if this value is set)
                                                //!< Optional for pre-Kepler
    NvU32                   bIsPortIdSet;       //!< set this flag on if and only if portid value is set
} NV_I2C_INFO_V3;

typedef NV_I2C_INFO_V3                     NV_I2C_INFO;

#define NV_I2C_INFO_VER3  MAKE_NVAPI_VERSION(NV_I2C_INFO_V3,3)
#define NV_I2C_INFO_VER2  MAKE_NVAPI_VERSION(NV_I2C_INFO_V2,2)
#define NV_I2C_INFO_VER1  MAKE_NVAPI_VERSION(NV_I2C_INFO_V1,1)

#define NV_I2C_INFO_VER  NV_I2C_INFO_VER3
//! @}

/***********************************************************************************/


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_I2CRead
//
//!  This function reads the data buffer from the I2C port.
//!                 The I2C request must be for a DDC port: pI2cInfo->bIsDDCPort = 1.
//!
//!                 A data buffer size larger than 16 bytes may be rejected if a register address is specified.  In such a case,
//!                 NVAPI_ARGUMENT_EXCEED_MAX_SIZE would be returned.
//!
//!                 If a register address is specified (i.e. regAddrSize is positive), then the transaction will be performed in
//!                 the combined format described in the I2C specification.  The register address will be written, followed by
//!                 reading into the data buffer.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 85
//!
//! \param [in]   hPhysicalGPU     GPU selection.
//! \param [out]  NV_I2C_INFO     *pI2cInfo The I2C data input structure
//!
//! \retval   NVAPI_OK                            Completed request
//! \retval   NVAPI_ERROR                         Miscellaneous error occurred.
//! \retval   NVAPI_HANDLE_INVALIDATED            Handle passed has been invalidated (see user guide).
//! \retval   NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle.
//! \retval   NVAPI_INCOMPATIBLE_STRUCT_VERSION   Structure version is not supported.
//! \retval   NVAPI_INVALID_ARGUMENT - argument does not meet specified requirements
//! \retval   NVAPI_ARGUMENT_EXCEED_MAX_SIZE - an argument exceeds the maximum 
//!
//! \ingroup i2capi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_I2CRead(NvPhysicalGpuHandle hPhysicalGpu, NV_I2C_INFO *pI2cInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_I2CWrite
//
//!  This function writes the data buffer to the I2C port.
//!
//!                 The I2C request must be for a DDC port: pI2cInfo->bIsDDCPort = 1.
//!
//!                 A data buffer size larger than 16 bytes may be rejected if a register address is specified.  In such a case,
//!                 NVAPI_ARGUMENT_EXCEED_MAX_SIZE would be returned.
//!
//!                 If a register address is specified (i.e. regAddrSize is positive), then the register address will be written
//!                 and the data buffer will immediately follow without a restart.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 85
//!
//! \param [in]   hPhysicalGPU     GPU selection.
//! \param [in]   pI2cInfo         The I2C data input structure
//!
//! \retval   NVAPI_OK                            Completed request
//! \retval   NVAPI_ERROR                         Miscellaneous error occurred.
//! \retval   NVAPI_HANDLE_INVALIDATED            Handle passed has been invalidated (see user guide).
//! \retval   NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle.
//! \retval   NVAPI_INCOMPATIBLE_STRUCT_VERSION    Structure version is not supported.
//! \retval   NVAPI_INVALID_ARGUMENT              Argument does not meet specified requirements
//! \retval   NVAPI_ARGUMENT_EXCEED_MAX_SIZE      Argument exceeds the maximum 
//!
//! \ingroup i2capi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_I2CWrite(NvPhysicalGpuHandle hPhysicalGpu, NV_I2C_INFO *pI2cInfo);


//! \addtogroup i2capi
//! @{
#define NVAPI_I2C_FLAGS_NONE                  0 //!< None
#define NVAPI_I2C_FLAGS_PRIVILEGE           0x1 //!< Used in NV_I2C_INFO_EX.
#define NVAPI_I2C_FLAGS_DATA_ENCRYPTED      0x2 //!< Encrypted I2C has been deprecated. 
#define NVAPI_I2C_FLAGS_NONSTD_SI1930UC     0x4 //!< Used in NV_I2C_INFO_EX.
#define NVAPI_I2C_FLAGS_FORCE_MOT           0x8  //!< Currently supports only DP and Vista above.
                                                 //!< Forces MOT bit on irrespective of size of the data to be passed
                                                 //!< till transaction is completed
#define NVAPI_I2C_FLAGS_PX3540              0x10 //!< Used in NV_I2C_INFO_EX.
//! @}


//! \ingroup i2capi
//! Used in NvAPI_I2CWriteEx() and NvAPI_I2CReadEx().
typedef struct 
{
    NvU32                   flags;        //!< I2C flags for Privileged, encrypted and non-standard Si1930uC i2c access
    NvU32                   encrClientID; //!< Client ID for Encrypted I2C (unused)
} NV_I2C_INFO_EX;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_I2CWriteEx
//
//! DESCRIPTION:   This function writes the data buffer to the I2C port. \n
//!                 Pass displayMask as zero, if I2C access is required for non-display devices.
//!
//!                 A data buffer size larger than 16 bytes may be rejected if a register address is specified.  In such a case,
//!                 NVAPI_ARGUMENT_EXCEED_MAX_SIZE would be returned.
//!
//!                 If a register address is specified (i.e. regAddrSize is positive), then the register address will be written
//!                 and the data buffer will immediately follow without a restart.
//!
//!                 If a DDC port is passed (bIsDDCPort = 1), then displayMask is a required parameter.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 170
//!
//! \param [in]  hPhysicalGPU                  GPU selection
//! \param       NV_I2C_INFO     *pI2cInfo     The I2C data input structure
//! \param       NV_I2C_INFO_EX  *pI2cInfoEx   The I2C extended data input structure
//!
//! \retval      NVAPI_OK                           Completed request
//! \retval      NVAPI_ERROR                        Miscellaneous error occurred
//! \retval      NVAPI_HANDLE_INVALIDATED           Handle passed has been invalidated (see user guide)
//! \retval      NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE Handle passed is not a physical GPU handle
//! \retval      NVAPI_INCOMPATIBLE_STRUCT_VERSION  Structure version is not supported
//! \retval      NVAPI_INVALID_ARGUMENT             Argument does not meet specified requirements
//! \retval      NVAPI_ARGUMENT_EXCEED_MAX_SIZE     Argument exceeds the maximum 
//!
//! \ingroup i2capi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_I2CWriteEx(NvPhysicalGpuHandle hPhysicalGpu, NV_I2C_INFO *pI2cInfo, NV_I2C_INFO_EX *pI2cInfoEx);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_I2CReadEx
//
//! DESCRIPTION:   This function reads the data buffer from the I2C port.
//!                 Please pass displayMask as zero, if I2C access required for non-display devices.
//!
//!                 A data buffer size larger than 16 bytes may be rejected if a register address is specified.  In such a case,
//!                 NVAPI_ARGUMENT_EXCEED_MAX_SIZE would be returned.
//!
//!                 If a register address is specified (i.e. regAddrSize is positive), then the transaction will be performed in
//!                 the combined format described in the I2C specification.  The register address will be written, followed by
//!                 reading into the data buffer.
//!
//!                 If a DDC port is passed (bIsDDCPort = 1), then displayMask is a required parameter.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 170
//!
//! \param [in] hPhysicalGPU                 GPU selection.
//! \param      NV_I2C_INFO     *pI2cInfo    The I2C data input structure
//! \param      NV_I2C_INFO_EX  *pI2cInfoEx  The I2C extended data input structure
//!
//! \retval    NVAPI_OK                            Completed request
//! \retval    NVAPI_ERROR                         Miscellaneous error occurred
//! \retval    NVAPI_HANDLE_INVALIDATED            Handle passed has been invalidated (see user guide)
//! \retval    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle
//! \retval    NVAPI_INCOMPATIBLE_STRUCT_VERSION   Structure version is not supported
//! \retval    NVAPI_INVALID_ARGUMENT              Argument does not meet specified requirements
//! \retval    NVAPI_ARGUMENT_EXCEED_MAX_SIZE      An argument exceeds the maximum 
//!
//! \ingroup i2capi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_I2CReadEx(NvPhysicalGpuHandle hPhysicalGpu, NV_I2C_INFO *pI2cInfo, NV_I2C_INFO_EX *pI2cInfoEx);


/*!
 * The IDs of each type of I2C command available 
 */
typedef enum
{
   /*!
    * This transaction type is used to perform the Quick SMBus Read/write command 
    * on a slave device. No data is sent or received, just used to verify the 
    * presence of the device.
    * Refer SMBus spec 2.0 (section 5.5.1 Quick Command)
    * SMBus Quick Write : S Addr|Wr [A] P
    * SMBus Quick Read  : S Addr|Rd [A] P
    */
   NV_I2C_INFO_TRANSACTION_TYPE_SMBUS_QUICK_RW,
   /*!
    * This transaction type is used to perform the I2C byte read/write from/to 
    * a slave device. As per the spec last byte should be NA (Not Acknolwedged) 
    * by slave.
    * Refer I2CBus spec 3.0 (section 9 Fig 11 and Fig 12) or Refer SMBus spec 
    * 2.0 (section 5.5.2 Send Byte and 5.5.3 Receive Byte).
    * I2C Byte Write : S Addr|Wr [A] Data [NA] P
    * I2C Byte Read  : S Addr|Rd [A] Data NA P
    */
   NV_I2C_INFO_TRANSACTION_TYPE_I2C_BYTE_RW,
   /*!
    * This transaction type is used to perform the I2C block (buffer) 
    * read/write from/to a slave device. As per the spec last byte should be NA
    * (Not Acknolwedged) by slave.
    * Refer I2CBus spec 3.0 (section 9 Fig 11 and Fig 12)
    * I2C Byte Write : S Addr|Wr [A] Data1 [A]...Data(N-1) [A] DataN [NA] P
    * I2C Byte Read  : S Addr|Rd [A] Data1 A...Data(N-1) A DataN NA P
    *
    * Distinction between I2C_BLOCK and SMBUS_BLOCK protocol:
    * In I2C Block write it is the slave device (and in I2C Block read its 
    * the master device) that determines the number of bytes to transfer by 
    * asserting the NAK at last bit before stop. This differs from the SMBus 
    * block mode write command in which the master determines the block 
    * write transfer size. In I2c Block read there is no limit to maximum size 
    * of data that could be transferred whereas in SMBus block it is restricted
    * to 255 bytes (0xFF).
    */
   NV_I2C_INFO_TRANSACTION_TYPE_I2C_BLOCK_RW,
   /*!
    * This transaction type is used to perform the I2C Buffer read/write 
    * from/to a register of a slave device. It does not send bytecount as 
    * part of data buffer.
    * Not a part of SMBus spec.
    * I2C Buffer Write : S Addr|Wr [A] cmd [A] Data1 [A]...DataN[A] P
    * I2C Buffer Read  : S Addr|Wr [A] cmd [A] Sr Addr|Rd [A] Data1 A...
    *                    DataN-1 A DataN A P
    *
    * Distinction between SMBUS_BLOCK and I2C_BUFFER protocol:
    * In SMBUS_BLOCK Read/write the first byte of data buffer contains the 
    * count size (The number of bytes to be transferred) and it is restricted 
    * to 255 bytes whereas in I2C_BUFFER, count size is not sent during the 
    * transfer and there is no restriction in terms of size.
    *
    * Distinction between I2C_BLOCK and I2C_BUFFER protocol:
    * I2C_BUFFER takes the register address as argument whereas I2C_BLOCK does
    * not have any register or command provision.
    */
   NV_I2C_INFO_TRANSACTION_TYPE_I2C_BUFFER_RW,
   /*!
    * This transaction type is used to perform the I2C byte read/write from/to
    * a slave device
    * Refer SMBus spec 2.0 (section 5.5.4 Write Byte and 5.5.5 Read Byte)
    * SMBus Byte Write : S Addr|Wr [A] cmd [A] Data [A] P
    * SMBus Byte Read  : S Addr|Wr [A] cmd [A] Sr Addr|Rd [A] Data A P
    */
   NV_I2C_INFO_TRANSACTION_TYPE_SMBUS_BYTE_RW,
   /*!
    * This transaction type is used to perform the SMBus byte read/write 
    * from/to a register of a slave device
    * Refer SMBus spec 2.0 (section 5.5.4 Write Word and 5.5.5 Read Word)
    * SMBus Word Write : S Addr|Wr [A] cmd [A] DataLow [A] DataHigh [A] P 
    * SMBus Word Read  : S Addr|Wr [A] cmd [A] Sr Addr|Rd [A] DataLow A 
    *                    DataHigh A P
    */
   NV_I2C_INFO_TRANSACTION_TYPE_SMBUS_WORD_RW,
   /*!
    * This transaction type is used to perform the SMBus Block read/write 
    * from/to a register of a slave device
    * Refer SMBus spec 2.0 (section 5.5.7 Block Write/Read)
    * SMBus Block Write : S Addr|Wr [A] cmd [A] ByteCount [A] Data1 [A]...
    *                    DataN-1 [A] DataN[A] P
    * SMBus Block Read  : S Addr|Wr [A] cmd [A] Sr Addr|Rd [A] ByteCount A 
    *                    Data1 A...DataN-1 A DataN A P
    *
    * Distinction between I2C_BLOCK and SMBUS_BLOCK protocol:
    * In I2C Block write it is the slave device (and in I2C Block read its 
    * the master device) that determines the number of bytes to transfer by 
    * asserting the NAK at last bit before stop. This differs from the SMBus 
    * block mode write/Read command in which the master determines the block 
    * write transfer size. In I2c Block read/Write there is no limit to maximum 
    * size of data that could be transferred whereas in SMBus block it is 
    * restricted to 255 bytes (0xFF).
    */
   NV_I2C_INFO_TRANSACTION_TYPE_SMBUS_BLOCK_RW,
   /*!
    * This transaction type is used to perform the SMBus process call. It sends 
    * data and waits for the slave to return a value dependent on that data. 
    * The protocol is simply a SMBus write Word followed by a SMBus Read Word 
    * without the Read-Word command field and the Write-Word STOP bit. 
    * Note that there is no STOP condition before the repeated START condition, 
    * and that a NACK signifies the end of the read transfer. 
    *
    * Refer SMBus spec 2.0 (section 5.5.6 Process Call)
    * SMBus Process Call : S Addr|Wr [A] cmd [A] DataLow [A] DataHigh [A] 
    *                      Sr Addr|Rd [A] DataLow [A] DataHigh [NA] P
    */
   NV_I2C_INFO_TRANSACTION_TYPE_SMBUS_PROCESS_CALL,
   /*!
    * This transaction type is used to perform the SMBus Block Write Block Read
    * process call.
    * The block write-block read process call is a two-part message. The call 
    * begins with a slave address and a write condition. After the command code
    * the host issues a write byte count (M) that describes how many more bytes
    * will be written in the first part of the message.
    * If a master has 6 bytes to send, the byte count field will have the value
    * 6 (0000 0110b), followed by the 6 bytes of data. The write byte count (M)
    * cannot be zero. 
    * The second part of the message is a block of read data beginning with a 
    * repeated start condition followed by the slave address and a Read bit.
    * The next byte is the read byte count (N), which may differ from the write
    * byte count (M). The read byte count (N) cannot be zero. The combined data
    * payload must not exceed 32 bytes. 
    * The byte length restrictions of this process call are summarized as 
    * follows:
    * M >= 1 byte 
    * N >= 1 byte 
    * M + N <= 32 bytes 
    * Note that there is no STOP condition before the repeated START condition, 
    * and that a NACK signifies the end of the read transfer.
    *
    * Refer SMBus spec 2.0 (section 5.5.8 Block Write Block Read Process Call)
    * SMBus Process Call : S Addr|Wr [A] cmd [A] ByteCount=M [A] Data1 [A]...
    *                      DataN-1 [A] DataM[A] Sr Addr|Rd [A] ByteCount=N [A] 
    *                      Data1 [A]...DataN [NA] P
    */
   NV_I2C_INFO_TRANSACTION_TYPE_SMBUS_BLOCK_PROCESS_CALL,
   /*!
    * This transaction type is used to perform SMBus buffer read/write 
    * from/to multiple registers of a slave device known as Auto Increment.
    * It is not a part of any standard I2C/SMBus spec but a feature of many
    * SMBus devices like EEPROM.
    * It is also used for reading a block of bytes from a designated register 
    * that is specified through the two Comm bytes.of a slave device or writing
    * a block of bytes from a designated register of a slave device (Note : The
    * command byte in this case could be 0, 2 or 4 Bytes)
    * SMBus Multi-Byte Register Block Write : S Addr|Wr [A] cmd1 A cmd 2 [A]...
    *                cmdN [A] data1 [A] Data2 [A].....DataN [A] P
    * SMBus Multi-Byte Register Block Read : S Addr|Rd [A] cmd1 A cmd 2 [A]...
    *                cmdN [A] data1 [A] Sr Addr [A] Data1 A Data2 A...DataN A P
    *
    * This transaction type could be also used for those devices which supports 
    * AUTO_INC. Even though it is frequently related to I2C/SMBus, automatic 
    * incrementation is not part of any I2C standard but rather a common
    * feature found in many I2C devices. What it means is that the device
    * maintains in internal pointer which is  automatically incremented upon 
    * data read or write activities and which can be manually set to a fixed 
    * value. This comes in handy when storing larger amounts of data for 
    * instance in an ordinary I2C RAM or EEPROM.
    * SMBus AUTO_INC Write : S Addr|Wr [A] cmd1 A Data1 [A] Data2 [A]...
    *                        DataN [A] P
    * SMBus AUTO_INC Read : S Addr|Rd [A] cmd1 A data1 [A] Sr Addr [A] Data1 A
    *                       Data2 A...DataN A P
    * If the device does not support AUTO_INC set warFlags of 
    * NV_I2C_INFO_TRANSACTION_DATA_SMBUS_MULTIBYTE_REGISTER_BLOCK_RW to 
    * NV_NV_I2C_INFO_SMBUS_MULTIBYTE_REGISTER_BLOCK_RW_WAR_FLAGS_NO_AUTO_INC.
    */
   NV_I2C_INFO_TRANSACTION_TYPE_SMBUS_MULTIBYTE_REGISTER_BLOCK_RW,
   /*!
    * This transaction type is used to perform the EDID read via DDC.
    */
   NV_I2C_INFO_TRANSACTION_TYPE_READ_EDID_DDC
} NV_I2C_INFO_TRANSACTION_TYPE;

/*!
 * The following defines specify WAR flags that can be specified during
 * I2C Quick Read or Write command (Refer NV_I2C_INFO_TRANSACTION_TYPE_SMBUS_QUICK_RW).
 *
 * _NONE
 *    No workaround is needed.
 *
 * _TEST_PORT
 *     Use this flag to have the client sent a request to test a port instead 
 *     of performing any transaction on it. Transaction type has to be 
 *     NV_I2C_INFO_TRANSACTION_TYPE_SMBUS_QUICK_RW.
 */

#define NV_I2C_INFO_SMBUS_QUICK_RW_WAR_FLAGS_NONE                            0
#define NV_I2C_INFO_SMBUS_QUICK_RW_WAR_FLAGS_TEST_PORT                       1

/*!
 * NV_I2C_INFO_TRANSACTION_DATA_SMBUS_QUICK_RW
 *
 * Specifies the structure of data filled by the client for I2C transaction 
 * when the.transaction type is NV_I2C_INFO_TRANSACTION_TYPE_SMBUS_QUICK_RW.
 *
 */
typedef struct
{
   /*!
    * This field must be specified by the client to indicate whether the
    * command is a write (TUE) or a read (FALSE).
    */
    NvU8  bWrite;
    /*!
    * Transaction specific flags. (see To do)
    */
   NvU32 warFlags;
} NV_I2C_INFO_TRANSACTION_DATA_SMBUS_QUICK_RW;

/*!
 * NV_I2C_INFO_TRANSACTION_DATA_I2C_BYTE_RW
 *
 * Specifies the structure of data filled by the client for I2C transaction 
 * when the.transaction type is NV_I2C_INFO_TRANSACTION_TYPE_I2C_BYTE_RW.
 *
 */
typedef struct
{
   /*!
    * This field must be specified by the client to indicate whether the
    * command is a write (TRUE) or a read (FALSE).
    */
   NvU8  bWrite;
   /*!
    * The main message data.
    */
   NvU8 *pMessage;
} NV_I2C_INFO_TRANSACTION_DATA_I2C_BYTE_RW;

/*!
 * NV_I2C_INFO_TRANSACTION_DATA_I2C_BLOCK_RW
 *
 * Specifies the structure of data filled by the client for I2C transaction 
 * when the transaction type is NV_I2C_INFO_TRANSACTION_TYPE_I2C_BLOCK_RW.
 *
 */
typedef struct
{
   /*!
    * This field must be specified by the client to indicate whether the
    * command is a write (TRUE) or a read (FALSE).
    */
   NvU8  bWrite;
   /*!
    * This parameter specifies the number of bytes to read or
    * write from the slave after the register address is written.
    */
   NvU32 messageLength;
   /*!
    * The main message data.
    */
   NvU8 *pMessage;
} NV_I2C_INFO_TRANSACTION_DATA_I2C_BLOCK_RW;

/*!
 * NV_I2C_INFO_TRANSACTION_DATA_SMBUS_BYTE_RW
 *
 * Specifies the structure of data filled by the client for I2C transaction 
 * when the.transaction type is NV_I2C_INFO_TRANSACTION_TYPE_SMBUS_BYTE_RW.
 *
 */
typedef struct
{
   /*!
    * This field must be specified by the client to indicate whether the
    * command is a write (TRUE) or a read (FALSE).
    */
   NvU8  bWrite;
   /*!
    * The address of the register.
    */
   NvU8  registerAddress;
   /*!
    * The main message data.
    */
   NvU8 *pMessage;
} NV_I2C_INFO_TRANSACTION_DATA_SMBUS_BYTE_RW;

/*!
 * NV_I2C_INFO_TRANSACTION_DATA_SMBUS_WORD_RW
 *
 * Specifies the structure of data filled by the client for I2C transaction 
 * when the.transaction type is NV_I2C_INFO_TRANSACTION_TYPE_SMBUS_WORD_RW.
 *
 */
typedef struct
{
   /*!
    * This field must be specified by the client to indicate whether the
    * command is a write (TRUE) or a read (FALSE).
    */
   NvU8  bWrite;
   /*!
    * The address of the register.
    */
   NvU8  registerAddress;
   /*!
    * The main message data.
    */
   NvU16 *pMessage;
} NV_I2C_INFO_TRANSACTION_DATA_SMBUS_WORD_RW;

/*!
 * NV_I2C_INFO_TRANSACTION_DATA_SMBUS_BUFFER_RW
 *
 * Specifies the structure of data filled by the client for I2C transaction 
 * when the.transaction type is NV_I2C_INFO_TRANSACTION_TYPE_SMBUS_BUFFER_RW.
 *
 */
typedef struct
{
   /*!
    * This field must be specified by the client to indicate whether the
    * command is a write (TRUE) or a read (FALSE).
    */
   NvU8  bWrite;
   /*!
    * Transaction specific flags to be set (see 
    * NV_NV_I2C_INFO_BUFFER_RW_WAR_FLAGS_*)
    */
   NvU32 warFlags;
   /*!
    * This parameter specifies how many bytes to write as part of the
    * register address. If zero is specified, then no index will be sent.
    */
   NvU8  registerAddress;
   /*!
    * This parameter specifies the number of bytes to read or 
    * write from the slave after the register address is written.
    */
   NvU32 messageLength;
   /*!
    * The main message data.
    */
   NvU8  *pMessage;
} NV_I2C_INFO_TRANSACTION_DATA_I2C_BUFFER_RW;

/*!
 * NV_I2C_INFO_TRANSACTION_DATA_SMBUS_BLOCK_RW
 *
 * Specifies the structure of data filled by the client for I2C transaction 
 * when the.transaction type is NV_I2C_INFO_TRANSACTION_TYPE_SMBUS_BLOCK_RW.
 *
 */
typedef struct
{
   /*!
    * This field must be specified by the client to indicate whether the
    * command is a write (TRUE) or a read (FALSE).
    */
   NvU8   bWrite;
   /*!
    * This parameter specifies how many bytes to write as part of the
    * register address. If zero is specified, then no index will be sent.
    */
   NvU8   registerAddress;
   /*!
    * This parameter specifies the number of bytes to read or 
    * write from the slave after the register address is written.
    */
   NvU32  messageLength;
   /*!
    * The main message data.
    */
   NvU8  *pMessage;
} NV_I2C_INFO_TRANSACTION_DATA_SMBUS_BLOCK_RW;

/*!
 * NV_I2C_INFO_TRANSACTION_DATA_SMBUS_PROCESS_CALL
 *
 * Specifies the structure of data filled by the client for I2C transaction 
 * when the.transaction type is NV_I2C_INFO_TRANSACTION_TYPE_SMBUS_PROCESS_CALL.
 *
 */
typedef struct
{
   /*!
    * This parameter specifies how many bytes to write as part of the
    * register address. If zero is specified, then no index will be sent.
    */
   NvU8  registerAddress;
   /*!
    * The message data to be written to the slave.
    */
   NvU16 *pWriteMessage;
   /*!
    * The message data to be read from the slave.
    */
   NvU16 *pReadMessage;
} NV_I2C_INFO_TRANSACTION_DATA_SMBUS_PROCESS_CALL;

/*!
 * NV_I2C_INFO_TRANSACTION_DATA_SMBUS_BLOCK_PROCESS_CALL
 *
 * Specifies the structure of data filled by the client for I2C transaction 
 * when the.transaction type is 
 * NV_I2C_INFO_TRANSACTION_TYPE_SMBUS_BLOCK_PROCESS_CALL.
 *
 */
typedef struct
{
   /*!
    * This parameter specifies how many bytes to write as part of the
    * register address. If zero is specified, then no index will be sent.
    */
   NvU8  registerAddress;
   /*!
    * This parameter specifies the number of bytes to write the the slave 
    * after the writeByteCount is sent to the slave.
    */
   NvU32 writeMessageLength;
   /*!
    * The message buffer to be written to the slave.
    */
   NvU8 *pWriteMessage;
   /*!
    * This parameter specifies the number of bytes to read from the slave 
    * after the readByteCount is sent to the slave.
    */
   NvU32 readMessageLength;
   /*!
    * The message buffer to be read from the slave.
    */
   NvU8  *pReadMessage;
} NV_I2C_INFO_TRANSACTION_DATA_SMBUS_BLOCK_PROCESS_CALL;

/*!
 * The following defines specify WAR flags that can be specified during
 * I2C buffer Read or Write to Multibyte Regsiter 
 * (Refer NV_I2C_INFO_TRANSACTION_TYPE_SMBUS_MULTIBYTE_REGISTER_BLOCK_RW)
 *
 * _NONE
 *    No workaround is needed.
 *
 * _NO_AUTO_INC
 *   This value specifies that the device does not support auto-increment.
 *   Most devices allow you to write multiple bytes after specifying a
 *   register address, and the subsequent bytes will go to incremented
 *   addresses. Without auto-increment, we write a buffer of data as a
 *   sequence of address-register-value triplets separated by starts.
 */

#define NV_I2C_INFO_SMBUS_MULTIBYTE_REGISTER_BLOCK_RW_WAR_FLAGS_NONE         0
#define NV_I2C_INFO_SMBUS_MULTIBYTE_REGISTER_BLOCK_RW_WAR_FLAGS_NO_AUTO_INC  1
/*!
 * NV_I2C_INFO_TRANSACTION_DATA_SMBUS_MULTIBYTE_REGISTER_BLOCK_RW
 *
 * Specifies the structure of data filled by the client for I2C transaction 
 * when the.transaction type is 
 * NV_I2C_INFO_TRANSACTION_TYPE_SMBUS_MULTIBYTE_REGISTER_BLOCK_RW.
 */
typedef struct
{
   /*!
    * This field must be specified by the client to indicate whether the
    * command is a write (TRUE) or a read (FALSE).
    */
    NvU8  bWrite;
   /*!
    * Transaction specific flags (see 
    * NV_I2C_INFO_SMBUS_MULTIBYTE_REGISTER_BLOCK_RW_WAR_FLAGS_*)
    */
   NvU32  warFlags;
   /*!
    * This parameter specifies how many bytes to write as part of the
    * register address. If zero is specified, then no index will be sent.
    */
   NvU32  indexLength;
   /*!
    * Optional indexing data; aka register address.
    */
   NvU8  *pIndex;
   /*!
    * This parameter specifies the number of bytes to read or 
    * write from the slave after the register address is written.
    */
   NvU32  messageLength;
   /*!
    * The main message data.
    */
   NvU8  *pMessage;
} NV_I2C_INFO_TRANSACTION_DATA_SMBUS_MULTIBYTE_REGISTER_BLOCK_RW;

/*!
 * NV_I2C_INFO_TRANSACTION_DATA_READ_EDID_DDC
 *
 * Specifies the structure of data filled by the client for I2C transaction 
 * when the.transaction type is NV_I2C_INFO_TRANSACTION_TYPE_READ_EDID_DDC.
 *
 */
typedef struct
{
    /*!
     * The segment number of the EDID block which is to be read.
     */
    NvU8  segmentNumber;
    /*!
     * The address of the register.
     */
    NvU8  registerAddress;
   /*!
    * This parameter specifies the number of bytes to read or
    * write from the slave after the register address is written.
    */
    NvU32 messageLength;
    /*!
     * The main message data.
     */
    NvU8 *pMessage;
} NV_I2C_INFO_TRANSACTION_DATA_READ_EDID_DDC;

/*!
 * NV_I2C_INFO_TRANSACTION_DATA
 *
 * This union encapsulates the transaction data corresponding to the 
 * transaction type enlisted above.
 */
typedef union
{
   /*!
    * This transaction data is to be filled when transaction type is 
    * NV_I2C_INFO_TRANSACTION_TYPE_SMBUS_QUICK_RW.
    */
    NV_I2C_INFO_TRANSACTION_DATA_SMBUS_QUICK_RW                    smbusQuickData;
   /*!
    * This transaction data is to be filled when transaction type is 
    * NV_I2C_INFO_TRANSACTION_TYPE_I2C_BYTE_RW.
    */
    NV_I2C_INFO_TRANSACTION_DATA_I2C_BYTE_RW                       i2cByteData;
   /*!
    * This transaction data is to be filled when transaction type is 
    * NV_I2C_INFO_TRANSACTION_TYPE_I2C_BLOCK_RW.
    */
    NV_I2C_INFO_TRANSACTION_DATA_I2C_BLOCK_RW                      i2cBlockData;
   /*!
    * This transaction data is to be filled when transaction type is 
    * NV_I2C_INFO_TRANSACTION_TYPE_I2C_BUFFER_RW.
    */
    NV_I2C_INFO_TRANSACTION_DATA_I2C_BUFFER_RW                     i2cBufferData;
   /*!
    * This transaction data is to be filled when transaction type is 
    * NV_I2C_INFO_TRANSACTION_TYPE_SMBUS_BYTE_RW.
    */
    NV_I2C_INFO_TRANSACTION_DATA_SMBUS_BYTE_RW                     smbusByteData;
   /*!
    * This transaction data is to be filled when transaction type is 
    * NV_I2C_INFO_TRANSACTION_TYPE_SMBUS_WORD_RW.
    */
    NV_I2C_INFO_TRANSACTION_DATA_SMBUS_WORD_RW                     smbusWordData;
   /*!
    * This transaction data is to be filled when transaction type is 
    * NV_I2C_INFO_TRANSACTION_TYPE_SMBUS_BLOCK_RW.
    */
    NV_I2C_INFO_TRANSACTION_DATA_SMBUS_BLOCK_RW                    smbusBlockData;
   /*!
    * This transaction data is to be filled when transaction type is 
    * NV_I2C_INFO_TRANSACTION_TYPE_SMBUS_PROCESS_CALL.
    */
    NV_I2C_INFO_TRANSACTION_DATA_SMBUS_PROCESS_CALL                smbusProcessData;
   /*!
    * This transaction data is to be filled when transaction type is 
    * NV_I2C_INFO_TRANSACTION_TYPE_SMBUS_BLOCK_PROCESS_CALL.
    */
    NV_I2C_INFO_TRANSACTION_DATA_SMBUS_BLOCK_PROCESS_CALL          smbusBlockProcessData;
   /*!
    * This transaction data is to be filled when transaction type is 
    * NV_I2C_INFO_TRANSACTION_TYPE_SMBUS_MULTIBYTE_REGISTER_BLOCK_RW.
    */
    NV_I2C_INFO_TRANSACTION_DATA_SMBUS_MULTIBYTE_REGISTER_BLOCK_RW smbusMultibyteRegisterData;
   /*!
    * This transaction data is to be filled when transaction type is 
    * NV_I2C_INFO_TRANSACTION_TYPE_READ_EDID_DDC.
    */
    NV_I2C_INFO_TRANSACTION_DATA_READ_EDID_DDC edidData;
} NV_I2C_INFO_TRANSACTION_DATA;

/*!
 * LOCATION_TYPE
 *
 * This enum specifies different I2C supported according different location
 * used to communicate with slave
 */
typedef enum
{
   /*!
    * This type is used to specify transaction with display (DDC)
    */
    LOCATION_TYPE_DISPLAY = 0x0,
    /*!
    * This type is used to specify plain I2C transaction
    */
    LOCATION_TYPE_ADDRESS,
} LOCATION_TYPE;

/*!
 * LOCATION_TYPE_DATA_DISPLAY
 *
 * Structure holds information for I2C over DDC
 */
typedef struct
{
   /*!
    * DisplayId of the display device to be communicated
    */
    NvU32 displayId;
} LOCATION_TYPE_DATA_DISPLAY;

/*!
 * LOCATION_TYPE_DATA_ADDRESS
 *
 * Structure holds information for I2C over DDC
 */
typedef struct
{
   /*!
    * The address of the I2C slave. The address of the I2C slave. The
    * address should be shifted left by one. For example, the I2C
    * address 0x50, often used for reading EDIDs, would be stored here
    * as 0xA0. This matches the position within the byte sent by the
    * master, as the last bit is reserved to specify the read or write
    * direction.
    */
    NvU16 deviceAddress;
} LOCATION_TYPE_DATA_ADDRESS;

/*!
 * LOCATION_DATA
 *
 * This structure encapsulates union of the location type
 * enlisted in enum LOCATION_TYPE.
 */

 #define NV_I2C_INFO_PORT_ID_UNITIALIZED  (+255U)

typedef struct
{
   union
   {
        /*!
        * if Slave is Display device
        */
        LOCATION_TYPE_DATA_DISPLAY display;
        /*!
        * if Slave is Non DDC device
        */
        LOCATION_TYPE_DATA_ADDRESS address;
        /*!
        * Following variable is reserved for future use
        */
        NvU8 rsvd[16];
    };
    /*!
    * The logical port ID.
    * Note: Initialize to (NV_I2C_INFO_PORT_ID_UNITIALIZED) if want to use primary port
    */
    NvU8  portId;
    LOCATION_TYPE locDataType;
} LOCATION_DATA;

/*!
 * NV_I2C_TRANSACTION_INFO_V1
 *
 * Used in NvAPI_I2CTransaction()
 */
typedef struct
{
    /*!
     * The structure version.
     */
    NvU32  version;
    /*!
    * This parameter specifies optional flags used to control certain modal
    * features such as target speed and addressing mode. The currently
    * defined fields are described previously; see NVAPI_I2C_FLAGS_* 
    */
    NvU32 flags;
    /*!
    * location at which to transact
    */
    LOCATION_DATA locData;
   /*!
    * The target speed of the transaction in (kHz) (Chosen from the enum NV_I2C_SPEED).
    */
    NV_I2C_SPEED i2cSpeedKhz;
   /*!
    * The transaction type.
    */
    NV_I2C_INFO_TRANSACTION_TYPE transType;
   /*!
    * The transaction data corresponding transaction type.
    */
    NV_I2C_INFO_TRANSACTION_DATA transData;
    /*!
     * Following variable is reserved for future use
     */
    NvU8 rsvd[32];
} NV_I2C_TRANSACTION_INFO_V1;

typedef NV_I2C_TRANSACTION_INFO_V1               NV_I2C_TRANSACTION_INFO;

#define NV_I2C_TRANSACTION_INFO_VER1             MAKE_NVAPI_VERSION(NV_I2C_TRANSACTION_INFO_V1,1)

#define NV_I2C_TRANSACTION_INFO_VER              NV_I2C_TRANSACTION_INFO_VER1
//! @}
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_I2CTransaction
//
//! DESCRIPTION:   This function reads/writes the data buffer from the I2C port.
//!
//!                 A data buffer size larger than 16 bytes may be rejected if a register address is specified.  In such a case,
//!                 NVAPI_ARGUMENT_EXCEED_MAX_SIZE would be returned.
//!
//!                 If a register address is specified (i.e. regAddrSize is positive), then the transaction will be performed in
//!                 the combined format described in the I2C specification.  The register address will be written, followed by
//!                 reading into the data buffer.
//!
//!                 If a DDC port is passed (bIsDDCPort = 1), then displayId is a required parameter.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]      hPhysicalGPU          GPU selection.
//! \param [out]     pI2CPorts             Pointer to NV_I2C_TRANSACTION_INFO structure.
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \ingroup i2capi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_I2CTransaction(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_I2C_TRANSACTION_INFO *pI2CTranInfo);




//! \ingroup i2capi
typedef struct
{
    NvU32                version;        //!< The structure version.
    NvU32                portId;            //!< [out]Port identifier. An integer between 0 to 15 to identify an I2C port
    NvU32                 portSpeed;        //!< [out]Contains the current I2C speed of the port.
} NV_I2C_PORT_INFO_V1;

//! \ingroup i2capi
typedef NV_I2C_PORT_INFO_V1                                     NV_I2C_PORT_INFO;

//! \ingroup i2capi
#define NV_I2C_PORT_INFO_VER1                                      MAKE_NVAPI_VERSION(NV_I2C_PORT_INFO_V1,1)

//! \ingroup i2capi
#define NV_I2C_PORT_INFO_VER                                    NV_I2C_PORT_INFO_VER1

//! \ingroup i2capi
#define NV_NVAPI_MAX_I2C_NUM_PORTS                                 16

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_Get_I2C_Ports_Info
//
//! DESCRIPTION:   This API gets information about the I2C ports.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]      hPhysicalGPU          GPU selection.
//! \param [out]  pI2CPorts         Pointer to an array of NV_I2C_PORT_INFO structures. Typically, the size of this array should be NV_NVAPI_MAX_I2C_NUM_PORTS.
//! \param [in]      numPorts         The number of elements in the array pI2CPorts. 
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \ingroup i2capi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_Get_I2C_Ports_Info(__in NvPhysicalGpuHandle hPhysicalGpu, __inout_ecount(numPorts) NV_I2C_PORT_INFO *pI2CPorts, __in NvU32 numPorts);


// END OF I2C API

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_RestartDisplayDriver
//
//! DESCRIPTION:     This API restarts the display driver.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//!  \retval    NVAPI_OK                               Call succeeded.
//!  \retval    NVAPI_API_NOT_INTIALIZED               NVAPI not initialized
//!  \retval    NVAPI_ERROR                            The call failed
//!  \retval    NVAPI_TIMEOUT_RECONFIGURING_GPU_TOPO   Timeout occured while reconfiguring GPUs.
//!
//!  \ingroup driverapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_RestartDisplayDriver();




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GetValidGpuTopologiesInternal
//
//! DESCRIPTION:     This API is similar to NvAPI_GetValidGpuTopologies() but returns the topologies that are
//!                  valid but not allowed to be active, such as two GPUs in a subset of three GPUs.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \param [out]    ptopology    An array of *pCount (OUT) topology structures. Use NvAPI_SetGpuTopology() to set up
//!                              one or several of these GPU topologies.
//! \param [out]    sliGroup     An array of *sliGroupCount (OUT) SLI group structures, describing which topologies
//!                              can be set up concurrently.
//! \param [out]    pStatus      Any system status returned in case zero topology is retrieved.
//!                              System status is one or more flags in ::NV_GPU_TOPOLOGY_STATUS_FLAGS when SLI is NOT capable.
//!
//! \retval  ::NVAPI_OK                        Call succeeded; 1 or more GPU topologies were returned.
//! \retval  ::NVAPI_INVALID_ARGUMENT          One or more arguments are invalid.
//! \retval  ::NVAPI_NVIDIA_DEVICE_NOT_FOUND   No NVIDIA GPU driving a display was found.
//! \retval  ::NVAPI_ERROR                     Miscellaneous Error.
//!
//! \ingroup  gputopology
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetValidGpuTopologiesInternal(NV_GPU_VALID_GPU_TOPOLOGIES *pTopology, NvU32 *pStatus);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetValidGpuTopologiesMosaic
//! \code
//! DESCRIPTION:     This API is similar to NvAPI_GetValidGpuTopologies() but it returns valid GPU topologies that will allow base Mosaic.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//! PARAMETERS:      pTopology(OUT): An array of *pCount (OUT) topology structures. Use NvAPI_SetGpuTopology() to set
//!                  up one of these GPU topologies.
//!                  pTopology->sliGroup(OUT): An array of NV_SLI_GROUP structures, describing which topologies
//!                  can be set up concurrently.In base_mosaic case, there would be 1 topology per group.
//!                  pStatus(OUT): Any system status returned in case zero topology is retrieved.
//!                  System status is one or more flags in NV_GPU_TOPOLOGY_STATUS_FLAGS when SLI is NOT capable.
//!
//! RETURN STATUS    NVAPI_OK: Call succeeded; 1 or more GPU topologies were returned
//!                  NVAPI_INVALID_ARGUMENT: one or more args are invalid
//!                  NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//!                  NVAPI_ERROR: Miscellaneous Error.
//! \endcode
//! \ingroup gputopology
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetValidGpuTopologiesMosaic(NV_GPU_VALID_GPU_TOPOLOGIES *pTopology, NvU32 *pStatus);




///////////////////////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GetInvalidGpuTopologies
//
//! DESCRIPTION:     This API returns all invalid GPU topologies and the current active topologies.
//!                  This call returns an array of NV_GPU_TOPOLOGY structs; one for each invalid configuration 
//!                  of GPUs present in the system. Note that this list is constant while GPUs remain in the 
//!                  same slots in the system.  It is not affected by which GPUs that are presently in use.
//!
//!                  The topologies with the status ::NV_GPU_TOPOLOGY_STATUS_TOPOLOGY_NOT_ALLOWED are valid for
//!                  the system but not for productization.
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 165
//!
//!
//! \param [out]    ptopology      An array of *pCount (OUT) topology structures.
//! \param [out]    sliGroup       No SLI groups returned here.
//! \param [out]    sliGroupCount  *sliGroupCount = 0.
//!
//! \retval         NVAPI_OK                       Call succeeded; one or more GPU topologies were returned.
//! \retval         NVAPI_INVALID_ARGUMENT         One or more arguments are invalid.
//! \retval         NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found.
//! \retval         NVAPI_ERROR                    Miscellaneous Error.
//!
//! \ingroup gputopology
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetInvalidGpuTopologies(NV_GPU_INVALID_GPU_TOPOLOGIES *pTopology);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_SetGpuTopologies
//
//! This function configures the physical GPUs in the system into one or more logical devices
//!                  defined by the NV_GPU_TOPOLOGY structure. After successful execution of this call, the caller needs to enumerate  
//!                  all the GPU handles again.
//!
//! It is recommended that the calling application:
//!                  - Save the current GPU topology retrieved from NvAPI_EnumLogicalGPUs and NvAPI_GetPhysicalGPUsFromLogicalGPU APIs.
//!                  - Save the current view state for associated displays on these GPUs using the GetView and GetDisplayTargets APIs.
//!                  - Set NV_GPU_TOPOLOGY.displayGpuIndex to the GPU index in the topology with an active display connection.
//!                  - If DEFER_3D_APP_SHUTDOWN is not set, notify the user that all 3D application will be forced to close.
//!                  - Itself does not create 3D handles or objects that can block the topology transition.
//!
//! On Windows Vista:
//!                  - The calling application must run in elevated mode for the transition to succeed. 
//!                  - This API can be called from a system service to derive the elevated context of the System service.
//! 
//! - Running non-migratable applications can prevent a successful transition if DEFER_3D_APP_SHUTDOWN is set. 
//! - To query non-migratable applications, use the NvAPI_QueryNonMigratableApps() API.
//!
//! - When enabling more than one multi-GPU topology, set the NV_GPU_TOPOLOGY_SLI_GROUPS flag.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 85
//!
//! \param [in]  pTopology     a pointer to the NV_GPU_VALID_GPU_TOPOLOGIES structure defining the desired GPU topologies to be set.
//!                                  The set of possible GPU topologies can be first queried using NvAPI_GetValidGpuTopologies.
//! \param [in]  flags         \see NV_SET_GPU_TOPOLOGY_FLAGS
//!
//! \return      This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!              specific meaning for this API, they are listed below.
//! 
//! \retval      NVAPI_TIMEOUT_RECONFIGURING_GPU_TOPO  Timeout occurred while reconfiguring GPUs.
//! \retval      NVAPI_IMPLICIT_SET_GPU_TOPOLOGY_CHANGE_NOT_ALLOWED   There is any implicit GPU topology active. Use NVAPI_SetHybridMode() to change the topology.
//! \retval      NVAPI_REQUEST_USER_TO_CLOSE_NON_MIGRATABLE_APPS Prompt the user to close all non-migratable applications.
//!
//! \ingroup     gputopology
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetGpuTopologies(NV_GPU_VALID_GPU_TOPOLOGIES *pTopology, NvU32 flags);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_GPU_GetPerGpuTopologyStatus
//
//! This function returns per-GPU topology state flags from NV_GPU_TOPOLOGY_STATUS_FLAGS for the queried GPU handle.
//!  \note The per-GPU topology status can be queried independent of the whether the queried GPU is part of a topology or not.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 95
//!
//! \param [out]  hPhysicalGPU    GPU selection.
//! \param [out]  pStatus         Indicates one or more flags from NV_GPU_TOPOLOGY_STATUS_FLAGS which are the subset of the 
//!                               same flags retrieved from NV_GPU_TOPOLOGY.status or pStatus in NvAPI_GetValidGpuTopologies() API.
//!
//! \retval    NVAPI_OK                            Completed request
//! \retval    NVAPI_ERROR                         Miscellaneous error occurred
//! \retval    NVAPI_HANDLE_INVALIDATED            Handle passed has been invalidated (see user guide)
//! \retval    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle
//! \ingroup gputopology
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetPerGpuTopologyStatus(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pStatus);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetTopologyStatusString
//
//!  DESCRIPTION: This function converts an SLI status into a NULL-terminated string.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//!
//! \return  NULL-terminated string (always, never NULL)
//!
//! \ingroup gputopology
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetTopologyStatusString(NvU32 nr,NvAPI_String szDesc);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetTopologyFlagString
//
//!   DESCRIPTION: This function converts an SLI topology flag value string into a NULL-terminated string.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//! 
//! \return  NULL-terminated string (always, never NULL)
//!
//! \ingroup gputopology
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetTopologyFlagString(NvU32 nr,NvAPI_String szDesc);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetSliGroupFlagString
//
//   DESCRIPTION: converts an SLI group flag value string into a null terminated string
//
//! SUPPORTED OS:  Windows XP and higher
//!
//
// RETURN STATUS: null terminated string (always, never NULL)
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetSliGroupFlagString(NvU32 nr,NvAPI_String szDesc);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetGpuTopologySystemProperties
//
//! DESCRIPTION: This function returns the system properties mask that determines the SLI approval
//!              state. 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//!
//! \param [in]   pTopology           Topology with the GPU count and the physical GPU handles set.
//! \param [out]  pSystemProperties   The system properties mask for this SLI config.
//!
//! \retval     NVAPI_OK                Request is completed.
//! \retval     NVAPI_ERROR             A miscellaneous error occurred.
//! \retval     NVAPI_INVALID_ARGUMENT  One or more arguments are invalid.
//!
//! \ingroup gputopology
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetGpuTopologySystemProperties(NV_GPU_TOPOLOGY *pTopology, NvU32 *pSystemProperties);




//! \ingroup gputopology
//! Used in NvAPI_GetGpuTopologySystemPropertiesString().
typedef enum
{
    NV_GPU_TOPOLOGY_SYSPROP_IS_MOBILE               = 0x00000001, //!< Notebook configuration
    NV_GPU_TOPOLOGY_SYSPROP_IS_CANOAS               = 0x00000002, //!< Canoas configuration
    NV_GPU_TOPOLOGY_SYSPROP_IS_E551                 = 0x00000004, //!< E551 configuration
    NV_GPU_TOPOLOGY_SYSPROP_IS_BR02                 = 0x00000008, //!< The configuration has a BR02
    NV_GPU_TOPOLOGY_SYSPROP_IS_BR03                 = 0x00000010, //!< Each GPU is behind a BR03
    NV_GPU_TOPOLOGY_SYSPROP_IS_BR04                 = 0x00000020, //!< Each GPU is behind a BR04
    NV_GPU_TOPOLOGY_SYSPROP_IS_BR_ANY               = 0x00000040, //!< The configuration has either none or any BR03, BR04
    NV_GPU_TOPOLOGY_SYSPROP_IS_CPU_XEON             = 0x00000080, //!< Is the CPU a Xeon
    NV_GPU_TOPOLOGY_SYSPROP_IS_QUADRO               = 0x00000100, //!< Quadro only
    NV_GPU_TOPOLOGY_SYSPROP_IS_OS_VISTA             = 0x00000200, //!< OS is Vista
    NV_GPU_TOPOLOGY_SYSPROP_IS_2BR03                = 0x00000400, //!< Minimum of 2 Cascaded BR03s behind each GPU
    NV_GPU_TOPOLOGY_SYSPROP_IS_3BR03                = 0x00000800, //!< Minimum of 3 Cascaded BR03s behind each GPU
    NV_GPU_TOPOLOGY_SYSPROP_IS_OS_XP                = 0x00001000, //!< OS is XP
    NV_GPU_TOPOLOGY_SYSPROP_IS_VIDEO_BRIDGE         = 0x00002000, //!< Video bridge present
    NV_GPU_TOPOLOGY_SYSPROP_IS_OS_UNIX              = 0x00004000, //!< OS is Unix
    NV_GPU_TOPOLOGY_SYSPROP_IS_GEFORCE              = 0x00008000, //!< GeForce only
    NV_GPU_TOPOLOGY_SYSPROP_IS_CANOAS2              = 0x00010000, //!< Canoas 2.0 config
    NV_GPU_TOPOLOGY_SYSPROP_IS_OS_MODS              = 0x00040000, //!< OS is MODS
    NV_GPU_TOPOLOGY_SYSPROP_IS_COMMON_BR03          = 0x00080000, //!< All GPUs have a common BR03
    NV_GPU_TOPOLOGY_SYSPROP_IS_COMMON_BR04          = 0x00100000, //!< All GPUs have a common BR04
    NV_GPU_TOPOLOGY_SYSPROP_IS_SHARED_BR03          = 0x00200000, //!< Each GPU is shares a BR03 with another GPU
    NV_GPU_TOPOLOGY_SYSPROP_IS_SHARED_BR04          = 0x00400000, //!< Each GPU is shares a BR04 with another GPU
    NV_GPU_TOPOLOGY_SYSPROP_IS_2BR04                = 0x00800000, //!< There is a minimum of 2 Cascaded BR04s behind each GPU
    NV_GPU_TOPOLOGY_SYSPROP_IS_BR04_REV_A03         = 0x01000000, //!< All BR04 revisions are A03
    NV_GPU_TOPOLOGY_SYSPROP_IS_MXM_INTERPOSER       = 0x02000000, //!< All GPUS are behind an MXM_INTERPOSER interposer card
    NV_GPU_TOPOLOGY_SYSPROP_IS_NO_BR_NOTBR04A03     = 0x04000000, //!< All non-root port bridges in the system other than GX2 are BR04 A03
    NV_GPU_TOPOLOGY_SYSPROP_IS_SLI_APPROVAL_COOKIE  = 0x08000000, //!< The SBIOS has an SLI approval cookie
    NV_GPU_TOPOLOGY_SYSPROP_IS_BR04_PRESENT         = 0x10000000, //!< A BR04 is present in the system - not necessarily serving a GPU
    NV_GPU_TOPOLOGY_SYSPROP_IS_2BR04_NOT_CASCADED           = 0x20000000, //!< There is a minimum of two non-cascaded BR04s in the system.
    NV_GPU_TOPOLOGY_SYSPROP_IS_4_WAY_SLI_APPROVAL_COOKIE    = 0x40000000, //!< The SBIOS has an SLI approval cookie allowing 4-way SLI
    NV_GPU_TOPOLOGY_SYSPROP_IS_TEMPLATE_APPROVAL_COOKIE     = 0x80000000, //!< The SBIOS has an template approval cookie. It does not mean it is valid.
} NV_GPU_TOPOLOGY_SYSTEM_PROPERTY_FLAGS;


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetGpuTopologySystemPropertiesString
//
//!   DESCRIPTION: This API converts an SLI system properties mask into a NULL-terminated string.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \return NULL-terminated string (always, never NULL)
//!
//! \ingroup ingroup gputopology
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetGpuTopologySystemPropertiesString(NvU32 nr,NvAPI_String szDesc);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetGpuTopologySystemPropertiesEx
//
//! \fn NvAPI_GetGpuTopologySystemPropertiesEx(NV_GPU_TOPOLOGY *pTopology, NV_GPU_TOPOLOGY_SYSTEM_PROPERTIES *pSystemProperties)
//! \code
//! DESCRIPTION: returns the system properties mask the SLI approval
//!              uses to make its decision
//!              This call deprecates NvAPI_GetGpuTopologySystemProperties()
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:     pTopology(IN) - Topology with the gpu count and the physical gpu handles set.
//!                 pSystemProperties(OUT)  - the system properties for this SLI config.
//!
//! RETURN STATUS:
//!    NVAPI_OK - completed request
//!    NVAPI_ERROR - miscellaneous error occurred
//!    NVAPI_INVALID_ARGUMENT - one or more args are invalid
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gputopology
//! @{

typedef struct
{
    NvU32 version;                      //!< [00:31] Structure version

    NvU32 bIsMobile:1;                  //!< [32:32] Mobile config
    NvU32 bIsCanoas:1;                  //!< [33:33] Canoas config
    NvU32 bIsE551:1;                    //!< [34:34] E551 config
    NvU32 bIsBR02:1;                    //!< [35:35] Config has a BR02
    NvU32 bIsBR03:1;                    //!< [36:36] Each GPU is behind a BR03
    NvU32 bIsBR04:1;                    //!< [37:37] Each GPU is behind a BR04
    NvU32 bIsBrAny:1;                   //!< [38:38] Config has none or any BR03, BR04
    NvU32 bIsCPUXeon:1;                 //!< [39:39] Is the CPU a Xeon
    NvU32 bIsQuadro:1;                  //!< [40:40] Quadro only
    NvU32 bIsOSVista:1;                 //!< [41:41] OS is Vista
    NvU32 bIs2BR03:1;                   //!< [42:42] minimum of 2 Cascaded BR03s behind each GPU
    NvU32 bIs3BR03:1;                   //!< [43:43] minimum of 3 Cascaded BR03s behind each GPU
    NvU32 bIsOSXP:1;                    //!< [44:44] OS is XP
    NvU32 bIsVideoBridge:1;             //!< [45:45] Video bridge present, circular or not
    NvU32 bIsOSUnix:1;                  //!< [46:46] OS is Unix
    NvU32 bIsGeForce:1;                 //!< [47:47] GeForce only
    NvU32 bIsCanoas2:1;                 //!< [48:48] Canoas 2.0 config
    NvU32 bIsOSMODS:1;                  //!< [49:49] OS is MODS
    NvU32 bIsCommonBR03:1;              //!< [50:50] All GPUs have a common BR03
    NvU32 bIsCommonBR04:1;              //!< [51:51] All GPUs have a common BR04 
    NvU32 bIsSharedBR03:1;              //!< [52:52] Each GPU is shares a BR03 with another GPU
    NvU32 bIsSharedBR04:1;              //!< [53:53] Each GPU is shares a BR04 with another GPU
    NvU32 bIs2BR04:1;                   //!< [54:54] There is a minimum of 2 Cascaded BR04s behind each GPU
    NvU32 bIsBR04RevA03:1;              //!< [55:55] All BR04 revisions are A03
    NvU32 bIsMXMIinterposer:1;          //!< [56:56] All GPUS are behind an MXM_INTERPOSER interposer card
    NvU32 bIsNoBrNorBR04A03:1;          //!< [57:57] All non-root port bridges in the system other than GX2 are BR04 A03
    NvU32 bIsSliAapprovalCookie:1;      //!< [58:58] The SBIOS has an SLI approval cookie
    NvU32 bIsBR04Present:1;             //!< [59:59] A BR04 is present in the system - not necessarily serving a GPU
    NvU32 bIs2BR04NotCascaded:1;        //!< [60:60] There is a minimum of two non cascaded BR04s in the system
    NvU32 bIs4WaySliApprovalCookie:1;   //!< [60:60] The SBIOS has an SLI approval cookie allowing 4-way SLI
    NvU32 bIsTemplateApprovalCookie:1;  //!< [61:61] The SBIOS has an template approval cookie. It does not mean it is valid.
    NvU32 bIsCircularVideoBridge:1;     //!< [62:62] Circular video bridge present
    NvU32 bIsGeforceOnWorkstation:1;    //!< [63:63] This system allows Geforce SLI on workstation systems, applicable to _VER_2 or greater
             
 } NV_GPU_TOPOLOGY_SYSTEM_PROPERTIES_V1;

typedef NV_GPU_TOPOLOGY_SYSTEM_PROPERTIES_V1 NV_GPU_TOPOLOGY_SYSTEM_PROPERTIES_V2;

typedef struct
{
    NvU32 version;                      //!< [00:31]  Structure version
    NvU32 bIsMobile:1;                  //!< [32:32]  Mobile config
    NvU32 bIsCanoas:1;                  //!< [33:33]  Canoas config
    NvU32 bIsE551:1;                    //!< [34:34]  E551 config
    NvU32 bIsBR02:1;                    //!< [35:35]  Config has a BR02
    NvU32 bIsBR03:1;                    //!< [36:36]  Each GPU is behind a BR03
    NvU32 bIsBR04:1;                    //!< [37:37]  Each GPU is behind a BR04
    NvU32 bIsBrAny:1;                   //!< [38:38]  Config has none or any BR03, BR04
    NvU32 bIsCPUXeon:1;                 //!< [39:39]  Is the CPU a Xeon
    NvU32 bIsQuadro:1;                  //!< [40:40]  Quadro only
    NvU32 bIsOSVista:1;                 //!< [41:41]  OS is Vista
    NvU32 bIs2BR03:1;                   //!< [42:42]  minimum of 2 Cascaded BR03s behind each GPU
    NvU32 bIs3BR03:1;                   //!< [43:43]  minimum of 3 Cascaded BR03s behind each GPU
    NvU32 bIsOSXP:1;                    //!< [44:44]  OS is XP
    NvU32 bIsVideoBridge:1;             //!< [45:45]  Video bridge present, circular or not
    NvU32 bIsOSUnix:1;                  //!< [46:46]  OS is Unix
    NvU32 bIsGeForce:1;                 //!< [47:47]  GeForce only
    NvU32 bIsCanoas2:1;                 //!< [48:48]  Canoas 2.0 config
    NvU32 bIsOSMODS:1;                  //!< [49:49]  OS is MODS
    NvU32 bIsCommonBR03:1;              //!< [50:50]  All GPUs have a common BR03
    NvU32 bIsCommonBR04:1;              //!< [51:51]  All GPUs have a common BR04 
    NvU32 bIsSharedBR03:1;              //!< [52:52]  Each GPU is shares a BR03 with another GPU
    NvU32 bIsSharedBR04:1;              //!< [53:53]  Each GPU is shares a BR04 with another GPU
    NvU32 bIs2BR04:1;                   //!< [54:54]  There is a minimum of 2 Cascaded BR04s behind each GPU
    NvU32 bIsBR04RevA03:1;              //!< [55:55]  All BR04 revisions are A03
    NvU32 bIsMXMIinterposer:1;          //!< [56:56]  All GPUS are behind an MXM_INTERPOSER interposer card
    NvU32 bIsNoBrNorBR04A03:1;          //!< [57:57]  This property is deprecated in favor of bIsNoBr3rdParty
    NvU32 bIsSliAapprovalCookie:1;      //!< [58:58]  The SBIOS has an SLI approval cookie
    NvU32 bIsBR04Present:1;             //!< [59:59]  A BR04 is present in the system - not necessarily serving a GPU
    NvU32 bIs2BR04NotCascaded:1;        //!< [60:60]  There is a minimum of two non-cascaded BR04s in the system
    NvU32 bIs4WaySliApprovalCookie:1;   //!< [61:61]  The SBIOS has an SLI approval cookie allowing 4-way SLI
    NvU32 bIsTemplateApprovalCookie:1;  //!< [62:62]  The SBIOS has an template approval cookie. It does not mean it is valid.
    NvU32 bIsCircularVideoBridge:1;     //!< [63:63]  Circular video bridge present
    NvU32 bIsGeforceOnWorkstation:1;    //!< [64:64]  This system allows Geforce SLI on workstation systems, applicable to _VER_2 or greater
    NvU32 bIsGpuNoSliSupport:1;         //!< [65:65]  Each GPU doesn't support SLI
    NvU32 bIsGpuGt200AndAbove:1;        //!< [66:66]  This property is deprecated in favor of bIsGpuBaseMosaicSupport
    NvU32 bIsNoVideoBridge:1;           //!< [67:67]  There is no video bridge
    NvU32 bIsP2PWriteAllowed:1;         //!< [68:68]  P2P Writes are allowed
    NvU32 bIsP2PReadAllowed:1;          //!< [69:69]  P2P Reads are allowed
    NvU32 bIsGpuBaseMosaicSupport:1;    //!< [70:70]  Each GPU supports base Mosaic
    NvU32 bIsPLX:1;                     //!< [71:71]  Each GPU is behind a PLX bridge
    NvU32 bIsCommonPLX:1;               //!< [72:72]  All GPUs have a common PLX bridge
    NvU32 bIsSharedPLX:1;               //!< [73:73]  Each GPU shares a PLX bridge with another GPU
    NvU32 bIsNoBr3rdParty;              //!< [74:74]  All non-root port bridges in the system other than GX2 are supported
    NvU32 reserved1:21;                 //!< [75:95]  reserved
    NvU32 reserved;                     //!< [96:127] reserved
} NV_GPU_TOPOLOGY_SYSTEM_PROPERTIES_V3;

typedef NV_GPU_TOPOLOGY_SYSTEM_PROPERTIES_V3 NV_GPU_TOPOLOGY_SYSTEM_PROPERTIES;

#define NV_GPU_TOPOLOGY_SYSTEM_PROPERTIES_VER_1 MAKE_NVAPI_VERSION(NV_GPU_TOPOLOGY_SYSTEM_PROPERTIES_V1,1)
#define NV_GPU_TOPOLOGY_SYSTEM_PROPERTIES_VER_2 MAKE_NVAPI_VERSION(NV_GPU_TOPOLOGY_SYSTEM_PROPERTIES_V2,2)
#define NV_GPU_TOPOLOGY_SYSTEM_PROPERTIES_VER_3 MAKE_NVAPI_VERSION(NV_GPU_TOPOLOGY_SYSTEM_PROPERTIES_V3,1)
#define NV_GPU_TOPOLOGY_SYSTEM_PROPERTIES_VER   NV_GPU_TOPOLOGY_SYSTEM_PROPERTIES_VER_3

//! @}


//! \ingroup gputopology
NVAPI_INTERFACE NvAPI_GetGpuTopologySystemPropertiesEx(NV_GPU_TOPOLOGY *pTopology, NV_GPU_TOPOLOGY_SYSTEM_PROPERTIES *pSystemProperties);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetGpuTopologySystemPropertiesStringEx
//
//! \code
//! DESCRIPTION: Converts an SLI system properties mask into a null terminated string
//!              This call deprecates NvAPI_GetGpuTopologySystemPropertiesString
//!
//! PARAMETERS:  pSystemProperties(IN)  - the system properties structure for this SLI config.
//!              szDesc (OUT) - null terminated string (always, never NULL)
//!                 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! RETURN STATUS: 
//!    NVAPI_OK - completed request
//!    NVAPI_ERROR - miscellaneous error occurred
//! \endcode
//! \ingroup gputopology
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetGpuTopologySystemPropertiesStringEx(NV_GPU_TOPOLOGY_SYSTEM_PROPERTIES *pSystemProperties, NvAPI_String szDesc);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_GPU_GetAllGpusOnSameBoard
//
//!  This function returns a set of GPUs handles that exists on the same board as the queried GPU handle.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 95
//!
//! \param [in]  hPhysicalGPU   GPU selection.
//! \param [out] nvGPUHandle    The associated GPUs on the same board as the queried GPU. This array includes the queried GPU handle too.
//! \param [out] pGpuCount      The count of GPUs that exists on the same board. This count includes the queried GPU handle too.
//!
//! \retval  NVAPI_OK                            Completed request
//! \retval  NVAPI_ERROR                         Miscellaneous error occurred.
//! \retval  NVAPI_HANDLE_INVALIDATED            Handle passed has been invalidated (see user guide).
//! \retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle.
//! \ingroup gputopology
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetAllGpusOnSameBoard(NvPhysicalGpuHandle hPhysicalGpu, NvPhysicalGpuHandle nvGPUHandle[NVAPI_MAX_PHYSICAL_GPUS], NvU32 *pGpuCount);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SYS_GetChipSetTopologyStatus
//
//!  This function returns topology state flags from NV_GPU_TOPOLOGY_STATUS_FLAGS possible with the System ChipSet.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 95
//!
//! \param [out] pStatus  Indicates one or more flags from NV_GPU_TOPOLOGY_STATUS_FLAGS which are the subset of the 
//!                       same flags retrieved from NV_GPU_TOPOLOGY.status or pStatus in NvAPI_GetValidGpuTopologies() API.
//!  
//! \retval  NVAPI_OK     Completed request
//! \retval  NVAPI_ERROR  Miscellaneous error occurred
//! \ingroup gputopology
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_GetChipSetTopologyStatus(NvU32 *pStatus);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_SetTopologyDisplayGPU
//
//! DESCRIPTION:    This function switches the display output between GPUs in an active GPU topology.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 165 
//!
//!  \param [in]    hLogicalGPU      Active logical GPU topology containing more than one physical GPU.
//!  \param [in]    hGPU             Target GPU handle for outputting the display.
//!  \param [in]    displayOutputId  Connected display output Id on the target GPU which should be activated. See \ref handles.
//!
//!  \retval        NVAPI_OK                       Call succeeded. Display output switched on the target GPU's displayOutputId.
//!  \retval        NVAPI_INVALID_ARGUMENT         One or more arguments are invalid. displayOutputId should be connected to the target hGPU.
//!  \retval        NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found.
//!  \retval        NVAPI_NO_ACTIVE_SLI_TOPOLOGY   The logical GPU does not contain more than one physical GPU.
//!  \retval        NVAPI_NO_VIDLINK               A video bridge is required for this target GPU switch to succeed.
//!  \retval        NVAPI_ERROR                    The request failed.
//!
//!  \ingroup       gputopology
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetTopologyDisplayGPU(NvLogicalGpuHandle hLogicalGPU, NvPhysicalGpuHandle hGPU, NvU32 displayOutputId);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GetTopologyDisplayGPU
//
//! DESCRIPTION:    This function queries the target GPU and display output ID on an active GPU topology.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 165 
//!
//!  \param [in]    hLogicalGPU         Active logical GPU topology containing more than one physical GPU.
//!  \param [out]   pPhysicalGpu        The target GPU handle where the display is getting outputted.
//!  \param [out]   pDisplayOutputId    The active connected display output ID on the target GPU. See \ref handles.
//!
//!  \retval        NVAPI_OK                       Call succeeded. 
//!  \retval        NVAPI_INVALID_ARGUMENT         One or more arguments are invalid. 
//!  \retval        NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found.
//!  \retval        NVAPI_ERROR                    The request failed.
//!
//!  \ingroup       gputopology
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetTopologyDisplayGPU(NvLogicalGpuHandle hLogicalGPU, NvPhysicalGpuHandle *pPhysicalGpu, NvU32 *pDisplayOutputId);

// End of GPU topology configuration APIs





//! \ingroup gpu
//! Used in NvAPI_GPU_Get_DisplayPort_DongleInfo().
typedef struct
{
    NvU32      version;        //!< Structure version
    struct{
        NvU32   displayMask;  //!< This field name should be outputid and will have only one bit set.
    } input;
    struct{
        NvU32   isDP2DVI:1;           //!< Passive DP to DVI Dongle.
        NvU32   isDP2HDMI:1;          //!< Passive DP to HDMI Dongle.
        NvU32   isDMS592DVI:1;        //!< LFH_DVI
        NvU32   isDMS592VGA:1;        //!< LFH_VGA
        NvU32   isDP2VGA:1;           //!< DP to VGA Dongle. This information is not available on WinXP.
        NvU32   isDP2DVIActive:1;     //!< Active DP to DVI Dongle. This information is not available on WinXP.
        NvU32   isDP2HDMIActive:1;    //!< Active DP to HDMI Dongle. This information is not available on WinXP.
        NvU32   reserved : 25;
    } output;

} NV_NVAPI_GET_DP_DONGLE_INFO;

//! \ingroup gpu
//! Macro for constructing the version field of NV_NVAPI_GET_DP_DONGLE_INFO
#define NV_NVAPI_GET_DP_DONGLE_INFO_VER  MAKE_NVAPI_VERSION(NV_NVAPI_GET_DP_DONGLE_INFO,1)


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_Get_DisplayPort_DongleInfo
//
//! DESCRIPTION: This API gets DisplayPort dongle information, such as DP2DVI or DP2HDMI. 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//! 
//! \param [in]     hPhysicalGPU   GPU selection.
//! \param [in,out] pDongleInfo    Data input/output structure
//!            
//! \retval ::NVAPI_OK                            Completed request
//! \retval ::NVAPI_ERROR                         Miscellaneous error occurred
//! \retval ::NVAPI_INVALID_ARGUMENT              One or more args are invalid
//! \retval ::NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_Get_DisplayPort_DongleInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_NVAPI_GET_DP_DONGLE_INFO *pDongleInfo);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_SetPerfLevel
//
//! DESCRIPTION: This function sets the GPU perf level to a specified level. For testing only.
//!              There is a known limitation that after locking to the target perf level, 
//!              there is currently no way to release the lock. \n
//!              Note that this function is now obsolete and is being replaced by NvAPI_GPU_SetForcePstate.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 100
//!
//!  \retval  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle is invalid.
//!  \retval  NVAPI_OK                            GPU perf level is successfully set.
//!  \retval  NVAPI_ERROR                         Failed to set GPU perf level.
//!
//!  \ingroup gpuclock
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetPerfLevel(NvPhysicalGpuHandle hPhysicalGpu, NvU32 level);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_SetForcePstate
//
//! DESCRIPTION:    This function forces the GPU into the specified performance state (P-State).
//!                 \sa NvAPI_GPU_GetPstates() for list of P-States. 
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 165
//!
//!  \param [in]     hPhysicalGPU  GPU selection.
//!  \param [in]     forcePstate   The ID of the P-State to force the GPU into.
//!                                Specify NV_GPU_PERF_PSTATE_UNDEFINED to stop
//!                                forcing to any P-State, and allow the driver to
//!                                dynamically determine the optimal P-State. 
//!                                See \ref NV_GPU_PERF_PSTATE_ID
//!  \param [in]     fallback      The fallback strategy when the specified P-State
//!                                is not available.
//!                         - If FALLBACK_RETURN_ERROR is specified, the function returns an
//!                           error when the P-State specified by forcePstate is not available.
//!                         - If FALLBACK_HIGHER_PERF is specified, the function falls back
//!                           to a higher P-State, or to the highest possible P-State if no higher performance
//!                           P-State is found.
//!                         - If FALLBACK_LOWER_PERF is specified, the function falls back
//!                           to a lower P-State, or to the lowest possible P-State if no lower performance 
//!                           P-State is found.
//! 
//!   \retval     NVAPI_OK                             Completed request
//!   \retval     NVAPI_ERROR                          Miscellaneous error occurred.
//!   \retval     NVAPI_HANDLE_INVALIDATED             Handle passed has been invalidated (see user guide).
//!   \retval     NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE   Handle passed is not a physical GPU handle.
//!   \retval     NVAPI_NOT_SUPPORTED                  P-States is not supported on this setup.
//!   \retval     NVAPI_INVALID_ARGUMENT               Invalid input parameter
//!
//!   \ingroup    gpupstate
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetForcePstate(NvPhysicalGpuHandle hPhysicalGpu, 
                                         NV_GPU_PERF_PSTATE_ID forcePstate,
                                         NV_GPU_PERF_PSTATE_FALLBACK fallback);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_SetForcePstateEx
//
//! DESCRIPTION:     This API forces the GPU into the specified performance state (P-State).
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 180
//!
//! \param [in]   hPhysicalGPU   GPU selection
//! \param [in]   forcePstate    The ID of the P-State into which to force the GPU; Specify
//!                              ::NV_GPU_PERF_PSTATE_UNDEFINED to stop forcing to any P-State, 
//!                              and allow the driver to dynamically determine the optimal P-State.
//!                              See \ref NV_GPU_PERF_PSTATE_ID. 
//! \param [in]   fallback       The fallback strategy when the specified P-State is not available.
//!                              For example, 
//!                              - If FALLBACK_RETURN_ERROR is specified, the function would just return
//!                                an error when the P-State specified by forcePstate is not available.
//!                              - If FALLBACK_HIGHER_PERF is specified, the function would fall back
//!                                to a higher performance P-State, or to the P-State with the highest
//!                                possible performance if no higher performance P-State is found.
//!                              - If FALLBACK_LOWER_PERF is specified, the function would fallback
//!                                to a lower performance P-State, or to the P-State with the lowest
//!                                possible performance if no lower performance P-State is found.
//! \param [in]    flags         Options that control the behavior of the P-State change.
//!                              Valid flags:
//!                              ::NV_GPU_PERF_SET_FORCE_PSTATE_FLAGS_ASYNC - Change the p-state asynchronously.
//!                              When this flag is set, the p-state change may not complete before the function returns.
//!
//! retval    ::NVAPI_OK                             Completed request
//! retval    ::NVAPI_ERROR                          Miscellaneous error occurred
//! retval    ::NVAPI_HANDLE_INVALIDATED             Handle passed has been invalidated (see user guide)
//! retval    ::NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE   Handle passed is not a physical GPU handle
//! retval    ::NVAPI_NOT_SUPPORTED                  P-States is not supported on this setup
//! retval    ::NVAPI_INVALID_ARGUMENT               Invalid input parameter
//!
//! \ingroup  gpupstate
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetForcePstateEx(NvPhysicalGpuHandle hPhysicalGpu,
                                           NV_GPU_PERF_PSTATE_ID forcePstate,
                                           NV_GPU_PERF_PSTATE_FALLBACK fallback,
                                           NvU32 flags);





///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_SetPerfClockControl
//
//!  This function sets the GPU perf controls - graphics, memory, and thermal. The
//!  changes for each of graphics, memory, and thermal controls will be 
//!  enabled/disabled according to the parameters passed in. \n
//!  1 = enabled, 0 = disabled.  \n
//!  For testing only.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 100
//!
//!  \param [in] hPhysicalGpu   The physical GPU handle
//!  \param [in] graphicsEnable Graphics perf control enable(1)/disable(0) 
//!  \param [in] memoryENable   Memory perf control enable(1)/disable(0)
//!  \param [in] thermalEnable  Thermal perf control enable(1)/disable(0)
//!
//!  \retval     NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE   Handle is invalid.
//!  \retval     NVAPI_OK                             GPU perf clock control is successfully set.
//!  \retval     NVAPI_ERROR                          Failed to set the GPU perf clock control.
//!
//!  \ingroup gpuclock
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetPerfClockControl(NvPhysicalGpuHandle hPhysicalGpu,
                                               NvU32 graphicsEnable,
                                               NvU32 memoryEnable,
                                               NvU32 thermalEnable);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetPerfClockControl
//
//!  This function retrieves dynamic performance clock controls status. \n 
//!  1 = enabled, 0 = disabled.
//! 
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 100
//!
//!  \param [in]  hPhysicalGpu   The physical GPU handle
//!  \param [out] graphicsEnable Describes whether or not dynamic graphics clock changes are enabled. 
//!  \param [out] memoryENable   Describes whether or not dynamic memory clock changes are enabled.
//!  \param [out] thermalEnable  Describes whether or not thermal changes are enabled.
//!
//!  \retval      NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle is invalid
//!  \retval      NVAPI_OK                            GPU perf clock control retrieved successfully.
//!  \retval      NVAPI_ERROR                         Failed to get the GPU perf clock control.
//! 
//!  \ingroup gpuclock
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetPerfClockControl(NvPhysicalGpuHandle hPhysicalGpu,
                                              NvU32 *graphicsEnabled,
                                              NvU32 *memoryEnabled,
                                              NvU32 *thermalEnabled);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetCoreVoltage
//
//!   This function gets sampled GPU voltage in millivolts.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 100
//!
//!   \retval    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle is invalid.
//!   \retval    NVAPI_OK                            Successfully retrieved voltage value.
//!   \retval    NVAPI_ERROR                         Failed to get voltage value.
//!
//!   \ingroup gpuvoltage
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetCoreVoltage(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *voltage);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_SetCoreVoltageControl
//
//!   This function sets the GPU core-voltage control (enable or disable).
//!   On success, the core voltage change feature is enabled or disabled. \n
//!   1 = enabled, 0 = disabled. \n
//!   For testing purposes only.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 100
//!
//!   \retval   NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle is invalid.
//!   \retval   NVAPI_OK                            Successfully set voltage control.
//!   \retval   NVAPI_ERROR                         Failed to set voltage control.
//!
//!   \ingroup gpuvoltage
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetCoreVoltageControl(NvPhysicalGpuHandle hPhysicalGpu, NvU32 enable);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetCoreVoltageControl
//
//!   This function gets the GPU core voltage control state (enabled or disabled).
//!   On success, 'enabled' describes whether or not the core voltage change feature is enabled. \n
//!   1 = enabled, 0 = disabled.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 100
//!
//!   \retval    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle is invalid.
//!   \retval    NVAPI_OK                            Successfully got voltage control.
//!   \retval    NVAPI_ERROR                         Failed to get voltage control.
//!
//!   \ingroup gpuvoltage
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetCoreVoltageControl(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *enabled);



//! \addtogroup gpuvoltage
//! @{

//! Used in NvAPI_GPU_GetVoltageDomainsInfo().
//! Fields marked with [SET] must be populated when making NvAPI_GPU_GetVoltageDomainsInfo() call.
typedef struct _NV_GPU_VOLTAGE_DOMAIN_INFO_V1
{
    //! Domain ID (To be [SET] only if NV_GPU_VOLTAGE_DOMAINS_INFO_V<n>::numDomains > 0).
    NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID domainId;

    //! Voltage step size for this domain in uV.
    NvU32                              stepSizeuV;
} NV_GPU_VOLTAGE_DOMAIN_INFO_V1;

//! Used in NvAPI_GPU_GetVoltageDomainsInfo().
//! Fields marked with [SET] must be populated when making NvAPI_GPU_GetVoltageDomainsInfo() call.
typedef struct _NV_GPU_VOLTAGE_DOMAINS_INFO_V1
{
    //! [SET] Version info of the structure (NV_GPU_VOLTAGE_DOMAINS_INFO_VER<n>).
    NvU32 version;

    //! Reserved for future use.
    NvU32 flags;

    //! [SET] Number of voltage domains to query for obtaining their static information.
    //! Clients should set this to 0 to query all supported domains.
    NvU32 numDomains;

    //! Array of voltage domains and has 0 to numDomains - 1 as valid index range.
    NV_GPU_VOLTAGE_DOMAIN_INFO_V1 domains[NVAPI_MAX_GPU_PERF_VOLTAGES];
} NV_GPU_VOLTAGE_DOMAINS_INFO_V1;

//! Used in NvAPI_GPU_GetVoltageDomainsInfo().
typedef NV_GPU_VOLTAGE_DOMAINS_INFO_V1         NV_GPU_VOLTAGE_DOMAINS_INFO;

//! Macro for constructing the version field of NV_GPU_VOLTAGE_DOMAINS_INFO_V1.
#define NV_GPU_VOLTAGE_DOMAINS_INFO_VER1       MAKE_NVAPI_VERSION(NV_GPU_VOLTAGE_DOMAINS_INFO_V1, 1)

//! Macro for constructing the version field of NV_GPU_VOLTAGE_DOMAINS_INFO_VER1.
#define NV_GPU_VOLTAGE_DOMAINS_INFO_VER        NV_GPU_VOLTAGE_DOMAINS_INFO_VER1

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetVoltageDomainsInfo
//
//! DESCRIPTION:  This API returns static information for the specified domains.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Version: 313.xx
//!
//! \param [in]  hPhysicalGpu          The physical GPU handle
//! \param [out] pVoltageDomainsInfo   Pointer to structure containing the static information
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status.
//!          If there are return error codes with specific meaning for this API,
//!          they are listed below.
//! \retval  NVAPI_INVALID_ARGUMENT    Number of requested domains exceed NVAPI_MAX_GPU_PERF_VOLTAGES.
//! \ingroup gpuvoltage
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetVoltageDomainsInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_VOLTAGE_DOMAINS_INFO *pVoltageDomainsInfo);



//! \addtogroup gpuvoltage
//! @{

//! Used in NvAPI_GPU_GetVoltageDomainsStatus().
//! Fields marked with [SET] must be populated when making NvAPI_GPU_GetVoltageDomainsStatus() call.
typedef struct 
{
    //! Domain ID (To be [SET] only if NV_GPU_VOLTAGE_DOMAINS_STATUS_V<n>::numDomains > 0).
    NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID domainId;

    //! Current voltage for this domain in uV.
    NvU32                              voltageuV;
} NV_GPU_VOLTAGE_DOMAIN_STATUS_V1;

//! Used in NvAPI_GPU_GetVoltageDomainsStatus().
//! Fields marked with [SET] must be populated when making NvAPI_GPU_GetVoltageDomainsStatus() call.
typedef struct
{
    //! [SET] Version info of the structure (NV_GPU_VOLTAGE_DOMAINS_STATUS_VER<n>).
    NvU32 version;

    //! Reserved for future use.
    NvU32 flags;

    //! [SET] Number of voltage domains to query for obtaining their current status.
    //! Clients should set this to 0 to query all supported domains.
    NvU32 numDomains;

    //! Array of voltage domains and has 0 to numDomains - 1 as valid index range.
    NV_GPU_VOLTAGE_DOMAIN_STATUS_V1 domains[NVAPI_MAX_GPU_PERF_VOLTAGES];
} NV_GPU_VOLTAGE_DOMAINS_STATUS_V1;

//! Used in NvAPI_GPU_GetVoltageDomainsStatus().
typedef NV_GPU_VOLTAGE_DOMAINS_STATUS_V1       NV_GPU_VOLTAGE_DOMAINS_STATUS;

//! Macro for constructing the version field of NV_GPU_VOLTAGE_DOMAINS_STATUS_V1.
#define NV_GPU_VOLTAGE_DOMAINS_STATUS_VER1     MAKE_NVAPI_VERSION(NV_GPU_VOLTAGE_DOMAINS_STATUS_V1, 1)

//! Macro for constructing the version field of NV_GPU_VOLTAGE_DOMAINS_STATUS_VER1.
#define NV_GPU_VOLTAGE_DOMAINS_STATUS_VER      NV_GPU_VOLTAGE_DOMAINS_STATUS_VER1

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetVoltageDomainsStatus
//
//! DESCRIPTION:  This API returns current status for the specified domains.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Version: 295.xx
//!
//! \param [in]  hPhysicalGpu          The physical GPU handle
//! \param [out] pVoltageDomainsStatus Pointer to structure containing the current status
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status.
//!          If there are return error codes with specific meaning for this API,
//!          they are listed below.
//! \retval  NVAPI_INVALID_ARGUMENT    Number of requested domains exceed NVAPI_MAX_GPU_PERF_VOLTAGES.
//! \ingroup gpuvoltage
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetVoltageDomainsStatus(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_VOLTAGE_DOMAINS_STATUS *pVoltageDomainsStatus);





//! \addtogroup gpupower
//! @{
#define NV_GPU_POWER_DEVICE_MAX_DEVICES_V1                                    32

typedef enum _NV_GPU_POWER_DEVICE_TYPE
{
    NV_GPU_POWER_DEVICE_TYPE_DISABLED = 0,
    NV_GPU_POWER_DEVICE_TYPE_INA219,
    NV_GPU_POWER_DEVICE_TYPE_VT1165,
    NV_GPU_POWER_DEVICE_TYPE_CHL8112,
    NV_GPU_POWER_DEVICE_TYPE_INA209,
    NV_GPU_POWER_DEVICE_TYPE_INA3221,
    NV_GPU_POWER_DEVICE_TYPE_BA00,
    NV_GPU_POWER_DEVICE_TYPE_BA10HW,
    NV_GPU_POWER_DEVICE_TYPE_BA10SW,
    NV_GPU_POWER_DEVICE_TYPE_BA11HW,
    NV_GPU_POWER_DEVICE_TYPE_BA11SW,
    NV_GPU_POWER_DEVICE_TYPE_BA12HW,

} NV_GPU_POWER_DEVICE_TYPE;

typedef enum _NV_GPU_POWER_DEVICE_POWER_RAIL
{
  NV_GPU_POWER_DEVICE_POWER_RAIL_DISABLED              =        0x00000000,
  NV_GPU_POWER_DEVICE_POWER_RAIL_OUTPUT_NVVDD          =        0x00000001,
  NV_GPU_POWER_DEVICE_POWER_RAIL_OUTPUT_FBVDD          =        0x00000002,
  NV_GPU_POWER_DEVICE_POWER_RAIL_OUTPUT_FBVDDQ         =        0x00000003,
  NV_GPU_POWER_DEVICE_POWER_RAIL_OUTPUT_FBVDD_Q        =        0x00000004,
  NV_GPU_POWER_DEVICE_POWER_RAIL_OUTPUT_PEXVDD         =        0x00000005,
  NV_GPU_POWER_DEVICE_POWER_RAIL_OUTPUT_A3V3           =        0x00000006,
  NV_GPU_POWER_DEVICE_POWER_RAIL_INPUT_EXT12V_8PIN0    =        0x000000FA,
  NV_GPU_POWER_DEVICE_POWER_RAIL_INPUT_EXT12V_8PIN1    =        0x000000FB,
  NV_GPU_POWER_DEVICE_POWER_RAIL_INPUT_EXT12V_6PIN0    =        0x000000FC,
  NV_GPU_POWER_DEVICE_POWER_RAIL_INPUT_EXT12V_6PIN1    =        0x000000FD,
  NV_GPU_POWER_DEVICE_POWER_RAIL_INPUT_PEX3V3          =        0x000000FE,
  NV_GPU_POWER_DEVICE_POWER_RAIL_INPUT_PEX12V          =        0x000000FF,

} NV_GPU_POWER_DEVICE_POWER_RAIL;

/*!
 * Used in \ref NV_GPU_POWER_DEVICE_INFO_V2.
 *
 * Structure of static information specific to the BA00 power device.  This
 * Power Device is the very basic BA implementation found on GK10X and the
 * model which helps correct for its inaccuracy.
 */
typedef struct _NV_GPU_POWER_DEVICE_INFO_BA00
{
    /*!
     * Index into Power Equation table for equation to estimate leakage power.
     */
    NvU8 leakageIdx;
    /*!
     * Index into Power Equation table for first fit equation to estimate BA
     * v0.0 dynamic power.  BA v0.0 sensor will use all fits in the range
     * [\ref fitIdxFirst, \ref fitIdxLast] to estimate dynamic power.
     */
    NvU8 fitIdxFirst;
    /*!
     * Index into Power Equation table for last fit equation to estimate BA
     * v0.0 dynamic power.  BA v0.0 sensor will use all fits in the range
     * [\ref fitIdxFirst, \ref fitIdxLast] to estimate dynamic power.
     */
    NvU8 fitIdxLast;
    /*!
     * Index into Power Equation table for conservative "high power" fit
     * equation to estimate BA v0.0 dynamic power.  This fit equation is the
     * most conservative fit which was trained from the most aggresive power
     * virus app (e.g. GLI).
     *
     * This high power fit may be disabled by setting to \ref
     * NV_GPU_POWER_PWR_EQUATION_INDEX_INVALID.  Otherwise, index must be
     * within range [\ref fitIdxFirst, \ref fitIdxLast].
     *
     * Due to lack of TEX coverage, BA v0.0 exhibits lack of level separation
     * between the most aggressive power virus apps (e.g. GLI) and and some of
     * the more aggressive perf apps (e.g. 3DM11 GT1) - thus certain perf apps
     * can be fit with the conservative high power fit and their power can be
     * over-estimated, leading to sub-optimal performance from over-capping.
     *
     * PWR_DEVICE_BA00 WARs this problem by only considering the conservative
     * "high power" fit when the last estimated total power (e.g. \ref
     * RM_PMU_PMGR_PWR_DEVICE_BA00_PROV_TOTAL_POWER) is > \ref threshmWHiPwr.
     * Board solutions will specify this threshold value at a value that perf
     * apps should not hit for worst-case operating conditions - i.e. such that
     * the perf-trained fits evaluate to this point only for very extreme
     * workloads.
     */
    NvU8 fitIdxHiPwr;
    /*!
     * Threshold for estimated total power (e.g. \ref
     * RM_PMU_PMGR_PWR_DEVICE_BA00_PROV_TOTAL_POWER) which will enable the
     * conservative "high power" fit - \ref fitIdxHiPwr, per the PWR_DEVICE_BA00
     * WAR for level separation.
     */
    NvU32 threshmWHiPwr;
} NV_GPU_POWER_DEVICE_INFO_BA00;

/*!
 * Used in \ref NV_GPU_POWER_DEVICE_INFO_V2.
 *
 * Structure of static information specific to the BA1XHW power device.  This
 * Power Device is GPU's internal HW logic designed for curent/power estimation
 * on GK11X (BA10HW), GK20X (BA11HW) and GM10X+ (BA12HW).
 */
typedef struct _NV_GPU_POWER_DEVICE_INFO_BA1XHW
{
    /*!
     * Index into Power Equation Table (PWR_EQUATION) for the scaling equation
     */
    NvU8    scalingEquIdx;
    /*!
     * Index into Power Equation Table (PWR_EQUATION) for the offset equation
     */
    NvU8    offsetEquIdx;
    /*!
     * Index of associated HW BA averaging window
     */
    NvU8    windowIdx;
    /*!
     * Number of bits to right-shift within Step Period Integrator HW
     */
    NvU8    sumShift;
    /*!
     * Size of BA averaging window expressed as log2(utils clocks)
     */
    NvU8    winPeriod;
    /*!
     * If set to '1' then device monitors/estimates GPU current [mA], 
     * otherwise power [mW]
     */
    NvU32   isMeasuringCurrent:1;
    /*!
     * If set to '1' then include BA figures from silicon powerd with NVVDD
     */
    NvU32   isMonitoringNVVDD:1;
    /*!
     * If set to '1' then include BA figures from silicon powerd with FBVDDQ
     */
    NvU32   isMonitoringFBVDDQ:1;
    /*!
     * Reserved for future use  
     */
    NvU32   reserved:29;
} NV_GPU_POWER_DEVICE_INFO_BA1XHW;

/*!
 * Used in \ref NV_GPU_POWER_DEVICE_INFO_V2.
 *
 * Structure of static information specific to the BA1XSW power device.  This
 * Power Device is RM's SW wrapper around HW debug functionality designed for
 * curent/power estimation on GK11X (BA10SW) and GK20X (BA11SW).
 */
typedef struct _NV_GPU_POWER_DEVICE_INFO_BA1XSW
{
    /*!
     * Index into Power Devices Table of parent BA1XHW device to monitor.
     */
    NvU8    pwrDeviceIdx;
    /*!
     * Minimum sampling period in units of micro-seconds [us].
     *
     * Once PMU samples BA using debug registers they are cleared and it has to
     * wait this minimum time for new BA to accumulate before it samples again.
     * Meanwhile it will report cached value from previous period.
     */
    NvU32   minSamplingPeriodus;
} NV_GPU_POWER_DEVICE_INFO_BA1XSW;

/*!
 * Used in \ref NV_GPU_POWER_DEVICE_INFO_V2.
 *
 * Structure of static information specific to the INA209 power device.  This
 * Power Device is TI's INA209 ADC which can monitor power, current, and voltage
 * of a single provider, as well as provide various HW-threshold-based current
 * capping feautres.
 */
typedef struct _NV_GPU_POWER_DEVICE_INFO_INA209
{
    /*!
     * Shunt Resistor Resistance (mOhm)
     */
    NvU16 rShuntmOhm;
    /*!
     * Configuration register value
     */
    NvU16 calibration;
    /*!
     * Calibration register value
     */
    NvU16 configuration;
    /*!
     * Critical DAC+ register value
     */
    NvU16 criticalDacPos;
    /*!
     * Critical DAC- register value
     */
    NvU16 criticalDacNeg;
} NV_GPU_POWER_DEVICE_INFO_INA209;

/*!
 * Used in \ref NV_GPU_POWER_DEVICE_INFO_V2.
 *
 * Structure of static information specific to the INA219 power device.  This
 * Power Device is TI's INA219 ADC which can monitor power, current, and voltage
 * of a single provider.
 */
typedef struct _NV_GPU_POWER_DEVICE_INFO_INA219
{
    /*!
     * Shunt Resitor Resistance (mOhm)
     */
    NvU16 rShuntmOhm;
    /*!
     * Configuration register value
     */
    NvU16 calibration;
    /*!
     * Calibration register value
     */
    NvU16 configuration;
} NV_GPU_POWER_DEVICE_INFO_INA219;

/*!
 * Used in \ref NV_GPU_POWER_DEVICE_INFO_INA3221.
 *
 * Macro to represent number of physical channels on an INA3221 device.
 */
#define NV_GPU_POWER_DEVICE_INFO_INA3221_CH_NUM                             0x03

/*!
 * Used in \ref NV_GPU_POWER_DEVICE_INFO_V2.
 *
 * Structure of static information specific to the INA3221 power device.  This
 * Power Device is TI's INA3221 ADC which can monitor power, current, and
  * voltage of 3 providers as well as alert control functionality.
 */
typedef struct _NV_GPU_POWER_DEVICE_INFO_INA3221
{
    /*!
     * Shunt Resitor Resistance (mOhm)
     */
    NvU16       rShuntmOhm[NV_GPU_POWER_DEVICE_INFO_INA3221_CH_NUM];
    /*!
     * Configuration register value
     */
    NvU16       configuration;
    /*!
     * Mask/Enable register value
     */
    NvU16       maskEnable;
    /*!
     * The GPIO function this device could trigger.
     */
    NvU8        gpioFunction;
    /*!
     * Current value linear correction factor M. This is used to adjust
     * INA3221's measurement in using Mx + B correction. Unitless.
     * This value is in UFXP4_12 format.
     */
    NvU16       currCorrectM;
    /*!
     * Current value linear correction factor B. Units of Amps. This value is in
     * SFXP4_12 format.
     */
    NvS16       currCorrectB;
} NV_GPU_POWER_DEVICE_INFO_INA3221;

/*!
 * Used in \ref NV_GPU_POWER_DEVICE_GET_INFO_V1.
 *
 * Structure of static information describing a POWER_DEVICE, which specifies
 * per the Power Sensors Table spec a power sensor on the board or GPU which is
 * capable of provide telemtry for some subset of power, current, and voltage on
 * a set number of providers.
 */
typedef struct _NV_GPU_POWER_DEVICE_INFO_V1
{
    /*!
     * This will be populated using one of the enums values defined for
     * NV_GPU_POWER_DEVICE_TYPE.
     */
    NvU8  type;
    /*!
     * This will be populated using one of the enums values defined for
     * NV_GPU_POWER_DEVICE_TYPE.
     */
    NvU8  powerRail;
} NV_GPU_POWER_DEVICE_INFO_V1;

/*!
 * Used in \ref NV_GPU_POWER_DEVICE_GET_INFO_V2.
 *
 * Structure of static information describing a POWER_DEVICE, which specifies
 * per the Power Sensors Table spec a power sensor on the board or GPU which is
 * capable of provide telemtry for some subset of power, current, and voltage on
 * a set number of providers.
 */
typedef struct _NV_GPU_POWER_DEVICE_INFO_V2
{
    /*!
     * This will be populated using one of the enums values defined for
     * NV_GPU_POWER_DEVICE_TYPE.
     */
    NvU8  type;
    /*!
     * This will be populated using one of the enums values defined for
     * NV_GPU_POWER_DEVICE_TYPE.
     */
    NvU8  powerRail;

    /*!
     * Reserved 32 bytes of space so can add new data w/o needing to add a new
     * version.
     */
    NvU8 rsvd[32];

    /*!
     * Union of type-specific data.
     */
    union
    {
        NV_GPU_POWER_DEVICE_INFO_BA00    ba00;
        NV_GPU_POWER_DEVICE_INFO_BA1XHW  ba1xhw;
        NV_GPU_POWER_DEVICE_INFO_BA1XSW  ba1xsw;
        NV_GPU_POWER_DEVICE_INFO_INA209  ina209;
        NV_GPU_POWER_DEVICE_INFO_INA219  ina219;
        NV_GPU_POWER_DEVICE_INFO_INA3221 ina3221;

        /*!
         * Reserving 48 bytes of space so can add new types without needing to
         * add a new version.
         */
        NvU8 rsvd[48];
    } data;
} NV_GPU_POWER_DEVICE_INFO_V2;

/*!
 * Used in \ref NvAPI_GPU_PowerDeviceGetInfo().
 *
 * Structure representing the static state information associated with the GPU's
 * POWER_DEVICE functionality.
 */
typedef struct _NV_GPU_POWER_DEVICE_GET_INFO_V1
{
    /*!
     * Version of structure.  Must always be first.
     */
    NvU32  version;

    /*!
     * Mask of POWER_DEVICE entries specified on this GPU.
     */
    NvU32  pwrDeviceMask;

    /*!
     * Array of POWER_DEVICE entries.  Has valid indexes corresponding to the
     * bits set in \ref pwrDeviceMask.
     */
    NV_GPU_POWER_DEVICE_INFO_V1
        devices[NV_GPU_POWER_DEVICE_MAX_DEVICES_V1];
} NV_GPU_POWER_DEVICE_GET_INFO_V1;

/*!
 * Used in \ref NvAPI_GPU_PowerDeviceGetInfo().
 *
 * Structure representing the static state information associated with the GPU's
 * POWER_DEVICE functionality.
 */
typedef struct _NV_GPU_POWER_DEVICE_GET_INFO_V2
{
    /*!
     * Version of structure.  Must always be first.
     */
    NvU32  version;

    /*!
     * Mask of POWER_DEVICE entries specified on this GPU.
     */
    NvU32  pwrDeviceMask;

    /*!
     * Reserving 32 bytes of for future use w/o needing to add new structure
     * version.
     */
    NvU8   rsvd[32];

    /*!
     * Array of POWER_DEVICE entries.  Has valid indexes corresponding to the
     * bits set in \ref pwrDeviceMask.
     */
    NV_GPU_POWER_DEVICE_INFO_V2
        devices[NV_GPU_POWER_DEVICE_MAX_DEVICES_V1];
} NV_GPU_POWER_DEVICE_GET_INFO_V2;

#define NV_GPU_POWER_DEVICE_GET_INFO_VER_1   MAKE_NVAPI_VERSION(NV_GPU_POWER_DEVICE_GET_INFO_V1,1)
#define NV_GPU_POWER_DEVICE_GET_INFO_VER_2   MAKE_NVAPI_VERSION(NV_GPU_POWER_DEVICE_GET_INFO_V2,1)
#define NV_GPU_POWER_DEVICE_GET_INFO_VER     NV_GPU_POWER_DEVICE_GET_INFO_VER_2

typedef NV_GPU_POWER_DEVICE_GET_INFO_V2 NV_GPU_POWER_DEVICE_GET_INFO;


//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_PowerDeviceGetInfo
//
//! \code
//! DESCRIPTION: Gets information about the Power Device Support on the
//!              board.
//!
//! PARAMETERS:  hPhysicalGPU(IN) - GPU selection.
//!              pPwrDevInfo(OUT) - Structure describing the pwrDevices
//!                present/supported on the board.
//!              - pwrDeviceMask is a mask of the valid power device entries in
//!                  the devices[] array.  Every bit set in the mask represents
//!                  a valid entry in the array.
//!              - devices has valid indexes corresponding to the set bits in
//!                  pwrDeviceMask.
//!                - devices[i].type represents the type of power device.  Must
//!                    be one of the NV_GPU_POWER_DEVICE_TYPE_<xyz> enumerations.
//!                - devices[i].powerRaile representst he power rail the power
//!                    device is monitoring - maybe an input or output power
//!                    rail.  Must be one of the
//!                    NV_GPU_POWER_DEVICE_POWER_RAIL_<xyz> enumerations.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! RETURN STATUS:
//!    NVAPI_OK - completed request
//!    NVAPI_ERROR - miscellaneous error occurred
//!    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//!    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//!    NVAPI_NOT_SUPPORTED - P-States is not supported on this setup
//!    NVAPI_INVALID_ARGUMENT - Invalid input parameter
//! \endcode
//! \ingroup gpupower
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_PowerDeviceGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_POWER_DEVICE_GET_INFO *pPwrDevInfo);


//! \ingroup gpupower
typedef struct
{
    NvU32  version;

    NvU32  pwrDeviceMask;
    struct
    {
        NvU32 powermW;
        NvU32 voltageuV;
        NvU32 currentmA;
    } devices[NV_GPU_POWER_DEVICE_MAX_DEVICES_V1];
} NV_GPU_POWER_DEVICE_GET_STATUS_V1;

//! \ingroup gpupower
#define NV_GPU_POWER_DEVICE_GET_STATUS_VER_1   MAKE_NVAPI_VERSION(NV_GPU_POWER_DEVICE_GET_STATUS_V1,1)
//! \ingroup gpupower
#define NV_GPU_POWER_DEVICE_GET_STATUS_VER     NV_GPU_POWER_DEVICE_GET_STATUS_VER_1
//! \ingroup gpupower
#define NV_GPU_POWER_DEVICE_GET_STATUS         NV_GPU_POWER_DEVICE_GET_STATUS_V1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_PowerDeviceGetStatus
//
//! \code
//! DESCRIPTION: Queries the latest readings for a subset of the Power Devices
//!              on the board.
//!
//! PARAMETERS:  hPhysicalGPU(IN) - GPU selection.
//!              pPwrDevStatus(OUT) - Structure for querying a subset of the
//!                power devices present/supported on a board.
//!              - pwrDeviceMask specifies the subset of power devices to query.
//!                  This must be a subset of the mask returned by
//!                  NvAPI_GPU_PowerDeviceGetInfo().
//!              - devices has valid indexes corresponding to the set bits in
//!                  pwrDeviceMask.
//!                - devices[i].powermW returns the queried power device's latest
//!                    power reading in mW.
//!                - devices[i].voltageuV returns the queried power device's latest
//!                    voltage reading in uV.
//!                - devices[i].currentmA returns the queried power device's latest
//!                    current reading in mA.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! RETURN STATUS:
//!    NVAPI_OK - completed request
//!    NVAPI_ERROR - miscellaneous error occurred
//!    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//!    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//!    NVAPI_NOT_SUPPORTED - P-States is not supported on this setup
//!    NVAPI_INVALID_ARGUMENT - Invalid input parameter
//! \endcode
//! \ingroup gpupower
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_PowerDeviceGetStatus(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_POWER_DEVICE_GET_STATUS *pPwrDevStatus);


//! \ingroup gpupower
//! @{

#define NV_GPU_POWER_MONITOR_CHANNEL_INDEX_INVALID                          0xFF

#define NV_GPU_POWER_MONITOR_MAX_CHANNELS_V1                                  32
#define NV_GPU_POWER_MONITOR_MAX_CHANNELS_V2                                  32

#define NV_GPU_POWER_MONITOR_MAX_CHANNEL_RELATIONSHIPS_V2                     32

/*!
 * Enumeration of POWER_CHANNEL types. Different types implement the
 * POWER_CHANNEL functionality via different mechanisms.  Also, specifies how
 * to interpret the channel type data union.
 */
typedef enum
{
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE_DEFAULT = 0x00000000,
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE_SUMMATION,
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE_ESTIMATION,
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE_SLOW,
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE_GEMINI_CORRECTION,
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE_1X,
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE_SENSOR,
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE;

/*!
 * Enumeration of power rails a POWER_CHANNEL may be monitoring.  Rails prefixed
 * with "_OUTPUT" are output power rails, prefixed with "_INPUT" are input power
 * rails.
 */
typedef enum
{
    NV_GPU_POWER_CHANNEL_POWER_RAIL_UNKNOWN               =        0x00000000,
    NV_GPU_POWER_CHANNEL_POWER_RAIL_OUTPUT_NVVDD          =        0x00000001,
    NV_GPU_POWER_CHANNEL_POWER_RAIL_OUTPUT_FBVDD          =        0x00000002,
    NV_GPU_POWER_CHANNEL_POWER_RAIL_OUTPUT_FBVDDQ         =        0x00000003,
    NV_GPU_POWER_CHANNEL_POWER_RAIL_OUTPUT_FBVDD_Q        =        0x00000004,
    NV_GPU_POWER_CHANNEL_POWER_RAIL_OUTPUT_PEXVDD         =        0x00000005,
    NV_GPU_POWER_CHANNEL_POWER_RAIL_OUTPUT_A3V3           =        0x00000006,
    NV_GPU_POWER_CHANNEL_POWER_RAIL_OUTPUT_3V3NV          =        0x00000007,
    NV_GPU_POWER_CHANNEL_POWER_RAIL_OUTPUT_TOTAL_GPU      =        0x00000008,
    NV_GPU_POWER_CHANNEL_POWER_RAIL_OUTPUT_FBVDDQ_GPU     =        0x00000009,
    NV_GPU_POWER_CHANNEL_POWER_RAIL_OUTPUT_FBVDDQ_MEM     =        0x0000000A,
    NV_GPU_POWER_CHANNEL_POWER_RAIL_OUTPUT_SRAM           =        0x0000000B,
    NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_SRAM            =        0x000000F0,
    NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_PWR_SRC_PP      =        0x000000F1,
    NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_3V3_PP          =        0x000000F2,
    NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_3V3_MAIN        =        0x000000F3,
    NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_3V3_AON         =        0x000000F4,
    NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_TOTAL_BOARD     =        0x000000F5,
    NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_NVVDD           =        0x000000F6,
    NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_FBVDD           =        0x000000F7,
    NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_FBVDDQ          =        0x000000F8,
    NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_FBVDD_Q         =        0x000000F9,
    NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_EXT12V_8PIN0    =        0x000000FA,
    NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_EXT12V_8PIN1    =        0x000000FB,
    NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_EXT12V_6PIN0    =        0x000000FC,
    NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_EXT12V_6PIN1    =        0x000000FD,
    NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_PEX3V3          =        0x000000FE,
    NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_PEX12V          =        0x000000FF,
} NV_GPU_POWER_CHANNEL_POWER_RAIL;

/*!
 * Enumeration of POWER_CHANNEL_RELATIONSHIP types.  Different
 * POWER_CHANNEL_RELATIONSHIP types use different functionality to implement the
 * interface by which to scale power readings.  This enumeration also specifies
 * how to interpret the the channel relationship type data union.
 */
typedef enum _NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_TYPE
{
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_TYPE_WEIGHT             = 0x00000000,
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_TYPE_BALANCED_PHASE_EST,
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_TYPE_BALANCING_PWM_WEIGHT,
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_TYPE_REGULATOR_LOSS_EST,
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_TYPE;

/*!
 * Used in \ref NV_GPU_POWER_MONITOR_GET_INFO_V1.  Structure representing the
 * static state corresponding to a POWER_CHANNEL.
 *
 * \note This structure is deprecated for \ref
 *  NV_GPU_POWER_MONITOR_POWER_CHANNEL_INFO_V2.
 */
typedef struct
{
    /*!
     * This field has been deprecated and will not be populated.
     *
     * Please see to \ref
     * NV_GPU_POWER_MONITOR_POWER_CHANNEL_SUMMATION_1X_INFO::pwrDeviceMask or
     * INFONV_GPU_POWER_MONITOR_POWER_CHANNEL_SENSOR_INFO::pwrDevIdx.
     */
    NvU32 pwrDeviceMask;
    /*!
     * Static offset (in mW) which is added to all statistics related to power.
     */
    NvS32 pwrOffsetmW;
    /*!
     * This field has been deprecated and will not be populated.
     *
     * Please see to \ref
     * NV_GPU_POWER_MONITOR_POWER_CHANNEL_SUMMATION_1X_INFO::pwrLimitmW.
     */
    NvU32 pwrLimitmW;
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_INFO_V1;

/*!
 * Used in \ref NvAPI_GPU_PowerMonitorGetInfo().  Structure representing static
 * state describing a GPU's supported power topology.  A "power topology" is
 * defined as the set of power rails (i.e. power channels) which can be
 * measured/estimated in some way and all the details about how they are
 * measured/estimated.
 *
 * \note This structure is deprecated for \ref
 *  NV_GPU_POWER_MONITOR_GET_INFO_V2.
 */
typedef struct
{
    /*!
     * Version of structure.  Must always be first.
     */
    NvU32  version;

    /*!
     * Specifies whether power monitoring is supported on the board.
     */
    NvU8   bSupported;
    /*!
     * The period (in ms) between the samples of each power channel by the
     * RM/PMU PWR software stack.
     */
    NvU32  samplingPeriodms;
    /*!
     * The number of samples per "iteration".  An "iteration" is the number of
     * samples over which samples are averaged and after which all
     * POWER_CAPPPING or POWER_POLICY entires are evaluated.
     */
    NvU32  sampleCount;

    /*!
     * Mask of valid power monitoring channel entries in the \ref channels[]
     * array.  Every bit set represents a valid entry in the array.
     */
    NvU32  channelMask;
    /*!
     * Array of static information describing POWER_CHANNELs.  Has valid indexes
     * corresponding to the set bits in \ref channelMask.
     */
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_INFO_V1 channels[NV_GPU_POWER_MONITOR_MAX_CHANNELS_V1];
} NV_GPU_POWER_MONITOR_GET_INFO_V1;

/*!
 * Used in \ref NV_GPU_POWER_MONITOR_POWER_CHANNEL_INFO_V2.  Structure
 * representing data specific to \ref
 * NV_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE_1X.  This POWER_CHANNEL type
 * represents the data specific to the Power Tables 1.0 channels used in GF10X
 * power capping.
 */
typedef struct
{
    /*!
     * Mask of POWER_DEVICEs to use as input for this channel.  The conception of
     * a mask of POWER_DEVICEs is legacy - the new PWR_CHANNEL_SENSOR class can
     * only refer to a single POWER_DEVICE and provider.
     */
    NvU32       pwrDeviceMask;

    /*!
     * Power Limit (mW)
     */
    NvU32       pwrLimitmW;
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_1X_INFO;

/*!
 * Used in \ref NV_GPU_POWER_MONITOR_POWER_CHANNEL_INFO_V2.  Structure
 * representing data specific to \ref
 * NV_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE_1X.  This POWER_CHANNEL type
 * represents the data specific to the slowdown channels used in GF10X
 * power capping.
 */
typedef struct
{
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_1X_INFO super;
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_SLOW_INFO;

/*!
 * Used in \ref NV_GPU_POWER_MONITOR_POWER_CHANNEL_INFO_V2.  Structure
 * representing data specific to \ref
 * NV_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE_1X.  This POWER_CHANNEL type
 * represents the data specific the Gemini Correction channels used in GF10X
 * Gemini power capping.
 */
typedef struct
{
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_SLOW_INFO super;
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_GEMINI_CORRECTION_INFO;

/*!
 * Used in \ref NV_GPU_POWER_MONITOR_POWER_CHANNEL_INFO_V2.  Structure
 * representing data specific to \ref
 * NV_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE_SENSOR.  This POWER_CHANNEL type
 * queries the given POWER_DEVICE for power telemetry.
 */
typedef struct
{
    /*!
     * Index into the Power Sensors Table for the POWER_DEVICE from which this
     * POWER_CHANNEL should query power values.
     */
    NvU8 pwrDevIdx;

    /*!
     * Index of the POWER_DEVICE Provider to query.
     */
    NvU8 pwrDevProvIdx;
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_SENSOR_INFO;

/*!
 * Used in \ref NV_GPU_POWER_MONITOR_POWER_CHANNEL_INFO_V2.  Structure
 * representing data specific to \ref
 * NV_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE_SUMMATION.  This POWER_CHANNEL type
 * will sum all the readings corresponding to all POWER_CHANNEL_RELATIONSHIPs in
 * the range [\ref relIdxFirst, \ref relIdxLast].
 */
typedef struct
{
    /*!
     * First index into the POWER_CHANNEL_RELATIONSHIP table.
     */
    NvU8 relIdxFirst;
    /*!
     * Last index into the POWER_CHANNEL_RELATIONSHIP table.
     */
    NvU8 relIdxLast;
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_SUMMATION_INFO;

/*!
 * Used in \ref NV_GPU_POWER_MONITOR_GET_INFO_V2.  Structure representing the
 * static state corresponding to a POWER_CHANNEL.
 *
 * \note This structure must remain binary-compatible with \ref
 * NV_GPU_POWER_MONITOR_POWER_CHANNEL_INFO_V1 (from power 1.0/Power Capping).
 * Thus, some fields aren't grouped together logically and some fields aren't
 * applicablef or all POWER_CHANNEL types (\ref
 * NV_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE).
 */
typedef struct
{
    // Ordering of variables needs to be maintained with _V1.

    /*!
     * This field has been deprecated and will not be populated.
     *
     * Please see to \ref
     * NV_GPU_POWER_MONITOR_POWER_CHANNEL_SUMMATION_1X_INFO::pwrDeviceMask or
     * INFONV_GPU_POWER_MONITOR_POWER_CHANNEL_SENSOR_INFO::pwrDevIdx.
     */
    NvU32 pwrDeviceMask;
    /*!
     * Power Correction Offset - signed mW.
     */
    NvS32 pwrOffsetmW;
    /*!
     * This field has been deprecated and will not be populated.
     *
     * Please see to \ref
     * NV_GPU_POWER_MONITOR_POWER_CHANNEL_SUMMATION_1X_INFO::pwrLimitmW.
     */
    NvU32 pwrLimitmW;

    // Begin new variables for _V2.

    /*!
     * NV_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE_<xyz>.
     */
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE type;

    /*!
     * Power Rail - NV_GPU_POWER_CHANNEL_POWER_RAIL_<xyz>.
     */
    NvU8  pwrRail;
    /*!
     * Fixed voltage (in uV) to assume for this PWR_CHANNEL.  Used to simplify
     * power <-> current conversion.
     */
    NvU32 voltFixeduV;
    /*!
     * Power Correction Slope - unsigned FXP20.12 value.
     */
    NvU32 pwrCorrSlope;
    /*!
     * Corection slope (unitless FXP20.12) which is used to correct current
     * readings from this channel.
     */
    NvU32 currCorrSlope;
    /*!
     * Correction offset (mA) by which is used to correct current readings from
     * this channel.
     */
    NvS32 currCorrOffsetmA;

    /*!
     * Reserving 8 bytes of space so can add new types without needing to
     * add a new version.
     */
    NvU8 rsvd[8];

    /*!
     * Union of type-specific data.  Interpreted based on \ref type value.
     */
    union
    {
        NV_GPU_POWER_MONITOR_POWER_CHANNEL_1X_INFO                c1x;
        NV_GPU_POWER_MONITOR_POWER_CHANNEL_GEMINI_CORRECTION_INFO gemmCorr;
        NV_GPU_POWER_MONITOR_POWER_CHANNEL_SENSOR_INFO            sensor;
        NV_GPU_POWER_MONITOR_POWER_CHANNEL_SLOW_INFO              slow;
        NV_GPU_POWER_MONITOR_POWER_CHANNEL_SUMMATION_INFO         sum;
        /*!
         * Reserving 16 bytes of space so can add new types without needing to
         * add a new version.
         */
        NvU8 rsvd[16];
    } data;
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_INFO_V2;

#define NV_GPU_POWER_MONITOR_POWER_CHANNEL_INFO         NV_GPU_POWER_MONITOR_POWER_CHANNEL_INFO_V2

/*!
 * Used in \ref NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_INFO_V2.
 * Structure representing data specific to \ref
 * NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_TYPE_WEIGHT.  This
 * POWER_CHANNEL_RELATIONSHIP type will take the power reading from the
 * specified channel (\ref chIdx) and will scale readings by teh specified \ref
 * weight to its reading.
 */
typedef struct
{
    /*!
     * Weight value by which to scale readings.  Signed FXP 20.12 number.
     * Unitless.
     */
    NvS32 weight;
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_WEIGHT_INFO;

/*!
 * Used in \ref NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_INFO_V2.
 *
 * Structure representing data specific to \ref
 * NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_TYPE_BALANCED_PHASE_EST.
 *
 * This is a relationship evaluates to a proportion of power
 * of the specififed channel index, where the proportion is a dynamic factor
 * depending on the value of the balanced phases.
 *
 * This Channel Relationship is intended to be used to compute the total input
 * power of a voltage regulator of which one or more phases are being
 * dynamically balanced via the _BALANCE Power Policy and Power Policy
 * Relationship Classes.
 */
typedef struct
{
    /*!
     * Total number of phases by which to scale up the estimated power.
     */
    NvU8 numTotalPhases;
    /*!
     * Number of static phases which should be included in the evaluation of
     * this Channel Relationship.
     */
    NvU8 numStaticPhases;
    /*!
     * Index of first _BALANCE Power Policy Relationship representing a
     * balanced phase.  This relationship must be of type _BALANCE.
     */
    NvU8 balancedPhasePolicyRelIdxFirst;
    /*!
     * Index of last _BALANCE Power Policy Relationship representing a
     * balanced phase.  This relationship must be of type _BALANCE.
     */
    NvU8 balancedPhasePolicyRelIdxLast;
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_BALANCED_PHASE_EST_INFO;

/*!
 * Used in \ref NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_INFO_V2.
 *
 * Structure representing data specific to \ref
 * NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_TYPE_BALANCING_PWM_WEIGHT.
 *
 * This is a relationship evaluates to a proportion of power of the specififed
 * channel index, where the proportion is the current PWM percentage of a
 * Balancing Power Policy Relationship.
 */
typedef struct
{
    /*!
     * Index to PWR_POLICY_RELATIONSHIP object of type
     * PWR_POLICY_RELATIONSHIP_BALANCE which will be queried for its current PWM
     * percentage.
     */
    NvU8   balancingRelIdx;

    /*!
     * Boolean indicating whether to use the primary/normal or
     * secondary/inverted PWM percentage as the weight.
     */
    NvU8   bPrimary;
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_BALANCING_PWM_WEIGHT_INFO;

/*!
 * Enumeration for various types of voltage regulators in the topology relationship class.
 */
typedef enum _NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_REGULATOR_TYPE
{
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_REGULATOR_TYPE_NVVDD      =     0x00000000,
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_REGULATOR_TYPE_FBVDD,
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_REGULATOR_TYPE;

/*!
 * Used in \ref NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_INFO_V3.
 *
 * Structure representing data specific to \ref
 * NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_TYPE_REGULATOR_LOSS_EST.
 *
 * Structure for data specific to a regulator loss estimate power channel
 * relationship type. This is a relationship to estimate the output value
 * based on provided coefficients.
 */
typedef struct _NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_REGULATOR_LOSS_EST_INFO
{
   /*!
     * Regulator type.
     */
    NvU8 regulatorType;                

    /*!
     * Constant Coefficient 0 (mW, FXP20.12 signed)
     */
    NvS32 coefficient0;

    /*!
     * Constant Coefficient 1 (mV, FXP20.12 signed)
     */
    NvS32 coefficient1;

    /*!
     * First-order Coefficient 2 (mW / mV, FXP20.12 signed)
     */
    NvS32 coefficient2;

    /*!
     * First-order Coefficient 3 (mW / mV, FXP20.12 signed)
     */
    NvS32 coefficient3;

    /*!
     * First-order Coefficient 4 (mV / mV, FXP20.12 signed)
     */
    NvS32 coefficient4;

    /*!
     * First-order Coefficient 5 (mV / mV, FXP20.12 signed)
     */
    NvS32 coefficient5;
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_REGULATOR_LOSS_EST_INFO;

/*!
 * Used in \ref NV_GPU_POWER_MONITOR_GET_INFO_V2.  Structure representing the
 * static state corresponding to a POWER_CHANNEL_RELATIONSHIP.
 */
typedef struct
{
    /*!
     * NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_TYPE_<xyz>
     */
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_TYPE type;

    /*!
     * Index of the POWER_CHANNEL for this POWER_CHANNEL_RELATIONSHIP.  Readings
     * will be taken from this POWER_CHANNEL when evaluating this
     * POWER_CHANNEL_RELATIONSHIP.
     */
    NvU8 chIdx;

    /*!
     * Union of type-specific data.  Interpreted based on \ref type value.
     */
    union
    {
        NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_WEIGHT_INFO
            weight;
        NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_BALANCED_PHASE_EST_INFO
            balancedPhaseEst;
        NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_BALANCING_PWM_WEIGHT_INFO
            balancingPwmWeight;
        /*!
         * Reserving 16 bytes of space so can add new types without needing to
         * add a new version.
         */
        NvU8 rsvd[16];
    } data;
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_INFO_V2;

/*!
 * Used in \ref NV_GPU_POWER_MONITOR_GET_INFO_V3.  Structure representing the
 * static state corresponding to a POWER_CHANNEL_RELATIONSHIP.
 */
typedef struct _NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_INFO_V3
{
    /*!
     * NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_TYPE_<xyz>
     */
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_TYPE type;

    /*!
     * Index of the POWER_CHANNEL for this POWER_CHANNEL_RELATIONSHIP.  Readings
     * will be taken from this POWER_CHANNEL when evaluating this
     * POWER_CHANNEL_RELATIONSHIP.
     */
    NvU8 chIdx;

    /*!
     * Union of type-specific data.  Interpreted based on \ref type value.
     */
    union
    {
        NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_WEIGHT_INFO
            weight;
        NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_BALANCED_PHASE_EST_INFO
            balancedPhaseEst;
        NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_BALANCING_PWM_WEIGHT_INFO
            balancingPwmWeight;
        NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_REGULATOR_LOSS_EST_INFO
            regulatorLossEst;
        /*!
         * Reserving 32 bytes of space so can add new types without needing to
         * add a new version.
         */
        NvU8 rsvd[32];
    } data;
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_INFO_V3;

#define NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_INFO NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_INFO_V3

/*!
 * Used in \ref NvAPI_GPU_PowerMonitorGetInfo().  Structure representing static
 * state describing a GPU's supported power topology.  A "power topology" is
 * defined as the set of power rails (i.e. power channels) which can be
 * measured/estimated in some way and all the details about how they are
 * measured/estimated.
 */
typedef struct
{
    /*!
     * Version of structure.  Must always be first.
     */
    NvU32  version;

    /*!
     * Specifies whether power monitoring is supported on the board.
     */
    NvU8   bSupported;
    /*!
     * The period (in ms) between the samples of each power channel by the
     * RM/PMU PWR software stack.
     */
    NvU32  samplingPeriodms;
    /*!
     * The number of samples per "iteration".  An "iteration" is the number of
     * samples over which samples are averaged and after which all
     * POWER_CAPPPING or POWER_POLICY entires are evaluated.
     */
    NvU32  sampleCount;

    /*!
     * Mask of valid power monitoring channel entries in the \ref channels[]
     * array.  Every bit set represents a valid entry in the array.
     */
    NvU32  channelMask;
    /*!
     * Mask of valid power monitoring channel relationship entries in the \ref
     * chRels[] array.  Every bit set represents a valid entry in the array.
     */
    NvU32  chRelMask;
    /*!
     * Set of POWER_CHANNELs, that, when added up, yield total GPU power.  Must be a
     * subset of \ref channelMask above.
     *
     * \note This is as legacy implementation for
     * PWR1.0/Power Capping Table, in which all rails are listed separately and
     * must be summed separately. For PWR2.0/Power Policy Table, this mask is
     * implemented but it is deprecated in favor of \ref totalGpuChannelIdx.
     */
    NvU32  totalGpuPowerChannelMask;
    /*!
     * POWER_CHANNEL index corresponding to TOTAL_GPU power.  This value is to
     * be referenced in PWR2.0/Power Policy Table for the single channel which
     * represents total GPU power.
     *
     * \note NV_GPU_POWER_MONITOR_CHANNEL_INDEX_INVALID denotes a single
     * POWER_CHANNEL for total GPU power is not supported.
     */
    NvU8   totalGpuChannelIdx;

    /*!
     * Reserving 11 bytes for future use w/o needing to add new structure
     * version.
     */
    NvU8   rsvd[11];

    /*!
     * Array of static information describing POWER_CHANNELs.  Has valid indexes
     * corresponding to the set bits in \ref channelMask.
     */
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_INFO_V2 channels[NV_GPU_POWER_MONITOR_MAX_CHANNELS_V2];

    /*!
     * Array of static information describing POWER_CHANNEL_RELATIONSHIPs.  Has
     * valid indexes corresponding to the set bits in \ref chRelMask.
     */
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_INFO_V2 chRels[NV_GPU_POWER_MONITOR_MAX_CHANNEL_RELATIONSHIPS_V2];
} NV_GPU_POWER_MONITOR_GET_INFO_V2;

/*!
 * Used in \ref NvAPI_GPU_PowerMonitorGetInfo().  Structure representing static
 * state describing a GPU's supported power topology.  A "power topology" is
 * defined as the set of power rails (i.e. power channels) which can be
 * measured/estimated in some way and all the details about how they are
 * measured/estimated.
 */
typedef struct _NV_GPU_POWER_MONITOR_GET_INFO_V3
{
    /*!
     * Version of structure.  Must always be first.
     */
    NvU32  version;

    /*!
     * Specifies whether power monitoring is supported on the board.
     */
    NvU8   bSupported;
    /*!
     * The period (in ms) between the samples of each power channel by the
     * RM/PMU PWR software stack.
     */
    NvU32  samplingPeriodms;
    /*!
     * The number of samples per "iteration".  An "iteration" is the number of
     * samples over which samples are averaged and after which all
     * POWER_CAPPPING or POWER_POLICY entires are evaluated.
     */
    NvU32  sampleCount;

    /*!
     * Mask of valid power monitoring channel entries in the \ref channels[]
     * array.  Every bit set represents a valid entry in the array.
     */
    NvU32  channelMask;
    /*!
     * Mask of valid power monitoring channel relationship entries in the \ref
     * chRels[] array.  Every bit set represents a valid entry in the array.
     */
    NvU32  chRelMask;
    /*!
     * Set of POWER_CHANNELs, that, when added up, yield total GPU power.  Must be a
     * subset of \ref channelMask above.
     *
     * \note This is as legacy implementation for
     * PWR1.0/Power Capping Table, in which all rails are listed separately and
     * must be summed separately. For PWR2.0/Power Policy Table, this mask is
     * implemented but it is deprecated in favor of \ref totalGpuChannelIdx.
     */
    NvU32  totalGpuPowerChannelMask;
    /*!
     * POWER_CHANNEL index corresponding to TOTAL_GPU power.  This value is to
     * be referenced in PWR2.0/Power Policy Table for the single channel which
     * represents total GPU power.
     *
     * \note NV_GPU_POWER_MONITOR_CHANNEL_INDEX_INVALID denotes a single
     * POWER_CHANNEL for total GPU power is not supported.
     */
    NvU8   totalGpuChannelIdx;

    /*!
     * Reserving 11 bytes for future use w/o needing to add new structure
     * version.
     */
    NvU8   rsvd[11];

    /*!
     * Array of static information describing POWER_CHANNELs.  Has valid indexes
     * corresponding to the set bits in \ref channelMask.
     */
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_INFO_V2 channels[NV_GPU_POWER_MONITOR_MAX_CHANNELS_V2];

    /*!
     * Array of static information describing POWER_CHANNEL_RELATIONSHIPs.  Has
     * valid indexes corresponding to the set bits in \ref chRelMask.
     */
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_INFO_V3 chRels[NV_GPU_POWER_MONITOR_MAX_CHANNEL_RELATIONSHIPS_V2];
} NV_GPU_POWER_MONITOR_GET_INFO_V3;
#define NV_GPU_POWER_MONITOR_GET_INFO_VER_1   MAKE_NVAPI_VERSION(NV_GPU_POWER_MONITOR_GET_INFO_V1,1)
#define NV_GPU_POWER_MONITOR_GET_INFO_VER_2   MAKE_NVAPI_VERSION(NV_GPU_POWER_MONITOR_GET_INFO_V2,1)
#define NV_GPU_POWER_MONITOR_GET_INFO_VER_3   MAKE_NVAPI_VERSION(NV_GPU_POWER_MONITOR_GET_INFO_V3,3)
#define NV_GPU_POWER_MONITOR_GET_INFO_VER     NV_GPU_POWER_MONITOR_GET_INFO_VER_3

#define NV_GPU_POWER_MONITOR_GET_INFO         NV_GPU_POWER_MONITOR_GET_INFO_V3

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_PowerMonitorGetInfo
//
//! DESCRIPTION: Gets information about the Power Monitoring Support on the
//!              board.
//!
//!              Power Monitoring is a feature by which the PMU regularly samples
//!              a set of power channels, which are each a collection of one or
//!              more power devices.  Monitoring collects one or more samples on
//!              each channel per each iteration and then provides various
//!              statistical information about the iteration.  This statistical
//!              information is available to the user and also maybe used as input
//!              for other features (such as power capping).
//!
//! \param [in]  hPhysicalGPU GPU selection.
//! \param [out] pPwrMonInfo  Structure describing the power monitoring
//!                support on the baord.
//!
//! TCC_SUPPORTED
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! RETURN STATUS:
//!    NVAPI_OK - completed request
//!    NVAPI_ERROR - miscellaneous error occurred
//!    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//!    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//!    NVAPI_NOT_SUPPORTED - P-States is not supported on this setup
//!    NVAPI_INVALID_ARGUMENT - Invalid input parameter
//! \endcode
//! \ingroup gpupower
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_PowerMonitorGetInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_POWER_MONITOR_GET_INFO *pPwrMonInfo);


//! \addtogroup gpupower
//! @{

/*!
 * Used in \ref NV_GPU_POWER_MONITOR_GET_STATUS_V1.  Structure representing the
 * most recent dynamic state of a POWER_CHANNEL.
 */
typedef struct
{
    /*!
     * Average power (in mW) for the last iteration of samples on this
     * POWER_CHANNEL.
     */
    NvU32 pwrAvgmW;
    /*!
     * Minimum power (in mW) for the last iteration of samples on this
     * POWER_CHANNEL.
     */
    NvU32 pwrMinmW;
    /*!
     * Maximum power (in mW) for the last iteration of samples on this
     * POWER_CHANNEL.
     */
    NvU32 pwrMaxmW;
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_STATUS_V1;

/*!
 * Used in \ref NvAPI_GPU_PowerMonitorGetStatus().  Structure representing a
 * requested set of POWER_CHANNELs for which the client wants to retrieve the
 * latest/current set of dynamic state.
 *
 * \note This structure has been deprecated in favor of
 * \ref NV_GPU_POWER_MONITOR_GET_STATUS_V2.
 */
typedef struct
{
    /*!
     * Version of structure.  Must always be first.
     */
    NvU32  version;

    /*!
     * Specifies the subset of power monitoring channels to query.  This must be
     * a subset of the mask returned by \ref NvAPI_GPU_PowerMonitorGetInfo().
     */
    NvU32  channelMask;

    /*!
     * Array of dynamic state corresponding to the specified set of
     * POWER_CHANNELs.  Has valid indexes corresponding to the set bits in \ref
     * channelMask.
     */
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_STATUS_V1
        channels[NV_GPU_POWER_MONITOR_MAX_CHANNELS_V1];
} NV_GPU_POWER_MONITOR_GET_STATUS_V1;

/*!
 * Used in \ref NV_GPU_POWER_MONITOR_GET_STATUS_V1.  Structure representing the
 * most recent dynamic state of a POWER_CHANNEL.
 */
typedef struct
{
    /*!
     * Average power (in mW) for the last iteration of samples on this
     * POWER_CHANNEL.
     */
    NvU32 pwrAvgmW;
    /*!
     * Minimum power (in mW) for the last iteration of samples on this
     * POWER_CHANNEL.
     */
    NvU32 pwrMinmW;
    /*!
     * Maximum power (in mW) for the last iteration of samples on this
     * POWER_CHANNEL.
     */
    NvU32 pwrMaxmW;
    /*!
     * Measured current (in mA) for the last iteration of samples on this
     * POWER_CHANNEL.
     */
    NvU32 currmA;
    /*!
     * Measured voltage (in uV) for the last iteration of samples on this
     * POWER_CHANNEL.
     */
    NvU32 voltuV;

    /*!
     * Reserving 24 bytes for future use w/o needing to add new structure
     * version.
     */
    NvU8  rsvd[24];
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_STATUS_V2;

/*!
 * Used in \ref NvAPI_GPU_PowerMonitorGetStatus().  Structure representing a
 * requested set of POWER_CHANNELs for which the client wants to retrieve the
 * latest/current set of dynamic state.
 */
typedef struct
{
    /*!
     * Version of structure.  Must always be first.
     */
    NvU32  version;

    /*!
     * Specifies the subset of power monitoring channels to query.  This must be
     * a subset of the mask returned by \ref NvAPI_GPU_PowerMonitorGetInfo().
     */
    NvU32  channelMask;

    /*!
     * Total GPU power corresponding ot the last iteration of sampling.  This is
     * the summation of the values corresponding to the POWER_CHANNELs indexes
     * provided in \ref
     * NV_GPU_POWER_MONITOR_GET_INFO_V2::totalGpuPowerChannelMask.
     */
    NvU32  totalGpuPowermW;

    /*!
     * Reserving 16 bytes of space so can add new types without needing to
     * add a new version.
     */
    NvU8 rsvd[16];

    /*!
     * Array of dynamic state corresponding to the specified set of
     * POWER_CHANNELs.  Has valid indexes corresponding to the set bits in \ref
     * channelMask.
     */
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_STATUS_V2
        channels[NV_GPU_POWER_MONITOR_MAX_CHANNELS_V1];
} NV_GPU_POWER_MONITOR_GET_STATUS_V2;

#define NV_GPU_POWER_MONITOR_GET_STATUS_VER_1   MAKE_NVAPI_VERSION(NV_GPU_POWER_MONITOR_GET_STATUS_V1,1)
#define NV_GPU_POWER_MONITOR_GET_STATUS_VER_2   MAKE_NVAPI_VERSION(NV_GPU_POWER_MONITOR_GET_STATUS_V2,1)
#define NV_GPU_POWER_MONITOR_GET_STATUS_VER     NV_GPU_POWER_MONITOR_GET_STATUS_VER_2

#define NV_GPU_POWER_MONITOR_GET_STATUS         NV_GPU_POWER_MONITOR_GET_STATUS_V2

//! @}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_PowerMonitorGetStatus
//
//! \code
//! DESCRIPTION: Queries the latest statistics from a subset of Power Monitoring
//!              channels supported on the board.
//!
//! PARAMETERS:  hPhysicalGPU(IN) - GPU selection.
//!              pPwrMonStatus(IN/OUT) - Structure for querying a subset of power //!
//!                  monitoring channels supported on the board.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! RETURN STATUS:
//!    NVAPI_OK - completed request
//!    NVAPI_ERROR - miscellaneous error occurred
//!    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//!    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//!    NVAPI_NOT_SUPPORTED - P-States is not supported on this setup
//!    NVAPI_INVALID_ARGUMENT - Invalid input parameter
//! \endcode
//! \ingroup gpupower
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_PowerMonitorGetStatus(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_POWER_MONITOR_GET_STATUS *pPwrMonStatus);


//! \addtogroup gpupower
//! @{
#define NV_GPU_POWER_CAPPING_ALG_DISABLED                         0x00000000
#define NV_GPU_POWER_CAPPING_ALG_TEMPERATURE_SLOWDOWN             0x00000001
#define NV_GPU_POWER_CAPPING_ALG_PSTATE_CAP                       0x00000002

typedef struct
{
    NvU32  version;

    NvU8   alg;
    NvU32  channelMask;
} NV_GPU_POWER_CAPPING_GET_INFO_V1;

#define NV_GPU_POWER_CAPPING_GET_INFO_VER_1   MAKE_NVAPI_VERSION(NV_GPU_POWER_CAPPING_GET_INFO_V1,1)
#define NV_GPU_POWER_CAPPING_GET_INFO_VER     NV_GPU_POWER_CAPPING_GET_INFO_VER_1

#define NV_GPU_POWER_CAPPING_GET_INFO         NV_GPU_POWER_CAPPING_GET_INFO_V1

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_PowerCappingGetInfo
//
//! \code
//! DESCRIPTION: Gets information about the Power Capping support on the
//!              board.
//!
//!              Power Capping is a feature which monitors a subset of power
//!              monitoring channels and takes some corrective action when the
//!              channels exceed their limits, attempting to bring power back
//!              within the limits.
//!
//! PARAMETERS:  hPhysicalGPU(IN) - GPU selection.
//!              pPwrCapInfo(OUT) - Structure describing Power Capping support in
//!                the board.
//!              - alg specifies the Power Capping algorithm supported on the
//!                  board.  Must be an NV_GPU_POWER_CAPPING_ALG_<xyz>
//!                  enumeration.
//!              - channelMask is the subset of power monitoring channels which
//!                  the power capping algorithm is using as input.  This must be
//!                  a subset of the channelMask returned by
//!                  NvAPI_GPU_PowerMonitorGetInfo().
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! RETURN STATUS:
//!    NVAPI_OK - completed request
//!    NVAPI_ERROR - miscellaneous error occurred
//!    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//!    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//!    NVAPI_NOT_SUPPORTED - P-States is not supported on this setup
//!    NVAPI_INVALID_ARGUMENT - Invalid input parameter
//! \endcode
//! \ingroup gpupower
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_PowerCappingGetInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_POWER_CAPPING_GET_INFO *pPwrCapInfo);




//! \addtogroup gpupower
//! @{
#define NV_GPU_POWER_CAPPING_SLOWDOWN_MAX_CHANNELS_V1                          8

typedef struct
{
    NvU32  version;

    NvU8   bEnabled;
    NvU8   factorIndex;
    NvU8   factorCount;
    NvU32  capRatio;
    struct
    {
        NvU8 numerator;
        NvU8 denominator;
    } factors[NV_GPU_POWER_CAPPING_SLOWDOWN_MAX_CHANNELS_V1];
} NV_GPU_POWER_CAPPING_SLOWDOWN_GET_STATUS_V1;

#define NV_GPU_POWER_CAPPING_SLOWDOWN_GET_STATUS_VER_1  MAKE_NVAPI_VERSION(NV_GPU_POWER_CAPPING_SLOWDOWN_GET_STATUS_V1,1)
#define NV_GPU_POWER_CAPPING_SLOWDOWN_GET_STATUS_VER    NV_GPU_POWER_CAPPING_SLOWDOWN_GET_STATUS_VER_1

#define NV_GPU_POWER_CAPPING_SLOWDOWN_GET_STATUS        NV_GPU_POWER_CAPPING_SLOWDOWN_GET_STATUS_V1

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_PowerCappingSlowdownGetStatus
//
//! \code
//! DESCRIPTION: Queries the latest status for slowdown-based power capping.
//!
//! PARAMETERS:  hPhysicalGPU(IN) - GPU selection.
//!              pPwrCapSlowStatus(OUT) - Structure to query the latest status of
//!                slowdown-based power capping.
//!              - bEnabled specifies whether the power capping algorithm is
//!                  currently enabled.  The algorithm may be dynamically
//!                  disabled/enabled for various reasons (power virus app
//!                  detection, etc.).
//!              - factorIndex is the index into the factors array corresponding
//!                  to the currently active slowdown.
//!              - factorCount is the number of slowdown factors being used by
//!                  the slowdown algorithm.
//!              - capRatio is the ratio of their power limits under which all
//!                  power monitoring channels must be in order for the algorithm
//!                  to decrement the slowdown factor index.
//!              - factors is has valid indexes between 0 and factorCount - 1.
//!                - factors[i].numerator is the numerator of the slowdown factor
//!                    specified as numerator / denominator.
//!                - factors[i].denominator is the numerator of the slowdown 
//!                    factor specified as numerator / denominator.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! RETURN STATUS:
//!    NVAPI_OK - completed request
//!    NVAPI_ERROR - miscellaneous error occurred
//!    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//!    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//!    NVAPI_NOT_SUPPORTED - P-States is not supported on this setup
//!    NVAPI_INVALID_ARGUMENT - Invalid input parameter
//! \endcode
//! \ingroup gpupower
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_PowerCappingSlowdownGetStatus(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_POWER_CAPPING_SLOWDOWN_GET_STATUS *pPwrCapSlowStatus);


//! \ingroup gpupower
//! @{

#define NV_GPU_POWER_EQUATION_MAX_EQUATIONS_V1                               32

/*!
 * Special value corresponding to an invalid Power Equation index.  This value
 * means that equation is not specified.
 */
#define NV_GPU_POWER_EQUATION_INDEX_INVALID                                0xFF

/*!
 * Enumeration of POWER_EQUATION equation types.  Different types implement the
 * POWER_EQUATION functionality via different mechanisms.  Also, specifies how to
 * interpret the equation entry/equation type data union.
 */
typedef enum _NV_GPU_POWER_EQUATION_TYPE
{
    NV_GPU_POWER_EQUATION_TYPE_LEAKAGE_DTCS11  = 0x00000000,
    NV_GPU_POWER_EQUATION_TYPE_BA1X_SCALE      = 0x00000001,
    NV_GPU_POWER_EQUATION_TYPE_BA00_FIT        = 0x00000002,

    NV_GPU_POWER_EQUATION_TYPE_LEAKAGE         = 0xFFFFFFFE,
    /*!
     * Unknown/unsupported type via NVAPI.  Should always be last.
     */
    NV_GPU_POWER_EQUATION_TYPE_UNKNOWN         = 0xFFFFFFFF,
} NV_GPU_POWER_EQUATION_TYPE;

/*!
 * Used in \ref NV_GPU_POWER_EQUATION_INFO_V1.  Structure repesenting data
 * specific to \ref NV_GPU_POWER_EQUATION_TYPE_LEAKAGE. Data common to 
 * all leakage equations.
 */
typedef struct _NV_GPU_POWER_EQUATION_LEAKAGE_INFO
{
    /*!
     * Floor-sweeping efficiency percentage.  Unsigned FXP4.12 value.  Unitless.
     */
    NvU16 fsEff;
    /*!
     * Power-gating efficiency percentage.  Unsigned FXP4.12 value.  Unitless.
     */
    NvU16 pgEff;
} NV_GPU_POWER_EQUATION_LEAKAGE_INFO;

/*!
 * Used in \ref NV_GPU_POWER_EQUATION_INFO_V1.  Structure repesenting data
 * specifici to \ref NV_GPU_POWER_EQUATION_TYPE_LEAKAGE_DTCS11. This 
 * POWER_EQUATION type calculates the equation power based on a set of 4 
 * coefficients, IDDQ, voltage, and temperature.
 */
typedef struct _NV_GPU_POWER_EQUATION_LEAKAGE_DTCS11_INFO
{
    /*!
     * Data common to all leakage power equations
     */
    NV_GPU_POWER_EQUATION_LEAKAGE_INFO  leakage;
    /*!
     * Coefficient 0.
     */
    NvU32 k0;
    /*!
     * Coefficient 1.
     */
    NvU32 k1;
    /*!
     * Coefficient 2.
     */
    NvU32 k2;
    /*!
     * Coefficient 3.
     */
    NvS32 k3;
} NV_GPU_POWER_EQUATION_LEAKAGE_DTCS11_INFO;

/*!
 * Used in \ref NV_GPU_POWER_EQUATION_INFO_V1.
 *
 * Structure repesenting data specific to \ref
 * NV_GPU_POWER_EQUATION_TYPE_BA00_FIT.  This POWER_EQUATION type is used by
 * NV_GPU_POWER_DEVICE_EQUATION_TYPE_BA00 to calculate the dynamic power based
 * on observed BA, frequency, and voltage.
 */
typedef struct _NV_GPU_POWER_EQUATION_BA00_FIT_INFO
{
    /*!
     * Slope of GPC2CLk frequency (MHz) vs. expected BA (raw BA units) curve.
     */
    NvU32 expBASlope;
    /*!
     * Intercept of GPC2CLk frequency (MHz) vs. expected BA (raw BA units)
     * curve.
     */
    NvU32 expBAIntercept;
    /*!
     * Slope of BA (raw BA untis) vs. expected dynamic power normalized by
     * voltage squared (A / V) curve.
     */
    NvU32 expDynPwrSlope;
    /*!
     * Intercept of BA (raw BA untis) vs. expected dynamic power normalized by
     * voltage squared (A / V) curve.
     */
    NvU32 expDynPwrIntercept;
} NV_GPU_POWER_EQUATION_BA00_FIT_INFO;

/*!
 * Used in \ref NV_GPU_POWER_EQUATION_INFO_V1.
 *
 * Structure repesenting data specific to \ref
 * NV_GPU_POWER_EQUATION_BA1X_SCALE_INFO. This POWER_EQUATION type is used by
 * NV_GPU_POWER_EQUATION_TYPE_BA1X_SCALE to calculate scaling factors
 * for BA1X devices.
 */
typedef struct _NV_GPU_POWER_EQUATION_BA1X_SCALE_INFO
{
    /*!
     * Reference voltage (uV)
     */
    NvU32   refVoltageuV;
    /*!
     * BA2mW scale factor [unitless unsigned FXP 20.12 value].
     */
    NvU32   ba2mW;
    /*!
     * Reference GPCCLK (MHz)
     */
    NvU32   gpcClkMHz;
    /*!
     * Reference UTILSCLK (MHz)
     */
    NvU32   utilsClkMHz;
} NV_GPU_POWER_EQUATION_BA1X_SCALE_INFO;

/*!
 * Used in \ref NV_GPU_POWER_EQUATION_INFO_PARAMS_V1.  Structure repesenting
 * data specific to \ref NV_GPU_POWER_EQUATION_INFO_V1.  This specifies static
 * information of PWR_EQUATION, which specifies Equations.
 */
typedef struct _NV_GPU_POWER_EQUATION_INFO_V1
{
    /*!
     * NV_GPU_POWER_EQUATION_TYPE_<xyz>.
     */
    NV_GPU_POWER_EQUATION_TYPE type;

    /*!
     * Reserving 16 bytes for future use w/o needing to add new structure
     * version.
     */
    NvU8  rsvd[16];

    /*!
     * Union of type-specific data.  Interpreted based on \ref type value.
     */
    union
    {
        NV_GPU_POWER_EQUATION_LEAKAGE_INFO        leakage;
        NV_GPU_POWER_EQUATION_LEAKAGE_DTCS11_INFO dtcs11;
        NV_GPU_POWER_EQUATION_BA00_FIT_INFO       ba00Fit;
        NV_GPU_POWER_EQUATION_BA1X_SCALE_INFO     ba1xScale;
        /*!
         * Reserving 32 bytes of space so can add new types without needing to
         * add a new version.
         */
        NvU8 rsvd[32];
    } data;
} NV_GPU_POWER_EQUATION_INFO_V1;

/*!
 * Used in \ref NvAPI_GPU_PowerEquationGetInfo().  Structure representing the
 * static information/capabilities of a GPU's POWER_EQUATION functionality, sets
 * of equations for calculating/estimating equation power on a power rail.
 */
typedef struct _NV_GPU_POWER_EQUATION_INFO_PARAMS_V1
{
    /*!
     * Version of structure.  Must always be first.
     */
    NvU32  version;

    /*!
     * Data describing IDDQ used for equation evaluation
     */
    struct
    {
        /*!
         * HW IDDQ fuse version.
         */
        NvU32 versionHw;
        /*!
         * SW IDDQ version.
         */
        NvU32 version;
        /*!
         * IDDQ value (mA).
         */
        NvU32 valuemA;
    } iddq;

    /*!
     * Mask of valid power equation equation entries in the \ref equations[]
     * array.  Every bit set represents a valid entry in the array.
     */
    NvU32 equationMask;

    /*!
     * Reserving 16 bytes for future use w/o needing to add new structure
     * version.
     */
    NvU8  rsvd[16];

    /*!
     * Array of static information describing POWER_EQUATIONs.  Has valid indexes
     * corresponding to the set bits in \ref equationMask.
     */
    NV_GPU_POWER_EQUATION_INFO_V1 equations[NV_GPU_POWER_EQUATION_MAX_EQUATIONS_V1];
} NV_GPU_POWER_EQUATION_INFO_PARAMS_V1;

#define NV_GPU_POWER_EQUATION_INFO_PARAMS_VER_1   MAKE_NVAPI_VERSION(NV_GPU_POWER_EQUATION_INFO_PARAMS_V1,1)
#define NV_GPU_POWER_EQUATION_INFO_PARAMS_VER     NV_GPU_POWER_EQUATION_INFO_PARAMS_VER_1

typedef NV_GPU_POWER_EQUATION_INFO_PARAMS_V1      NV_GPU_POWER_EQUATION_INFO_PARAMS;

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    NvAPI_GPU_PowerEquationGetInfo()
//
//! DESCRIPTION: Retrieves information about the POWER_EQUATION support on the
//!              GPU.
//!
//!              POWER_EQUATION entries are equations which specifies set of
//!              independent variables and coefficients that can be used to
//!              calculate various power related expressions.  This function
//!              retrieves static information about the set of POWER_EQUATIONs
//!              supported by this GPU for use by other features like 
//!              POWER_POLICYs and POWER_DEVICEs.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version: 310.67
//!
//! \param [in]  hPhysicalGPU   GPU selection
//! \param [out] pEquationInfo  Structure containing the description of the
//!                   POWER_EQUATION support on the GPU.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gpupower
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_PowerEquationGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_POWER_EQUATION_INFO_PARAMS *pEquationInfo);


//! \ingroup gpupower
//! @{

#define NV_GPU_POWER_LEAKAGE_MAX_LEAKAGES_V1                                   4
#define NV_GPU_POWER_LEAKAGE_MAX_LEAKAGES_V2                                  32

/*!
 * Special value corresponding to an invalid Power Equation index.  This value
 * means that equation is not specified.
 */
#define NV_GPU_POWER_EQUATION_INDEX_INVALID                                 0xFF

/*!
 * Enumeration of POWER_LEAKAGE equation types.  Different types implement the
 * POWER_LEAKAGE functionality via different mechanisms.  Also, specifies how to
 * interpret the leakage entry/equation type data union.
 */
typedef enum
{
    NV_GPU_POWER_LEAKAGE_TYPE_DTCS10    = 0x00000000,
    NV_GPU_POWER_LEAKAGE_TYPE_DTCS11    = 0x00000001,
    NV_GPU_POWER_LEAKAGE_TYPE_BA00_FIT  = 0x00000002,
    /*!
     * Unknown/unsupported type via NVAPI.  Should always be last.
     */
    NV_GPU_POWER_LEAKAGE_TYPE_UNKNOWN = 0xFFFFFFFF,
} NV_GPU_POWER_LEAKAGE_TYPE;

/*!
 * Used in \ref NV_GPU_POWER_LEAKAGE_INFO_V1.  Structure repesenting data
 * specifici to \ref NV_GPU_POWER_LEAKAGE_TYPE_DTCS10.  This POWER_LEAKAGE type
 * calculates the leakage power based on a set of 4 coefficients, IDDQ, voltage,
 * and temperature.
 */
typedef struct
{
    /*!
     * Coefficient 0.
     */
    float k0;
    /*!
     * Coefficient 1.
     */
    float k1;
    /*!
     * Coefficient 2.
     */
    float k2;
    /*!
     * Coefficient 3.
     */
    NvS32 k3;
} NV_GPU_POWER_LEAKAGE_DTCS10_INFO;

/*!
 * Used in \ref NV_GPU_POWER_LEAKAGE_INFO_V1.  Structure repesenting data
 * specifici to \ref NV_GPU_POWER_LEAKAGE_TYPE_DTCS10.  This POWER_LEAKAGE type
 * calculates the leakage power based on a set of 4 coefficients, IDDQ, voltage,
 * and temperature.
 */
typedef struct
{
    /*!
     * Coefficient 0.
     */
    NvU32 k0;
    /*!
     * Coefficient 1.
     */
    NvU32 k1;
    /*!
     * Coefficient 2.
     */
    NvU32 k2;
    /*!
     * Coefficient 3.
     */
    NvS32 k3;
} NV_GPU_POWER_LEAKAGE_DTCS11_INFO;

/*!
 * Used in \ref NV_GPU_POWER_LEAKAGE_INFO_PARAMS_V1.  Structure repesenting data
 * specific to \ref NV_GPU_POWER_LEAKAGE_TYPE_DTCS10.  This POWER_LEAKAGE type
 * calculates the leakage power based on a set of 4 coefficients, IDDQ, voltage,
 * and temperature.
 */
typedef struct
{
    /*!
     * NV_GPU_POWER_LEAKAGE_TYPE_<xyz>.
     */
    NV_GPU_POWER_LEAKAGE_TYPE type;

    /*!
     * Floor-sweeping efficiency percentage.  Unsigned FXP4.12 value.  Unitless.
     */
    NvU16 fsEff;
    /*!
     * Power-gating efficiency percentage.  Unsigned FXP4.12 value.  Unitless.
     */
    NvU16 pgEff;

    /*!
     * Reserving 16 bytes for future use w/o needing to add new structure
     * version.
     */
    NvU8  rsvd[16];

    /*!
     * Union of type-specific data.  Interpreted based on \ref type value.
     */
    union
    {
        NV_GPU_POWER_LEAKAGE_DTCS10_INFO    dtcs10;
        NV_GPU_POWER_LEAKAGE_DTCS11_INFO    dtcs11;
        NV_GPU_POWER_EQUATION_BA00_FIT_INFO ba00Fit;
        /*!
         * Reserving 32 bytes of space so can add new types without needing to
         * add a new version.
         */
        NvU8 rsvd[32];
    } data;
} NV_GPU_POWER_LEAKAGE_INFO_V1;

/*!
 * Used in \ref NvAPI_GPU_PowerLeakageGetInfo().  Structure representing the
 * static information/capabilities of a GPU's POWER_LEAKAGE functionality, sets
 * of equations for calculating/estimating leakage power on a power rail.
 */
typedef struct
{
    /*!
     * Version of structure.  Must always be first.
     */
    NvU32  version;

    /*!
     * HW IDDQ fuse version.
     */
    NvU32 hwIddqVersion;
    /*!
     * SW IDDQ version.
     */
    NvU32 iddqVersion;
    /*!
     * IDDQ value (mA).
     */
    NvU32 iddqmA;

    /*!
     * Mask of valid power leakage equation entries in the \ref leakages[]
     * array.  Every bit set represents a valid entry in the array.
     */
    NvU32 leakageMask;

    /*!
     * Reserving 16 bytes for future use w/o needing to add new structure
     * version.
     */
    NvU8  rsvd[16];

    /*!
     * Array of static information describing POWER_LEAKAGEs.  Has valid indexes
     * corresponding to the set bits in \ref leakageMask.
     */
    NV_GPU_POWER_LEAKAGE_INFO_V1 leakages[NV_GPU_POWER_LEAKAGE_MAX_LEAKAGES_V1];
} NV_GPU_POWER_LEAKAGE_INFO_PARAMS_V1;

/*!
 * Used in \ref NvAPI_GPU_PowerLeakageGetInfo().  Structure representing the
 * static information/capabilities of a GPU's POWER_LEAKAGE functionality, sets
 * of equations for calculating/estimating leakage power on a power rail.
 */
typedef struct
{
    /*!
     * Version of structure.  Must always be first.
     */
    NvU32  version;

    /*!
     * HW IDDQ fuse version.
     */
    NvU32 hwIddqVersion;
    /*!
     * SW IDDQ version.
     */
    NvU32 iddqVersion;
    /*!
     * IDDQ value (mA).
     */
    NvU32 iddqmA;

    /*!
     * Mask of valid power leakage equation entries in the \ref leakages[]
     * array.  Every bit set represents a valid entry in the array.
     */
    NvU32 leakageMask;

    /*!
     * Reserving 16 bytes for future use w/o needing to add new structure
     * version.
     */
    NvU8  rsvd[16];

    /*!
     * Array of static information describing POWER_LEAKAGEs.  Has valid indexes
     * corresponding to the set bits in \ref leakageMask.
     */
    NV_GPU_POWER_LEAKAGE_INFO_V1 leakages[NV_GPU_POWER_LEAKAGE_MAX_LEAKAGES_V2];
} NV_GPU_POWER_LEAKAGE_INFO_PARAMS_V2;

#define NV_GPU_POWER_LEAKAGE_INFO_PARAMS_VER_1   MAKE_NVAPI_VERSION(NV_GPU_POWER_LEAKAGE_INFO_PARAMS_V1,1)
#define NV_GPU_POWER_LEAKAGE_INFO_PARAMS_VER_2   MAKE_NVAPI_VERSION(NV_GPU_POWER_LEAKAGE_INFO_PARAMS_V2,1)
#define NV_GPU_POWER_LEAKAGE_INFO_PARAMS_VER     NV_GPU_POWER_LEAKAGE_INFO_PARAMS_VER_2

#define NV_GPU_POWER_LEAKAGE_INFO_PARAMS         NV_GPU_POWER_LEAKAGE_INFO_PARAMS_V2

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    NvAPI_GPU_PowerLeakageGetInfo()
//
//! DESCRIPTION: Retrieves information about the POWER_LEAKAGE support on the
//!              GPU.
//!
//!              POWER_LEAKAGE entries are equations which estimate leakage
//!              power on a given power rail.  This function retrieves static
//!              information about the set of POWER_LEAKAGE equations supported
//!              by this GPU for use by other features like POWER_POLICYs.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version: 295.40
//!
//! \param [in]  hPhysicalGPU  GPU selection
//! \param [out] pLeakageInfo  Structure containing the description of the
//!                   POWER_LEAKAGE support on the GPU.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gpupower
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_PowerLeakageGetInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_POWER_LEAKAGE_INFO_PARAMS *pLeakageInfo);

//! \ingroup gpupower
//! @{

/*!
 * The following structures are used in \ref NvAPI_GPU_PowerLeakageGetStatus(),
 * which is now deprecated!
 */

#define NV_GPU_POWER_LEAKAGE_MAX_VOLTAGE_ENTRIES_V1                           32
#define NV_GPU_POWER_LEAKAGE_MAX_VOLTAGE_ENTRIES_V2                           64

/*!
 * Used in \ref NV_GPU_POWER_LEAKAGE_STATUS_V1.  Structure representing the
 * estimated leakage power associated with a given voltage.  This is provided to
 * allow estimating the leakage power under the current conditions (temperature,
 * IDDQ) at a different voltage.
 */
typedef struct
{
    /*!
     * Voltage (uV) key for this entry.
     */
    NvU32 voltageuV;
    /*!
     * Latest leakage power value (mW) for this leakage equation.
     */
    NvU32 pwrLeakagemW;
} NV_GPU_POWER_LEAKAGE_STATUS_VOLTAGE_ENTRY;

/*!
 * Used in \ref NV_GPU_POWER_LEAKAGE_STATUS_PARAMS_V1.  Structure representing
 * the set of leakage power estimates (based on voltage) for the current
 * conditions (temperature, IDDQ, etc.).
 */
typedef struct
{
    /*!
     * Number of voltage entries supported for this POWER_LEAKAGE equation.
     */
    NvU8 numVoltEntries;

    /*!
     * Reserving 16 bytes for future use w/o needing to add new structure
     * version.
     */
    NvU8  rsvd[16];

    /*!
     * Array of voltage entries for this POWER_LEAKAGE equation.  Has valid
     * indexes in the range [0, \ref numVoltEntries).
     */
    NV_GPU_POWER_LEAKAGE_STATUS_VOLTAGE_ENTRY
        voltEntries[NV_GPU_POWER_LEAKAGE_MAX_VOLTAGE_ENTRIES_V1];
} NV_GPU_POWER_LEAKAGE_STATUS_V1;

/*!
 * Used in \ref NvAPI_GPU_PowerLeakageGetStatus.  Structure representing the
 * current state of a requested set of POWER_LEAKAGE equations.
 */
typedef struct
{
    /*!
     * Version of structure.  Must always be first.
     */
    NvU32  version;

    /*!
     * Latest temperature used to calculate leakage power.
     *
     * SIgned FXP 24.8 value.  Units of C.
     */
    NvS32 tj;

    /*!
     * Mask of POWER_LEAKAGE equation entries requested by the client.  Results
     * will be returned in the indexes within \ref leakages corresponding to
     * bits set in this mask.
     */
    NvU32 leakageMask;

    /*!
     * Reserving 16 bytes for future use w/o needing to add new structure
     * version.
     */
    NvU8  rsvd[16];

    /*!
     * Array of current state of requested set of POWER_LEAKAGEs.  Has valid
     * indexes corresponding to the set bits in \ref leakageMask.
     */
    NV_GPU_POWER_LEAKAGE_STATUS_V1 leakages[NV_GPU_POWER_LEAKAGE_MAX_LEAKAGES_V1];
} NV_GPU_POWER_LEAKAGE_STATUS_PARAMS_V1;

/*!
 * Used in \ref NV_GPU_POWER_LEAKAGE_STATUS_PARAMS_V2.  Structure representing
 * the set of leakage power estimates (based on voltage) for the current
 * conditions (temperature, IDDQ, etc.).
 */
typedef struct
{
    /*!
     * Number of voltage entries supported for this POWER_LEAKAGE equation.
     */
    NvU8 numVoltEntries;

    /*!
     * Reserving 16 bytes for future use w/o needing to add new structure
     * version.
     */
    NvU8  rsvd[16];

    /*!
     * Array of voltage entries for this POWER_LEAKAGE equation.  Has valid
     * indexes in the range [0, \ref numVoltEntries).
     */
    NV_GPU_POWER_LEAKAGE_STATUS_VOLTAGE_ENTRY
        voltEntries[NV_GPU_POWER_LEAKAGE_MAX_VOLTAGE_ENTRIES_V2];
} NV_GPU_POWER_LEAKAGE_STATUS_V2;

/*!
 * Used in \ref NvAPI_GPU_PowerLeakageGetStatus.  Structure representing the
 * current state of a requested set of POWER_LEAKAGE equations.
 */
typedef struct
{
    /*!
     * Version of structure.  Must always be first.
     */
    NvU32  version;

    /*!
     * Latest temperature used to calculate leakage power.
     *
     * SIgned FXP 24.8 value.  Units of C.
     */
    NvS32 tj;

    /*!
     * Mask of POWER_LEAKAGE equation entries requested by the client.  Results
     * will be returned in the indexes within \ref leakages corresponding to
     * bits set in this mask.
     */
    NvU32 leakageMask;

    /*!
     * Reserving 16 bytes for future use w/o needing to add new structure
     * version.
     */
    NvU8  rsvd[16];

    /*!
     * Array of current state of requested set of POWER_LEAKAGEs.  Has valid
     * indexes corresponding to the set bits in \ref leakageMask.
     */
    NV_GPU_POWER_LEAKAGE_STATUS_V2 leakages[NV_GPU_POWER_LEAKAGE_MAX_LEAKAGES_V1];
} NV_GPU_POWER_LEAKAGE_STATUS_PARAMS_V2;


#define NV_GPU_POWER_LEAKAGE_STATUS_PARAMS_VER_1   MAKE_NVAPI_VERSION(NV_GPU_POWER_LEAKAGE_STATUS_PARAMS_V1,1)
#define NV_GPU_POWER_LEAKAGE_STATUS_PARAMS_VER_2   MAKE_NVAPI_VERSION(NV_GPU_POWER_LEAKAGE_STATUS_PARAMS_V2,1)
#define NV_GPU_POWER_LEAKAGE_STATUS_PARAMS_VER     NV_GPU_POWER_LEAKAGE_STATUS_PARAMS_VER_2

#define NV_GPU_POWER_LEAKAGE_STATUS_PARAMS         NV_GPU_POWER_LEAKAGE_STATUS_PARAMS_V2

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    NvAPI_GPU_PowerLeakageGetStatus()
//
//! DESCRIPTION: Retrieves the current state for a requested set of
//!              POWER_LEAKAGE equations on the GPU.
//!
//!              This call is now DEPRECATED.  It will only return NVAPI_OK with
//!              no functionality.
//!
//! \deprecated  Do not use this function - it is deprecated in release 295. Instead, use NvAPI_GPU_PowerLeakageGetStatus.
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version: 295.40
//!
//! \param [in]     hPhysicalGPU    GPU selection
//! \param [in/out] pLeakageStatus  Structure containing the description of the
//!                   POWER_LEAKAGE state of the GPU.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gpupower
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 295. Instead, use NvAPI_GPU_PowerLeakageGetStatus.")
NVAPI_INTERFACE NvAPI_GPU_PowerLeakageGetStatus(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_POWER_LEAKAGE_STATUS_PARAMS *pLeakageStatus);


//! \ingroup gpupower
//! @{

#define NV_GPU_POWER_POLICY_MAX_POLICIES_V1                                   16
#define NV_GPU_POWER_POLICY_MAX_POLICY_RELATIONSHIPS_V1                       16

/*!
 * Enumeration of POWER_POLICY types.  Different types implement the
 * POWER_POLICY functionalty via different mechanisms.  Also, specifies how to
 * interpret the policy type data union.
 */
typedef enum
{
    NV_GPU_POWER_POLICY_TYPE_TOTAL_GPU = 0x00000000,
    NV_GPU_POWER_POLICY_TYPE_WORKLOAD,
    NV_GPU_POWER_POLICY_TYPE_BANG_BANG_VF,
    NV_GPU_POWER_POLICY_TYPE_PROP_LIMIT,
    NV_GPU_POWER_POLICY_TYPE_HW_THRESHOLD,
    NV_GPU_POWER_POLICY_TYPE_MARCH_N,
    /*!
     * This class is deprecated, but kept for backwards compatibility.
     */
    NV_GPU_POWER_POLICY_TYPE_MARCH_N_BA00,
    NV_GPU_POWER_POLICY_TYPE_MARCH_VF,
    /*!
     * This class is deprecated, but kept for backwards compatibility.
     */
    NV_GPU_POWER_POLICY_TYPE_MARCH_VF_BA00,
    NV_GPU_POWER_POLICY_TYPE_VIOLATION_CONTROL,
    NV_GPU_POWER_POLICY_TYPE_BALANCE,
    NV_GPU_POWER_POLICY_TYPE_GEMINI,
    /*!
     * The following are virtual Power Policy classes/types.  They are interface
     * types which other Power Policy classes will implement.
     */
    NV_GPU_POWER_POLICY_TYPE_MARCH_BA00 = 0xFFFFFFFA,
    /*!
     * This class is deprecated, but kept for backwards compatibility.
     */
    NV_GPU_POWER_POLICY_TYPE_MARCH      = 0xFFFFFFFB,
    NV_GPU_POWER_POLICY_TYPE_NDIV       = 0xFFFFFFFC,
    NV_GPU_POWER_POLICY_TYPE_DOMGRP     = 0xFFFFFFFD,
    NV_GPU_POWER_POLICY_TYPE_LIMIT      = 0xFFFFFFFE,
    /*!
     * Unknown/unsupported type via NVAPI.  Should always be last.
     */
    NV_GPU_POWER_POLICY_TYPE_UNKNOWN = 0xFFFFFFFF,
} NV_GPU_POWER_POLICY_TYPE;

/*!
 * Enumeration of units which a POWER_POLICY uses.  This specifies the units to
 * apply to both the \ref value and \ref limit fields.
 */
typedef enum
{
    NV_GPU_POWER_POLICY_LIMIT_UNIT_POWER_MW = 0x00000000,
    NV_GPU_POWER_POLICY_LIMIT_UNIT_CURRENT_MA,
} NV_GPU_POWER_POLICY_LIMIT_UNIT;

/*!
 * Enumeration of POWER_POLICY_RELATIONSHIP types.  Different
 * POWER_POLICY_RELATIONSHIP types use different functionality to implement the
 * interface by which to set limits and retrieve values.  This enumeration also
 * specifies how to interpret the the channel relationship type data union.
 */
typedef enum
{
    NV_GPU_POWER_POLICY_RELATIONSHIP_TYPE_WEIGHT  = 0x00000000,
    NV_GPU_POWER_POLICY_RELATIONSHIP_TYPE_BALANCE,
    NV_GPU_POWER_POLICY_RELATIONSHIP_TYPE_UNKNOWN = 0xFFFFFFFF,
} NV_GPU_POWER_POLICY_RELATIONSHIP_TYPE;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_BANG_BANG_VF_INFO, \ref
 * NV_GPU_POWER_POLICY_WORKLOAD_INFO, \ref NV_GPU_POWER_POLICY_INFO_V1.
 * Structure of static information specific to the DOMGRP POWER_POLICY.  This
 * POWER_POLICY is a virtual/super class, which is extended/implemented by other
 * POWER_POLICY clases (e.g. WORKLOAD and BANG_BANG_VF).
 */
typedef struct _NV_GPU_POWER_POLICY_DOMGRP_INFO
{
    /*!
     * A boolean flag to indicate that the output Domain Group limits computed
     * by this POWER_POLICY should be floored to the 3D Boost VPstate (commonly
     * referred to as "Base Clock" in the GPU Boost/SmartPower/PWR 2.0
     * documentation).
     */
    NvU8 b3DBoostVpstateFloor;
    
    /*!
     * Cap the system below the "Inflection vpstate index" when the current
     * limit is smaller than this "Inflection limit". This inflection limit can
     * help improve some pstate thrashing issue when the power limit is reduced
     * into the "battery" or certain lower pstate range.
     */
    NvU32 limitInflection;
} NV_GPU_POWER_POLICY_DOMGRP_INFO;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_MARCH_N_INFO, \ref
 * NV_GPU_POWER_POLICY_MARCH_N_BA00_INFO, \ref NV_GPU_POWER_POLICY_INFO_V1.
 *
 * Structure of static information specific to the NDIV POWER_POLICY.  This
 * POWER_POLICY is a virtual/super class, which is extended/implemented by other
 * POWER_POLICY clases (e.g. MARCH_N).
 */
typedef struct _NV_GPU_POWER_POLICY_NDIV_INFO
{
    /*!
     * Maximum NDIV value for this policy.
     */
    NvU8       ndivCoeffMax;
} NV_GPU_POWER_POLICY_NDIV_INFO;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_INFO_V1.  Structure of static information
 * specific to the BANG_BANG_VF POWER_POLICY.  This POWER_POLICY implements a
 * bang-bang step controller along the VF curve.
 */
typedef struct _NV_GPU_POWER_POLICY_BANG_BANG_VF_INFO
{
    /*!
     * Must always be first in structure!
     */
    NV_GPU_POWER_POLICY_DOMGRP_INFO domGrp;

    /*!
     * Ratio of the limit (\ref NV_GPU_POWER_POLICY_STATUS_V1::limitCurr) below
     * which the controlled value (NV_GPU_POWER_POLICY_STATUS_V1::valueCurr)
     * must fall in order for the Bang-Bang algorithm to initiate the uncap
     * action.
     *
     * Unitless Unsigned FXP 4.12.
     */
    NvU16 uncapLimitRatio;
} NV_GPU_POWER_POLICY_BANG_BANG_VF_INFO;

/*!
 * Enumerations/macros defining the different types of hysteresis values a
 * PWR_POLICY_MARCH may use.
 *
 * _RATIO - The hysteresis amount is a ratio of the limit value:
 *      uncapLimit = limitValue * ratio.
 *
 * _STATIC_VALUE - The hysteresis amount is a static value which is subtracted
 *      from the limit value:
 *      uncapLimit = limitValue - staticValue
 */
#define NV_GPU_POWER_POLICY_MARCH_HYSTERESIS_TYPE_RATIO             0x00
#define NV_GPU_POWER_POLICY_MARCH_HYSTERESIS_TYPE_STATIC_VALUE      0x01

/*!
 * Union of type-specific hysteresis values.
 */
typedef union _NV_GPU_POWER_POLICY_MARCH_HYSTERESIS_DATA
{
    /*!
     * Ratio value corresponding to
     * NV_GPU_POWER_POLICY_MARCH_HYSTERESIS_TYPE_RATIO.
     */
    NvU16 ratio;
    /*!
     * Static value corresponding to
     * NV_GPU_POWER_POLICY_MARCH_HYSTERESIS_TYPE_STATIC_VALUE.
     */
    NvU16 staticValue;
} NV_GPU_POWER_POLICY_MARCH_HYSTERESIS_DATA;

/*!
 * Structure representing the hysteresis value for a PWR_POLICY_MARCH object.
 */
typedef struct _NV_GPU_POWER_POLICY_MARCH_HYSTERESIS
{
    /*!
     * @ref NV_GPU_POWER_POLICY_MARCH_HYSTERESIS_TYPE_<XYZ>
     */
    NvU8 type;
    /*!
     * Union of type specific data.  Interpreted by @ref type.
     */
    NV_GPU_POWER_POLICY_MARCH_HYSTERESIS_DATA data;
} NV_GPU_POWER_POLICY_MARCH_HYSTERESIS;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_MARCH_BA00_INFO.
 *
 * The GK10X BA v0.0 sensor has a lot of error/noise and thus does not have a
 * very reliable/accurate mapping between BA units and power.
 *
 * The best we can do is train the data for the worst-case workload, so that we
 * can guarantee for all workloads <= worst-case power will be <= the power
 * limit.
 *
 * The training fit is planar equation taking the following indepednent
 * variables:
 *     BA - Block Activity values in raw BA units.
 *     CF - dynamic power normalized for voltage - i.e. P_{D} / V^2 = C * V^2 *
 *         F / V^2 = C * F.  In units of A / V.
 *     F - Target frequency (MHz) as calculated by the RM.
 *
 *     coeffBA * BA + coeffCF * CF + coeffF * F = intercept
 *
 *     The coefficients and intercept are all signed FXP20.12 values.
 */
typedef struct _NV_GPU_POWER_POLICY_MARCH_BA00_PLANE_FIT
{
    /*!
     * Coefficient for BA independent variable.  Signed FXP20.12.
     */
    NvS32 coeffBA;
    /*!
     * Coefficient for CF independent variable.  Signed FXP20.12.
     */
    NvS32 coeffCF;
    /*!
     * Coefficient for F independent variable.  Signed FXP20.12.
     */
    NvS32 coeffF;
    /*!
     * Intercept planar equation.  Signed FXP20.12.
     */
    NvS32 intercept;
} NV_GPU_POWER_POLICY_MARCH_BA00_PLANE_FIT;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_MARCH_INFO.
 *
 * Structure of static information specific to the MARCH BA00 POWER_POLICY
 * interface.  This interface provides marching functionality with correction
 * for GK10X BA v0.0 inaccuracy.
 */
typedef struct _NV_GPU_POWER_POLICY_MARCH_BA00_INFO
{
    /*!
     * Index of PWR_LEAKAGE equation which will be used to estimate the leakage
     * power and compute the dynamic power component:
     *
     *     dynamic = total - leakage
     */
    NvU8 leakageIdx;
    /*!
     * Equation defining the planar fit for BA and power.
     */
    NV_GPU_POWER_POLICY_MARCH_BA00_PLANE_FIT planeFit;
} NV_GPU_POWER_POLICY_MARCH_BA00_INFO;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_MARCH_N_INFO, \ref
 * NV_GPU_POWER_POLICY_MARCH_N_BA00_INFO, \ref
 * NV_GPU_POWER_POLICY_MARCH_VF_INFO, \ref
 * NV_GPU_POWER_POLICY_MARCH_VF_BA00_INFO.
 *
 * Structure of static
 * information specific to the MARCH POWER_POLICY interface.  This interface
 * provides marching functionality by which it issues actions to cap or uncap
 * corresponding to a policy's value and limit.
 */
typedef struct _NV_GPU_POWER_POLICY_MARCH_INFO
{
    /*!
     * \ref NV_GPU_POWER_POLICY_TYPE
     */
    NV_GPU_POWER_POLICY_TYPE type;
    /*!
     * Number of steps by which the implementing class should respond to various
     * actions.
     */
    NvU8 stepSize;
    /*!
     * Hysteresis amount for uncapping.
     */
    NV_GPU_POWER_POLICY_MARCH_HYSTERESIS hysteresis;

    /*!
     * Union of type-specific data.
     */
    union
    {
        NV_GPU_POWER_POLICY_MARCH_BA00_INFO ba00;
    } data;
} NV_GPU_POWER_POLICY_MARCH_INFO;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_INFO_V1.
 *
 * Structure of static information
 * specific to the MARCH_N POWER_POLICY.  This POWER_POLICY will adjust the NDIV
 * GPCCLK coefficient per the MARCH POWER_POLICY interface corresponding to the
 * policy's value and limit.
 */
typedef struct _NV_GPU_POWER_POLICY_MARCH_N_INFO
{
    /*!
     * @copydoc RM_PMU_PMGR_PWR_POLICY_NDIV
     *
     * Must always be first in structure!
     */
    NV_GPU_POWER_POLICY_NDIV_INFO  ndiv;
    /*!
     * @copydoc RM_PMU_PMGR_PWR_POLICY_MARCH
     *
     * The common PWR_POLICY_MARCH initialization data.  This data does not need
     * to be at any fixed location, it is handled elsewhere.
     */
    NV_GPU_POWER_POLICY_MARCH_INFO march;
} NV_GPU_POWER_POLICY_MARCH_N_INFO;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_INFO_V1.
 *
 * This structure is deprecated, but kept for backward-compatibility.
 */
typedef NV_GPU_POWER_POLICY_MARCH_N_INFO
    NV_GPU_POWER_POLICY_MARCH_N_BA00_INFO;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_INFO_V1.
 *
 * Structure of static information
 * specific to the _MARCH_VF POWER_POLICY.  This POWER_POLICY will adjust the NDIV
 * GPCCLK coefficient per the MARCH POWER_POLICY interface corresponding to the
 * policy's value and limit.
 */
typedef struct _NV_GPU_POWER_POLICY_MARCH_VF_INFO
{
    /*!
     * @copydoc RM_PMU_PMGR_PWR_POLICY_NDIV
     *
     * Must always be first in structure!
     */
    NV_GPU_POWER_POLICY_DOMGRP_INFO domGrp;
    /*!
     * @copydoc RM_PMU_PMGR_PWR_POLICY_MARCH
     *
     * The common PWR_POLICY_MARCH initialization data.  This data does not need
     * to be at any fixed location, it is handled elsewhere.
     */
    NV_GPU_POWER_POLICY_MARCH_INFO  march;
} NV_GPU_POWER_POLICY_MARCH_VF_INFO;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_INFO_V1.
 *
 * This structure is deprecated, but kept for backward-compatibility.
 */
typedef NV_GPU_POWER_POLICY_MARCH_VF_INFO
    NV_GPU_POWER_POLICY_MARCH_VF_BA00_INFO;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_INFO_V1.  Structure of static information
 * specific to the PROP_LIMIT POWER_POLICY.  This POWER_POLICY will update the
 * limits of all POWER_POLICYs corresponding to the specified
 * POWER_POLICY_RELATIONSHIPs by the proportion of this policy's value and
 * limit.
 */
typedef struct _NV_GPU_POWER_POLICY_PROP_LIMIT_INFO
{
    /*!
     * Index of first POWER_POLICY_RELATIONSHIP in the Power Policy Table.  This
     * PWR_POLICY_PROP_LIMIT will adjust the limits of all POWER_POLICYs
     * corresponding to the POWER_POLICY_RELATIONSHIPs in the range
     * [policyRelIdxFirst, \ref policyRelIdxLast].
     */
    NvU8 policyRelIdxFirst;
    /*!
     * Index of last POWER_POLICY_RELATIONSHIP in the Power Policy Table.  This
     * PWR_POLICY_PROP_LIMIT will adjust the limits of all POWER_POLICYs
     * corresponding to the POWER_POLICY_RELATIONSHIPs in the range
     * [\ref policyRelIdxFirst, policyRelIdxLast].
     */
    NvU8 policyRelIdxLast;
    /*!
     * Boolean flag indicating whether "dummy" operation is desired for this
     * PWR_POLICY_PROP_LIMIT object.  When "dummy" operation is engaged, the
     * PWR_POLICY_PROP_LIMIT object will compute the desired limit requests for
     * all referenced (via PWR_POLICY_RELATIONSHIPs) PWR_POLICY objects, but
     * will only store them internally and not issue the requests.
     *
     * This functionality is useful for IRB the PWR_POLICY_PROP_LIMIT is
     * controlling a single phase of NVVDD, such that any limit can be enforced
     * entirely via IRB by shifting the phase away -
     * i.e. even a limit of 0 can be satisfied.
     */
    NvU8 bDummy;
} NV_GPU_POWER_POLICY_PROP_LIMIT_INFO;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_INFO_V1.  Structure of static information
 * specific to the TOTAL_GPU POWER_POLICY.
 */
typedef struct _NV_GPU_POWER_POLICY_TOTAL_GPU_INFO
{
    /*!
     * Power Policy Table Relationship index corresponding to the FB
       POWER_POLICY to update for this Total GPU Power Policy.
     */
    NvU8  fbPolicyRelIdx;
    /*!
     * Power Policy Table Relationship index corresponding to the Core
       POWER_POLICY to update for this Total GPU Power Policy.
     */
    NvU8  corePolicyRelIdx;
    /*!
     * Static value (in specified units) to subtract out of the total available
     * limit before assigning the remainder to Core and FB.
     */
    NvU32 staticValue;
    /*!
     * Cap the system below the "Inflection vpstate index" when the current
     * limit is smaller than this "Inflection limit". This inflection limit can
     * help improve some pstate thrashing issue when the power limit is reduced
     * into the "battery" or certain lower pstate range.
     */
    NvU32 limitInflection;
    /*!
     * Boolean indicating that the adjustment behavior is enabled.
     */
    NvU8  bAdjEnabled;
    /*!
     * Index of the first Power Policy Relationship in the Power Policy Table,
     * specifying the set of PWR_POLICY objects to adjust as this object's limit
     * is changed by the user.  The set is specified as the range
     * [adjRelIdxFirst, @ref adjRelIdxLast].
     */
    NvU8  adjRelIdxFirst;
    /*!
     * Index of the last Power Policy Relationship in the Power Policy Table,
     * specifying the set of PWR_POLICY objects to adjust as this object's limit
     * is changed by the user.  The set is specified as the range
     * [@ref adjRelIdxFirst, adjRelIdxLast].
     */
    NvU8  adjRelIdxLast;
    /*!
     * Static rail power channel index. Will point to the power channel
     * representing static rail power draw.
     * This value and staticValue above will indicate if board is using fixed
     * value or channel index to represent static power draw. If pwrChannelIdx
     * equals 0xff then staticValue contains the fixed offset. If staticValue is
     * 0 then pwrChannelIdx may contain the channel index to static rail, or 0xff.
     */
    NvU8  pwrChannelIdx;
} NV_GPU_POWER_POLICY_TOTAL_GPU_INFO;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_INFO_V1.  Structure of static information
 * specific to the WORKLOAD POWER_POLICY.
 */
typedef struct _NV_GPU_POWER_POLICY_WORKLOAD_INFO
{
    /*!
     * Must always be first in structure!
     */
    NV_GPU_POWER_POLICY_DOMGRP_INFO domGrp;

    /*!
     * Index of leakage equation in Power Leakage Table.
     */
    NvU8   leakageIdx;
    /*!
     * Size of the workload median filter.
     */
    NvU8   medianFilterSize;
} NV_GPU_POWER_POLICY_WORKLOAD_INFO;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_INFO_V2.  Structure of static information
 * specific to the HW_THRESHOLD POWER_POLICY.
 */
typedef struct _NV_GPU_POWER_POLICY_HW_THRESHOLD_INFO
{
    /*!
     * HW Threshold index. The Theshold Index is a PWR_DEVICE-specific enum for
     * different threshold features in a given PWR_DEVICE. The definition of
     * each PWR_DEVICE's supported threshold indexes can be found in Power
     * Sensors Table Spec.
     */
    NvU8        thresholdIdx;
    /*!
     * Low HW Threshold index. The Low Threshold Index is a PWR_DEVICE-specific
     * enum for threshold holding either low limit or hysteresis value. It is
     * used when NV_GPU_POWER_POLICY_HW_THRESHOLD_INFO
     * ::isUsingLowThreshold is set to '1'. The definition of each PWR_DEVICE's
     * supported threshold indexes can be found in Power Sensors Table Spec.
     */
    NvU8        lowThresholdIdx;
    /*!
     * If set to '1' then low threshold data should be used and if set to '0'
     * then low threshold data should not be used. Supported only on
     * selected PWR_DEVICEs.
     */
    NvU8        isUsingLowThreshold;
    /*!
     * Value of low threshold relative to threshold limit. It is used when
     * NV2080_CTRL_PMGR_PWR_POLICY_INFO_DATA_HW_THRESHOLD::bUseLowThreshold is
     * set to NV_TRUE.
     */
    NvU16       lowThresholdValue;
} NV_GPU_POWER_POLICY_HW_THRESHOLD_INFO;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_INFO_V2.  Structure of static information
 * specific to the VIOLATION_CONTROL POWER_POLICY.
 */
typedef struct _NV_GPU_POWER_POLICY_VIOLATION_CONTROL_INFO
{
    /*!
     * HW_THRESHOLD specific data.
     */
    NV_GPU_POWER_POLICY_HW_THRESHOLD_INFO   hwThreshold;
    /*!
     * Limit Drop Rate. Once violation rate goes beyond this rate, VC will
     * try to drop target power policy's power limit.
     */
    NvU32   limitDropRate;
    /*!
     * Limit Raise Rate. Once violation rate goes below this rate, VC will
     * try to raise target power policy's power limit.
     */
    NvU32   limitRaiseRate;
    /*!
     * Limit Drop Value. The power value in milli-Watts that VC will drop
     * each time.
     */
    NvU32   limitDropValuemW;
    /*!
     * Limit Raise Value. The power value in milli-Watts that VC will raise
     * each time.
     */
    NvU32   limitRaiseValuemW;
    /*!
     * Policy Relationship table index. This index points to the target policy
     * VC is trying to control.
     */
    NvU8    policyRelIdx;
} NV_GPU_POWER_POLICY_VIOLATION_CONTROL_INFO;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_INFO_V2.  Structure of static information
 * specific to the BALANCE POWER_POLICY.
 */
typedef struct _NV_GPU_POWER_POLICY_BALANCE_INFO
{
    /*!
     * Index of first Power Policy Relationship object for this class.
     * The classes which extend this Virtual class will run the power balancing
     * algorithm on all controllers specified by @ref PWR_POLICY_RELATIONSHIP
     * objects in the range (@ref policyRelIdxFirst, @ref policyRelIdxLast)
     */
    NvU8          policyRelIdxFirst;

    /*!
     * Index of last Power Policy Relationship for this class.
     * The classes which extend this Virtual class will run the power balancing
     * algorithm on all controllers specified by @ref PWR_POLICY_RELATIONSHIP
     * objects in the range (@ref policyRelIdxFirst, @ref policyRelIdxLast)
     */
    NvU8          policyRelIdxLast;
} NV_GPU_POWER_POLICY_BALANCE_INFO;

/*!
 * Enumeration/handle for which GPU a PWR_POLICY_GEMINI class represents in the
 * PWR_GEMINI synchronized balancing algorithm.
 */
typedef enum
{
    /*!
     * The SLAVE policy does not specify the control parameters in
     * the VBIOS.  In the PWR_GEMINI algorithm, this is policy which is
     * associated with the negative polarity of the limitDelta.
     *
     * Otherwise, the MASTER and SLAVE are functionally equivalent.
     */
    NV_GPU_POWER_POLICY_GEMINI_GPU_SLAVE = 0x0,
    /*!
     * The MASTER policy is the one which specifies the control parameters in
     * the VBIOS.  In the PWR_GEMINI algorithm, this is policy which is
     * associated with the positive polarity of the limitDelta.
     *
     * Otherwise, the MASTER and SLAVE are functionally equivalent.
     */
    NV_GPU_POWER_POLICY_GEMINI_GPU_MASTER,
    /*!
     * Must always be last.
     */
    NV_GPU_POWER_POLICY_GEMINI_MAX_GPUS,
} NV_GPU_POWER_POLICY_GEMINI_GPU;

/*!
 * Structure representing the Gemini SLI Balancing parameters, populated from
 * the VBIOS in a GEMINI_MASTER class.  However, they are common to both
 * master and slave.
 */
typedef struct
{
    /*!
     * Sampling polling period (ms).
     */
    NvU16 samplePeriodms;
    /*!
     * Step size to use when shifting the deltas from one policy to another.  In
     * limit units (i.e. mW or mA).
     */
    NvU32 deltaStepSize;
    /*!
     * Absolute value maximum possible delta.  The maximum amount of power which
     * can be shifted from one GPU to another.
     */
    NvU32 deltaMax;
    /*!
     * Maximum allowed difference of the respective limits from the respective
     * values of the balanced PWR_POLICYs associated with a PWR_POLICY_GEMINI
     * for the PWR_POLICY_GEMINI object to be considered for balancing.
     *
     * This feature prevents the PWR_GEMINI algorithm from making a balancing
     * action which would not have any impact on the clocks - i.e. the none of
     * the balanced PWR_POLICYs are constraining the clocks, so giving them more
     * power won't increase performance.
     */
    NvU32 diffMax;
} NV_GPU_POWER_POLICY_GEMINI_CONTROLLER_PARAMS;

/*!
 * Structure representing static informtion of @ref PWR_GEMINI.  This is the
 * master controller which is associated with a pair of @ref PWR_POLICY_GEMINI
 * objects and implements the acutal Gemini synchronized power balancing
 * algorithm.
 */
typedef struct
{
    /*!
     * Index of this object within the OBJGPUMGR::pwrGemini PMGR_DEVICE_GROUP.
     */
    NvU8  geminiIdx;

    /*!
     * The OBJGPU::boardId for this Gemini SLI balancing algorithm.  Unique
     * identifier for systems with multiple Gemini balancing algorithms.
     */
    NvU32 boardId;

    /*!
     * Control parameters for this Gemini SLI balancing algorithm.
     */
    NV_GPU_POWER_POLICY_GEMINI_CONTROLLER_PARAMS params;
} NV_GPU_POWER_POLICY_GEMINI_INFO_CONTROLLER;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_INFO_V2.  Structure of static information
 * specific to the GEMINI POWER_POLICY.
 */
typedef struct _NV_GPU_POWER_POLICY_GEMINI_INFO
{
    /*!
     * Handle for which GPU is this PWR_POLICY_GEMINI class in the
     * PWR_GEMINI synchronized balancing algorithm.
     */
    NV_GPU_POWER_POLICY_GEMINI_GPU gpu;

    /*!
     * Index of first Power Policy Relationship object for this class.
     * The classes which extend this Virtual class will run the power balancing
     * algorithm on all controllers specified by @ref PWR_POLICY_RELATIONSHIP
     * objects in the range (@ref policyRelIdxFirst, @ref policyRelIdxLast)
     */
    NvU8          policyRelIdxFirst;

    /*!
     * Index of last Power Policy Relationship for this class.
     * The classes which extend this Virtual class will run the power balancing
     * algorithm on all controllers specified by @ref PWR_POLICY_RELATIONSHIP
     * objects in the range (@ref policyRelIdxFirst, @ref policyRelIdxLast)
     */
    NvU8          policyRelIdxLast;

    /*!
     * Master controller static state.
     */
    NV_GPU_POWER_POLICY_GEMINI_INFO_CONTROLLER controller;
} NV_GPU_POWER_POLICY_GEMINI_INFO;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_INFO_PARAMS_V1.  Structure of static
 * information describing a POWER_POLICY, which specifies a power policy/limit to
 * enforce on the GPU.
 */
typedef struct _NV_GPU_POWER_POLICY_INFO_V1
{
    /*!
     * NV_GPU_POWER_POLICY_TYPE_<xyz>.
     */
    NV_GPU_POWER_POLICY_TYPE type;

    /*!
     * Index into Power Topology Table (POWER_CHANNEL) for input channel.
     */
    NvU8  chIdx;

    /*!
     * Units of limit values.
     */
    NV_GPU_POWER_POLICY_LIMIT_UNIT limitUnit;
    /*!
     * Minimum allowed limit value.
     */
    NvU32 limitMin;
    /*!
     * Rated/default limit value.
     */
    NvU32 limitRated;
    /*!
     * Maximum allowed limit value.
     */
    NvU32 limitMax;

    /*!
     * Reserving 16 bytes of space so can add new types without needing to
     * add a new version.
     */
    NvU8 rsvd[16];

    /*!
     * Type-specific information.  Interpreted by \ref type.
     */
    union
    {
        NV_GPU_POWER_POLICY_DOMGRP_INFO        domGrp;
        NV_GPU_POWER_POLICY_NDIV_INFO          ndiv;
        NV_GPU_POWER_POLICY_BANG_BANG_VF_INFO  bangBangVf;
        NV_GPU_POWER_POLICY_PROP_LIMIT_INFO    propLimit;
        NV_GPU_POWER_POLICY_TOTAL_GPU_INFO     totalGpu;
        NV_GPU_POWER_POLICY_WORKLOAD_INFO      workload;
        NV_GPU_POWER_POLICY_HW_THRESHOLD_INFO  hwThreshold;
        /*!
         * Reserving 16 bytes of space so can add new types without needing to
         * add a new version.
         */
        NvU8 rsvd[16];
    } data;
} NV_GPU_POWER_POLICY_INFO_V1;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_INFO_PARAMS_V1.  Structure of static
 * information describing a POWER_POLICY, which specifies a power policy/limit to
 * enforce on the GPU.
 */
typedef struct _NV_GPU_POWER_POLICY_INFO_V2
{
    /*!
     * NV_GPU_POWER_POLICY_TYPE_<xyz>.
     */
    NV_GPU_POWER_POLICY_TYPE type;

    /*!
     * Index into Power Topology Table (POWER_CHANNEL) for input channel.
     */
    NvU8  chIdx;

    /*!
     * Units of limit values.
     */
    NV_GPU_POWER_POLICY_LIMIT_UNIT limitUnit;
    /*!
     * Minimum allowed limit value.
     */
    NvU32 limitMin;
    /*!
     * Rated/default limit value.
     */
    NvU32 limitRated;
    /*!
     * Maximum allowed limit value.
     */
    NvU32 limitMax;
    /*!
     * Battery allowed limit value.
     */
    NvU32 limitBatt;
    /*!
     * Integral Control: No of past samples, looking at which the
     * control algorithm does an adjustment to the future samples.
     */
    NvU8   pastSampleCount;
    /*!
     * Integral Control: No of future samples to apply the limit adjustment.
     */
    NvU8   nextSampleCount;
    /*!
     * Integral Control: The minimum value of the bounding box for
     * the limit adjustment, a ratio from the current policy limit.
     *   
     * Unitless Unsigned FXP 4.12.
     */
    NvU16  ratioLimitMin;
    /*!
     * Integral Control: The maximum value of the bounding box for 
     * the limit adjustment, a ratio from the current policy limit.
     *
     * Unitless Unsigned FXP 4.12.
     */
    NvU16  ratioLimitMax;

    /*!
     * Power Policy 3.x Only
     * Sampling Multiplier for this policy. The polling period of this policy
     * will be sampleMult * baseSamplePeriod.
     */
    NvU8   sampleMult;

    /*!
     * Reserving 5 bytes of space so can add new types without needing to
     * add a new version.
     */
    NvU8 rsvd[5];

    /*!
     * Type-specific information.  Interpreted by \ref type.
     */
    union
    {
        NV_GPU_POWER_POLICY_DOMGRP_INFO             domGrp;
        NV_GPU_POWER_POLICY_NDIV_INFO               ndiv;
        NV_GPU_POWER_POLICY_BANG_BANG_VF_INFO       bangBangVf;
        NV_GPU_POWER_POLICY_MARCH_N_INFO            marchN;
        NV_GPU_POWER_POLICY_MARCH_N_BA00_INFO       marchNBA00;
        NV_GPU_POWER_POLICY_MARCH_VF_INFO           marchVF;
        NV_GPU_POWER_POLICY_MARCH_VF_BA00_INFO      marchVFBA00;
        NV_GPU_POWER_POLICY_PROP_LIMIT_INFO         propLimit;
        NV_GPU_POWER_POLICY_TOTAL_GPU_INFO          totalGpu;
        NV_GPU_POWER_POLICY_WORKLOAD_INFO           workload;
        NV_GPU_POWER_POLICY_HW_THRESHOLD_INFO       hwThreshold;
        NV_GPU_POWER_POLICY_VIOLATION_CONTROL_INFO  vControl;
        NV_GPU_POWER_POLICY_BALANCE_INFO            balance;
        NV_GPU_POWER_POLICY_GEMINI_INFO             gemini;
        /*!
         * Reserving 48 bytes of space so can add new types without needing to
         * add a new version.
         */
        NvU8 rsvd[48];
    } data;
} NV_GPU_POWER_POLICY_INFO_V2;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_RELATIONSHIP_INFO_V1.  Structure
 * representing a POWER_POLICY_RELATIONSHIP which scales its applied limit value
 * by a specified coefficient/weight.
 */
typedef struct _NV_GPU_POWER_POLICY_RELATIONSHIP_WEIGHT_INFO
{
    /*!
     * Coefficient/weight by which to scale the limit value which the the
     * updating policy wants to apply to the POWER_POLICY corresponding to \ref
     * NV_GPU_POWER_POLICY_RELATIONSHIP_INFO_V1::policyIdx.
     *
     * Unsigned FXP4.12 value.  Unitless.
     */
    NvU16 weight;
} NV_GPU_POWER_POLICY_RELATIONSHIP_WEIGHT_INFO;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_RELATIONSHIP_INFO_V2.  Structure
 * representing a POWER_POLICY_RELATIONSHIP_BALANCE
 */
typedef struct _NV_GPU_POWER_POLICY_RELATIONSHIP_BALANCE_INFO
{
    /*!
     * Index into Power Policy Table. This should point to object of type
     * @ref PWR_POLICY_LIMIT (or class derived thereof)
     *
     * Another index used in conjunction with this is
     * @ref PWR_POLICY_RELATIONSHIP::policyIdx. (and hence this index is
     * secondary policy id)
     *
     * The policies pointed to by these two indexes will be used by a
     * @ref PWR_POLICY_BALANCE object which references instance of this class.
     */
    NvU8                    secPolicyIdx;

    /*!
     * GPIO function for Power Balancing PWM signal.
     */
    NvU32                   gpioFunc;

    /*!
     * PWM Source. @ref RM_PMU_PMGR_PWM_SOURCE
     */
    NvU8                    pwmSource;

    /*!
     * PWM frequency in Hz.
     */
    NvU32                   pwmFreqHz;

    /*!
     * PWM period. This is a value in terms of PWM generator's input-clock ticks.
     * This does not have the units of time.
     */
    NvU32                   pwmPeriod;

    /*!
     * PWM duty cycle at start. Unitless quantity in %.
     * Represented as unsigned FXP 16_16
     */
    NvU32                   pwmDutyCycleInitial;

    /*!
     * PWM duty cycle setp size. Unitless quantity in %.
     * Represented as unsigned FXP 16_16
     */
    NvU32                   pwmDutyCycleStepSize;

    /*!
     * Index into Power Topology Table @ref PWR_CHANNEL
     * The PWR_CHANNEL object at this index is used to estimate the power for the
     * corresponding phase. This estimate will be used by the
     * @ref PWR_POLICY_BALANCE object referenced by @ref PWR_POLICY_RELATIONSHIP::policyIdx.
     *
     * Value of @ref NV2080_CTRL_PMGR_PWR_CHANNEL_INDEX_INVALID means the estimate
     * is not available and hence this value should not be used.
     */
    NvU8                    phaseEstimateChIdx;
} NV_GPU_POWER_POLICY_RELATIONSHIP_BALANCE_INFO;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_INFO_PARAMS_V1.  Structure representing a
 * POWER_POLICY_RELATIONSHIP - specifying how one policy can update the limit
 * value of another.  POWER_POLICYs which take policy actions by updating the
 * limits of other channels (i.e. implementing NV_GPU_POWER_POLICY_TYPE_LIMIT)
 * use indexes to POWER_POLICY_RELATIONSHIPs to determine which policies to
 * update.
 */
typedef struct _NV_GPU_POWER_POLICY_RELATIONSHIP_INFO_V1
{
    /*!
     * \ref NV_GPU_POWER_POLICY_RELATIONSHIP_TYPE_<xyz>
     */
    NV_GPU_POWER_POLICY_RELATIONSHIP_TYPE type;
    /*!
     * Index of POWER_POLICY to update.
     */
    NvU8 policyIdx;

    /*!
     * Reserving 16 bytes for future use w/o needing to add new structure
     * version.
     */
    NvU8  rsvd[16];

    /*!
     * Type-specific information.
     */
    union
    {
        NV_GPU_POWER_POLICY_RELATIONSHIP_WEIGHT_INFO weight;
        /*!
         * Reserving 16 bytes for future use w/o needing to add new structure
         * version.
         */
        NvU8  rsvd[16];
    } data;
} NV_GPU_POWER_POLICY_RELATIONSHIP_INFO_V1;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_INFO_PARAMS_V2.  Structure representing a
 * POWER_POLICY_RELATIONSHIP - specifying how one policy can update the limit
 * value of another.  POWER_POLICYs which take policy actions by updating the
 * limits of other channels (i.e. implementing NV_GPU_POWER_POLICY_TYPE_LIMIT)
 * use indexes to POWER_POLICY_RELATIONSHIPs to determine which policies to
 * update.
 */
typedef struct _NV_GPU_POWER_POLICY_RELATIONSHIP_INFO_V2
{
    /*!
     * \ref NV_GPU_POWER_POLICY_RELATIONSHIP_TYPE_<xyz>
     */
    NV_GPU_POWER_POLICY_RELATIONSHIP_TYPE type;
    /*!
     * Index of POWER_POLICY to update.
     */
    NvU8 policyIdx;

    /*!
     * Reserving 16 bytes for future use w/o needing to add new structure
     * version.
     */
    NvU8  rsvd[16];

    /*!
     * Type-specific information.
     */
    union
    {
        NV_GPU_POWER_POLICY_RELATIONSHIP_WEIGHT_INFO  weight;
        NV_GPU_POWER_POLICY_RELATIONSHIP_BALANCE_INFO balance;

        /*!
         * Reserving 48 bytes for future use w/o needing to add new structure
         * version.
         */
        NvU8  rsvd[48];
    } data;
} NV_GPU_POWER_POLICY_RELATIONSHIP_INFO_V2;

//! \ingroup gpupower
//! @{

/*!
 * Structure for a power limit corresponding to an externally set power state.
 */
typedef struct
{
    /*!
     * Version of structure.  Must always be first.
     */
    NvU32  version;
    /*!
     * Power policy table index
     */
    NvU8  policyTableIdx;
    /*!
     * Power limit, in mW
     */
    NvU32 limit;
} NV_GPU_PWR_POLICY_EXT_LIMIT_V1;


#define NV_GPU_PWR_POLICY_EXT_LIMIT_VER_1   MAKE_NVAPI_VERSION(NV_GPU_PWR_POLICY_EXT_LIMIT_V1,1)
#define NV_GPU_PWR_POLICY_EXT_LIMIT_VER     NV_GPU_PWR_POLICY_EXT_LIMIT_VER_1

#define NV_GPU_PWR_POLICY_EXT_LIMIT         NV_GPU_PWR_POLICY_EXT_LIMIT_V1
/*!
 * Enumeration of identifiers for external (system-imposed) power states.
 * We support up to four of these power states, which are requested by
 * the system at runtime via ACPI notification 0xD2 - 0xD5 in order to
 * impose power restrictions on GPU performance.  These power states
 * also correspond to auxiliary power states 1 to 4
 * Only one state is active at any
 * moment, and there is a special state, D1 to represent no system-imposed
 * restrictions.
 *
 * Internally a power state provides a limit input value and client, along with
 * an index to a power policy object.  The limit inputs are additional inputs
 * to the arbiterer and do not override the limits set by VBIOS.
 */
typedef enum
{
    NV_GPU_PWR_POLICY_EXT_POWER_STATE_ID_D2    = 0x00000000,
    NV_GPU_PWR_POLICY_EXT_POWER_STATE_ID_D3,
    NV_GPU_PWR_POLICY_EXT_POWER_STATE_ID_D4,
    NV_GPU_PWR_POLICY_EXT_POWER_STATE_ID_D5,
    NV_GPU_PWR_POLICY_EXT_POWER_STATE_ID_COUNT,
    NV_GPU_PWR_POLICY_EXT_POWER_STATE_ID_D1    = 0xFFFFFFFF,
} NV_GPU_PWR_POLICY_EXT_POWER_STATE_ID;

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    NvAPI_GPU_SetExternPowerState()
//
//! DESCRIPTION: Sets a desired external power state
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version: ??
//!
//! \param [in]  hPhysicalGPU   GPU selection
//! \param [out] powerState     The power state to be set
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gpupower
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetExternPowerState(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_PWR_POLICY_EXT_POWER_STATE_ID powerState);

/*!
 * Used in \ref NvAPI_GPU_PowerPolicyGetInfo. This represents the Power Policy
 * Table Version as given by \ref NV2080_CTRL_PMGR_PWR_POLICY_TABLE_VERSION_2X/3X
 */
#define NV_GPU_POWER_POLICY_TABLE_VERSION_2X               0x20
#define NV_GPU_POWER_POLICY_TABLE_VERSION_3X               0x30

/*!
 * Used in \ref NvAPI_GPU_PowerPolicyGetInfo.  Structure representing the static
 * state information associated with the GPU's POWER_POLICY functionality.
 */
typedef struct _NV_GPU_POWER_POLICY_INFO_PARAMS_V1
{
    /*!
     * Version of structure.  Must always be first.
     */
    NvU32  version;

    /*!
     * Mask of POWER_POLICY entries specified on this GPU.
     */
    NvU32 policyMask;
    /*!
     * Mask of POWER_POLICY_DOMGRP entries which are take policy actions
     * by setting Domain Group PERF_LIMITs.
     */
    NvU32 domGrpPolicyMask;
    /*!
     * Mask of POWER_POLICY_LIMIT entries which take policy actions by
     * requesting new limit values on other PWR_POLICY entries.
     */
    NvU32 limitPolicyMask;
    /*!
     * Mask of POWER_POLICY_RELATIONSHIP entries specified on this GPU.
     */
    NvU32 policyRelMask;

    /*!
     * Power Policy Table index for POWER_POLICY controlling Total Gpu Power
     * (TGP).  This is the hard limit for total GPU power which will always be
     * enforced by the RM power policy functionality.
     */
    NvU8  tgpPolicyIdx;
    /*!
     * Power Policy Table index for POWER_POLICY controlling Room Temperature
     * Power (RTP).  This is the soft limit for GPU power which will be
     * enforced down to the 3D Boost VPstate (aka "Base Clock" in the PWR
     * 2.0/SmartPower/GPU Boost literature).  This policy is not required to be
     * present on all GPUs.
     */
    NvU8  rtpPolicyIdx;

    /*!
     * Reserving 16 bytes reserved for future use w/o needing to add new structure
     * version.
     */
    NvU8  rsvd[16];

    /*!
     * Array of POWER_POLICY entries.  Has valid indexes corresponding to the
     * bits set in \ref policyMask.
     */
    NV_GPU_POWER_POLICY_INFO_V1 policies[NV_GPU_POWER_POLICY_MAX_POLICIES_V1];
    /*!
     * Array of POWER_POLICY_RELAIONSHIP entries.  Has valid indexes
     * corresponding to the bits set in \ref policyRelMask.
     */
    NV_GPU_POWER_POLICY_RELATIONSHIP_INFO_V1
        policyRels[NV_GPU_POWER_POLICY_MAX_POLICY_RELATIONSHIPS_V1];
} NV_GPU_POWER_POLICY_INFO_PARAMS_V1;

/*!
 * Used in \ref NvAPI_GPU_PowerPolicyGetInfo.  Structure representing the static
 * state information associated with the GPU's POWER_POLICY functionality.
 */
typedef struct _NV_GPU_POWER_POLICY_INFO_PARAMS_V2
{
    /*!
     * Version of structure.  Must always be first.
     */
    NvU32  version;

    /*!
     * Mask of POWER_POLICY entries specified on this GPU.
     */
    NvU32 policyMask;
    /*!
     * Mask of POWER_POLICY_DOMGRP entries which are take policy actions
     * by setting Domain Group PERF_LIMITs.
     */
    NvU32 domGrpPolicyMask;
    /*!
     * Mask of POWER_POLICY_LIMIT entries which take policy actions by
     * requesting new limit values on other PWR_POLICY entries.
     */
    NvU32 limitPolicyMask;
    /*!
     * Mask of POWER_POLICY_RELATIONSHIP entries specified on this GPU.
     */
    NvU32 policyRelMask;

    /*!
     * Power Policy Table index for POWER_POLICY controlling Total Gpu Power
     * (TGP).  This is the hard limit for total GPU power which will always be
     * enforced by the RM power policy functionality.
     */
    NvU8  tgpPolicyIdx;
    /*!
     * Power Policy Table index for POWER_POLICY controlling Room Temperature
     * Power (RTP).  This is the soft limit for GPU power which will be
     * enforced down to the 3D Boost VPstate (aka "Base Clock" in the PWR
     * 2.0/SmartPower/GPU Boost literature).  This policy is not required to be
     * present on all GPUs.
     */
    NvU8  rtpPolicyIdx;

    /*!
     * Reserving 16 bytes reserved for future use w/o needing to add new structure
     * version.
     */
    NvU8  rsvd[16];

    /*!
     * Array of POWER_POLICY entries.  Has valid indexes corresponding to the
     * bits set in \ref policyMask.
     */
    NV_GPU_POWER_POLICY_INFO_V2 policies[NV_GPU_POWER_POLICY_MAX_POLICIES_V1];
    /*!
     * Array of POWER_POLICY_RELAIONSHIP entries.  Has valid indexes
     * corresponding to the bits set in \ref policyRelMask.
     */
    NV_GPU_POWER_POLICY_RELATIONSHIP_INFO_V1
        policyRels[NV_GPU_POWER_POLICY_MAX_POLICY_RELATIONSHIPS_V1];
} NV_GPU_POWER_POLICY_INFO_PARAMS_V2;

/*!
 * Used in \ref NvAPI_GPU_PowerPolicyGetInfo.  Structure representing the static
 * state information associated with the GPU's POWER_POLICY functionality.
 */
typedef struct _NV_GPU_POWER_POLICY_INFO_PARAMS_V3
{
    /*!
     * Version of structure.  Must always be first.
     */
    NvU32 version;

    /*!
     * Mask of POWER_POLICY entries specified on this GPU.
     */
    NvU32 policyMask;
    /*!
     * Mask of POWER_POLICY_DOMGRP entries which are take policy actions
     * by setting Domain Group PERF_LIMITs.
     */
    NvU32 domGrpPolicyMask;
    /*!
     * Mask of POWER_POLICY_LIMIT entries which take policy actions by
     * requesting new limit values on other PWR_POLICY entries.
     */
    NvU32 limitPolicyMask;

    /*!
     * Mask of POWER_POLICY_RELATIONSHIP entries specified on this GPU.
     */
    NvU32 policyRelMask;

    /*!
     * Power Policy Table index for POWER_POLICY controlling Total Gpu Power
     * (TGP).  This is the hard limit for total GPU power which will always be
     * enforced by the RM power policy functionality.
     */
    NvU8  tgpPolicyIdx;
    /*!
     * Power Policy Table index for POWER_POLICY controlling Room Temperature
     * Power (RTP).  This is the soft limit for GPU power which will be
     * enforced down to the 3D Boost VPstate (aka "Base Clock" in the PWR
     * 2.0/SmartPower/GPU Boost literature).  This policy is not required to be
     * present on all GPUs.
     */
    NvU8  rtpPolicyIdx;

    /*!
     * Mask of POWER_POLICY_BALANCE entries specified on this GPU.
     */
    NvU32 balancePolicyMask;

    /*!
     * Power Policy 3.X Only
     * Base sampling period for all power policies in milli-seconds.
     */
    NvU16 baseSamplePeriod;

    /*!
     * Power Policy Table Version
     */
    NvU8 policyVersion;

    /*!
     * Reserving 29 bytes reserved for future use w/o needing to add new structure
     * version.
     */
    NvU8  rsvd[29];

    /*!
     * Array of POWER_POLICY entries.  Has valid indexes corresponding to the
     * bits set in \ref policyMask.
     */
    NV_GPU_POWER_POLICY_INFO_V2 policies[NV_GPU_POWER_POLICY_MAX_POLICIES_V1];
    /*!
     * Array of POWER_POLICY_RELAIONSHIP entries.  Has valid indexes
     * corresponding to the bits set in \ref policyRelMask.
     */
    NV_GPU_POWER_POLICY_RELATIONSHIP_INFO_V2
        policyRels[NV_GPU_POWER_POLICY_MAX_POLICY_RELATIONSHIPS_V1];
} NV_GPU_POWER_POLICY_INFO_PARAMS_V3;

/*!
 * Used in \ref NvAPI_GPU_PowerPolicyGetInfo.  Structure representing the static
 * state information associated with the GPU's POWER_POLICY functionality.
 */
typedef struct _NV_GPU_POWER_POLICY_INFO_PARAMS_V4
{
    /*!
     * Version of structure.  Must always be first.
     */
    NvU32 version;

    /*!
     * Mask of POWER_POLICY entries specified on this GPU.
     */
    NvU32 policyMask;
    /*!
     * Mask of POWER_POLICY_DOMGRP entries which are take policy actions
     * by setting Domain Group PERF_LIMITs.
     */
    NvU32 domGrpPolicyMask;
    /*!
     * Mask of POWER_POLICY_LIMIT entries which take policy actions by
     * requesting new limit values on other PWR_POLICY entries.
     */
    NvU32 limitPolicyMask;

    /*!
     * Mask of POWER_POLICY_RELATIONSHIP entries specified on this GPU.
     */
    NvU32 policyRelMask;

    /*!
     * Power Policy Table index for POWER_POLICY controlling Total Gpu Power
     * (TGP).  This is the hard limit for total GPU power which will always be
     * enforced by the RM power policy functionality.
     */
    NvU8  tgpPolicyIdx;
    /*!
     * Power Policy Table index for POWER_POLICY controlling Room Temperature
     * Power (RTP).  This is the soft limit for GPU power which will be
     * enforced down to the 3D Boost VPstate (aka "Base Clock" in the PWR
     * 2.0/SmartPower/GPU Boost literature).  This policy is not required to be
     * present on all GPUs.
     */
    NvU8  rtpPolicyIdx;

    /*!
     * Mask of POWER_POLICY_BALANCE entries specified on this GPU.
     */
    NvU32 balancePolicyMask;

    /*!
     * Power Policy 3.X Only
     * Base sampling period for all power policies in milli-seconds.
     */
    NvU16 baseSamplePeriod;

    /*!
     * Power Policy Table Version
     */
    NvU8 policyVersion;

    /*!
     * Power Policy 3.X Only
     * Minimum client sample period in mill-seconds.
     */
    NvU16 minClientSamplePeriod;

    /*!
     * Power Policy 3.X Only
     * Low Sampling Multiplier used in lower Pstate.
     */
    NvU8  lowSamplingMult;

    /*!
     * Reserving 25 bytes reserved for future use w/o needing to add new structure
     * version.
     */
    NvU8  rsvd[25];

    /*!
     * Array of POWER_POLICY entries.  Has valid indexes corresponding to the
     * bits set in \ref policyMask.
     */
    NV_GPU_POWER_POLICY_INFO_V2 policies[NV_GPU_POWER_POLICY_MAX_POLICIES_V1];
    /*!
     * Array of POWER_POLICY_RELAIONSHIP entries.  Has valid indexes
     * corresponding to the bits set in \ref policyRelMask.
     */
    NV_GPU_POWER_POLICY_RELATIONSHIP_INFO_V2
        policyRels[NV_GPU_POWER_POLICY_MAX_POLICY_RELATIONSHIPS_V1];
    /*!
    * [out] - Array of externally available power states
    */
    NV_GPU_PWR_POLICY_EXT_LIMIT extLimits[NV_GPU_PWR_POLICY_EXT_POWER_STATE_ID_COUNT];

    /*!
    * [out] - Currently set external power state
    */
    NV_GPU_PWR_POLICY_EXT_POWER_STATE_ID extPowerState;
} NV_GPU_POWER_POLICY_INFO_PARAMS_V4;

#define NV_GPU_POWER_POLICY_INFO_PARAMS_VER_1   MAKE_NVAPI_VERSION(NV_GPU_POWER_POLICY_INFO_PARAMS_V1,1)
#define NV_GPU_POWER_POLICY_INFO_PARAMS_VER_2   MAKE_NVAPI_VERSION(NV_GPU_POWER_POLICY_INFO_PARAMS_V2,1)
#define NV_GPU_POWER_POLICY_INFO_PARAMS_VER_3   MAKE_NVAPI_VERSION(NV_GPU_POWER_POLICY_INFO_PARAMS_V3,1)
#define NV_GPU_POWER_POLICY_INFO_PARAMS_VER_4   MAKE_NVAPI_VERSION(NV_GPU_POWER_POLICY_INFO_PARAMS_V4,4)
#define NV_GPU_POWER_POLICY_INFO_PARAMS_VER     NV_GPU_POWER_POLICY_INFO_PARAMS_VER_4

#define NV_GPU_POWER_POLICY_INFO_PARAMS         NV_GPU_POWER_POLICY_INFO_PARAMS_V4

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    NvAPI_GPU_PowerPolicyGetInfo()
//
//! DESCRIPTION: Retrieves information about the POWER_POLICY support on the
//!              GPU.
//!
//!              POWER_POLICY entries are limits (in current or power) which
//!              the RM/PMU POWER_POLICY functionality must try to enforce on
//!              given power rails via a specified mechanism.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version: 295.40
//!
//! \param [in]  hPhysicalGPU   GPU selection
//! \param [out] pPolicyInfo    Structure containing the description of POWER_POLICYs.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gpupower
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_PowerPolicyGetInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_POWER_POLICY_INFO_PARAMS *pPolicyInfo);

//! \ingroup gpupower
//! @{

#define NV_GPU_POWER_POLICY_DOMAIN_GROUPS_LIMTS_MAX_DOMAIN_GROUPS              2
#define NV_GPU_POWER_POLICY_DOMAIN_GROUP_LIMIT_VALUE_DISABLED         0xFFFFFFFF

/*!
 * Used in \ref NV_GPU_POWER_POLICY_STATUS_DOMGRP.  The set of domain group
 * limit values (currently only maximums) that a POWER_POLICY_DOMGRP object
 * wishes to apply to the GPU.
 */
typedef struct
{
    /*!
     * Array of domain-group-specific limit values.  This array is indexed by
     * the domain group indexes.
     */
    NvU32 values[NV_GPU_POWER_POLICY_DOMAIN_GROUPS_LIMTS_MAX_DOMAIN_GROUPS];
} NV_GPU_POWER_POLICY_STATUS_DOMAIN_GROUP_LIMITS;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_STATUS_V1, \ref
 * NV_GPU_POWER_POLICY_STATUS_MARCH_N, \ref
 * NV_GPU_POWER_POLICY_STATUS_MARCH_N_BA00.
 *
 * Structure representing the _NDIV-specific algorithm dyanmic state data.  This
 * is the current state of various algorithm input/output data for the last
 * evaluation of the algorithm.  This information is useful for debugging
 * algorithm behavior.
 */
typedef struct
{
    /*!
     * Current requested max NDIV coefficient value.
     */
    NvU8  ndivCoeff;
} NV_GPU_POWER_POLICY_STATUS_NDIV;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_STATUS_BANG_BANG_VF_V1, \ref
 * NV_GPU_POWER_POLICY_STATUS_WORKLOAD_V2, \ref NV_GPU_POWER_POLICY_STATUS_V1,
 * \ref NV_GPU_POWER_POLICY_STATUS_V2.
 * Structure of state specific to the DOMGRP virtual/super POWER_POLICY.
 */
typedef struct
{
    /*!
     * The domain group limit values this POWER_POLICY_DOMGRP object wishes to
     * apply to GPU.
     */
    NV_GPU_POWER_POLICY_STATUS_DOMAIN_GROUP_LIMITS domGrpLimits;
} NV_GPU_POWER_POLICY_STATUS_DOMGRP_V1;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_STATUS_BANG_BANG_VF_V2, \ref
 * NV_GPU_POWER_POLICY_STATUS_WORKLOAD_V2, \ref NV_GPU_POWER_POLICY_STATUS_V3.
 * Structure of state specific to the DOMGRP virtual/super POWER_POLICY.
 */
typedef struct
{
    /*!
     * The domain group limit values this POWER_POLICY_DOMGRP object wishes to
     * apply to GPU.
     */
    NV_GPU_POWER_POLICY_STATUS_DOMAIN_GROUP_LIMITS domGrpLimits;
    /*!
     * The domain group ceiling values which are determing the highest possible
     * clocks this this POWER_POLICY_DOMGRP object can apply to GPU.
     */
    NV_GPU_POWER_POLICY_STATUS_DOMAIN_GROUP_LIMITS domGrpCeiling;

    /*!
     * Reserved space to allow extending super-class without affecting
     * implementing classes.
     */
    NvU8 rsvd[16];
} NV_GPU_POWER_POLICY_STATUS_DOMGRP_V2;

/*!
 * Macros encoding the actions/decisions the POWER_POLICY_BANG_BANG_VF controller
 * may make at each evaluation.
 *
 * _NONE - Current value is acceptable, so do not change the requested clock
 *     amount.
 * _CAP - Current value is above the limit, so VF values must be capped down one
 *     step (if available).
 * _UNCAP - Current value is <= the limit * uncapLimitRatio, so VF values may be
 *     uncaped one step (if available).
 */
#define NV_GPU_POWER_POLICY_BANG_BANG_VF_ACTION_NONE                  0x00000000
#define NV_GPU_POWER_POLICY_BANG_BANG_VF_ACTION_CAP                   0x00000001
#define NV_GPU_POWER_POLICY_BANG_BANG_VF_ACTION_UNCAP                 0x00000002

/*!
 * Used in \ref NV_GPU_POWER_POLICY_STATUS_BANG_BANG_VF.  This structure
 * represents (pstate index, VF entry index) set which represents an operational
 * VF point.  This structure is represent both the current/input VF point and
 * the requested/output VF point for the _BANG_BANG_VF Power Policy.
 */
typedef struct
{
    /*!
     * Pstate index.  This is the index of the pstate within the VBIOS Perf
     * Table, not a pstate name/number - e.g. index 0 => P8, index 3 => P0.
     */
    NvU8 pstateIdx;
    /*!
     * VF Entry Index.  This is the index of the VF entry within the VBIOS VF
     * table.
     */
    NvU8 vfIdx;
} NV_GPU_POWER_POLICY_STATUS_BANG_BANG_VF_INDEXES;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_STATUS_V1.  Structure representing the
 * _BANG_BANG_VF-specific algorithm dyanmic state data.  This is the current
 * state of various algorithm input/output data for the last evaluation of the
 * algorithm.  This information is useful for debugging algorithm behavior.
 */
typedef struct
{
    /*!
     * Must always be first in structure.
     */
    NV_GPU_POWER_POLICY_STATUS_DOMGRP_V1 domGrp;

    /*!
     * Last action taken by the _BANG_BANG_VF algorithm.
     *
     * \ref NV_GPU_POWER_POLICY_BANG_BANG_VF_ACTION_<xyz>.
     */
    NvU8 action;
    /*!
     * Input VF point to the _BANG_BANG_VF algorithm for \ref action.
     */
    NV_GPU_POWER_POLICY_STATUS_BANG_BANG_VF_INDEXES
        input;
    /*!
     * Output VF point of the _BANG_BANG_VF algorithm as decided by the \ref
     * action.
     */
    NV_GPU_POWER_POLICY_STATUS_BANG_BANG_VF_INDEXES
        output;
} NV_GPU_POWER_POLICY_STATUS_BANG_BANG_VF_V1;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_STATUS_V1.  Structure representing the
 * _BANG_BANG_VF-specific algorithm dyanmic state data.  This is the current
 * state of various algorithm input/output data for the last evaluation of the
 * algorithm.  This information is useful for debugging algorithm behavior.
 */
typedef struct
{
    /*!
     * Must always be first in structure.
     */
    NV_GPU_POWER_POLICY_STATUS_DOMGRP_V2 domGrp;

    /*!
     * Last action taken by the _BANG_BANG_VF algorithm.
     *
     * \ref NV_GPU_POWER_POLICY_BANG_BANG_VF_ACTION_<xyz>.
     */
    NvU8 action;
    /*!
     * Input VF point to the _BANG_BANG_VF algorithm for \ref action.
     */
    NV_GPU_POWER_POLICY_STATUS_BANG_BANG_VF_INDEXES
        input;
    /*!
     * Output VF point of the _BANG_BANG_VF algorithm as decided by the \ref
     * action.
     */
    NV_GPU_POWER_POLICY_STATUS_BANG_BANG_VF_INDEXES
        output;
} NV_GPU_POWER_POLICY_STATUS_BANG_BANG_VF_V2;

/*!
 * Macros encoding the actions/decisions the PWR_POLICY_MARCH controller
 * may make at each evaluation.
 *
 * _NONE - Current value is acceptable, so do not change the requested state.
 * _CAP - Current value is above the limit, so algorithm must cap down one
 *     step size (if available).
 * _UNCAP - Current value is <= the uncap limit (determined by hysteresis), so
 *     algorithm may uncap by one step size (if available).
 */
#define NV_GPU_POWER_POLICY_MARCH_ACTION_NONE                       0x00
#define NV_GPU_POWER_POLICY_MARCH_ACTION_CAP                        0x01
#define NV_GPU_POWER_POLICY_MARCH_ACTION_UNCAP                      0x02


/*!
 * Used in \ref GPU_POWER_POLICY_STATUS_MARCH.
 *
 * Structure representing _MARCH_BA00-specific algorithm dynamic state data.
 * This is the current state of various algorithm input/output data for the last
 * evaluation of the algorithm.  This information is useful for debugging
 * algorithm behavior.
 */
typedef struct
{
    /*!
     * Voltage value (uV) used for leakage power estimation and dynamic power
     * normalization.  Cached in object to be returned via @ref
     * pwrPolicyMarchQuery_BA00() for debugging.
     */
    NvU32 voltageuV;
    /*!
     * GPC2CLK frequency (MHz) used for BA plane fit.
     */
    NvU32 freqMHz;
    /*!
     * Last computed leakage power (mW) returned from @ref pLeakage.  Cached in
     * object to be returned via @ref pwrPolicyMarchQuery_BA00() for debugging.
     */
    NvU32 pwrLeakagemW;
    /*!
     * Last computed BA limit via @ref pwrPolicyMarchLimitGet_BA00() to be used
     * as marching policy limit.  Cached in object to be returned via @ref
     * pwrPolicyMarchQuery_BA00() for debugging.
     */
    NvU32 limitCurrBA;
} NV_GPU_POWER_POLICY_STATUS_MARCH_BA00;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_STATUS_MARCH_N, \ref
 * NV_GPU_POWER_POLICY_STATUS_MARCH_N_BA00, \ref
 * NV_GPU_POWER_POLICY_STATUS_MARCH_VF, \ref
 * NV_GPU_POWER_POLICY_STATUS_MARCH_VF_BA00.
 *
 * Structure representing the _MARCH-specific algorithm dyanmic state
 * data.  This is the current state of various algorithm input/output data for
 * the last evaluation of the algorithm.  This information is useful for
 * debugging algorithm behavior.
 */
typedef struct
{
    /*!
     * \ref NV_GPU_POWER_POLICY_TYPE
     */
    NV_GPU_POWER_POLICY_TYPE type;
    /*!
     * Current uncap limit - as calculated by output of PWR_POLICY::limitCurr and
     * PWR_POLICY_MARCH::hysteresis.
     */
    NvU32 uncapLimit;
    /*!
     * Last action taken by the _MARCH algorithm.
     *
     * @ref NV_GPU_POWER_POLICY_MARCH_ACTION_<xyz>
     */
    NvU8  action;

    /*!
     * Union of type-specific data.
     */
    union
    {
        NV_GPU_POWER_POLICY_STATUS_MARCH_BA00 ba00;
    } data;
} NV_GPU_POWER_POLICY_STATUS_MARCH;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_STATUS_V1.
 *
 * Stucture representing MARCH_N-specific PWR_POLICY dynamic status.  This is
 * the current state of various algorithm input/output data for the last
 * evaluation of the algorithm.  This information is useful for debugging
 * algorithm behavior.
 */
typedef struct
{
    /*!
     * @copydoc NV_GPU_POWER_POLICY_STATUS_NDIV
     *
     * Must always be first in structure!
     */
    NV_GPU_POWER_POLICY_STATUS_NDIV  ndiv;
    /*!
     * Common state of the PWR_POLICY_MARCH algorithm.  Does not need to be at
     * any specific location in the sturcture.
     */
    NV_GPU_POWER_POLICY_STATUS_MARCH march;
} NV_GPU_POWER_POLICY_STATUS_MARCH_N;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_STATUS_V1.
 *
 * This structure is deprecated, but kept for backward-compatibility.
 */
typedef NV_GPU_POWER_POLICY_STATUS_MARCH_N
    NV_GPU_POWER_POLICY_STATUS_MARCH_N_BA00;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_STATUS_V1.
 *
 * Stucture representing MARCH_N-specific PWR_POLICY dynamic status.  This is
 * the current state of various algorithm input/output data for the last
 * evaluation of the algorithm.  This information is useful for debugging
 * algorithm behavior.
 */
typedef struct
{
    /*!
     * @copydoc NV_GPU_POWER_POLICY_STATUS_DOMGRP_V1
     *
     * Must always be first in structure!
     */
    NV_GPU_POWER_POLICY_STATUS_DOMGRP_V1 domGrp;
    /*!
     * Common state of the PWR_POLICY_MARCH algorithm.  Does not need to be at
     * any specific location in the sturcture.
     */
    NV_GPU_POWER_POLICY_STATUS_MARCH  march;
} NV_GPU_POWER_POLICY_STATUS_MARCH_VF_V1;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_STATUS_V1.
 *
 * Stucture representing MARCH_N-specific PWR_POLICY dynamic status.  This is
 * the current state of various algorithm input/output data for the last
 * evaluation of the algorithm.  This information is useful for debugging
 * algorithm behavior.
 */
typedef struct
{
    /*!
     * @copydoc NV_GPU_POWER_POLICY_STATUS_DOMGRP_V2
     *
     * Must always be first in structure!
     */
    NV_GPU_POWER_POLICY_STATUS_DOMGRP_V2 domGrp;
    /*!
     * Common state of the PWR_POLICY_MARCH algorithm.  Does not need to be at
     * any specific location in the sturcture.
     */
    NV_GPU_POWER_POLICY_STATUS_MARCH  march;
} NV_GPU_POWER_POLICY_STATUS_MARCH_VF_V2;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_STATUS_V1.
 *
 * This structure is deprecated, but kept for backward-compatibility.
 */
typedef NV_GPU_POWER_POLICY_STATUS_MARCH_VF_V1
    NV_GPU_POWER_POLICY_STATUS_MARCH_VF_BA00;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_STATUS_WORKLOAD.
 *
 * This represents the current GPU state which is passed as input to PMU function
 * _pwrPolicyWorkloadComputeWorkload() to calculate the current workload/active
 * capacitance (w).
 *
 *     w = (Ptotal - Pleakage) / (V^2 * f)
 */
typedef struct
{
    /*!
     * Estimated leakage power (mW).
     */
    NvU32 pwrLeakagemW;
    /*!
     * Frequency (MHz)
     */
    NvU32 freqMHz;
    /*!
     * Voltage^2 (mV^2).
     */
    NvU32 voltmV2;
} NV_GPU_POWER_POLICY_STATUS_WORKLOAD_WORK_INPUT;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_STATUS_WORKLOAD.
 *
 * This represents a leakage and voltage combination for which the WORKLOAD
 * algorithrm should compute the highest possible frequency.  This structure is
 * passed as input to PMU function _pwrPolicyWorkloadVfEntryComputeClkMHz().
 *
 * The value returned from the PMU will represent the last calculation for the
 * highest set of frequencies the WORKLOAD algorithm deems possible for the
 * given workload per PMU function _pwrPolicyWorkloadComputeClkMHz().
 */
typedef struct
{
    /*!
     * The filtered workload/active capacitance (w) which is used to determine
     * the target clocks.
     */
    NvU32 workloadmWperMHzmV2;
    /*!
     * Estimated leakage power (mW).
     */
    NvU32 pwrLeakagemW;
    /*!
     * Frequency (MHz)
     */
    NvU32 freqMaxMHz;
    /*!
     * Voltage^2 (mV^2).
     */
    NvU32 voltmV2;
    /*!
     * The current VF entry being evaluated.  This is purely for debugging, it
     * is not actually used in PMU function
     * _pwrPolicyWorkloadVfEntryComputeClkMHz().
     */
    NvU8  vfEntryIdx;
} NV_GPU_POWER_POLICY_STATUS_WORKLOAD_FREQ_INPUT;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_STATUS_V1.  Stucture representing
 * WORKLOAD-specific POWER_POLICY dynamic status.
 */
typedef struct
{
    /*!
     * Must always be first in structure.
     */
    NV_GPU_POWER_POLICY_STATUS_DOMGRP_V1           domGrp;
    NV_GPU_POWER_POLICY_STATUS_WORKLOAD_WORK_INPUT work;
    NV_GPU_POWER_POLICY_STATUS_WORKLOAD_FREQ_INPUT freq;
    /*!
     * The current workload value for this iteration which will be fed into the
     * median filter.
     */
    NvU32 workloadmWperMHzmV2;
} NV_GPU_POWER_POLICY_STATUS_WORKLOAD_V1;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_STATUS_V1.  Stucture representing
 * WORKLOAD-specific POWER_POLICY dynamic status.
 */
typedef struct
{
    /*!
     * Must always be first in structure.
     */
    NV_GPU_POWER_POLICY_STATUS_DOMGRP_V2           domGrp;
    NV_GPU_POWER_POLICY_STATUS_WORKLOAD_WORK_INPUT work;
    NV_GPU_POWER_POLICY_STATUS_WORKLOAD_FREQ_INPUT freq;
    /*!
     * The current workload value for this iteration which will be fed into the
     * median filter.
     */
    NvU32 workloadmWperMHzmV2;
} NV_GPU_POWER_POLICY_STATUS_WORKLOAD_V2;

#define NV_GPU_POWER_POLICY_STATUS_MAX_LIMIT_INPUTS                          0x4
#define NV_GPU_POWER_POLICY_STATUS_MAX_LIMIT_INPUTS_EXTRA                    0x2

/*!
 * Special POWER_POLICY index for \ref NV_GPU_POWER_POLICY_STATUS_LIMIT_INPUT
 * structure.  This is the policy value specified/desired by the RM PWR code.
 * This entry holds the default/desired value from the Power Policy Table and
 * any user/client-requested tweaks to the POWER_POLICY value.
 */
#define NV_GPU_POWER_POLICY_STATUS_LIMIT_INPUT_POLICY_IDX_RM                0xFF

/*!
 * Used in \ref NV_GPU_POWER_POLICY_STATUS_LIMIT_INPUTS.  Structure representing
 * an input/requested POWER_POLICY limit value from other clients (other
 * POWER_POLICYs or the RM).  Each POWER_POLICY object arbitrates between its
 * requested values to apply the lowest value.
 */
typedef struct
{
    /*!
     * POWER_POLICY index for the client which requested this limit value.
     *
     * \note Special value NV_GPU_POWER_POLICY_STATUS_LIMIT_INPUT_POLICY_IDX_RM
     * is used to denote the value requested by the RM.
     */
    NvU8 pwrPolicyIdx;
    /*!
     * Limit value requested by the client.  In units as specified in @ref
     * NV_GPU_POWER_POLICY_INFO_V1::limitUnit.
     */
    NvU32 limitValue;
} NV_GPU_POWER_POLICY_STATUS_LIMIT_INPUT;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_STATUS_V1.  Structure repesenting the
 * current set of active NV_GPU_POWER_POLICY_STATUS_LIMIT_INPUTs, by which
 * clients can request limit values for a given POWER_POLICY.  The POWER_POLICY
 * will arbitrate between all these entries (picking the lowest value) to
 * determine the current limit value.
 */
typedef struct
{
    /*!
     * Current number of active limits.  Will always be <= \ref
     * NV_GPU_POWER_POLICY_STATUS_MAX_LIMIT_INPUTS.
     */
    NvU8 numInputs;
    /*!
     * Array of NV_GPU_POWER_POLICY_STATUS_LIMIT_INPUT entries.  Has valid
     * indexes in the range of [0, \ref numInputs).
     */
    NV_GPU_POWER_POLICY_STATUS_LIMIT_INPUT
        inputs[NV_GPU_POWER_POLICY_STATUS_MAX_LIMIT_INPUTS];
} NV_GPU_POWER_POLICY_STATUS_LIMIT_INPUTS;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_STATUS_V4.  Structure repesenting extra
 * \ref NV_GPU_POWER_POLICY_STATUS_LIMIT_INPUT per policy.
 */
typedef struct
{
    /*!
     * Array of extra NV_GPU_POWER_POLICY_STATUS_LIMIT_INPUT entries.
     */
    NV_GPU_POWER_POLICY_STATUS_LIMIT_INPUT
        inputs[NV_GPU_POWER_POLICY_STATUS_MAX_LIMIT_INPUTS_EXTRA];
} NV_GPU_POWER_POLICY_STATUS_LIMIT_INPUTS_EXTRA;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_STATUS_V1.  Structure repesenting the
 * current set of active NV_GPU_POWER_POLICY_STATUS_LIMIT_INPUTs, by which
 * clients can request limit values for a given POWER_POLICY.  The POWER_POLICY
 * will arbitrate between all these entries (picking the lowest value) to
 * determine the current limit value.
 */
typedef struct _NV_GPU_POWER_POLICY_STATUS_HW_THRESHOLD
{
    /*!
     * violation counter number.
     */
    NvU32       violationCnt;
} NV_GPU_POWER_POLICY_STATUS_HW_THRESHOLD;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_STATUS_V1.  Structure repesenting the
 * current set of active NV_GPU_POWER_POLICY_STATUS_LIMIT_INPUTs, by which
 * clients can request limit values for a given POWER_POLICY.  The POWER_POLICY
 * will arbitrate between all these entries (picking the lowest value) to
 * determine the current limit value.
 */
typedef struct _NV_GPU_POWER_POLICY_STATUS_VIOLATION_CONTROL
{
    /*!
     * HW_THRESHOLD specific data.
     */
    NV_GPU_POWER_POLICY_STATUS_HW_THRESHOLD hwThreshold;
    /*!
     * violation rate.
     */
    NvU32       violationRate;
    /*!
     * target power limit. Units in (milliwatt).
     */
    NvU32       targetPLimitmW;
} NV_GPU_POWER_POLICY_STATUS_VIOLATION_CONTROL;

/*!
 * Maximum number of PWR_POLICY_RELATIONSHIP_BALANCE objects which a
 * PWR_POLICY_BALANCE object can reference.  This value is used specify the
 * maximum array size possible for sorting buffer.
 */
#define NV_GPU_POWER_POLICY_STATUS_BALANCE_MAX_RELATIONSHIP_ENTRIES            4

/*!
 * Used in \ref NV_GPU_POWER_POLICY_STATUS_BALANCE.
 *
 * Structure representing a POWER_POLICY_RELATIONSHIP_BALANCE object's dynamic
   state data within a POWER_POLICY_BALANCE object.
 */
typedef struct _NV_GPU_POWER_POLICY_STATUS_BALANCE_RELATIONSHIP_ENTRY
{
    /*!
     * Index of PWR_POLICY_RELATIONSHIP_BALANCE object corresponding to this entry.
     */
    NvU8  relIdx;
    /*!
     * Lower requested limit from either of the two PWR_POLICY objects to which
     * the corresponding PWR_POLICY_RELATIONSHIP_BALANCE object points.
     */
    NvU32 limitLower;
    /*!
     * Difference between lower and higher limits of the two PWR_POLICY objects
     * to which the corresponding PWR_POLICY_RELATIONSHIP_BALANCE object points.
     */
    NvU32 limitDiff;
} NV_GPU_POWER_POLICY_STATUS_BALANCE_RELATIONSHIP_ENTRY;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_STATUS_V1.
 */
typedef struct _NV_GPU_POWER_POLICY_STATUS_BALANCE
{
    NV_GPU_POWER_POLICY_STATUS_BALANCE_RELATIONSHIP_ENTRY
        relEntries[NV_GPU_POWER_POLICY_STATUS_BALANCE_MAX_RELATIONSHIP_ENTRIES];
} NV_GPU_POWER_POLICY_STATUS_BALANCE;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_STATUS_V1.
 */
typedef struct _NV_GPU_POWER_POLICY_STATUS_PROP_LIMIT
{
    /*!
     * Boolean indicating whether this PWR_POLICY_PROP_LIMIT object has been
     * dirtied by the @ref PWR_POLICY_BALANCE algorithm (via @ref
     * PWR_POLICY_RELATIONSHIP_BALANCE) and thus its capping request may be
     * inaccurate.
     */
    NvU8 bBalanceDirty;
} NV_GPU_POWER_POLICY_STATUS_PROP_LIMIT;

/*!
 * Enumeration of actions the PWR_GEMINI controller can take in an iteration.
 *
 * _TO_SLAVE - One delta step shifted to the SLAVE GPU
 * _NONE - No action
 * _MASTER - One delta step shifted to the MASTER GPU
 */
#define NV_GPU_POWER_POLICY_GEMINI_ACTION_TO_SLAVE                            -1
#define NV_GPU_POWER_POLICY_GEMINI_ACTION_NONE                                 0
#define NV_GPU_POWER_POLICY_GEMINI_ACTION_TO_MASTER                            1

/*!
 * Structure representing the dynamic state of a PWR_POLICY_GEMINI object/GPU
 * within a PWR_GEMINI controller.
 */
typedef struct
{
    /*!
     * The average frequency (kHz) for the previous sampling iteration.
     */
    NvU32 freqAvgkHz;
} NV_GPU_POWER_POLICY_STATUS_GEMINI_CONTROLLER_GPU;

/*!
 * Structure representing the dynamic state of a PWR_GEMINI object.
 */
typedef struct
{
    /*!
     * Balancing action taken during the previous iteration.  Stored here so it
     * can returned via @ref NV2080_CTRL_CMD_PMGR_PWR_POLICY_GET_STATUS for
     * debugging.
     *
     * @ref NV_GPU_POWER_POLICY_GEMINI_ACTION_<xyz>
     */
    NvS8   action;

    /*!
     * Flag indicating whether the PWR_GEMINI algorithm is currently enabled.
     */
    NvU8   bEnable;

    /*!
     * The limit delta value currently shifted to the MASTER gpu.  The SLAVE gpu
     * delta is just this value negated.
     */
    NvS32  limitDelta;

    /*!
     * GPU-specific state.
     */
    NV_GPU_POWER_POLICY_STATUS_GEMINI_CONTROLLER_GPU
        gpus[NV_GPU_POWER_POLICY_GEMINI_MAX_GPUS];
} NV_GPU_POWER_POLICY_STATUS_GEMINI_CONTROLLER;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_STATUS_V2.
 */
typedef struct _NV_GPU_POWER_POLICY_STATUS_GEMINI
{
    /*!
     * Status of the PWR_GEMINI object associated with this PWR_POLICY_GEMINI
     * object.
     */
    NV_GPU_POWER_POLICY_STATUS_GEMINI_CONTROLLER controller;
} NV_GPU_POWER_POLICY_STATUS_GEMINI;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_STATUS_PARAMS_V4. This structure represents
 * extra space for new Power Policy features to be added in, without a new
 * version.
 */
typedef struct
{
    /*!
     * Additional fields to represent two more limitInputs per policy.
     */
    NV_GPU_POWER_POLICY_STATUS_LIMIT_INPUTS_EXTRA  limitInputsExtra;
    /*!
     * Reserving extra space for future enhancement.
     */
    NvU8    rsvd[32];
} NV_GPU_POWER_POLICY_STATUS_EXTRA;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_STATUS_PARAMS_V1.  Structure of representing
 * the dynamic state associated with a POWER_POLICY entry.
 */
typedef struct
{
    /*!
     * NV_GPU_POWER_POLICY_TYPE_<xyz>.
     */
    NV_GPU_POWER_POLICY_TYPE type;

    /*!
     * Current limit value this POWER_POLICY object is enforcing.  This is the
     * arbitrated output (lowest) of all the
     * NV_GPU_POWER_POLICY_STATUS_LIMIT_INPUT entries specified in \ref
     * limitInputs.  Will always be within range of [\ref
     * NV_GPU_POWER_POLICY_INFO_V1::limitMin, \ref
     * NV_GPU_POWER_POLICY_INFO_V1::limitMax].
     */
    NvU32  limitCurr;
    /*!
     * Current value retreived from the monitored POWER_CHANNEL.
     */
    NvU32  valueCurr;

    /*!
     * Current state of this PWR_POLICY's set of
     * NV_GPU_POWER_POLICY_STATUS_LIMIT_INPUTs.
     */
    NV_GPU_POWER_POLICY_STATUS_LIMIT_INPUTS limitInputs;

    /*!
     * Reserving 16 bytes reserved for future use w/o needing to add new structure
     * version.
     */
    NvU8  rsvd[16];

    /*!
     * Type-specific dynamic state.
     */
    union
    {
        NV_GPU_POWER_POLICY_STATUS_DOMGRP_V1            domGrp;
        NV_GPU_POWER_POLICY_STATUS_NDIV                 ndiv;
        NV_GPU_POWER_POLICY_STATUS_BANG_BANG_VF_V1      bangBangVf;
        NV_GPU_POWER_POLICY_STATUS_MARCH_N              marchN;
        NV_GPU_POWER_POLICY_STATUS_MARCH_N_BA00         marchNBA00;
        NV_GPU_POWER_POLICY_STATUS_MARCH_VF_V1          marchVF;
        NV_GPU_POWER_POLICY_STATUS_MARCH_VF_BA00        marchVFBA00;
        NV_GPU_POWER_POLICY_STATUS_WORKLOAD_V1          workload;
        NV_GPU_POWER_POLICY_STATUS_HW_THRESHOLD         hwThreshold;
        NV_GPU_POWER_POLICY_STATUS_VIOLATION_CONTROL    vControl;
    } data;
} NV_GPU_POWER_POLICY_STATUS_V1;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_STATUS_PARAMS_V2. Structure of representing
 * the dynamic state associated with a POWER_POLICY entry.
 */
typedef struct
{
    /*!
     * NV_GPU_POWER_POLICY_TYPE_<xyz>.
     */
    NV_GPU_POWER_POLICY_TYPE type;

    /*!
     * Current limit value this POWER_POLICY object is enforcing.  This is the
     * arbitrated output (lowest) of all the
     * NV_GPU_POWER_POLICY_STATUS_LIMIT_INPUT entries specified in \ref
     * limitInputs.  Will always be within range of [\ref
     * NV_GPU_POWER_POLICY_INFO_V1::limitMin, \ref
     * NV_GPU_POWER_POLICY_INFO_V1::limitMax].
     */
    NvU32  limitCurr;
    /*!
     * Current value retreived from the monitored POWER_CHANNEL.
     */
    NvU32  valueCurr;

    /*!
     * Current state of this PWR_POLICY's set of
     * NV_GPU_POWER_POLICY_STATUS_LIMIT_INPUTs.
     */
    NV_GPU_POWER_POLICY_STATUS_LIMIT_INPUTS limitInputs;

    /*!
     * Delta which should be applied to arbitrated output of all limit values.
     * This balancing delta is adjusted via inter-GPU balancing algorithms which
     * are trying to optimize the power distribution to achieve maximal perf for
     * the given power limits.  Those algorithms will be transferring power
     * from one GPU to another behind the back of the user, so we don't want to
     * actually change the specified limit values or report this value back to
     * the user.
     */
    NvS32 limitDelta;

    /*!
     * Reserving 12 bytes reserved for future use w/o needing to add new structure
     * version.
     */
    NvU8  rsvd[12];

    /*!
     * Type-specific dynamic state.
     */
    union
    {
        NV_GPU_POWER_POLICY_STATUS_DOMGRP_V1            domGrp;
        NV_GPU_POWER_POLICY_STATUS_NDIV                 ndiv;
        NV_GPU_POWER_POLICY_STATUS_BANG_BANG_VF_V1      bangBangVf;
        NV_GPU_POWER_POLICY_STATUS_MARCH_N              marchN;
        NV_GPU_POWER_POLICY_STATUS_MARCH_N_BA00         marchNBA00;
        NV_GPU_POWER_POLICY_STATUS_MARCH_VF_V1          marchVF;
        NV_GPU_POWER_POLICY_STATUS_MARCH_VF_BA00        marchVFBA00;
        NV_GPU_POWER_POLICY_STATUS_WORKLOAD_V1          workload;
        NV_GPU_POWER_POLICY_STATUS_HW_THRESHOLD         hwThreshold;
        NV_GPU_POWER_POLICY_STATUS_VIOLATION_CONTROL    vControl;
        NV_GPU_POWER_POLICY_STATUS_BALANCE              balance;
        NV_GPU_POWER_POLICY_STATUS_PROP_LIMIT           propLimit;
        NV_GPU_POWER_POLICY_STATUS_GEMINI               gemini;

        /*!
         * Reserving 48 bytes of space so can add new types without needing to
         * add a new version.
         */
        NvU8 rsvd[48];
    } data;
} NV_GPU_POWER_POLICY_STATUS_V2;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_STATUS_PARAMS_V2. Structure of representing
 * the dynamic state associated with a POWER_POLICY entry.
 */
typedef struct
{
    /*!
     * NV_GPU_POWER_POLICY_TYPE_<xyz>.
     */
    NV_GPU_POWER_POLICY_TYPE type;

    /*!
     * Current limit value this POWER_POLICY object is enforcing.  This is the
     * arbitrated output (lowest) of all the
     * NV_GPU_POWER_POLICY_STATUS_LIMIT_INPUT entries specified in \ref
     * limitInputs.  Will always be within range of [\ref
     * NV_GPU_POWER_POLICY_INFO_V1::limitMin, \ref
     * NV_GPU_POWER_POLICY_INFO_V1::limitMax].
     */
    NvU32  limitCurr;
    /*!
     * Current value retreived from the monitored POWER_CHANNEL.
     */
    NvU32  valueCurr;

    /*!
     * Current state of this PWR_POLICY's set of
     * NV_GPU_POWER_POLICY_STATUS_LIMIT_INPUTs.
     */
    NV_GPU_POWER_POLICY_STATUS_LIMIT_INPUTS limitInputs;

    /*!
     * Delta which should be applied to arbitrated output of all limit values.
     * This balancing delta is adjusted via inter-GPU balancing algorithms which
     * are trying to optimize the power distribution to achieve maximal perf for
     * the given power limits.  Those algorithms will be transferring power
     * from one GPU to another behind the back of the user, so we don't want to
     * actually change the specified limit values or report this value back to
     * the user.
     */
    NvS32 limitDelta;
    /*!
     * The accumulated sum of differences between
     * the current power value and current policy limit.
     */
    NvS32   currRunningDiff;
    /*!
     * The new calculated power limit for all the future samples.
     */
    NvS32   currIntegralLimit;

    /*!
     * Reserving 4 bytes reserved for future use w/o needing to add new structure
     * version.
     */
    NvU8  rsvd[4];

    /*!
     * Type-specific dynamic state.
     */
    union
    {
        NV_GPU_POWER_POLICY_STATUS_DOMGRP_V2            domGrp;
        NV_GPU_POWER_POLICY_STATUS_NDIV                 ndiv;
        NV_GPU_POWER_POLICY_STATUS_BANG_BANG_VF_V2      bangBangVf;
        NV_GPU_POWER_POLICY_STATUS_MARCH_N              marchN;
        NV_GPU_POWER_POLICY_STATUS_MARCH_N_BA00         marchNBA00;
        NV_GPU_POWER_POLICY_STATUS_MARCH_VF_V2          marchVF;
        NV_GPU_POWER_POLICY_STATUS_MARCH_VF_BA00        marchVFBA00;
        NV_GPU_POWER_POLICY_STATUS_WORKLOAD_V2          workload;
        NV_GPU_POWER_POLICY_STATUS_HW_THRESHOLD         hwThreshold;
        NV_GPU_POWER_POLICY_STATUS_VIOLATION_CONTROL    vControl;
        NV_GPU_POWER_POLICY_STATUS_BALANCE              balance;
        NV_GPU_POWER_POLICY_STATUS_PROP_LIMIT           propLimit;
        NV_GPU_POWER_POLICY_STATUS_GEMINI               gemini;

       /*!
        * Reserving 48 bytes of space so can add new types without needing to
        * add a new version.
        */
        NvU8 rsvd[48];
    } data;
} NV_GPU_POWER_POLICY_STATUS_V3;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_V1.
 *
 * Structure representing a PWR_POLICY_RELATIONSHIP_BALANCE object's dynamic
 * state.
 */
typedef struct _NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_BALANCE_PROP_LIMIT
{
    /*!
     * Boolean indicating whether this PWR_POLICY_PROP_LIMIT object has been
     * dirtied by the @ref PWR_POLICY_BALANCE algorithm (via @ref
     * PWR_POLICY_RELATIONSHIP_BALANCE) and thus its capping request may be
     * inaccurate.
     */
    NvU8  bBalanceDirty;
    /*!
     * The input value (@ref PWR_POLICY::valueCurr) of the
     * PWR_POLICY_PROP_LIMIT object when evaluation begins.
     */
    NvS32 valueOld;
    /*!
     * The updated input value (@ref PWR_POLICY::valueCurr) of the
     * PWR_POLICY_PROP_LIMIT object after evaluation completes.
     */
    NvS32 valueNew;
    /*!
     * The requested limit (via @ref PWR_POLICY_RELATIONSHIP) of the
     * PWR_POLICY_PROP_LIMIT object when evaluation begins.
     */
    NvS32 limitRequestOld;
    /*!
     * The updated requested limit (via @ref PWR_POLICY_RELATIONSHIP) of the
     * PWR_POLICY_PROP_LIMIT object after evaluation completes.
     */
    NvS32 limitRequestNew;
} NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_BALANCE_PROP_LIMIT;

/*!
 * Macros defining the actions the PWR_POLICY_RELATIONSHIP_BALANCE object took
 * for the most recent iteration.
 *
 * _NONE - No action was taken to shift power.
 * _TO_PRI - Power was shifted to the primary PWR_POLICY_PROP_LIMIT object.
 * _TO_SEC - Power was shifted to the secondary PWR_POLICY_PROP_LIMIT object.
 */
#define NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_BALANCE_ACTION_NONE     0x0
#define NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_BALANCE_ACTION_TO_PRI   0x1
#define NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_BALANCE_ACTION_TO_SEC   0x2

/*!
 * Macros for indexes into @ref
 * NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_BALANCE::propLimits[] array.
 *
 * _PRI - The primary policy index - i.e. PWR_POLICY_RELATIONSHIP::policyIdx
 * _SEC - The secondary policy index - i.e.
 *      PWR_POLICY_RELATIONSHIP_BALANCE::secPolicyIdx.
 */
#define NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_BALANCE_PROP_LIMIT_PRI  0x0
#define NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_BALANCE_PROP_LIMIT_SEC  0x1
#define NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_BALANCE_MAX_PROP_LIMITS 0x2

/*!
 * Used in \ref NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_V1.
 */
typedef struct _NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_BALANCE
{
    /*!
     * @ref NV2080_CTRL_PMGR_PWR_POLICY_RELATIONSHIP_STATUS_BALANCE_ACTION_<xyz>
     */
    NvS8  action;
    /*!
     * Current PWM percent driven out on the balancing circuit's GPIO.  Unitless
     * UFXP 16.16 value.
     */
    NvU32 pwmPctCurr;
    /*!
     * Array of structures describing the dynamic state of both
     * PWR_POLICY_PROP_LIMIT objects.
     */
    NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_BALANCE_PROP_LIMIT
        propLimits[NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_BALANCE_MAX_PROP_LIMITS];
} NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_BALANCE;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_STATUS_PARAMS_V2  Structure of representing
 * the dynamic state associated with a POWER_POLICY_RELATIONSHIP entry.
 */
typedef struct
{
    /*!
     * NV_GPU_POWER_POLICY_RELATIONSHIP_TYPE_<xyz>.
     */
    NV_GPU_POWER_POLICY_RELATIONSHIP_TYPE type;

    /*!
     * Reserving 16 bytes for future use w/o needing to add new structure
     * version.
     */
    NvU8  rsvd[16];

    /*!
     * Type-specific dynamic state.
     */
    union
    {
        NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_BALANCE  balance;

        /*!
         * Reserving 48 bytes for future use w/o needing to add new structure
         * version.
         */
        NvU8 rsvd[48];
    } data;
} NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_V1;

/*!
 * Used in \ref NvAPI_GPU_PowerPolicyGetStatus.  Structure representing the
 * dynamic status information associated with a set of POWER_POLICYs within the
 * GPU's POWER_POLICY functionality.
 */
typedef struct
{
    /*!
     * Version of structure.  Must always be first.
     */
    NvU32  version;

    /*!
     * Mask of POWER_POLICY entries requested by the client.
     */
    NvU32 policyMask;

    /*!
     * The current arbitrated output domain group limit values the PMU
     * POWER_POLICY functionality is applying to the GPU.  The current arbitration
     * algorithm is to apply the minimum values of all PWR_POLICYs.  The RM
     * feeds this value into the PERF PERF_LIMIT infrastructure for clock
     * arbitration.
     */
    NV_GPU_POWER_POLICY_STATUS_DOMAIN_GROUP_LIMITS domGrpLimits;

    /*!
     * Reserving 16 bytes reserved for future use w/o needing to add new structure
     * version.
     */
    NvU8  rsvd[16];

    /*!
     * Array of POWER_POLICY entries.  Has valid indexes corresponding to
     * the bits set in \ref policyMask.
     */
    NV_GPU_POWER_POLICY_STATUS_V1 policies[NV_GPU_POWER_POLICY_MAX_POLICIES_V1];
} NV_GPU_POWER_POLICY_STATUS_PARAMS_V1;

/*!
 * Used in \ref NvAPI_GPU_PowerPolicyGetStatus.  Structure representing the
 * dynamic status information associated with a set of POWER_POLICYs within the
 * GPU's POWER_POLICY functionality.
 */
typedef struct
{
    /*!
     * Version of structure.  Must always be first.
     */
    NvU32  version;

    /*!
     * Mask of POWER_POLICY entries requested by the client.
     */
    NvU32  policyMask;

    /*!
     * The current arbitrated output domain group limit values the PMU
     * POWER_POLICY functionality is applying to the GPU.  The current arbitration
     * algorithm is to apply the minimum values of all PWR_POLICYs.  The RM
     * feeds this value into the PERF PERF_LIMIT infrastructure for clock
     * arbitration.
     */
    NV_GPU_POWER_POLICY_STATUS_DOMAIN_GROUP_LIMITS domGrpLimits;

    /*!
     * Mask of POWER_POLICY_RELATIONSHIP entries specified on this GPU.
     */
    NvU32  policyRelMask;

    /*!
     * Reserving 32 bytes reserved for future use w/o needing to add new structure
     * version.
     */
    NvU8  rsvd[32];

    /*!
     * Array of POWER_POLICY entries.  Has valid indexes corresponding to
     * the bits set in \ref policyMask.
     */
    NV_GPU_POWER_POLICY_STATUS_V2 policies[NV_GPU_POWER_POLICY_MAX_POLICIES_V1];

    /*!
     * Array of POWER_POLICY_RELATIONSHIP entries.  Has valid indexes
     * corresponding to the bits set in \ref policyRelMask.
     */
    NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_V1
        policyRels[NV_GPU_POWER_POLICY_MAX_POLICY_RELATIONSHIPS_V1];
} NV_GPU_POWER_POLICY_STATUS_PARAMS_V2;

/*!
 * Used in \ref NvAPI_GPU_PowerPolicyGetStatus.  Structure representing the
 * dynamic status information associated with a set of POWER_POLICYs within the
 * GPU's POWER_POLICY functionality.
 */
typedef struct
{
    /*!
     * Version of structure.  Must always be first.
     */
    NvU32  version;

    /*!
     * Mask of POWER_POLICY entries requested by the client.
     */
    NvU32  policyMask;

    /*!
     * The current arbitrated output domain group limit values the PMU
     * POWER_POLICY functionality is applying to the GPU.  The current arbitration
     * algorithm is to apply the minimum values of all PWR_POLICYs.  The RM
     * feeds this value into the PERF PERF_LIMIT infrastructure for clock
     * arbitration.
     */
    NV_GPU_POWER_POLICY_STATUS_DOMAIN_GROUP_LIMITS domGrpLimits;

    /*!
     * Mask of POWER_POLICY_RELATIONSHIP entries specified on this GPU.
     */
    NvU32  policyRelMask;

    /*!
     * Reserving 32 bytes reserved for future use w/o needing to add new structure
     * version.
     */
    NvU8  rsvd[32];

    /*!
     * Array of POWER_POLICY entries.  Has valid indexes corresponding to
     * the bits set in \ref policyMask.
     */
    NV_GPU_POWER_POLICY_STATUS_V3 policies[NV_GPU_POWER_POLICY_MAX_POLICIES_V1];

    /*!
     * Array of POWER_POLICY_RELATIONSHIP entries.  Has valid indexes
     * corresponding to the bits set in \ref policyRelMask.
     */
    NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_V1
        policyRels[NV_GPU_POWER_POLICY_MAX_POLICY_RELATIONSHIPS_V1];
} NV_GPU_POWER_POLICY_STATUS_PARAMS_V3;

/*!
 * Used in \ref NvAPI_GPU_PowerPolicyGetStatus.  Structure representing the
 * dynamic status information associated with a set of POWER_POLICYs within the
 * GPU's POWER_POLICY functionality.
 */
typedef struct
{
    /*!
     * Version of structure.  Must always be first.
     */
    NvU32  version;

    /*!
     * Mask of POWER_POLICY entries requested by the client.
     */
    NvU32  policyMask;

    /*!
     * The current arbitrated output domain group limit values the PMU
     * POWER_POLICY functionality is applying to the GPU.  The current arbitration
     * algorithm is to apply the minimum values of all PWR_POLICYs.  The RM
     * feeds this value into the PERF PERF_LIMIT infrastructure for clock
     * arbitration.
     */
    NV_GPU_POWER_POLICY_STATUS_DOMAIN_GROUP_LIMITS domGrpLimits;

    /*!
     * Mask of POWER_POLICY_RELATIONSHIP entries specified on this GPU.
     */
    NvU32  policyRelMask;

    /*!
     * Reserving 32 bytes reserved for future use w/o needing to add new structure
     * version.
     */
    NvU8  rsvd[32];

    /*!
     * Array of POWER_POLICY entries.  Has valid indexes corresponding to
     * the bits set in \ref policyMask.
     */
    NV_GPU_POWER_POLICY_STATUS_V3 policies[NV_GPU_POWER_POLICY_MAX_POLICIES_V1];

    /*!
     * Array of POWER_POLICY_RELATIONSHIP entries.  Has valid indexes
     * corresponding to the bits set in \ref policyRelMask.
     */
    NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_V1
        policyRels[NV_GPU_POWER_POLICY_MAX_POLICY_RELATIONSHIPS_V1];

    /*!
     * Power Policy Extra - extra bits for new power policy features.
     */
    NV_GPU_POWER_POLICY_STATUS_EXTRA    policyExtras[NV_GPU_POWER_POLICY_MAX_POLICIES_V1];
} NV_GPU_POWER_POLICY_STATUS_PARAMS_V4;

#define NV_GPU_POWER_POLICY_STATUS_PARAMS_VER_1   MAKE_NVAPI_VERSION(NV_GPU_POWER_POLICY_STATUS_PARAMS_V1,1)
#define NV_GPU_POWER_POLICY_STATUS_PARAMS_VER_2   MAKE_NVAPI_VERSION(NV_GPU_POWER_POLICY_STATUS_PARAMS_V2,1)
#define NV_GPU_POWER_POLICY_STATUS_PARAMS_VER_3   MAKE_NVAPI_VERSION(NV_GPU_POWER_POLICY_STATUS_PARAMS_V3,1)
#define NV_GPU_POWER_POLICY_STATUS_PARAMS_VER_4   MAKE_NVAPI_VERSION(NV_GPU_POWER_POLICY_STATUS_PARAMS_V4,1)
#define NV_GPU_POWER_POLICY_STATUS_PARAMS_VER     NV_GPU_POWER_POLICY_STATUS_PARAMS_VER_4

#define NV_GPU_POWER_POLICY_STATUS_PARAMS         NV_GPU_POWER_POLICY_STATUS_PARAMS_V4

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    NvAPI_GPU_PowerPolicyGetStatus()
//
//! DESCRIPTION:     Retrieves the current dynamic state of a set of POWER_POLICY
//!                  entries on the GPU.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version:  295.40
//!
//! \param [in]      hPhysicalGPU   GPU selection
//! \param [in/out]  pPolicyStatus  Structure containing the state of a set of POWER_POLICYs.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gpupower
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_PowerPolicyGetStatus(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_POWER_POLICY_STATUS_PARAMS *pPolicyStatus);




//! \ingroup gpupower
//! @{

/*!
 */
typedef struct
{
    /*!
     * Ratio to by which scale clock changes up.
     *
     * Unsigned FXP 4.12 value.  Unitless.
     */
    NvU16  clkUpScale;
    /*!
     * Ratio to by which scale clock changes down.
     *
     * Unsigned FXP 4.12 value.  Unitless.
     */
    NvU16  clkDownScale;
    /*!
     * Size of the workload median filter.
     *
     * \Note This values has be deprecated in favor of \ref
     * NV_GPU_POWER_POLICY_WORKLOAD_INFO::medianFilterSize.  This value will no
     * longer be populated by \ref NvAPI_GPU_PowerPolicyGetControl() nor will it
     * have any functional impact when provided to \ref
     * NvAPI_GPU_PowerPolicySetControl().
     */
    NvU8   medianFilterSize;
} NV_GPU_POWER_POLICY_WORKLOAD_CONTROL;

/*!
 * Used in \ref NV_GPU_POWER_POLICY_CONTROL_PARAMS_V1.  Structure repsenting the
 * control/policy parameters of a POWER_POLICY entry.
 */
typedef struct
{
    /*!
     * NV_GPU_POWER_POLICY_TYPE_<xyz>.
     */
    NV_GPU_POWER_POLICY_TYPE type;

    /*!
     * Current limit value to enforce as requested by a client.  Must always be
     * within range of [\ref NV_GPU_POWER_POLICY_INFO_V1::limitMin, \ref
     * NV_GPU_POWER_POLICY_INFO_V1::limitMax].
     */
    NvU32  limitCurr;

    /*!
     * Reserving 16 bytes reserved for future use w/o needing to add new structure
     * version.
     */
    NvU8  rsvd[16];

    /*!
     * Type-specific data.
     */
    union
    {
        NV_GPU_POWER_POLICY_WORKLOAD_CONTROL workload;
        /*!
         * Reserving 16 bytes reserved for future use w/o needing to add new structure
         * version.
         */
        NvU8  rsvd[16];
    } data;
} NV_GPU_POWER_POLICY_CONTROL_V1;

/*!
 */
typedef struct
{
    /*!
     * Boolean indicating that the BALANCE relationship's PWM value should be
     * locked to a simulated value, overriding the behavior of the BALANCE
     * relationship controller.
     */
    NvU8  bPwmSim;
    /*!
     * The PWM value (specified as unsigned FXP 16.16) used to simulate.  This
     * value is only applied when @ref bPwmSim == NV_TRUE.
     */
    NvU32 pwmPctSim;
} NV_GPU_POWER_POLICY_RELATIONSHIP_CONTROL_BALANCE;

/*!
 */
typedef struct
{
    /*!
     * NV_GPU_POWER_POLICY_RELATIONSHIP_TYPE_<xyz>.
     */
    NV_GPU_POWER_POLICY_RELATIONSHIP_TYPE type;

    /*!
     * Reserving 16 bytes for future use w/o needing to add new structure
     * version.
     */
    NvU8  rsvd[16];

    /*!
     * Type-specific dynamic state.
     */
    union
    {
        NV_GPU_POWER_POLICY_RELATIONSHIP_CONTROL_BALANCE balance;
        /*!
         * Reserving 48 bytes for future use w/o needing to add new structure
         * version.
         */
        NvU8 rsvd[48];
    } data;
} NV_GPU_POWER_POLICY_RELATIONSHIP_CONTROL_V1;

/*!
 * Used in \ref NvAPI_GPU_PowerPolicyGetControl, \ref NvAPI_GPU_PowerPolicySetControl.
 * Structure representing the control/policy parameters associated with a set of
 * POWER_POLICY entries in the GPU's POWER_POLICY power policy functionality.
 */
typedef struct
{
    /*!
     * Version of structure.  Must always be first.
     */
    NvU32  version;

    /*!
     * Mask of POWER_POLICY entries requested by the client.
     */
    NvU32 policyMask;

    /*!
     * Reserving 16 bytes reserved for future use w/o needing to add new structure
     * version.
     */
    NvU8  rsvd[16];

    /*!
     * Array of POWER_POLICY entries.  Has valid indexes corresponding to
     * the bits set in \ref policyMask.
     */
    NV_GPU_POWER_POLICY_CONTROL_V1 policies[NV_GPU_POWER_POLICY_MAX_POLICIES_V1];
} NV_GPU_POWER_POLICY_CONTROL_PARAMS_V1;

/*!
 * Used in \ref NvAPI_GPU_PowerPolicyGetControl, \ref NvAPI_GPU_PowerPolicySetControl.
 * Structure representing the control/policy parameters associated with a set of
 * POWER_POLICY entries in the GPU's POWER_POLICY power policy functionality.
 */
typedef struct
{
    /*!
     * Version of structure.  Must always be first.
     */
    NvU32  version;

    /*!
     * Mask of POWER_POLICY entries requested by the client.
     */
    NvU32 policyMask;

    /*!
     * Mask of POWER_POLICY_RELATIONSHIP entries requested by the client.
     */
    NvU32 policyRelMask;

    /*!
     * Reserving 16 bytes reserved for future use w/o needing to add new structure
     * version.
     */
    NvU8  rsvd[16];

    /*!
     * Array of POWER_POLICY entries.  Has valid indexes corresponding to
     * the bits set in \ref policyMask.
     */
    NV_GPU_POWER_POLICY_CONTROL_V1 policies[NV_GPU_POWER_POLICY_MAX_POLICIES_V1];

    /*!
     * Array of POWER_POLICY_RELATIONSHIP entries.  Has valid indexes corresponding to
     * the bits set in \ref policyMask.
     */
    NV_GPU_POWER_POLICY_RELATIONSHIP_CONTROL_V1
        policyRels[NV_GPU_POWER_POLICY_MAX_POLICY_RELATIONSHIPS_V1];
} NV_GPU_POWER_POLICY_CONTROL_PARAMS_V2;

#define NV_GPU_POWER_POLICY_CONTROL_PARAMS_VER_1   MAKE_NVAPI_VERSION(NV_GPU_POWER_POLICY_CONTROL_PARAMS_V1,1)
#define NV_GPU_POWER_POLICY_CONTROL_PARAMS_VER_2   MAKE_NVAPI_VERSION(NV_GPU_POWER_POLICY_CONTROL_PARAMS_V2,1)
#define NV_GPU_POWER_POLICY_CONTROL_PARAMS_VER     NV_GPU_POWER_POLICY_CONTROL_PARAMS_VER_2

#define NV_GPU_POWER_POLICY_CONTROL_PARAMS         NV_GPU_POWER_POLICY_CONTROL_PARAMS_V2

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    NvAPI_GPU_PowerPolicyGetControl()
//
//! DESCRIPTION:     This function retrieves the current control/policy of a set
//!                  of POWER_POLICY entries in the RM/PMU's POWER_POLICY
//!                  functionality.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version:  295.40
//!
//! \param [in]      hPhysicalGPU    GPU selection
//! \param [in/out]  pPolicyControl
//!     Structure containing the current control/policy of a set of
//!     POWER_POLICY entries.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gpupower
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_PowerPolicyGetControl(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_POWER_POLICY_CONTROL_PARAMS *pPolicyControl);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    NvAPI_GPU_PowerPolicySetControl()
//
//! DESCRIPTION:     This function requests the control/policy of a set
//!                  of POWER_POLICY entries in the RM/PMU's POWER_POLICY
//!                  functionality.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version:  295.40
//!
//! \param [in]      hPhysicalGPU    GPU selection
//! \param [in]      pPolicyControl
//!     Structure containing the requested control/policy of a set of
//!     POWER_POLICY entries.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \retval ::NVAPI_INVALID_USER_PRIVILEGE       - The caller does not have administrative privileges
//!
//! \ingroup gpupower
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_PowerPolicySetControl(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_POWER_POLICY_CONTROL_PARAMS *pPolicyControl);



//! \addtogroup gpupower
//! @{

/*!
 * Enumeration of Power Topology Channels.  Unique identifiers for different
 * power topology channels of the GPU.
 */
typedef enum
{
    NV_GPU_CLIENT_POWER_TOPOLOGY_CHANNEL_ID_TOTAL_GPU_POWER,
    NV_GPU_CLIENT_POWER_TOPOLOGY_CHANNEL_ID_NORMALIZED_TOTAL_POWER,
} NV_GPU_CLIENT_POWER_TOPOLOGY_CHANNEL_ID;

#define NV_GPU_CLIENT_POWER_CHANNEL_NUM_CHANNELS_V1    4

/*!
 * Used in \ref NV_GPU_CLIENT_POWER_TOPOLOGY_INFO_V1.
 */
typedef struct
{
    /*!
     * Topology Channel ID.  Unique identifier for a channel.
     */
    NV_GPU_CLIENT_POWER_TOPOLOGY_CHANNEL_ID channelId;

} NV_GPU_CLIENT_POWER_TOPOLOGY_CHANNEL_INFO_V1;

/*!
 * Used in \ref NvAPI_GPU_ClientPowerTopologyGetInfo().
 *
 * Describes the power topology of the GPU, including the set of channels
 * which are monitored.
 */
typedef struct
{
    /*!
     * Version of structure.  Must always be first.
     */
    NvU32  version;

    /*!
     * Indicates that this GPU supports Client Power Topology Interfaces.
     */
    NvU8   bSupported;

    /*!
     * Number of channels this GPU supports.
     */
    NvU8  numChannels;

    /*!
     * Array of static information for each Power Topology Channel.  This array
     * has a valid index ranging from 0 to numChannels - 1.
     */
    NV_GPU_CLIENT_POWER_TOPOLOGY_CHANNEL_INFO_V1
        channels[NV_GPU_CLIENT_POWER_CHANNEL_NUM_CHANNELS_V1];

} NV_GPU_CLIENT_POWER_TOPOLOGY_INFO_V1;

#define NV_GPU_CLIENT_POWER_TOPOLOGY_INFO_VER_1  MAKE_NVAPI_VERSION(NV_GPU_CLIENT_POWER_TOPOLOGY_INFO_V1,1)
#define NV_GPU_CLIENT_POWER_TOPOLOGY_INFO_VER    NV_GPU_CLIENT_POWER_TOPOLOGY_INFO_VER_1

#define NV_GPU_CLIENT_POWER_TOPOLOGY_INFO        NV_GPU_CLIENT_POWER_TOPOLOGY_INFO_V1

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_ClientPowerTopologyGetInfo
//
//! DESCRIPTION: Accessor for static information describing the public GPU
//!              power topology and capabilities.
//!
//!              Describes the power topology on the GPU, including the set of
//!              channels which are monitored and regularity with which they are
//!              monitored.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 295
//!
//! \param [in]  hPhysicalGPU             GPU selection
//! \param [out] pClientPowerTopologyInfo Structure containing the description
//!                  of the GPU power topology and capabilities
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gpupower
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_ClientPowerTopologyGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_CLIENT_POWER_TOPOLOGY_INFO *pClientPowerTopologyInfo);



//! \addtogroup gpupower
//! @{

/*!
 * Used in \ref NV_GPU_CLIENT_POWER_TOPOLOGY_CHANNEL_STATUS_V1
 * and \ref NV_GPU_CLIENT_POWER_POLICIES_POLICY_INFO_V1
 *
 * Describes single power value (reading or limit).
 */
typedef struct
{
    /*!
     * On output it denotes if power is also provided in [mW] units (absolute
     * power, available only on Quadro/Tesla).
     *
     * On input (when used within \ref NvAPI_GPU_ClientPowerPoliciesSetStatus)
     * it denotes if caller is trying to set limit using absolute power or
     * scaled power (percentage).
     */
    NvU32 bMilliWattValid:1;

    /*!
     * Reserved for future use.
     */
    NvU32 reserved:31;

    /*!
     * Power value in 0.001 [%] units (normalized to respective default TDP limit).
     */
    NvU32 mp;

    /*!
     * Power value in 1 [mW] units.
     */
    NvU32 mW;
} NV_GPU_CLIENT_POWER_READING_V1;

/*!
 * Used in \ref NV_GPU_CLIENT_POWER_TOPOLOGY_STATUS_V1.
 */
typedef struct
{
    /*!
     * Topology Channel ID.  Unique identifier for a channel.  Client will
     * specify this value if querying only certain channels.
     */
    NV_GPU_CLIENT_POWER_TOPOLOGY_CHANNEL_ID channelId;

    /*!
     * Latest power reading on specified channel.
     */
    NV_GPU_CLIENT_POWER_READING_V1 power;
} NV_GPU_CLIENT_POWER_TOPOLOGY_CHANNEL_STATUS_V1;

/*!
 * Used in \ref NvAPI_GPU_ClientPowerTopologyGetStatus().
 *
 * Retrieves the latest power readings (and other dynamic status) for a set of
 * topology channels.
 */
typedef struct
{
    /*!
     * Version of structure.  Must always be first.
     */
    NvU32  version;

    /*!
     * Number of channels this GPU supports.  Caller sets this value to 0 to
     * specify that all supported channels should be queried.
     */
    NvU8  numChannels;

    /*!
     * Array of latest power readings (and other status) for each specified Power
     * Topology Channel.  Array has a valid index ranging form 0 to numChannels - 1.
     */
    NV_GPU_CLIENT_POWER_TOPOLOGY_CHANNEL_STATUS_V1
        channels[NV_GPU_CLIENT_POWER_CHANNEL_NUM_CHANNELS_V1];

} NV_GPU_CLIENT_POWER_TOPOLOGY_STATUS_V1;

#define NV_GPU_CLIENT_POWER_TOPOLOGY_STATUS_VER_1  MAKE_NVAPI_VERSION(NV_GPU_CLIENT_POWER_TOPOLOGY_STATUS_V1,1)
#define NV_GPU_CLIENT_POWER_TOPOLOGY_STATUS_VER    NV_GPU_CLIENT_POWER_TOPOLOGY_STATUS_VER_1

#define NV_GPU_CLIENT_POWER_TOPOLOGY_STATUS        NV_GPU_CLIENT_POWER_TOPOLOGY_STATUS_V1

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_ClientPowerTopologyGetStatus
//
//! DESCRIPTION: Accessor for the public GPU power topology readings.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 295
//!
//! \param [in]    hPhysicalGPU               GPU selection
//! \param [inout] pClientPowerTopologyStatus Structure containing GPU power
//!                    topology readings.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gpupower
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_ClientPowerTopologyGetStatus(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_CLIENT_POWER_TOPOLOGY_STATUS *pClientPowerTopologyStatus);



//! \addtogroup gpupower
//! @{

/*!
 * Enumeration of Power Policies.  Unique identifiers for different Power
 * Policies being enforced on the GPU.
 */
typedef enum
{
    NV_GPU_CLIENT_POWER_POLICIES_POLICY_TOTAL_GPU_POWER,
} NV_GPU_CLIENT_POWER_POLICIES_POLICY_ID;

#define NV_GPU_CLIENT_POWER_POLICIES_NUM_POLICIES_V1         4

/*!
 * Used in \ref NV_GPU_CLIENT_POWER_POLICIES_INFO_V1.
 */
typedef struct
{
    /*!
     * Policy ID.  Unique identifier for a policy.
     */
    NV_GPU_CLIENT_POWER_POLICIES_POLICY_ID policyId;

    /*!
     * Topology channel ID this policy is controlling.
     */
    NV_GPU_CLIENT_POWER_TOPOLOGY_CHANNEL_ID channelId;

    /*!
     * Minimum allowed power policy limit.
     */
    NV_GPU_CLIENT_POWER_READING_V1 powerLimitMin;

    /*!
     * Default power policy limit.
     */
    NV_GPU_CLIENT_POWER_READING_V1 powerLimitDefault;

    /*!
     * Maximum allowed power policy limit.
     */
    NV_GPU_CLIENT_POWER_READING_V1 powerLimitMax;
} NV_GPU_CLIENT_POWER_POLICIES_POLICY_INFO_V1;

/*!
 * Used in \ref NV_GPU_CLIENT_POWER_POLICIES_INFO_V1.
 *
 * Describes the set of Power Policies which are controlling GPU power
 * consumption.
 */
typedef struct
{
    /*!
     * Version of structure.  Must always be first.
     */
    NvU32  version;

    /*!
     * Indicates that this GPU supports Client Power Policy Interfaces.
     */
    NvU8   bSupported;

    /*!
     * Number of Power Policies this GPU supports.
     */
    NvU8  numPolicies;

    /*!
     * Array of static information for each Power Policy.  Array has a valid
     * index ranging from 0 to numPolicies - 1.
     */
    NV_GPU_CLIENT_POWER_POLICIES_POLICY_INFO_V1
        policies[NV_GPU_CLIENT_POWER_POLICIES_NUM_POLICIES_V1];

} NV_GPU_CLIENT_POWER_POLICIES_INFO_V1;

#define NV_GPU_CLIENT_POWER_POLICIES_INFO_VER_1  MAKE_NVAPI_VERSION(NV_GPU_CLIENT_POWER_POLICIES_INFO_V1,1)
#define NV_GPU_CLIENT_POWER_POLICIES_INFO_VER    NV_GPU_CLIENT_POWER_POLICIES_INFO_VER_1

#define NV_GPU_CLIENT_POWER_POLICIES_INFO        NV_GPU_CLIENT_POWER_POLICIES_INFO_V1

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_ClientPowerPoliciesGetInfo
//
//! DESCRIPTION: Accessor for static information describing the public GPU
//!              power policies which are controlling GPU power consumption.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 295
//!
//! \param [in]  hPhysicalGPU             GPU selection
//! \param [out] pClientPowerPoliciesInfo Structure containing the description
//!                  of the GPU power policies.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gpupower
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_ClientPowerPoliciesGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_CLIENT_POWER_POLICIES_INFO *pClientPowerPoliciesInfo);





//! \addtogroup gpupower
//! @{

/*!
 * Used in \ref NV_GPU_CLIENT_POWER_POLICIES_STATUS_V1.
 */
typedef struct
{
    /*!
     * Policy ID.  Unique identifier for a policy.
     */
    NV_GPU_CLIENT_POWER_POLICIES_POLICY_ID policyId;

    /*!
     * Current power policy limit.
     */
    NV_GPU_CLIENT_POWER_READING_V1 powerLimit;

} NV_GPU_CLIENT_POWER_POLICIES_POLICY_STATUS_V1;

/*!
 * Used in \ref NV_GPU_CLIENT_POWER_POLICIES_STATUS_V1.
 *
 * Describes/specifies the current settings of a set of Power Policies which are
 * controlling GPU power consumption.
 */
typedef struct
{
    NvU32  version;

    /*!
     * Number of Power Policies specified in the policies array.  Caller sets
     * this value to 0 to specify that all policies should be queried.
     */
    NvU8  numPolicies;

    /*!
     * Array of current settings for each specified Power Policy.  This array
     * has a valid index ranging from 0 to numPolicies - 1.
     */
    NV_GPU_CLIENT_POWER_POLICIES_POLICY_STATUS_V1
        policies[NV_GPU_CLIENT_POWER_POLICIES_NUM_POLICIES_V1];

} NV_GPU_CLIENT_POWER_POLICIES_STATUS_V1;

#define NV_GPU_CLIENT_POWER_POLICIES_STATUS_VER_1  MAKE_NVAPI_VERSION(NV_GPU_CLIENT_POWER_POLICIES_STATUS_V1,1)
#define NV_GPU_CLIENT_POWER_POLICIES_STATUS_VER    NV_GPU_CLIENT_POWER_POLICIES_STATUS_VER_1

#define NV_GPU_CLIENT_POWER_POLICIES_STATUS        NV_GPU_CLIENT_POWER_POLICIES_STATUS_V1

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_ClientPowerPoliciesGetStatus
//
//! DESCRIPTION: Accessor for current state of the public GPU power
//!              policies which are controlling GPU power consumption.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 295
//!
//! \param [in]  hPhysicalGPU               GPU selection
//! \param [out] pClientPowerPoliciesStatus Structure containing the current
//!                  state of a set of GPU power policies.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gpupower
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_ClientPowerPoliciesGetStatus(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_CLIENT_POWER_POLICIES_STATUS *pClientPowerPoliciesStatus);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_ClientPowerPoliciesSetStatus
//
//! DESCRIPTION: Mutator for state of the public GPU power policies which
//!              are controlling GPU power consumption.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 295
//!
//! \param [in]  hPhysicalGPU               GPU selection
//! \param [out] pClientPowerPoliciesStatus Structure containing the requested
//!                  state of a set of GPU power policies.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gpupower
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_ClientPowerPoliciesSetStatus(__in NvPhysicalGpuHandle hPhysicalGpu, __in NV_GPU_CLIENT_POWER_POLICIES_STATUS *pClientPowerPoliciesStatus);




//////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_QueryGpuCap
//
//! \fn NvAPI_QueryGpuCap(NvLogicalGpuHandle hLogicalGPU, NVAPI_GPU_CAP capToQuery, NvU32 *pVal)
//!   DESCRIPTION: This function gets capability information from a logical GPU.
//!   
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 165
//!
//! \param [in]  hLogicalGPU Logical GPU selection.
//! \param [in]  capToQuery  GPU cap to query
//! \param [out] pVal        Returned value
//!
//! \retval  NVAPI_OK                           Query succeeded.
//! \retval  NVAPI_INVALID_ARGUMENT             pVal is NULL or capToQuery is invalid.
//! \retval  NVAPI_EXPECTED_LOGICAL_GPU_HANDLE  hLogicalGPU is not a valid handle.
//! \retval  NVAPI_HANDLE_INVALIDATED           hLogicalGPU has been invalidated.
//! \retval  NVAPI_ERROR                        Miscellaneous error occurred.
//
//////////////////////////////////////////////////////////////////////////////


//! \ingroup gpu
//! Used in NvAPI_QueryGpuCap().
typedef enum 
{
    NVAPI_GPU_CAP_UNDEFINED                                    = 0,
    NVAPI_GPU_CAP_GAMMA_CORRECT_AA_SUPPORTED                   = 1,
    NVAPI_GPU_CAP_TRANSPARENCY_AA_SUPPORTED                    = 2,
    NVAPI_GPU_CAP_SLI_RENDERING_DISABLED_DUE_TO_INTERLACE_MODE = 3,
    NVAPI_GPU_CAP_STEREO_DIN_AVAILABLE                         = 4,
    NVAPI_GPU_CAP_STEREO_CAPS                                  = 5,
    NVAPI_GPU_CAP_STEREO_DEFAULT                               = 6,
    NVAPI_GPU_CAP_ROTATION_COMPATIBLE_STEREO_CAPS              = 7,
    NVAPI_GPU_CAP_ROTATION_COMPATIBLE_STEREO_DEFAULT           = 8,
    NVAPI_GPU_CAP_SWAPGROUP_FOR_ALL_APPS_SUPPORTED             = 9,
    NVAPI_GPU_CAP_DEEP_COLOR_CAPS                              = 10,
    NVAPI_GPU_CAP_COUNT
} NVAPI_GPU_CAP;


//! \ingroup gpu
//! Possible return value of queries to NVAPI_GPU_CAP_STEREO_CAPS and
//! NVAPI_GPU_CAP_STEREO_DEFAULT
typedef enum 
{
    NVAPI_GPU_CAP_STEREO_CAP_DIN_AVAILABLE                = 0x00000001,
    NVAPI_GPU_CAP_STEREO_CAP_VERTICAL_INTERLACED          = 0x00000002,
    NVAPI_GPU_CAP_STEREO_CAP_TWINVIEW                     = 0x00000004,
    NVAPI_GPU_CAP_STEREO_CAP_DDC_AVAILABLE                = 0x00000008,
    NVAPI_GPU_CAP_STEREO_CAP_COLOR_LINE                   = 0x00000010,
    NVAPI_GPU_CAP_STEREO_CAP_COLOR_INTERLEAVED            = 0x00000020,
    NVAPI_GPU_CAP_STEREO_CAP_ANAGLYPH                     = 0x00000040,
    NVAPI_GPU_CAP_STEREO_CAP_HORIZONTAL_INTERLACED        = 0x00000080,
    NVAPI_GPU_CAP_STEREO_CAP_SIDE_FIELD                   = 0x00000100,
    NVAPI_GPU_CAP_STEREO_CAP_SUB_FIELD                    = 0x00000200,
    NVAPI_GPU_CAP_STEREO_CAP_CHECKERBOARD                 = 0x00000400,
    NVAPI_GPU_CAP_STEREO_CAP_INVERSE_CHECKERBOARD         = 0x00000800,
    NVAPI_GPU_CAP_STEREO_CAP_TRIDELITY_SL                 = 0x00001000,
    NVAPI_GPU_CAP_STEREO_CAP_TRIDELITY_MV                 = 0x00002000,
    NVAPI_GPU_CAP_STEREO_CAP_SEEFRONT                     = 0x00004000,
    NVAPI_GPU_CAP_STEREO_CAP_STEREO_MIRROR                = 0x00008000,
    NVAPI_GPU_CAP_STEREO_CAP_FRAME_SEQUENTIAL             = 0x00010000,
    NVAPI_GPU_CAP_STEREO_CAP_USB_EMITTER                  = 0x00020000,
    NVAPI_GPU_CAP_STEREO_CAP_PER_EYE_PAIR_FLIP            = 0x00040000,
    NVAPI_GPU_CAP_STEREO_CAP_PER_EYE_FLIP                 = 0x00080000,
} NVAPI_GPU_CAP_STEREO_CAP;


//! \ingroup gpu
//! Possible return value of queries to NVAPI_GPU_CAP_DEEP_COLOR_CAPS
typedef enum 
{
    NVAPI_GPU_CAP_DEEP_COLOR_CAP_SUPPORTED_BY_GPU          = 0x00000001,
    NVAPI_GPU_CAP_DEEP_COLOR_CAP_SUPPORTED_BY_DISPLAY      = 0x00000002,
    NVAPI_GPU_CAP_DEEP_COLOR_CAP_SUPPORTED_BY_DISPLAY_MODE = 0x00000004,
} NVAPI_GPU_CAP_DEEP_COLOR_CAP;


//! \ingroup gpu
NVAPI_INTERFACE NvAPI_QueryGpuCap(NvLogicalGpuHandle hLogicalGPU, NVAPI_GPU_CAP capToQuery, NvU32 *pVal);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_WorkstationFeatureSetup
//
//! \fn NvAPI_GPU_WorkstationFeatureSetup(NvPhysicalGpuHandle hPhysicalGpu, NvU32 featureEnableMask, NvU32 featureDisableMask)
//!   DESCRIPTION: This API configures the driver for a set of workstation features.
//!                The driver can allocate the memory resources accordingly.
//!
//! SUPPORTED OS:  Windows 7
//!
//!
//! \param [in]   hPhysicalGpu       Physical GPU Handle of the display adapter to be configured. GPU handles may be retrieved
//!                                  using NvAPI_EnumPhysicalGPUs. A value of NULL is permitted and applies the same operation
//!                                  to all GPU handles enumerated by NvAPI_EnumPhysicalGPUs.
//! \param [in]   featureEnableMask  Mask of features the caller requests to enable for use
//! \param [in]   featureDisableMask Mask of features the caller requests to disable 
//!
//!                As a general rule, features in the enable and disable masks are expected to be disjoint, although the disable 
//!                mask has precedence and a feature flagged in both masks will be disabled.
//!
//! \retval ::NVAPI_OK                            configuration request succeeded
//! \retval ::NVAPI_ERROR                         configuration request failed
//! \retval ::NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu is not a physical GPU handle.
//! \retval ::NVAPI_GPU_WORKSTATION_FEATURE_INCOMPLETE  requested feature set does not have all resources allocated for completeness.
//! \retval ::NVAPI_NO_IMPLEMENTATION             only implemented for Win7
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu 
typedef enum
{
    NVAPI_GPU_WORKSTATION_FEATURE_MASK_SWAPGROUP     = 0x00000001,
    NVAPI_GPU_WORKSTATION_FEATURE_MASK_STEREO        = 0x00000010,
    NVAPI_GPU_WORKSTATION_FEATURE_MASK_WARPING       = 0x00000100,
    NVAPI_GPU_WORKSTATION_FEATURE_MASK_PIXINTENSITY  = 0x00000200,
    NVAPI_GPU_WORKSTATION_FEATURE_MASK_GRAYSCALE     = 0x00000400,
    NVAPI_GPU_WORKSTATION_FEATURE_MASK_BPC10         = 0x00001000
} NVAPI_GPU_WORKSTATION_FEATURE_MASK;

//! \ingroup gpu
NVAPI_INTERFACE NvAPI_GPU_WorkstationFeatureSetup(__in NvPhysicalGpuHandle hPhysicalGpu, __in NvU32 featureEnableMask, __in NvU32 featureDisableMask);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_WorkstationFeatureQuery
//
//!   DESCRIPTION: This API queries the current set of workstation features.
//!
//! SUPPORTED OS:  Windows 7
//!
//!
//! \param [in]   hPhysicalGpu       Physical GPU Handle of the display adapter to be configured. GPU handles may be retrieved
//!                                  using NvAPI_EnumPhysicalGPUs. 
//! \param [out]  pConfiguredFeatureMask  Mask of features requested for use by client drivers
//! \param [out]  pConsistentFeatureMask  Mask of features that have all resources allocated for completeness.
//!
//! \retval ::NVAPI_OK                            configuration request succeeded
//! \retval ::NVAPI_ERROR                         configuration request failed
//! \retval ::NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu is not a physical GPU handle.
//! \retval ::NVAPI_NO_IMPLEMENTATION             only implemented for Win7
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
NVAPI_INTERFACE NvAPI_GPU_WorkstationFeatureQuery(__in NvPhysicalGpuHandle hPhysicalGpu, __out_opt NvU32 *pConfiguredFeatureMask, __out_opt NvU32 *pConsistentFeatureMask);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_WorkstationFeatureCommit
//
//!   DESCRIPTION: This API commits the configured workstation feature set to the kernel mode driver and validates resources to 
//!                promote the feature set to completeness.
//!
//! SUPPORTED OS:  Windows 7
//!
//!
//! \retval ::NVAPI_OK                            configuration request succeeded
//! \retval ::NVAPI_ERROR                         configuration request failed
//! \retval ::NVAPI_GPU_WORKSTATION_FEATURE_INCOMPLETE  not all resources for the configures feature set could be allocated for completeness.
//! \retval ::NVAPI_NO_IMPLEMENTATION             only implemented for Win7
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
NVAPI_INTERFACE NvAPI_GPU_WorkstationFeatureCommit();



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_NVPM_GetExportSetting
//
//!  This function returns the U32 value for the current NVPMAPI export
//!                setting.  This is usually stored in the registry and include
//!                info on if NVPMAPI is enabled, what the debug level is, etc.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \return NVAPI_ERROR or NVAPI_OK
//! \ingroup nvpmapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_NVPM_GetExportSetting(NvDisplayHandle hNvDisplay, NvU32 *pReturn);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAMES: NvAPI_NVPM_CreateGPUMapping
//                 NvAPI_NVPM_DestroyGPUMapping     
//                 NvAPI_NVPM_CreateSharedMemory
//                 NvAPI_NVPM_DestroySharedMemory
//                 NvAPI_NVPM_ReservePerfmonHW
//                 NvAPI_NVPM_ReleasePerfmonHW
//                 NvAPI_NVPM_SetPMTriggerInsert
//
//   DESCRIPTION: Used by NVPMAPI for setting up management of the data segment. Administrative rights are required.
//
// RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup nvpmapi
//! Used in all \ref nvpmapi
typedef struct 
{
    NvU32              version;    //!< Structure version, constructed from macro below
    NvU32              gpuCount;   //!< Number of mapped GPU memory spaces
    NvU64              hClient[NVAPI_MAX_PHYSICAL_GPUS];
    NvU64              hDevice[NVAPI_MAX_PHYSICAL_GPUS];
    void*             pMapping[NVAPI_MAX_PHYSICAL_GPUS];
} NV_NVPM_GPU_MAPPING;


//! \ingroup nvpmapi
//! Macro for constructing the version field of NV_NVPM_GPU_MAPPING
#define NV_NVPM_GPU_MAPPING_VER  MAKE_NVAPI_VERSION(NV_NVPM_GPU_MAPPING,1)


//! \ingroup nvpmapi 
typedef enum
{
    NV_NVPM_GPU_RELEASE_REQUEST = 0,  //!< release perfmon
    NV_NVPM_GPU_RESERVE_REQUEST,      //!< reserve perfmon 
}NV_NVPM_RESERVE_RELEASE_TYPE;

//! \ingroup nvpmapi
//! Used in NvAPI_NVPM_ReserveReleasePerfmonHW(). 
typedef struct
{
  NvU32                        version;    //!< Structure version
  NvU32                        gpuCount;   //!< Number of mapped GPU memory spaces
  NvPhysicalGpuHandle          hPhysicalGpus[NVAPI_MAX_PHYSICAL_GPUS];//!< Valid physical GPU handles
  NV_NVPM_RESERVE_RELEASE_TYPE requestType;//!< reserve/release request  
}NV_NVPM_GPU_PERFMON_MAPPING;


//! \ingroup nvpmapi
//! Macro for constructing the version field of NV_NVPM_PERFMON_MAPPING
#define NV_NVPM_GPU_PERFMON_MAPPING_VER MAKE_NVAPI_VERSION(NV_NVPM_GPU_PERFMON_MAPPING,1)




//! \addtogroup nvpmapi
//! These APIs are used by NVPMAPI for setting up management of the data segment. 
//! @{


//! SUPPORTED OS:  Windows XP and higher
//!
NVAPI_INTERFACE NvAPI_NVPM_CreateGPUMapping(NV_NVPM_GPU_MAPPING *pMapping);

//! SUPPORTED OS:  Windows XP and higher
//!
NVAPI_INTERFACE NvAPI_NVPM_DestroyGPUMapping(NV_NVPM_GPU_MAPPING *pMapping);

//! SUPPORTED OS:  Windows XP and higher
//!
NVAPI_INTERFACE NvAPI_NVPM_CreateSharedMemory();

//! SUPPORTED OS:  Windows XP and higher
//!
NVAPI_INTERFACE NvAPI_NVPM_DestroySharedMemory();

//! SUPPORTED OS:  Windows XP and higher
//!
NVAPI_INTERFACE NvAPI_NVPM_ReservePerfmonHW(NV_NVPM_GPU_MAPPING *pMapping);

//! SUPPORTED OS:  Windows XP and higher
//!
NVAPI_INTERFACE NvAPI_NVPM_ReleasePerfmonHW(NV_NVPM_GPU_MAPPING *pMapping);

//! SUPPORTED OS:  Windows XP and higher
//!
NVAPI_INTERFACE NvAPI_NVPM_SetPMTriggerInsert(NvDisplayHandle hNvDisplay, NvU32 value);
//! @}



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_NVPM_ReserveReleasePerfmonHW
//
//! \code
//!   DESCRIPTION: to reserve or release perfmon on a gpu in multigpu
//!                environment on Cuda profile etc.Currenly SLI support is 
//!                not provided it will return NVAPI_NOT_SUPPORTED
//!                if multigpu mode is enabled.
//!
//!   PARAMETERS:  pMapping(IN) : pointer to a structure variable of NV_NVPM_GPU_PERFMON_MAPPING
//!                
//!                
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! RETURN STATUS: NVAPI_OK: query succeeded
//!                NVAPI_INVALID_ARGUMENT: pMapping is NULL or gpuCount is not specified by user
//!                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: handle passed is not a physical GPU handle.
//!                NVAPI_HANDLE_INVALIDATED: hPhysicalGpu has been invalidated
//!                NVAPI_INVALID_HANDLE: hPhysicalGpu is not a valid handle
//!                NVAPI_NOT_SUPPORTED: not supported configuration
//!                NVAPI_NO_IMPLEMENTATION:not implemented
//! \endcode
//! \ingroup nvpmapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_NVPM_ReserveReleasePerfmonHW(NV_NVPM_GPU_PERFMON_MAPPING *pMapping);





//! \ingroup gpu
typedef struct
{
    NvU32 version;    //!< Structure version, constructed from macro below
    NvU32 IsWrongThermSetup :1;
    NvU32 IsEngineeringSample :1;
    NvU32 reserved : 30;
}NV_MODE_RESTRICT_PARAMS;

//! \ingroup gpu
//! Macro for constructing the version field of ::NV_MODE_RESTRICT_PARAMS
#define NV_MODE_RESTRICT_PARAMS_VER  MAKE_NVAPI_VERSION(NV_MODE_RESTRICT_PARAMS,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DIAG_ModeRestrictInfo
//
//! \code
//! DESCRIPTION: Returns the reason for system being in 800X600 mode.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! RETURN STATUS: NVAPI_OK: now *pModeRestrict contains the reason for system being in 800x600 mode.
//!                NVAPI_ERROR:If any way call is not success.
//!                NVAPI_NOT_SUPPORTED:If any way call is not success.
//!                NVAPI_HANDLE_INVALIDATED:If nvapi escape result handle is invalid.
//!                NVAPI_API_NOT_INTIALIZED:If NVAPI is not initialized.
//! \endcode
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DIAG_ModeRestrictInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_MODE_RESTRICT_PARAMS *pModeRestrict);



//! \ingroup gpu
//! @{

//! Let the control panel retrieve info on the various streams
typedef enum {
    NVAPI_AELPG_OPCODE_GET_ELPGINFO  = 0,
    NVAPI_AELPG_OPCODE_DEPRECATED    = 1,
    NVAPI_AELPG_OPCODE_HOLDOFF_AELPG = 2,
    NVAPI_AELPG_OPCODE_GET_VIDEOELPGINFO = 3,
    NVAPI_AELPG_OPCODE_GET_ELPGSTATS      = 4,
    NVAPI_AELPG_OPCODE_GET_VIDEOELPGSTATS = 5,
    NVAPI_AELPG_OPCODE_GET_MSPGSTATS      = 6,
    NVAPI_AELPG_OPCODE_GET_AELPGINFO      = 7,
    NVAPI_AELPG_OPCODE_GET_AELPG1INFO     = 8,
    NVAPI_AELPG_OPCODE_SET_IDLE_THRESHOLD = 9,
}NVAPI_AELPG_OPCODE;

typedef struct _NVAPI_ELPG_INFO
{
    NvU8  initialized;
    NvU8  enabled;
    NvU8  aelpgEnabled;
    NvU32 idleThreshold;
    NvU32 postPowerupThreshold;
    NvU8  powerStateEngine;
    NvU32 gatingCount;
    NvU32 denyCount;
}NVAPI_ELPG_INFO;

typedef NVAPI_ELPG_INFO NVAPI_VIDEO_ELPG_INFO;

#define NVAPI_AELPG_HISTOGRAM_SIZE 16

typedef struct _NVAPI_AELPG_INFO
{
    NvU8  enabled;
    NvU8  active;
    NvU32 holdTimeInSec;
    NvU32 badDecisionCount;
    NvU32 idleFilter;
    NvU32 powerSaving;
    NvU8  histogramBin[NVAPI_AELPG_HISTOGRAM_SIZE];
}NVAPI_AELPG_INFO;

typedef struct _NVAPI_ELPG_STATS_V1
{
    NvU32 gatingCount;
    NvU32 gatingTimeUs;
    NvU32 ungatingCount;
    NvU32 ungatingTimeUs;
    NvU32 avgEntryTimeUs;
    NvU32 avgExitTimeUs;
}NVAPI_ELPG_STATS_V1;

typedef struct _NVAPI_ELPG_STATS_V2
{
    NvU32 gatingCount;
    NvU32 gatingTimeUs;
    NvU32 ungatingCount;
    NvU32 ungatingTimeUs;
    NvU32 avgEntryTimeUs;
    NvU32 avgExitTimeUs;
    NvU32 maxEntryTimeUs;
    NvU32 maxExitTimeUs;
}NVAPI_ELPG_STATS_V2;

typedef struct _NVAPI_AELPG_REQUEST_V1
{
    NvU32                   version;            //!< (IN)  structure version
    NVAPI_AELPG_OPCODE      opCode;             //!< (IN)  opcode: getELPGInfo, getAElpgInfo, holdOffAELPG, getELPGStats
    union
    {
        NVAPI_ELPG_INFO     elpgInfo;           //!< (OUT) elpg info
        NVAPI_AELPG_INFO    aelpgInfo;          //!< (OUT) aelpg info
        NvU32               aelpgHoldTimeInSec; //!< (IN)  hold off aelpg for given number of seconds, only valid for opcode NVAPI_AELPG_OPCODE_HOLDOFF_AELPG
        NVAPI_ELPG_STATS_V1 elpgStats;          //!< (OUT) elpg statistics
        NvU32               idleThreshold;      //!< (IN)  new ELPG threshold, only for opcode NVAPI_AELPG_OPCODE_SET_IDLE_THRESHOLD. Set to 0 to re-enable AELPG
    }data;
    NvU64 reserved;
} NVAPI_AELPG_REQUEST_V1;

typedef struct _NVAPI_AELPG_REQUEST_V2
{
    NvU32                   version;            //!< (IN)  structure version
    NVAPI_AELPG_OPCODE      opCode;             //!< (IN)  opcode: getELPGInfo, getAElpgInfo, holdOffAELPG, getELPGStats
    union
    {
        NVAPI_ELPG_INFO     elpgInfo;           //!< (OUT) elpg info
        NVAPI_AELPG_INFO    aelpgInfo;          //!< (OUT) aelpg info
        NvU32               aelpgHoldTimeInSec; //!< (IN)  hold off aelpg for given number of seconds, only valid for opcode NVAPI_AELPG_OPCODE_HOLDOFF_AELPG
        NVAPI_ELPG_STATS_V2 elpgStats;          //!< (OUT) elpg statistics
        NvU32               idleThreshold;      //!< (IN)  new ELPG threshold, only for opcode NVAPI_AELPG_OPCODE_SET_IDLE_THRESHOLD. Set to 0 to re-enable AELPG
    }data;
    NvU64 reserved;
} NVAPI_AELPG_REQUEST_V2;

typedef NVAPI_AELPG_REQUEST_V2  NVAPI_AELPG_REQUEST;

//! Macro for constructing the version field of ::NVAPI_AELPG_REQUEST
#define NVAPI_HANDLE_AELPG_VER_1  MAKE_NVAPI_VERSION(NVAPI_AELPG_REQUEST_V1,1)
#define NVAPI_HANDLE_AELPG_VER_2  MAKE_NVAPI_VERSION(NVAPI_AELPG_REQUEST_V2,2)

#define NVAPI_HANDLE_AELPG_VER    NVAPI_HANDLE_AELPG_VER_2

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_HandleAELPG
//
//! \code
//!   DESCRIPTION: Get/Set (A)ELPG settings and statistics.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! RETURN STATUS: NVAPI_OK
//!                NVAPI_INVALID_ARGUMENT
//!                NVAPI_NVIDIA_DEVICE_NOT_FOUND
//!                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE
//!                NVAPI_NOT_SUPPORTED
//!                NVAPI_INCOMPATIBLE_STRUCT_VERSION
//! \endcode
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_HandleAELPG(NvPhysicalGpuHandle hPhysicalGpu, NVAPI_AELPG_REQUEST *pParms);

//! @}

/*!
 * Used in \ref NvAPI_GPU_HandlePSI
 * Lets the application retrive different data for PSI using these opcodes
 */
typedef enum _NVAPI_PSI_OPCODE{
    NVAPI_PSI_OPCODE_GET_PSISTAT      = 0,        //!< (IN) opcode to get PSI statisics
    NVAPI_PSI_SET_CURRENT_MA          = 1,        //!< (IN) Sets PSI Single phase crossover current
    NVAPI_PSI_GET_SUPPORT             = 2,        //!< (IN) Gets Different support parameters for PSI
    NVAPI_PSI_GET_SLEEP_MA            = 3,        //!< (IN) Gets sleep current for PSI CTRL
    NVAPI_PSI_GET_OPTIMAL_MA          = 4,        //!< (IN) Gets the single phase crossover current
    NVAPI_PSI_CTRL_RESET_ENGAGE_COUNT = 5,        //!< (IN) Resets PSI engage count for the specified CTRL
    NVAPI_PSI_RESET_ENGAGE_COUNT      = 6,        //!< (IN) Resets all engage counters
}NVAPI_PSI_OPCODE;

/*!
 * Used in \ref NVAPI_PSI_REQUEST
 * Structure representing PSI support for power saving feature
 */
typedef struct _NVPSI_SUPPORT
{
    NvU32  elpgCoupled :1;      //!< (IN/OUT) true if ELPG coupled PSI is supported
    NvU32  mscgCoupled :1;      //!< (IN/OUT) true if MSCG coupled PSI is supported
    NvU32  gc4Coupled :1;       //!< (IN/OUT) true if GC4 coupled PSI is supported
    NvU32  gc5Coupled :1;       //!< (IN/OUT) true if GC5 coupled PSI is supported
    NvU32  psiSupported :1;     //!< (OUT) true if PSI is supported on the system
    NvU32  psiCurrentaware :1;  //!< (OUT) true if current aware PSI is supported on the system
    NvU32  reserved:26;
}NVPSI_SUPPORT;

/*!
 * Used in \ref NVAPI_STAT
 * Structure representing PSI statistics for GR-ELPG power saving feature
 * Structure might be populated with more data in future
 *
 * psiCount : Denotes PSI engage count
 * iSleepmA : Denotes sleep current of power saving feature engaging PSI
 */
typedef struct _NVAPI_ELPG_STAT
{
    NvU32 psiCount;
    NvU32 iSleepmA;
}NVAPI_ELPG_STAT;

/*!
 * Used in \ref NVAPI_STAT
 * Structure representing PSI statistics for MSCG power saving feature
 * Structure might be populated with more data in future
 *
 * psiCount : Denotes PSI engage count
 * iSleepmA : Denotes sleep current of power saving feature engaging PSI
 */
typedef struct _NVAPI_MSCG_STAT
{
    NvU32 psiCount;
    NvU32 iSleepmA;
}NVAPI_MSCG_STAT;

/*!
 * Used in \ref NVAPI_STAT
 * Structure representing PSI statistics for GC4 power saving feature
 * Structure might be populated with more data in future
 *
 * psiCount : Denotes PSI engage count
 * iSleepmA : Denotes sleep current of power saving feature engaging PSI
 */
typedef struct _NVAPI_GC4_STAT
{
    NvU32 psiCount;
    NvU32 iSleepmA;
}NVAPI_GC4_STAT;

/*!
 * Used in \ref NVAPI_STAT
 * Structure representing PSI statistics for GC5 power saving feature
 * Structure might be populated with more data in future
 *
 * psiCount : Denotes PSI engage count
 * iSleepmA : Denotes sleep current of power saving feature engaging PSI
 */
typedef struct _NVAPI_GC5_STAT
{
    NvU32 psiCount;
    NvU32 iSleepmA;
}NVAPI_GC5_STAT;

typedef struct _NVPSI_STAT_V1
{
    union
    {
        NvU32 psiCount;
    }elpg;

    union
    {
        NvU32 psiCount;
    }mscg;

    union
    {
        NvU32 psiCount;
    }gc4;

    union
    {
        NvU32 psiCount;
    }gc5;
}NVPSI_STAT_V1;

/*!
 * Used in \ref NVAPI_PSI_REQUEST
 * Structure representing PSI statistics for powersaving features
 */
typedef struct _NVPSI_STAT
{
    NVAPI_ELPG_STAT  elpg;
    NVAPI_MSCG_STAT  mscg;
    NVAPI_GC4_STAT   gc4;
    NVAPI_GC5_STAT   gc5;
}NVPSI_STAT;

typedef struct _NVAPI_PSI_REQUEST_V1
{
    NvU32                  version;            //!< (IN)  structure version
    NVAPI_PSI_OPCODE       opCode;             //!< (IN)  opcode
    union
    {
        NvU32                  onePhaseCurrentmA;       //!< (IN)
        NVPSI_STAT_V1          psiStat;                //!< (OUT)
        NVPSI_SUPPORT          psiSupport;             //!< (OUT)
    } data;
}NVAPI_PSI_REQUEST_V1;
/*!
 * Used in \ref NvAPI_GPU_HandlePSI
 * Structure describes all info related to PSI 
 */
typedef struct _NVAPI_PSI_REQUEST_V2
{
    NvU32                  version;            //!< (IN)  structure version
    NVAPI_PSI_OPCODE       opCode;             //!< (IN)  opcode
    NVPSI_SUPPORT          psiSupport;         //!< (IN/OUT)
    union
    {
        NvU32                  onePhaseCurrentmA;       //!< (IN/OUT)
        NVPSI_STAT             psiStat;                //!< (OUT)
    } data;
}NVAPI_PSI_REQUEST_V2;

typedef NVAPI_PSI_REQUEST_V2 NVAPI_PSI_REQUEST;
//! Macro for constructing the version field of ::NVAPI_PSI_REQUEST
#define NVAPI_PSI_REQUEST_VER_1  MAKE_NVAPI_VERSION(NVAPI_PSI_REQUEST_V1, 1)
#define NVAPI_PSI_REQUEST_VER_2  MAKE_NVAPI_VERSION(NVAPI_PSI_REQUEST_V2, 2)

#define NVAPI_PSI_REQUEST_VER    NVAPI_PSI_REQUEST_VER_2

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    NvAPI_GPU_HandlePSI()
//
//! DESCRIPTION:     This function checks for PSI support, 
//!                  gets PSI statistics for power saving feature
//!                  as well as sets sleep current to change PSI behavior
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Version:  331
//!
//! \param [in]          hPhysicalGPU    GPU selection
//! \param [in,out]      NVAPI_PSI_REQUEST 
//!     Structure containing the requested data for PSI statistics, 
// !    support and onephase current
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_HandlePSI(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NVAPI_PSI_REQUEST *pParams);


//! \ingroup gpu
//! Used in NvAPI_GPU_GetNBSIParams().
#define NVAPI_MAX_NBSI_PARAM_SIZE 256

//! \ingroup gpu
//!  Constants for hive values defined for modules. \n
//! Used in NvAPI_GPU_GetNBSIParams().
typedef enum _NVAPI_BIOS_NBSI_MODULE_TYPES
{
    NVAPI_BIOS_NBSI_MODULE_GLOBAL=0,      //!< Global section contains version
    NVAPI_BIOS_NBSI_MODULE_RM ,
    NVAPI_BIOS_NBSI_MODULE_DD,             
    NVAPI_BIOS_NBSI_MODULE_VIDEO,         
    NVAPI_BIOS_NBSI_MODULE_CPL,            
    NVAPI_BIOS_NBSI_MODULE_D3D,            
    NVAPI_BIOS_NBSI_MODULE_OGL,
    NVAPI_BIOS_NBSI_PMU,           //!< PMU microcode
    NVAPI_BIOS_NBSI_MODE           //!< Modes
    } NVAPI_BIOS_NBSI_MODULE_TYPES; 



//! \ingroup gpu
//! Used in NvAPI_GPU_GetNBSIParams().
typedef enum _NVAPI_BIOS_NBSI_ERROR_CODES
{
    NVAPI_BIOS_GET_NBSI_SUCCESS         = 0x00000000,
    NVAPI_BIOS_GET_NBSI_OVERRIDE        = 0x00000001,
    NVAPI_BIOS_GET_NBSI_BAD_HASH        = 0xFFFFFFFA,
    NVAPI_BIOS_GET_NBSI_APITEST_SUCCESS = 0xFFFFFFFB,
    NVAPI_BIOS_GET_NBSI_BAD_TABLE       = 0xFFFFFFFC,
    NVAPI_BIOS_GET_NBSI_NO_TABLE        = 0xFFFFFFFD,
    NVAPI_BIOS_GET_NBSI_INCOMPLETE      = 0xFFFFFFFE,
    NVAPI_BIOS_GET_NBSI_NOT_FOUND       = 0xFFFFFFFF,
} NVAPI_BIOS_NBSI_ERROR_CODES;


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetNBSIParams
//
//! DESCRIPTION: This function gives the NBSI parameter value and NBSI return code as output.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 170
//!
//! \param [in]      hPhysicalGpu   GPU selection.
//! \param [in]      key            ASCII value of key, to be used to identify parameter name/value.
//! \param [in]      val            ASCII value of Value, to be used to identify parameter name/value.
//! \param [in]      moduleId       Enum value of module to which this parameter setting belongs.
//! \param [out]     data           Data stored for the paramter(NBSI setting object).
//! \param [in,out]  psizeofdata    Maximum size of data(return value)is passed in. 
//!                                 If successful, this parameter contains the actual size of the output data.
//! \param [out]     pnbsiErrorCode Returns possible error values of NBSI. (See NVAPI_BIOS_NBSI_ERROR_CODES.)
//!
//! \retval          NVAPI_INVALID_ARGUMENT              hPhysicalGpu or data is NULL
//! \retval          NVAPI_OK                           *data contains NBSI parameter value
//! \retval          NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found
//! \retval          NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  hPhysicalGpu was not a physical GPU handle
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetNBSIParams(NvPhysicalGpuHandle hPhysicalGpu, NvAPI_LongString key, NvAPI_LongString val, NVAPI_BIOS_NBSI_MODULE_TYPES moduleId, NvU8 data[NVAPI_MAX_NBSI_PARAM_SIZE], NvU32 *psizeofdata, NVAPI_BIOS_NBSI_ERROR_CODES *pnbsiErrorCode);






#ifndef ANY_SIZE_ARRAY
#define ANY_SIZE_ARRAY 127
#endif

//! \addtogroup gpu
//! @{

#define NBSIDIRHDRSTRING (NvU32) (('N'<<24)+('B'<<16)+('S'<<8)+'I')


// A directory of globs
#pragma pack(1)
//! A directory of NBSI globs 
typedef union _NBSI_DIRECTORY
{
    struct OLD_FORMAT                   //!< Original version for Beta
    {
        NvU8  numGlobs;                 //!< number of globs
        NvU8  dirVer;                   //!< dirVer
        NvU16 globType[1];              //!< NBSI_GLOB_TYPE (placeholder)
    } od;
    struct NEW_FORMAT                   //!< Shipping version
    {
        NvU32 nbsiHeaderString;         //!< header string NBSIDIRHDRSTRING
        NvU32 size;                     //!< size of entire directory
        NvU8  numGlobs;                 //!< number of globs
        NvU8  dirVer;                   //!< dirVer
        NvU16 globType[1];              //!< NBSI_GLOB_TYPE (placeholder
    } d;
} NBSI_DIRECTORY, *PNBSI_DIRECTORY;
#pragma pack()


#pragma pack(1)
typedef struct _NBSI_GEN_OBJ
{
    NvU64       sig;          //!< One-way Hash of the entire object
    // Hash from here -->
    NvU16       globType;     //!< NBSI_GLOB_TYPE
    NvU32       size;         //!< Total size of GLOB including Signature
    NvU16       majMinVer;    //!< Version of Generic Object in Maj:Min format
    // actual packed object data
    NvU8        objData[ANY_SIZE_ARRAY];
    // <-- to here
} NBSI_GEN_OBJ, *PNBSI_GEN_OBJ;
#pragma pack()


typedef enum _NBSI_TBL_SOURCES
{
    NBSI_TBL_SOURCE_BEST_FIT = 0,
    NBSI_TBL_SOURCE_REGISTRY = 1,
    NBSI_TBL_SOURCE_VBIOS    = 2,
    NBSI_TBL_SOURCE_I2C      = 4,
    NBSI_TBL_SOURCE_SBIOS    = 8,
    NBSI_TBL_SOURCE_ACPI     = 0x10
} NBSI_TBL_SOURCES, * PNBSI_TBL_SOURCES;


//! The number of NBSI_TBL_SOURCES entries (not including BEST FIT)
#define NBSI_TBL_SOURCE_MAX 5                    


#define nbsiobjtype(ch1,ch2) (NvU16) ((ch1<<8) + ch2)


//! NBSI glob types - used in NVAPI_GET_NBSI_OBJ, _NBSI_GEN_OBJ, _NBSI_DIRECTORY
typedef enum _NBSI_GLOB_TYPES
{
    NBSI_RSRVD_GLOB     = 0,                     //!< Reserved Glob type
    NBSI_DRIVER         = nbsiobjtype('D','R'),  //!< Driver Object
    NBSI_VBIOS          = nbsiobjtype('V','B'),  //!< VBIOS Object
    NBSI_HDCP           = nbsiobjtype('H','K'),  //!< HDCP Keys
    NBSI_HDD            = nbsiobjtype('H','D'),  //!< Storage Driver
    NBSI_NONVOLATILE    = nbsiobjtype('N','V')   //!< CMOS settings
} NBSI_GLOB_TYPE, * PNBSI_GLOB_TYPE;


#define GLOB_TYPE_APITEST            0xffff     //!< Used to test the NVAPI interface
#define GLOB_TYPE_GET_NBSI_DIR       0xfffe     //!< Used to get entire dir, must specify globSource (see _NVAPI_GET_NBSI_OBJ)
#define GLOB_TYPE_GET_NBSI_ACPI_RAW  0xfffd     //!< Used when accessing ACPI via GET NBSI OBJ call. Used by tools.
#define NBSI_FUNC_SUPPORT            0          //!< Function for checking NBSI ACPI support


#define NBSI_SOURCE_LOC NvU16


#define NVAPI_MAX_GET_NBSI_OBJ_SIZE 4096


#define NVAPI_MAX_GET_MAX_GLOB_INDEX 15

//! NBSI object parameters - used in NvAPI_GPU_GetNBSIObj() \n
//! When globtype = GLOB_TYPE_GET_NBSI_ACPI_RAW the following parameter changes are in effect:
//! -(IN) globtype = GLOB_TYPE_GET_NBSI_ACPI_RAW
//! -(OUT) globSource = return status from the ACPI call.
//! -(IN) dataoffset = ACPI function number.
//! -(IN/OUT) inoutdata (instead of "data") = Data to or from the ACPI call (must be <= 4K!)
//! -(IN/OUT) pSizeOfData In = size of inoutdata, Out = size returned from the ACPI call.
typedef struct _NVAPI_GET_NBSI_OBJ
{
    NvU32 version;                              //!< (IN) Structure version obtained from the macro #NVAPI_GET_NBSI_OBJ_VER
    NvU16 globType;                             //!< (IN) The glob Type for the NBSI object to get.
    NvU8  globIndex;                            //!< (IN/OUT) IN: The glob Index for the object to get (0..15) 0=best fit, 1=1st instance, 2=2nd instance etc.)
                                                //!<         OUT: The actual index found for the specified object
    NBSI_SOURCE_LOC globSource;                 //!< (IN/OUT) IN: Source of directory to get glob from (0=normal search sequence, 1..x specific dir location).
                                                //!<         OUT: Actual directory source object was found at.
    NvU32 dataOffset;                           //!< (IN) Starting data offset within the NBSI object to return (when doing multiple calls... 0=beginning of object)
    NvU8  data[NVAPI_MAX_GET_NBSI_OBJ_SIZE];    //!< (OUT) Buffer to hold return data
    NvU32 pSizeOfData;                          //!< (IN/OUT) IN: Contains the size of the data buffer
                                                //!<         OUT: Contains the amount of the data buffer filled
    NvU32 totalObjSize;                         //!< (OUT) Total size of the entire object (may exceed pSizeOfData)
    NVAPI_BIOS_NBSI_ERROR_CODES pNbsiErrorCode; //!< (OUT) NBSI error values returned
} NVAPI_GET_NBSI_OBJ;



//! Macro for constructing the version field of NVAPI_GET_NBSI_OBJ
#define NVAPI_GET_NBSI_OBJ_VER  MAKE_NVAPI_VERSION(NVAPI_GET_NBSI_OBJ,1)

//! @}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetNBSIObj
//
//! DESCRIPTION: This function sends and retrieves generic notebook system information (NBSI) objects (GLOBs).
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 175
//!
//!  \param [in]      hPhysicalGpu      GPU selection.
//!  \param [in/out]  getNbsiObjParms   NVAPI_GET_NBSI_OBJ packet containing requested/returned NBSI object.
//!
//!  \retval ::NVAPI_INVALID_ARGUMENT
//!  \retval ::NVAPI_OK  *data contains NBSI parameter value (including error code in pNbsiErrorCode on failure).
//!  \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND
//!  \retval ::NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE
//!
//!  \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetNBSIObj(NvPhysicalGpuHandle hPhysicalGpu, NVAPI_GET_NBSI_OBJ * getNbsiObjParms);




//! \addtogroup gpu
//! Used in _NV_IMP_MODE.
//! @{
#define NV_IMP_INTERLACED                         0
#define NV_IMP_PROGRESSIVE                        1
#define NV_IMP_VERTICAL_TAPS1                     2
#define NV_IMP_VERTICAL_TAPS2                     3
#define NV_IMP_VERTICAL_TAPS3                     4
#define NV_IMP_VERTICAL_TAPS3_ADAPTIVE            5
#define NV_IMP_VERTICAL_TAPS5                     6
#define NV_IMP_HORIZONTAL_TAPS1                   7
#define NV_IMP_HORIZONTAL_TAPS2                   8
#define NV_IMP_HORIZONTAL_TAPS8                   9
#define NV_IMP_FORMAT_I8                          10
#define NV_IMP_FORMAT_VOID16                      11
#define NV_IMP_FORMAT_VOID32                      12
#define NV_IMP_FORMAT_RF16_GF16_BF16_AF16         13
#define NV_IMP_FORMAT_A8R8G8B8                    14
#define NV_IMP_FORMAT_A2B10G10R10                 15
#define NV_IMP_FORMAT_A8B8G8R8                    16
#define NV_IMP_FORMAT_R5G6B5                      17
#define NV_IMP_FORMAT_A1R5G5B5                    18
#define NV_IMP_SS_X1AA                            19
#define NV_IMP_SS_X4AA                            20
#define NV_IMP_BASE_USAGE_BOUNDS_USABLE_CURRENT   21
#define NV_IMP_BASE_USAGE_BOUNDS_USABLE_NO        22
#define NV_IMP_BASE_USAGE_BOUNDS_USABLE_YES       23
#define NV_IMP_BASE_USAGE_BOUNDS_DEPTH_CURRENT    24
#define NV_IMP_BASE_USAGE_BOUNDS_DEPTH_8          25
#define NV_IMP_BASE_USAGE_BOUNDS_DEPTH_16         26
#define NV_IMP_BASE_USAGE_BOUNDS_DEPTH_32         27
#define NV_IMP_BASE_USAGE_BOUNDS_DEPTH_64         28
#define NV_IMP_BASE_USAGE_BOUNDS_SS_CURRENT       29
#define NV_IMP_BASE_USAGE_BOUNDS_SS_X1AA          30
#define NV_IMP_BASE_USAGE_BOUNDS_SS_X4AA          31
//! @}

//! \ingroup gpu
//! Used in NvAPI_IsModePossible(). 
typedef struct _NV_IMP_MODE
{
    NvU32 PixelClock;
    NvU32 RasterWidth;
    NvU32 RasterHeight;
    NvU32 RasterBlankStartX;
    NvU32 RasterBlankStartY;
    NvU32 RasterBlankEndX;
    NvU32 RasterBlankEndY;
    NvU32 RasterVertBlank2YStart;
    NvU32 RasterVertBlank2YEnd;
    NvU32 ViewportOutWidth;
    NvU32 ViewportOutHeight;
    NvU32 ViewportOutMinWidth;
    NvU32 ViewportOutMinHeight;
    NvU32 ViewportInWidth;
    NvU32 ViewportInHeight;

    NvU32 OverlayBpp;
        
    NvU32 Interlaced;

    struct
    {
        NvU32 VerticalTaps;
        NvU32 HorizontalTaps;
    } OutputScaler;

    struct
    {
        NvU32 Format;
        NvU32 SuperSample;
    } Params;

    struct
    {
        NvU32 Usable;
        NvU32 PixelDepth;
        NvU32 SuperSample;
    } BaseUsageBounds;
} NV_IMP_MODE;


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Disp_ConstructIMPMode
//
//! \code
//! PARAMETERS:    pDispPath    (IN)  - Pointer to a display path
//!                pIMPMode     (OUT) - IMP version of display path
//!
//!
//!    FOR INTERNAL TOOL USE ONLY
//!
//!
//! SUPPORTED OS:  Windows Vista and higher,  Mac OS X
//!
//! DESCRIPTION:   This function will convert the mode data from the
//!                pDispPath input to the display driver version of the
//!                IMP structure used for IsModePossible calls.
//!
//! RETURN STATUS:
//!                NVAPI_OK                  - completed request
//!                NVAPI_API_NOT_INITIALIZED - nvapi not initialized
//!                NVAPI_ERROR               - miscellaneous error occurred
//! \endcode
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Disp_ConstructIMPMode(NV_DISP_PATH *pPath, NV_IMP_MODE *pIMPMode);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_IsModePossible
//
//! DESCRIPTION:  This function returns whether a given list of modes (one per head) are possible. 
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 173
//!
//! \param [in]   nvGPUHandle    GPU selection
//! \param [in]   mode           Array of modes; one per head
//! \param [in]   modeCount      Number of modes in the array
//! \param [out]  impResult      Boolean: zero=mode not possible, one=mode possible
//!
//! \retval       NVAPI_API_NOT_INTIALIZED  You must call NvAPI_Initialize first.
//! \retval       NVAPI_ERROR               One of three things went wrong:
//!                                          - modeCount is zero
//!                                          - A value in the NV_IMP_MODE structure is invalid
//!                                          - The RM control call failed
//! \retval       NVAPI_NO_IMPLEMENTATION   Only available for up to two heads.
//! \retval       NVAPI_OK                  impResult holds the return value.
//!
//! \ingroup gpu 
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_IsModePossible(NvPhysicalGpuHandle nvGPUHandle, NV_IMP_MODE *mode, NvU32 modeCount, NvU8 *impResult);




//! \ingroup gpu
//! @{

#define NV_MAX_LINES_PER_IMP_LOG_ENTRY                     180
#define NV_FLAGS_CMDLINE_SHOW_IMPOSSIBLE_ENTRIES_ONLY      0x01
#define NV_FLAGS_CMDLINE_SHOW_POSSIBLE_ENTRIES_ONLY        0x02
#define NV_FLAGS_CMDLINE_READ_LAST_N_ENTRIES               0x04
#define NV_FLAGS_CMDLINE_RESET_IMP_LOG_ONLY                0x08

typedef struct _NV_IMP_LOG_ENTRY
{
    NvU32 lineCount;
    NvAPI_ShortString line[NV_MAX_LINES_PER_IMP_LOG_ENTRY];
} NV_IMP_LOG_ENTRY;


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DIAG_GetIsModePossibleLog
//
//! \code
//! PARAMETERS:    nvGPUHandle(IN)          - GPU selection
//!                pTextLog(OUT)            - Array of IMP Log entries in text format
//!                pCount(IN/OUT)           - Number of IMP Log entries
//!                nCount(IN)               - Number of recent entries to return 
//!                flags(IN)                - Flags defining which entries to return
//!
//! DESCRIPTION:   When called with pTextLog = NULL, returns the number of IMP log entries in pCount.
//!                When called with a valid pointer in pTextLog and non zero value through pCount, returns the array of log entries
//!                based on the value of flags:
//!                flags = 0 : Return all entries 
//!                flags = 1 : Return impossible entries only
//!                            (NV_FLAGS_CMDLINE_SHOW_IMPOSSIBLE_ENTRIES_ONLY)
//!                flags = 2 : Return possible entries only
//!                            (NV_FLAGS_CMDLINE_SHOW_POSSIBLE_ENTRIES_ONLY)
//!                flags = 4 : Return last nCount entries
//!                            (NV_FLAGS_CMDLINE_READ_LAST_N_ENTRIES)
//!                flags = 5 : Return last nCount impossible entries only
//!                            (NV_FLAGS_CMDLINE_READ_LAST_N_ENTRIES | NV_FLAGS_CMDLINE_SHOW_IMPOSSIBLE_ENTRIES_ONLY)
//!                flags = 6 : Return last nCount possible entries only
//!                            (NV_FLAGS_CMDLINE_READ_LAST_N_ENTRIES | NV_FLAGS_CMDLINE_SHOW_POSSIBLE_ENTRIES_ONLY)
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! RETURN STATUS: NVAPI_API_NOT_INTIALIZED: You must call NvAPI_Initialize first.
//!                NVAPI_ERROR:              miscellaneous error occurred
//!                NVAPI_NOT_SUPPORTED       this feature is not supported on this GPU
//!                NVAPI_OK:                 completed request.
//! \endcode
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DIAG_GetIsModePossibleLog(NvPhysicalGpuHandle nvGPUHandle, NV_IMP_LOG_ENTRY *pTextLog, NvU32 *pCount, NvU32 nCount, NvU32 flags);

//! @}





//! \ingroup gpu
//! Used in _NV_DISPLAY_CRC_CONFIG.
typedef enum
{
    NV_DISPLAY_CRC_CONTROL_CHANNEL_CORE,
    NV_DISPLAY_CRC_CONTROL_CHANNEL_BASE,
    NV_DISPLAY_CRC_CONTROL_CHANNEL_OVERLAY,
    NV_DISPLAY_CRC_CONTROL_CHANNEL_COUNT     //!< always last 
} NV_DISPLAY_CRC_CONTROL_CHANNEL;


//! \addtogroup gpu
//! Used in _NV_DISPLAY_CRC_CONFIG.
//! @{
typedef NvU32 NV_DISPLAY_CRC_CONTROL;
#define NV_DISPLAY_CRC_CONTROL_EXPECT_BUFFER_COLLAPSE    (1 << 0)
#define NV_DISPLAY_CRC_CONTROL_TIMESTAMP_MODE            (1 << 1)
#define NV_DISPLAY_CRC_CONTROL_FLIP_LOCK_MODE            (1 << 2)
#define NV_DISPLAY_CRC_CONTROL_CRC_DURING_SNOOZE         (1 << 3)
#define NV_DISPLAY_CRC_CONTROL_LEGACY_COMPUTE            (1 << 4)
#define NV_DISPLAY_CRC_CONTROL_ACTIVE_RASTER             (1 << 5)
#define NV_DISPLAY_CRC_CONTROL_COMPLETE_RASTER           (1 << 6)
#define NV_DISPLAY_CRC_CONTROL_NON_ACTIVE_RASTER         (1 << 7)
//! @}


//! \ingroup gpu
//! Display CRC configuration - used in NvAPI_SetDisplayCrcConfig().
typedef struct _NV_DISPLAY_CRC_CONFIG
{
    NV_DISPLAY_CRC_CONTROL            crcControl;
    NV_DISPLAY_CRC_CONTROL_CHANNEL    controlChannel;  //!< See #NV_DISPLAY_CRC_CONTROL_CHANNEL.
} NV_DISPLAY_CRC_CONFIG;



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SetDisplayCrcConfig
//
//! DESCRIPTION:   This function configures and starts the CRC collection on the display 
//!                output of the requested GPU.
//!
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 177
//!
//!   \param [in] nvGPUHandle          GPU selection
//!   \param [in] displayOutputId      Display output ID - See \ref handles.
//!   \param [in] pDisplayCrcConfig    CRC configuration 
//!
//!   \retval     NVAPI_API_NOT_INTIALIZED   Must call NvAPI_Initialize first.
//!   \retval     NVAPI_ERROR  
//!   \retval     NVAPI_OK                   Successfully configured the CRC notifier.
//!
//!   \ingroup    gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetDisplayCrcConfig(NvPhysicalGpuHandle nvGPUHandle, NvU32 displayOutputId, NV_DISPLAY_CRC_CONFIG *pDisplayCrcConfig);


//! \addtogroup gpu
//! Used in _NV_DISPLAY_CRC_ENTRY.
//! @{
typedef NvU32 NV_DISPLAY_CRC_ENTRY_FLAG;
#define NV_DISPLAY_CRC_ENTRY_FLAG_TIMESTAMP_MODE        (1 << 0)
#define NV_DISPLAY_CRC_ENTRY_FLAG_HW_FLIP_LOCK_MODE      (1 << 1)
#define NV_DISPLAY_CRC_ENTRY_FLAG_PRESENT_INTERVAL_MET  (1 << 2)
//! @}


//! \ingroup gpu
//! Used in NvAPI_ReadDisplayCrcData().
typedef struct _NV_DISPLAY_CRC_ENTRY
{
    NV_DISPLAY_CRC_ENTRY_FLAG    flag;
    NvU32                        auditTimeStamp;
    NvU32                        tag;
    NvU32                        compositorCrc;
    NvU32                        primaryOutputCrc;
    NvU32                        secondaryOutputCrc;
} NV_DISPLAY_CRC_ENTRY;


//! \addtogroup gpu
//! Used in _NV_DISPLAY_CRC_DATA_STATUS.
//! @{ 
typedef NvU32 NV_DISPLAY_CRC_STATUS;
#define NV_DISPLAY_CRC_STATUS_DONE                      (1 << 0)
#define NV_DISPLAY_CRC_STATUS_OVERRUN                   (1 << 1)
#define NV_DISPLAY_CRC_STATUS_DSI_OVERFLOW              (1 << 2)
#define NV_DISPLAY_CRC_STATUS_COMPOSITOR_OVERFLOW       (1 << 3)
#define NV_DISPLAY_CRC_STATUS_PRIMARY_OUTPUT_OVERFLOW   (1 << 4)
#define NV_DISPLAY_CRC_STATUS_SECONDARY_OUTPUT_OVERFLOW (1 << 5)
#define NV_DISPLAY_CRC_STATUS_EXPECT_BUFFER_COLLAPSE    (1 << 6)
#define NV_DISPLAY_CRC_STATUS_BUSY                      (1 << 7)
//! @}


//! \ingroup gpu
//! Used in NvAPI_ReadDisplayCrcData().
typedef struct _NV_DISPLAY_CRC_DATA_STATUS
{
    NV_DISPLAY_CRC_STATUS   crcStatus;       //!< Status of the data read    
    NvU32                   readEntryCount;  //!< Number of read entries
} NV_DISPLAY_CRC_DATA_STATUS;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_ReadDisplayCrcData
//
//! DESCRIPTION:   Read one CRC entry from the output display of the requested GPU.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 177
//!
//!  \param [in]   nvGPUHandle       GPU selection
//!  \param [in]   displayOutputId   Display output selection - See \ref handles.
//!  \param [out]  pCrcEntryArray    CRC data entry
//!  \param [out]  pCrcDataStatus    CRC data status
//!  \param [out]  arrayEntryCount   
//!
//!  \retval       NVAPI_API_NOT_INTIALIZED  You must call NvAPI_Initialize first.
//!  \retval       NVAPI_ERROR 
//!  \retval       NVAPI_OK                  impResult holds the return value. See NvAPI_IsModePossible().
//!
//!  \ingroup      gpu  
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_ReadDisplayCrcData(NvPhysicalGpuHandle nvGPUHandle, NvU32 displayOutputId, NV_DISPLAY_CRC_DATA_STATUS *pCrcDataStatus, NV_DISPLAY_CRC_ENTRY *pCrcEntryArray, NvU32 arrayEntryCount);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_QueryActiveApps
//
//! DESCRIPTION:     Query all applications running on the specified GPU.
//!
//! \param [in]      hPhysicalGpu   Physical GPU Handle for which apps will be retrieved. To get the list of apps on all GPUs, pass NVAPI_DEFAULT_HANDLE.
//! \param [in,out]  apps           Empty structure passed as an input and upon successful exit, it contains list of apps.
//! \param [in,out]  total          Total number of apps currently running.
//!
//! \deprecated  Do not use this function - it is deprecated in release 340. Instead, use NvAPI_GPU_QueryActiveAppsEx.
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! RETURN STATUS:
//!                  NVAPI_OK - completed request
//!                  NVAPI_ERROR - miscellaneous error occurred
//!                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 340. Instead, use NvAPI_GPU_QueryActiveAppsEx.")
NVAPI_INTERFACE NvAPI_GPU_QueryActiveApps(NvPhysicalGpuHandle hPhysicalGpu, NV_3D_APP_INFO apps[NVAPI_MAX_3D_Apps] , NvU32 *total);




#define NV_APP_ALL                     0x8fffffff  //!< apps which statisfy atleast one of below flags
#define NV_APP_3D_CONTEXT              0x00000001  //!< apps which created 3D context
#define NV_APP_OPEN_ADAPTER            0x00000002  //!< apps which called open adapter. only supported on optimus system
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_QueryActiveAppsEx
//
//! DESCRIPTION:     Query all applications running on the specified GPU.
//!
//! HOW TO USE: 1) for the PhysicalGpu, make a call to get count of active apps 
//!                using NvAPI_GPU_QueryActiveAppsEx by passing the apps as NULL
//!                On call success:
//!             2) Allocate memory based on count then make a call NvAPI_GPU_QueryActiveAppsEx to get apps
//! \param [in]      hPhysicalGpu   Physical GPU Handle for which apps will be retrieved.
//! \param [in]      flag           one or more of  NV_APP_***
//! \param [in,out]  apps           Empty structure passed as an input and upon successful exit, it contains list of apps.
//! \param [in,out]  total          Total number of apps currently running.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! RETURN STATUS:
//!                  NVAPI_OK - completed request
//!                  NVAPI_ERROR - miscellaneous error occurred
//!                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_QueryActiveAppsEx(__in NvPhysicalGpuHandle hPhysicalGpu, __in NvU32 flag, __inout NV_3D_APP_INFO *apps , __inout NvU32 *count);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetPowerConnectorStatus
//                     
//! DESCRIPTION:     This API provides the number of external power connector(s) on the GPU board 
//!                  and their connection status.
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 177
//!
//!  \param [in]    hPhysicalGpu            GPU selection.
//!  \param [out]   pConnectorCount         Number of the power connector(s) present on the GPU Board
//!  \param [out]   pConnectionAtBoot       Mask of the power connector(s) connected at the boot time
//!  \param [out]   pCurrentConnection      Mask of the power connector(s) connected currently
//! 
//!  \retval        NVAPI_OK                           - Completed request
//!  \retval        NVAPI_ERROR                        - Miscellaneous error occurred
//!  \retval        NVAPI_HANDLE_INVALIDATED           - handle passed has been invalidated (see user guide)
//!  \retval        NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//!
//!  \ingroup       gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetPowerConnectorStatus(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pConnectorCount, NvU32 *pConnectionAtBoot, NvU32 *pCurrentConnection);



//! \ingroup gpu
//! @{

typedef enum
{
    NV_GPU_NETLIST_REV0 = 0x00000012,
    NV_GPU_NETLIST_REV1 = 0x00000013
} NV_GPU_NETLIST_REV;


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetNetlistIdentifier
//
//! \code
//! PARAMETERS:      hPhysicalGpu(IN) - GPU selection.
//!                  revIndex(IN)     - Rev index to specify the emulation register.
//!                  pValue(OUT)      - Pointer to a variable to get the netlist data value from rev index passed. 
//!                     
//! DESCRIPTION:     This API gets the netlist data values from emulation registers.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! HOW TO USE:      NV_GPU_NETLIST_REV index= NV_GPU_NETLIST_REV0 or NV_GPU_NETLIST_REV1;
//!                  ret = NvAPI_GPU_GetNetlistIdentifier(hPhysicalGpu, index, &Value);  
//!                  On call success:
//!                  ValReg would contain the netlist data value corresponding to the index passed   
//!
//! RETURN STATUS: 
//!                  NVAPI_OK - completed request
//!                  NVAPI_ERROR - miscellaneous error occurred
//!                  NVAPI_NOT_SUPPORTED - functionality not supported 
//!                  NVAPI_INVALID_HANDLE - physical GPU not found
//!                  NVAPI_INVALID_ARGUMENT - invalid arugument passed
//!                  NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//!                  NVAPI_API_NOT_INITIALIZED - nvapi not initialized
//! \endcode
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetNetlistIdentifier(NvPhysicalGpuHandle nvGPUHandle, NV_GPU_NETLIST_REV revIndex, NvU32 *pValue);

//! @}



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: NvAPI_GPU_GetPstateLimitsInfo
//
//! \fn 
//! DESCRIPTION:   This API retrieves the list of p-state limiting factors for the specified physical GPU.
//!                      - numLimits is the number of limiting factors returned.
//!
//!                For each limiting factor:
//!                      - limitId is a unique identifier for each limiting factor.
//!                      - limitType is a flag that indicates how the limit is applied (minimum, maximum or both).
//! 
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 175
//!
//! \param [in]   hPhysicalGpu      GPU selection
//! \param [out]  pLimitsInfo       Pointer to the list of p-state limiting factors.

//! \retval    NVAPI_OK                            Completed request
//! \retval    NVAPI_ERROR                         Miscellaneous error occurred
//! \retval    NVAPI_INVALID_ARGUMENT              pDynamicPstatesInfo is NULL
//! \retval    NVAPI_HANDLE_INVALIDATED            Handle passed has been invalidated (see user guide)
//! \retval    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle
//! \retval    NVAPI_INCOMPATIBLE_STRUCT_VERSION   The version of the INFO struct is not supported
//
///////////////////////////////////////////////////////////////////////////////


//! \addtogroup gpupstate
//! @{

//! Used in NV_GPU_PSTATE_LIMITS_INFO.
#define NVAPI_MAX_PSTATE_LIMITS                 64

//
// Any new values must be added to the end
//
//! Performance state limit IDs. Used in NV_GPU_PSTATE_LIMIT_INFO and NV_GPU_PSTATE_LIMIT_STATUS. (limitId)
typedef enum
{
    NVAPI_PSTATE_LIMIT_PERFMON,
    NVAPI_PSTATE_LIMIT_NO_CLIENT,
    NVAPI_PSTATE_LIMIT_SCREEN_SAVER,
    NVAPI_PSTATE_LIMIT_NO_HIRES,
    NVAPI_PSTATE_LIMIT_OS_LEVEL,
    NVAPI_PSTATE_LIMIT_SPDIFF_GLITCH,
    NVAPI_PSTATE_LIMIT_DISPLAY_GLITCH,
    NVAPI_PSTATE_LIMIT_UNLOAD_DRIVER,
    NVAPI_PSTATE_LIMIT_POWERMIZER,
    NVAPI_PSTATE_LIMIT_STRESSTEST_FAILURE,
    NVAPI_PSTATE_LIMIT_RC_ERROR,
    NVAPI_PSTATE_LIMIT_MIN_FAN_LEVEL,
    NVAPI_PSTATE_LIMIT_MCLK_CLONE,
    NVAPI_PSTATE_LIMIT_OVERLAY,
    NVAPI_PSTATE_LIMIT_HIGHRES,
    NVAPI_PSTATE_LIMIT_BANDWIDTHFACTOR,
    NVAPI_PSTATE_LIMIT_HD_FRAMEDROP_WAR,
    NVAPI_PSTATE_LIMIT_ISMODEPOSSIBLE,
    NVAPI_PSTATE_LIMIT_HYBRID,
    NVAPI_PSTATE_LIMIT_INVALID_SYSCON,
    NVAPI_PSTATE_LIMIT_STRESSTEST_SETUP,
    NVAPI_PSTATE_LIMIT_FORCED,
    NVAPI_PSTATE_LIMIT_FORCED_DACPERFTEST,
    NVAPI_PSTATE_LIMIT_FORCED_ACSHMOO,
    NVAPI_PSTATE_LIMIT_FORCED_STRESSTEST,
    NVAPI_PSTATE_LIMIT_POWERMIZER_HARD,
    NVAPI_PSTATE_LIMIT_THERMAL,
    NVAPI_PSTATE_LIMIT_SYSPERF,
    NVAPI_PSTATE_LIMIT_PWR_SUPPLY_CAPACITY,
    NVAPI_PSTATE_LIMIT_SW_BATTPOWER,
    NVAPI_PSTATE_LIMIT_EXT_PERF_CONTROL,
    NVAPI_PSTATE_LIMIT_MXM_ACPOWER,
    NVAPI_PSTATE_LIMIT_AUX_POWER,
    NVAPI_PSTATE_LIMIT_SHORT_VBLANK,
    NVAPI_PSTATE_LIMIT_POWER_BALANCE,
    NVAPI_PSTATE_LIMIT_BANDWIDTH_HCLONE,
    NVAPI_PSTATE_LIMIT_AUX_PWR_STATE,
} NVAPI_PSTATE_LIMIT;

//! Performance state limit type - undefined. Used in NV_GPU_PSTATE_LIMIT_INFO. 
#define NVAPI_PSTATE_LIMIT_UNDEFINED            0xff

//! Performance state limit type - minimum. Used in NV_GPU_PSTATE_LIMIT_INFO.
#define NVAPI_PSTATE_LIMIT_TYPE_MIN             1

//! Performance state limit type - maximumm. Used in NV_GPU_PSTATE_LIMIT_INFO
#define NVAPI_PSTATE_LIMIT_TYPE_MAX             2

//! Performance state limit type - minimum/maximum. Used in NV_GPU_PSTATE_LIMIT_INFO
#define NVAPI_PSTATE_LIMIT_TYPE_BOTH            3


//! Used in NV_GPU_PSTATE_LIMITS_INFO.
typedef struct
{
    NvU8        limitId;      //!< The unique ID that identifies the limiting factor
    NvU8        limitType;    //!< Flag that indicates how the limit is applied - as a minimum, a maximum, or both.
} NV_GPU_PSTATE_LIMIT_INFO;


//! Used in NvAPI_GPU_GetPstateLimitsInfo90.
typedef struct 
{
    NvU32       version;        //!< Structure version
    NvU32       numLimits;      //!< The number of limiting factors
    NV_GPU_PSTATE_LIMIT_INFO    limitInfoList[NVAPI_MAX_PSTATE_LIMITS];        
} NV_GPU_PSTATE_LIMITS_INFO;


//! Used in NV_GPU_PSTATE_LIMITS_INFO.
#define NV_GPU_PSTATE_LIMITS_INFO_VER MAKE_NVAPI_VERSION(NV_GPU_PSTATE_LIMITS_INFO,1)


//! @}


//! \ingroup   gpupstate
NVAPI_INTERFACE NvAPI_GPU_GetPstateLimitsInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_PSTATE_LIMITS_INFO *pLimitsInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: NvAPI_GPU_GetPstateActiveLimits
//
//! \fn NvAPI_GPU_GetPstateActiveLimits(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_PSTATE_ACTIVE_LIMITS *pActiveLimits)
//! DESCRIPTION:   This API retrieves the list of active p-state limiting factors for the specified physical GPU.
//!                - numLimits is the number of limiting factors returned.
//!                For each limiting factor:
//!                - limitId is a unique ID that identifies the limiting factor.
//!                - pstate is the limit set for the p-state limiting factor.
//! 
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 175
//!
//! \param [in]  hPhysicalGpu   GPU selection
//! \param [out] pActiveLimits  Pointer to the list of active p-state limiting factors.
//!
//! \retval    NVAPI_OK                            Completed request
//! \retval    NVAPI_ERROR                         Miscellaneous error has occurred.
//! \retval    NVAPI_INVALID_ARGUMENT              pDynamicPstatesInfo is NULL.
//! \retval    NVAPI_HANDLE_INVALIDATED            Handle passed has been invalidated (see user guide).
//! \retval    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  Handle passed is not a physical GPU handle.
//! \retval    NVAPI_INCOMPATIBLE_STRUCT_VERSION   The version of the INFO struct is not supported.
//
///////////////////////////////////////////////////////////////////////////////

//! \addtogroup gpupstate
//! @{


//! Used in NV_GPU_PSTATE_ACTIVE_LIMITS.
typedef struct
{
    NvU8        limitId;  //!< Unique ID that identifies the limiting factor
    NvU8        pstate;   //!< The p-state limit that is set for the limiting factor.
} NV_GPU_PSTATE_LIMIT_STATUS;


//! Used in NvAPI_GPU_GetPstateActiveLimits().
typedef struct 
{
    NvU32       version;        //!< Structure version
    NvU32       numLimits;      //!< The number of limiting factors
    NV_GPU_PSTATE_LIMIT_STATUS    limitStatusList[NVAPI_MAX_PSTATE_LIMITS];        
} NV_GPU_PSTATE_ACTIVE_LIMITS;


//! Used in NV_GPU_PSTATE_ACTIVE_LIMITS.
#define NV_GPU_PSTATE_ACTIVE_LIMITS_VER MAKE_NVAPI_VERSION(NV_GPU_PSTATE_ACTIVE_LIMITS,1)

//! @}


//! \ingroup   gpupstate
NVAPI_INTERFACE NvAPI_GPU_GetPstateActiveLimits(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_PSTATE_ACTIVE_LIMITS *pActiveLimits);


//! \addtogroup gpupstate
//! @{


//! Performance limit ids - generic limit entries which can be used to
//! set limits via pstates, frequencies, virtual pstates, etc.
//!
//! Used in the various NvAPI_GPU_PerfLimit<xyz>() APIs below (limitId).
typedef enum _NV_GPU_PERF_LIMIT_ID
{
    NVAPI_PERF_LIMIT_ID_PERFMON             = 0x00000000,
    NVAPI_PERF_LIMIT_ID_NO_CLIENT,
    NVAPI_PERF_LIMIT_ID_SCREEN_SAVER,
    NVAPI_PERF_LIMIT_ID_NO_HIRES,
    NVAPI_PERF_LIMIT_ID_OS_LEVEL,
    NVAPI_PERF_LIMIT_ID_SPDIFF_GLITCH,
    NVAPI_PERF_LIMIT_ID_DISPLAY_GLITCH,
    NVAPI_PERF_LIMIT_ID_UNLOAD_DRIVER,
    NVAPI_PERF_LIMIT_ID_POWERMIZER,
    NVAPI_PERF_LIMIT_ID_STRESSTEST_FAILURE,
    NVAPI_PERF_LIMIT_ID_RC_ERROR,
    NVAPI_PERF_LIMIT_ID_MIN_FAN_LEVEL,
    NVAPI_PERF_LIMIT_ID_MCLK_CLONE,
    NVAPI_PERF_LIMIT_ID_OVERLAY,
    NVAPI_PERF_LIMIT_ID_HIGHRES,
    NVAPI_PERF_LIMIT_ID_BANDWIDTHFACTOR,
    NVAPI_PERF_LIMIT_ID_HD_FRAMEDROP_WAR,
    NVAPI_PERF_LIMIT_ID_ISMODEPOSSIBLE,
    NVAPI_PERF_LIMIT_ID_STRESSTEST_SETUP,
    NVAPI_PERF_LIMIT_ID_FORCED,
    NVAPI_PERF_LIMIT_ID_FORCED_DACPERFTEST,
    NVAPI_PERF_LIMIT_ID_FORCED_STRESSTEST,
    NVAPI_PERF_LIMIT_ID_POWERMIZER_HARD,
    NVAPI_PERF_LIMIT_ID_THERMAL,
    NVAPI_PERF_LIMIT_ID_SYSPERF,
    NVAPI_PERF_LIMIT_ID_PWR_SUPPLY_CAPACITY,
    NVAPI_PERF_LIMIT_ID_SW_BATTPOWER,
    NVAPI_PERF_LIMIT_ID_EXT_PERF_CONTROL,
    NVAPI_PERF_LIMIT_ID_MXM_ACPOWER,
    NVAPI_PERF_LIMIT_ID_AUX_POWER,
    NVAPI_PERF_LIMIT_ID_3D_WAR,
    NVAPI_PERF_LIMIT_ID_DEEP_IDLE,
    NVAPI_PERF_LIMIT_ID_CLIENT_SOFT,
    NVAPI_PERF_LIMIT_ID_CLIENT_HARD,
    NVAPI_PERF_LIMIT_ID_OVERCLOCK,
    NVAPI_PERF_LIMIT_ID_FORCED_LINKTRAIN,
    NVAPI_PERF_LIMIT_ID_POWER_BALANCE,
    NVAPI_PERF_LIMIT_ID_BUG_535734,
    NVAPI_PERF_LIMIT_ID_BOOST,
    NVAPI_PERF_LIMIT_ID_PM_DYNAMIC,
    NVAPI_PERF_LIMIT_ID_MODS_RULES,
    NVAPI_PERF_LIMIT_ID_EXCEPT_VIDEO,
    NVAPI_PERF_LIMIT_ID_SDI_INPUT_CAPTURE,
    NVAPI_PERF_LIMIT_ID_BANDWIDTH_HCLONE,
    NVAPI_PERF_LIMIT_ID_VPS_DISPLAY,
    NVAPI_PERF_LIMIT_ID_VPS,
    NVAPI_PERF_LIMIT_ID_CANOAS_MODE,
    NVAPI_PERF_LIMIT_ID_BUG_660789,
    NVAPI_PERF_LIMIT_ID_P1020_WAR,
    NVAPI_PERF_LIMIT_ID_LOCKED_DRIVER,
    NVAPI_PERF_LIMIT_ID_PMU_OVERRIDE,
    NVAPI_PERF_LIMIT_ID_CLIENT_0_MAX,
    NVAPI_PERF_LIMIT_ID_CLIENT_0_MIN,
    NVAPI_PERF_LIMIT_ID_CLIENT_1_MAX,
    NVAPI_PERF_LIMIT_ID_CLIENT_1_MIN,
    NVAPI_PERF_LIMIT_ID_CLIENT_2_MAX,
    NVAPI_PERF_LIMIT_ID_CLIENT_2_MIN,
    NVAPI_PERF_LIMIT_ID_PERFMON_GROUP_1,
    NVAPI_PERF_LIMIT_ID_PERFMON_GROUP_2,
    NVAPI_PERF_LIMIT_ID_PERFMON_GROUP_3,
    NVAPI_PERF_LIMIT_ID_RATED_TDP,
    NVAPI_PERF_LIMIT_ID_VDT_OVERVOLTAGE,
    NVAPI_PERF_LIMIT_ID_VDT_RELIABILITY,
    NVAPI_PERF_LIMIT_ID_PMU_DOM_GRP_1,
    NVAPI_PERF_LIMIT_ID_AUX_PWR_STATE,
    NVAPI_PERF_LIMIT_ID_PERFORMANCE_CAP,
    NVAPI_PERF_LIMIT_ID_THERM_POLICY_DOM_GRP_0,
    NVAPI_PERF_LIMIT_ID_THERM_POLICY_DOM_GRP_1,
    NVAPI_PERF_LIMIT_ID_VDT_RELIABILITY_ALT,
    NVAPI_PERF_LIMIT_ID_PERFORMANCE_CAP1,
    NVAPI_PERF_LIMIT_ID_RATED_TDP_MIN,
    NVAPI_PERF_LIMIT_ID_INTERNAL_CLIENT_0_MAX,
    NVAPI_PERF_LIMIT_ID_INTERNAL_CLIENT_0_MIN,
    NVAPI_PERF_LIMIT_ID_INTERNAL_CLIENT_1_MAX,
    NVAPI_PERF_LIMIT_ID_INTERNAL_CLIENT_1_MIN,
    NVAPI_PERF_LIMIT_ID_THERM_POLICY_NVVDD,
    NVAPI_PERF_LIMIT_ID_SLI_GPU_BOOST_DOM_GRP_0,
    NVAPI_PERF_LIMIT_ID_SLI_GPU_BOOST_DOM_GRP_1,
    NVAPI_PERF_LIMIT_ID_ISMODEPOSSIBLE_DISP,
    NVAPI_PERF_LIMIT_ID_CUDA_MAX,
    NVAPI_PERF_LIMIT_ID_SUSPEND_POWER,
    NVAPI_PERF_LIMIT_ID_EDP_POLICY_DOM_GRP_1,
    NVAPI_PERF_LIMIT_ID_GPU_IS_IDLE,
    NVAPI_PERF_LIMIT_ID_GPU_IS_IDLE_GROUP1,
    NVAPI_PERF_LIMIT_ID_SLI_DOM_GRP_0_MIN,
    NVAPI_PERF_LIMIT_ID_LAST,                              //!< Must always be last actual limit id
    NVAPI_PERF_LIMIT_ID_MAX_LIMITS          = 0x00000100,  //!< Maximum number of nV_GPU_PERF_LIMITs.  Cannot change this number without changing structure version.
    NVAPI_PERF_LIMIT_ID_UNKNOWN             = 0xFFFFFFFF,  //!< Special value for an unknown limit id
} NV_GPU_PERF_LIMIT_ID;

//! Maximum length of the name string (szName) returned with each
//! NV_GPU_PERF_LIMIT_INFO structure below.
#define NV_GPU_PERF_LIMIT_INFO_NAME_MAX_LENGTH_V1                            32

//! Used in \ref NV_GPU_PERF_LIMIT_INFO.  Flags to represent the following
//! configurations:
//!
//! _MIN
//!     This PERF_LIMIT is a minimum bound.  This flag is not mutually exclusive with
//!     the _MAX flag, if both are set then the PERF_LIMIT locks to the specified
//!     value.
//! _MAX
//!    This PERF_LIMIT is a maximum bound.  This flag is not mutually exclusive with
//!     the _MIN flag, if both are set then the PERF_LIMIT locks to the specified
//!     value.
#define NV_GPU_PERF_LIMIT_INFO_FLAGS_MIN                                     0x1
#define NV_GPU_PERF_LIMIT_INFO_FLAGS_MAX                                     0x2

//! Used in \ref NV_GPU_PERF_LIMITS_INFO_V1.  Describes the static information
//! corresponding to a PERF_LIMIT - such as its string name and direction
//! (min/max).
typedef struct
{
    /*!
     * NV_GPU_PERF_LIMIT_ID for this PERF_LIMIT.
     */
    NV_GPU_PERF_LIMIT_ID limitId;
    /*!
     * Internal RMCTRL id for this PERF_LIMIT - NV2080_CTRL_PERF_LIMIT_<xyz>.
     */
    NvU32                rmLimitId;
    /*!
     * NV_GPU_PERF_LIMIT_INFO_FLAGS_<xyz>
     */
    NvU32                flags;
    /*!
     * Priority of this input - higher number ~ higher priority.
     */
    NvU32                priority;
    /*!
     * User-friendly string name for PERF_LIMIT.
     */
    char                 szName[NV_GPU_PERF_LIMIT_INFO_NAME_MAX_LENGTH_V1];
} NV_GPU_PERF_LIMIT_INFO_V1;

//! Used in \ref NvAPI_GPU_PerfLimitsGetInfo().  Stucture representing the
//! static information for a set of PERF_LIMITs.
typedef struct
{
    /*!
     * Version of structure.  Must always be first.
     */
    NvU32                     version;
    /*!
     * Flags - currently reserved.
     */
    NvU32                     flags;
    /*!
     * Number of limits specified in the limits array.  Caller sets this value
     * to 0 to specify that all limits should be queried.
     */
    NvU32                     numLimits;
    /*!
     * Array of PERF_LIMIT info entries.  This array has a valid index ranging
     * from 0 to numLimits - 1.
     */
    NV_GPU_PERF_LIMIT_INFO_V1 limits[NVAPI_PERF_LIMIT_ID_MAX_LIMITS];
} NV_GPU_PERF_LIMITS_INFO_V1;

typedef NV_GPU_PERF_LIMITS_INFO_V1 NV_GPU_PERF_LIMITS_INFO;

//! Macro for constructing the version field of NV_GPU_PERF_LIMITS_INFO_V1
#define NV_GPU_PERF_LIMITS_INFO_VER1  MAKE_NVAPI_VERSION(NV_GPU_PERF_LIMITS_INFO_V1,1)

//! Macro for constructing the version field of NV_GPU_PERF_LIMITS
#define NV_GPU_PERF_LIMITS_INFO_VER   NV_GPU_PERF_LIMITS_INFO_VER1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    NvAPI_GPU_PerfLimitsGetInfo
//
//! DESCRIPTION:     This function retrieves the static information associated
//!                  with a set of PERF_LIMITs - generic limits on
//!                  performance/clocks as specified by pstate, clock
//!                  domain/frequency, fstate, etc.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 285
//!
//! \param [in]      hPhysicalGPU  GPU selection
//! \param [out]     pLimits       Structure containing the description of a set of PERF_LIMITs.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_PerfLimitsGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_PERF_LIMITS_INFO *pLimits);

//! @}



//! \addtogroup gpupstate
//! @{

//! Used in \ref NV_GPU_PERF_LIMIT_STATUS_INPUT_V1.  Specifies the type of input
//! value specified to a PERF_LIMIT - pstate, clock domain/frequency, etc.
typedef enum _NV_GPU_PERF_LIMIT_STATUS_INPUT_TYPE
{
    NVAPI_PERF_LIMIT_STATUS_INPUT_TYPE_DISABLED    = 0x00000000,
    NVAPI_PERF_LIMIT_STATUS_INPUT_TYPE_PSTATE,
    NVAPI_PERF_LIMIT_STATUS_INPUT_TYPE_FREQ,
    NVAPI_PERF_LIMIT_STATUS_INPUT_TYPE_VPSTATE,
    NVAPI_PERF_LIMIT_STATUS_INPUT_TYPE_VOLTAGE,                  //!< Now depreciated for _EX version
    NVAPI_PERF_LIMIT_STATUS_INPUT_TYPE_VOLTAGE_EX,
    NVAPI_PERF_LIMIT_STATUS_INPUT_TYPE_UNSUPPORTED = 0xFFFFFFFF, //!< Should always be last
} NV_GPU_PERF_LIMIT_STATUS_INPUT_TYPE;

//! Used in \ref NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_V1.  Data specific to the
//! _PSTATE PERF_LIMIT input type.
typedef struct
{
    /*!
     * Flags - currently reserved.
     */
    NvU32                 flags;
    /*!
     * Pstate ID at which to apply the limitiation.
     */
    NV_GPU_PERF_PSTATE_ID pstateId;
} NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_PSTATE;

//! Used in \ref NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_V1.  Data specific to the
//! _FREQ PERF_LIMIT input type.
typedef struct
{
    /*!
     * Flags - currently reserved.
     */
    NvU32                  flags;
    /*!
     * Clock frequency at which to apply the limit.
     */
    NvU32                  freqKHz;
    /*!
     * Clock domain on which to apply the limit.
     */
    NV_GPU_CLOCK_DOMAIN_ID domainId;
} NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_FREQ;

//! Used in \ref NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_V1.  Data specific to the
//! _VPSTATE PERF_LIMIT input type.
typedef struct
{
    /*!
     * Flags - currently reserved.
     */
    NvU32                  flags;
    /*!
     * vP-state at which to apply the limit.
     */
    NvU32                  vpstate;
} NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VPSTATE;

//! Used in \ref NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_V2.  Data specific to the
//! _VOLTAGE PERF_LIMIT input type.
typedef struct
{
    /*!
     * Domain group index specified as input.
     */
    NvU32                         domGrpIdx;
    /*!
     * ID of the voltage domain
     */
    NV_GPU_PERF_VOLTAGE_DOMAIN_ID domainId;
    /*!
     * Flags - bit 0 indicates that mvolt is evaluated from VDT
     */
    NvU32                         flags;
    /*!
     * Voltage in uV.
     */
    NvU32                         voltageuV;
} NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VOLTAGE;

//! Used in \ref NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_V3.  Data specific to the
//! _VOLTAGE PERF_LIMIT_EX input type.
typedef struct
{
    /*!
     * Domain group index specified as input.
     */
    NvU32                               domGrpIdx;
    /*!
     * Voltage data.
     */
    NV_GPU_PSTATE20_VOLTAGE_ENTRY_V1    volt;
} NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VOLTAGE_EX;

//! Used in \ref NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_V4.  Data specific to the
//! _VOLTAGE PERF_LIMIT_EX input type.
typedef struct
{
    /*!
     * Decoupled clock domain ID which this PERF_LIMIT is limiting.
     * NVAPI_GPU_CLOCK_DOMAIN_UNDEFINED is used for P-state limits.
     */
    NV_GPU_CLOCK_DOMAIN_ID              decoupledClockId;
    /*!
     * Voltage data.
     */
    NV_GPU_PSTATE20_VOLTAGE_ENTRY_V1    volt;
} NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VOLTAGE_EX2;

//! Used in \ref NV_GPU_PERF_LIMIT_STATUS_INPUT_V1.  Union of type-specific
//! input data.
typedef union
{
    /*!
     * Pstate type-specific data.
     */
    NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_PSTATE pstate;
    /*!
     * Clock domain/frequency type-specific data.
     */
    NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_FREQ   freq;
    /*!
     * vP-state type-specific data.
     */
    NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VPSTATE vpstate;
} NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_V1;

//! Used in \ref NV_GPU_PERF_LIMIT_STATUS_INPUT_V2.  Union of type-specific
//! input data.
typedef union
{
    /*!
     * Pstate type-specific data.
     */
    NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_PSTATE pstate;
    /*!
     * Clock domain/frequency type-specific data.
     */
    NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_FREQ   freq;
    /*!
     * vP-state type-specific data.
     */
    NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VPSTATE vpstate;
    /*!
    * Voltage type-specific data.
     */
    NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VOLTAGE volt;
} NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_V2;

//! Used in \ref NV_GPU_PERF_LIMIT_STATUS_INPUT_V3.  Union of type-specific
//! input data.
typedef union
{
    /*!
     * Pstate type-specific data.
     */
    NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_PSTATE     pstate;
    /*!
     * Clock domain/frequency type-specific data.
     */
    NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_FREQ       freq;
    /*!
     * vP-state type-specific data.
     */
    NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VPSTATE    vpstate;
    /*!
    * Voltage type-specific data.
     */
    NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VOLTAGE    volt;
    /*!
    * Extended Voltage type-specific data.
     */
    NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VOLTAGE_EX voltEx;
} NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_V3;

//! Used in \ref NV_GPU_PERF_LIMIT_STATUS_INPUT_V4.  Union of type-specific
//! input data.
typedef union
{
    /*!
     * Pstate type-specific data.
     */
    NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_PSTATE      pstate;
    /*!
     * Clock domain/frequency type-specific data.
     */
    NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_FREQ        freq;
    /*!
     * vP-state type-specific data.
     */
    NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VPSTATE     vpstate;
    /*!
    * Extended Voltage type-specific data.
     */
    NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VOLTAGE_EX2 voltEx;
} NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_V4;

//! Used in \ref NV_GPU_PERF_LIMIT_STATUS_V1.  Structure representing the input
//! specified to configure the PERF_LIMIT.
typedef struct
{
    /*!
     * Flags - currently reserved.
     */
    NvU32                                  flags;
    /*!
     * The type of data used to specify the PERF_LIMIT.
     */
    NV_GPU_PERF_LIMIT_STATUS_INPUT_TYPE    type;
    /*!
     * Type-specific data used to specify the PERF_LIMIT.
     */
    NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_V1 data;
} NV_GPU_PERF_LIMIT_STATUS_INPUT_V1;

//! Used in \ref NV_GPU_PERF_LIMIT_STATUS_V2.  Structure representing the input
//! specified to configure the PERF_LIMIT.
typedef struct
{
    /*!
     * Flags - currently reserved.
     */
    NvU32                                  flags;
    /*!
     * The type of data used to specify the PERF_LIMIT.
     */
    NV_GPU_PERF_LIMIT_STATUS_INPUT_TYPE    type;
    /*!
     * Type-specific data used to specify the PERF_LIMIT.
     */
    NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_V2 data;
} NV_GPU_PERF_LIMIT_STATUS_INPUT_V2;

//! Used in \ref NV_GPU_PERF_LIMIT_STATUS_V3.  Structure representing the input
//! specified to configure the PERF_LIMIT.
typedef struct
{
    /*!
     * Flags - currently reserved.
     */
    NvU32                                  flags;
    /*!
     * The type of data used to specify the PERF_LIMIT.
     */
    NV_GPU_PERF_LIMIT_STATUS_INPUT_TYPE    type;
    /*!
     * Type-specific data used to specify the PERF_LIMIT.
     */
    NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_V3 data;
} NV_GPU_PERF_LIMIT_STATUS_INPUT_V3;

//! Used in \ref NV_GPU_PERF_LIMIT_STATUS_V4.  Structure representing the input
//! specified to configure the PERF_LIMIT.
typedef struct
{
    /*!
     * Flags - currently reserved. Must be set to 0.
     */
    NvU32                                  flags;
    /*!
     * The type of data used to specify the PERF_LIMIT.
     */
    NV_GPU_PERF_LIMIT_STATUS_INPUT_TYPE    type;
    /*!
     * Type-specific data used to specify the PERF_LIMIT.
     */
    NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_V4 data;
} NV_GPU_PERF_LIMIT_STATUS_INPUT_V4;

//! Used in \ref NV_GPU_PERF_LIMIT_STATUS_V1.  Structure representing the output
//! of the PERF_LIMIT corresponding to the input supplied.  This is all internal
//! RM domain group information representing how the RM is enforcing this
//! policy.
typedef struct
{
    /*!
     * Flags - currently reserved.
     */
    NvU32 flags;
    /*!
     * Boolean indicating whether the PERF_LIMIT is currently enabled.
     */
    NvU8  bEnabled;
    /*!
     * Internal RM index of the domain group which this PERF_LIMIT is limiting.
     */
    NvU32 domainGroupIdx;
    /*!
     * Domain-group-specific value to which this PERF_LIMIT is limiting.
     */
    NvU32 value;
} NV_GPU_PERF_LIMIT_STATUS_OUTPUT_V1;

//! Used in \ref NV_GPU_PERF_LIMIT_STATUS_V4.  Structure representing the output
//! of the PERF_LIMIT corresponding to the input supplied.  This is all internal
//! RM information representing how the RM is enforcing this policy.
typedef struct
{
    /*!
     * Flags - currently reserved. Must be set to 0.
     */
    NvU32                  flags;
    /*!
     * Boolean indicating whether the PERF_LIMIT is currently enabled.
     */
    NvU8                   bEnabled;
    /*!
     * Decoupled clock domain ID which this PERF_LIMIT is limiting.
     * NVAPI_GPU_CLOCK_DOMAIN_UNDEFINED is used for P-state limits.
     */
    NV_GPU_CLOCK_DOMAIN_ID decoupledClockId;
    /*!
     * Internal frequency or P-state value to which this PERF_LIMIT is limiting.
     */
    NvU32                  value;
} NV_GPU_PERF_LIMIT_STATUS_OUTPUT_V4;

//! Used in \ref NV_GPU_PERF_LIMITS_STATUS_V1.  Structure representing the
//! current (or desired) status/settings of a PERF_LIMIT.  Can be used for both
//! an accessor and mutator for a PERF_LIMIT.
typedef struct
{
    /*!
     * NV_GPU_PERF_LIMIT_ID for this PERF_LIMIT.
     */
    NV_GPU_PERF_LIMIT_ID               limitId;
    /*!
     * Internal RM id for this PERF_LIMIT - NV2080_CTRL_PERF_LIMIT_<xyz>
     */
    NvU32                              rmLimitId;
    /*!
     * Flags - currently reserved.
     */
    NvU32                              flags;
    /*!
     * PERF_LIMIT input parameters.
     */
    NV_GPU_PERF_LIMIT_STATUS_INPUT_V1  input;
    /*!
     * PERF_LIMIT output parameters.
     */
    NV_GPU_PERF_LIMIT_STATUS_OUTPUT_V1 output;
} NV_GPU_PERF_LIMIT_STATUS_V1;

//! Used in \ref NV_GPU_PERF_LIMITS_STATUS_V2.  Structure representing the
//! current (or desired) status/settings of a PERF_LIMIT.  Can be used for both
//! an accessor and mutator for a PERF_LIMIT.
typedef struct
{
    /*!
     * NV_GPU_PERF_LIMIT_ID for this PERF_LIMIT.
     */
    NV_GPU_PERF_LIMIT_ID               limitId;
    /*!
     * Internal RM id for this PERF_LIMIT - NV2080_CTRL_PERF_LIMIT_<xyz>
     */
    NvU32                              rmLimitId;
    /*!
     * Flags - currently reserved.
     */
    NvU32                              flags;
    /*!
     * PERF_LIMIT input parameters.
     */
    NV_GPU_PERF_LIMIT_STATUS_INPUT_V2  input;
    /*!
     * PERF_LIMIT output parameters.
     */
    NV_GPU_PERF_LIMIT_STATUS_OUTPUT_V1 output;
} NV_GPU_PERF_LIMIT_STATUS_V2;

//! Used in \ref NV_GPU_PERF_LIMITS_STATUS_V3.  Structure representing the
//! current (or desired) status/settings of a PERF_LIMIT.  Can be used for both
//! an accessor and mutator for a PERF_LIMIT.
typedef struct
{
    /*!
     * NV_GPU_PERF_LIMIT_ID for this PERF_LIMIT.
     */
    NV_GPU_PERF_LIMIT_ID               limitId;
    /*!
     * Internal RM id for this PERF_LIMIT - NV2080_CTRL_PERF_LIMIT_<xyz>
     */
    NvU32                              rmLimitId;
    /*!
     * Flags - currently reserved.
     */
    NvU32                              flags;
    /*!
     * PERF_LIMIT input parameters.
     */
    NV_GPU_PERF_LIMIT_STATUS_INPUT_V3  input;
    /*!
     * PERF_LIMIT output parameters.
     */
    NV_GPU_PERF_LIMIT_STATUS_OUTPUT_V1 output;
} NV_GPU_PERF_LIMIT_STATUS_V3;

//! Used in \ref NV_GPU_PERF_LIMITS_STATUS_V4.  Structure representing the
//! current (or desired) status/settings of a PERF_LIMIT.  Can be used for both
//! an accessor and mutator for a PERF_LIMIT.
typedef struct
{
    /*!
     * NV_GPU_PERF_LIMIT_ID for this PERF_LIMIT.
     */
    NV_GPU_PERF_LIMIT_ID               limitId;
    /*!
     * Internal RM id for this PERF_LIMIT - NV2080_CTRL_PERF_LIMIT_<xyz>
     */
    NvU32                              rmLimitId;
    /*!
     * Flags - currently reserved.
     */
    NvU32                              flags;
    /*!
     * PERF_LIMIT input parameters.
     */
    NV_GPU_PERF_LIMIT_STATUS_INPUT_V4  input;
    /*!
     * PERF_LIMIT output parameters.
     */
    NV_GPU_PERF_LIMIT_STATUS_OUTPUT_V4 output;
} NV_GPU_PERF_LIMIT_STATUS_V4;

//! Used in \ref NvAPI_GPU_PerfLimitsGetStatus().  Structure represents a
//! requested set of PERF_LIMITs for which to query or set current
//! status/settings.
typedef struct
{
    /*!
     * Structure version.  Must always be frist.
     */
    NvU32                       version;
    /*!
     * Flags - currently reserved.
     */
    NvU32                       flags;
    /*!
     * Number of limits specified in the limits array.  Caller sets this value
     * to 0 to specify that all limits should be queried.
     */
    NvU32                       numLimits;
    /*!
     * Array of PERF_LIMIT status entries.  This array has a valid index ranging
     * from 0 to numLimits - 1.
     */
    NV_GPU_PERF_LIMIT_STATUS_V1 limits[NVAPI_PERF_LIMIT_ID_MAX_LIMITS];
} NV_GPU_PERF_LIMITS_STATUS_V1;

//! Used in \ref NvAPI_GPU_PerfLimitsGetStatus().  Structure represents a
//! requested set of PERF_LIMITs for which to query or set current
//! status/settings.
typedef struct
{
    /*!
     * Structure version.  Must always be first.
     */
    NvU32                       version;
    /*!
     * Flags - currently reserved.
     */
    NvU32                       flags;
    /*!
     * Number of limits specified in the limits array.  Caller sets this value
     * to 0 to specify that all limits should be queried.
     */
    NvU32                       numLimits;
    /*!
     * Array of PERF_LIMIT status entries.  This array has a valid index ranging
     * from 0 to numLimits - 1.
     */
    NV_GPU_PERF_LIMIT_STATUS_V2 limits[NVAPI_PERF_LIMIT_ID_MAX_LIMITS];
} NV_GPU_PERF_LIMITS_STATUS_V2;

//! Used in \ref NvAPI_GPU_PerfLimitsSetStatus().  Structure represents a
//! requested set of PERF_LIMITs for which to query or set current
//! status/settings.
typedef struct
{
    /*!
     * Structure version.  Must always be first.
     */
    NvU32                       version;
    /*!
     * Flags - currently reserved.
     */
    NvU32                       flags;
    /*!
     * Number of limits specified in the limits array.  Caller sets this value
     * to 0 to specify that all limits should be queried.
     */
    NvU32                       numLimits;
    /*!
     * Array of PERF_LIMIT status entries.  This array has a valid index ranging
     * from 0 to numLimits - 1.
     */
    NV_GPU_PERF_LIMIT_STATUS_V3 limits[NVAPI_PERF_LIMIT_ID_MAX_LIMITS];
} NV_GPU_PERF_LIMITS_STATUS_V3;

//! Used in \ref NvAPI_GPU_PerfLimitsSetStatus().  Structure represents a
//! requested set of PERF_LIMITs for which to query or set current
//! status/settings.
typedef struct
{
    /*!
     * Structure version.  Must always be first.
     */
    NvU32                       version;
    /*!
     * Flags - currently reserved.
     */
    NvU32                       flags;
    /*!
     * Number of limits specified in the limits array.  Caller sets this value
     * to 0 to specify that all limits should be queried.
     */
    NvU32                       numLimits;
    /*!
     * Array of PERF_LIMIT status entries.  This array has a valid index ranging
     * from 0 to numLimits - 1.
     */
    NV_GPU_PERF_LIMIT_STATUS_V4 limits[NVAPI_PERF_LIMIT_ID_MAX_LIMITS];
} NV_GPU_PERF_LIMITS_STATUS_V4;

typedef NV_GPU_PERF_LIMITS_STATUS_V4 NV_GPU_PERF_LIMITS_STATUS;

//! Macro for constructing the version field of NV_GPU_PERF_LIMITS_STATUS_V1
#define NV_GPU_PERF_LIMITS_STATUS_VER1  MAKE_NVAPI_VERSION(NV_GPU_PERF_LIMITS_STATUS_V1,1)
#define NV_GPU_PERF_LIMITS_STATUS_VER2  MAKE_NVAPI_VERSION(NV_GPU_PERF_LIMITS_STATUS_V2,2)
#define NV_GPU_PERF_LIMITS_STATUS_VER3  MAKE_NVAPI_VERSION(NV_GPU_PERF_LIMITS_STATUS_V3,3)
#define NV_GPU_PERF_LIMITS_STATUS_VER4  MAKE_NVAPI_VERSION(NV_GPU_PERF_LIMITS_STATUS_V4,4)

//! Macro for constructing the version field of NV_GPU_PERF_LIMITS
#define NV_GPU_PERF_LIMITS_STATUS_VER   NV_GPU_PERF_LIMITS_STATUS_VER4

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    NvAPI_GPU_PerfLimitsGetStatus
//
//! DESCRIPTION:     This function retrieves the current status/settings
//!                  associated with a set of PERF_LIMITs.  This includes both
//!                  the input which was used to configure the PERF_LIMIT, as
//!                  well as output internal RM domain group settings which are
//!                  being applied as policy.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 285
//!
//! \param [in]      hPhysicalGPU  GPU selection
//! \param [out]     pLimits       Structure containing the status of a set of PERF_LIMITs.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_PerfLimitsGetStatus(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_PERF_LIMITS_STATUS *pLimits);

//! @}



//! \addtogroup gpupstate
//! @{

//! Used in various Perf Client Limit APIs below.  Unique IDs corresponding to a
//! set of Perf Client Limits exposed to allow users to set limits on their current
//! clocks.
typedef enum _NV_PERF_CLIENT_LIMIT_ID
{
    NVAPI_PERF_CLIENT_LIMIT_0_MAX      = 0x00000000,       //!< Client limit 0 maximum limit - Recommended for use with PROCESSOR/GRAPHICS clock
    NVAPI_PERF_CLIENT_LIMIT_0_MIN,                         //!< Client limit 0 minimim limit - Recommended for use with PROCESSOR/GRAPHICS clock
    NVAPI_PERF_CLIENT_LIMIT_1_MAX,                         //!< Client limit 1 maximum limit - Recommended for use with MEMORY clock
    NVAPI_PERF_CLIENT_LIMIT_1_MIN,                         //!< Client limit 1 minimim limit - Recommended for use with MEMORY clock
    NVAPI_PERF_CLIENT_LIMIT_2_MAX,                         //!< Client limit 2 maximum limit - Recommended for use with PSTATE
    NVAPI_PERF_CLIENT_LIMIT_2_MIN,                         //!< Client limit 2 minimim limit - Recommended for use with PSTATE
    NVAPI_PERF_CLIENT_LIMIT_MAX_LIMITS = 0x00000020,       //!< Maximum number of supported client limits - cannot change this without changing structure version.
} NV_GPU_PERF_CLIENT_LIMIT_ID;

//! Type of data corresponding to a Perf Client Limit.
typedef enum _NV_PERF_CLIENT_LIMIT_TYPE
{
    NVAPI_PERF_CLIENT_LIMIT_TYPE_DISABLED = 0x00000000,
    NVAPI_PERF_CLIENT_LIMIT_TYPE_PSTATE,
    NVAPI_PERF_CLIENT_LIMIT_TYPE_FREQ,
} NV_GPU_PERF_CLIENT_LIMIT_TYPE;

//! Used in \ref NV_GPU_PERF_CLIENT_LIMIT_DATA_V1.  Data specific to the _PSTATE
//! Perf Client Limit type.
typedef struct
{
    /*!
     * Flags - currently reserved.
     */
    NvU32                 flags;
    /*!
     * Pstate ID at which to apply the limitiation.
     */
    NV_GPU_PERF_PSTATE_ID pstateId;
} NV_GPU_PERF_CLIENT_LIMIT_DATA_PSTATE;

//! Used in \ref NV_GPU_PERF_CLIENT_LIMIT_DATA_V1.  Data specific to the _FREQ
//! Perf Client Limit type.
typedef struct
{
    /*!
     * Flags - currently reserved.
     */
    NvU32                  flags;
    /*!
     * Clock frequency at which to apply the limit.
     */
    NvU32                  freqKHz;
    /*!
     * Clock domain on which to apply the limit.
     */
    NV_GPU_PUBLIC_CLOCK_ID domainId;
} NV_GPU_PERF_CLIENT_LIMIT_DATA_FREQ;

//! Used in \ref NV_GPU_PERF_CLIENT_LIMIT_V1.  Union of type-specific input
//! data.
typedef union
{
    /*!
     * Pstate type-specific data.
     */
    NV_GPU_PERF_CLIENT_LIMIT_DATA_PSTATE pstate;
    /*!
     * Clock domain/frequency type-specific data.
     */
    NV_GPU_PERF_CLIENT_LIMIT_DATA_FREQ   freq;
} NV_GPU_PERF_CLIENT_LIMIT_DATA_V1;

//! Used in \ref NV_GPU_PERF_CLIENT_LIMITS_V1.  Structure representing the
//! current or desired status/settings of a Perf Client Limit.
typedef struct
{
    /*!
     * NV_GPU_PERF_CLIENT_LIMIT_ID for this Perf Client Limit.
     */
    NV_GPU_PERF_CLIENT_LIMIT_ID      limitId;
    /*!
     * Flags - currently reserved.
     */
    NvU32                            flags;
    /*!
     * The type of data used to specify this Perf Client Limit.
     */
    NV_GPU_PERF_CLIENT_LIMIT_TYPE    type;
    /*!
     * Type-specific data used to specify this Perf Client Limit.
     */
    NV_GPU_PERF_CLIENT_LIMIT_DATA_V1 data;
} NV_GPU_PERF_CLIENT_LIMIT_V1;

//! Used in \ref NV_GPU_PERF_CLIENT_LIMITS.  Flags to represent the following
//! configurations:
//!
//! _ASYNC
//!     Apply new Perf Client Limits to HW asynchronously, not blocking
//!     returning from this call for values to be applied.  Only applicable to
//!     \ref NvAPI_GPU_PerfClientLimitsSetStatus().
#define NV_GPU_PERF_CLIENT_LIMITS_FLAGS_ASYNC     0x1

//! Used in \ref NvAPI_GPU_PerfClientLimitsGetStatus() and
//! \ref NvAPI_GPU_PerfClientLimitsSetStatus().  Structure representing the
//! current or desired status/settings of a set of Perf Client Limits.
typedef struct
{
    /*!
     * Version of structure.  Must always be first.
     */
    NvU32                       version;
    /*!
     * NV_GPU_PERF_CLIENT_LIMITS_FLAGS_<xyz>
     */
    NvU32                       flags;
    /*!
     * Number of limits specified in the limits array.  Caller sets this value
     * to 0 to specify that all limits should be queried.
     */
    NvU32                       numLimits;
    /*!
     * Array of Perf Client Limit status entries.  This array has a valid index
     * ranging from 0 to numLimits - 1.
     */
    NV_GPU_PERF_CLIENT_LIMIT_V1 limits[NVAPI_PERF_CLIENT_LIMIT_MAX_LIMITS];
} NV_GPU_PERF_CLIENT_LIMITS_V1;

typedef NV_GPU_PERF_CLIENT_LIMITS_V1 NV_GPU_PERF_CLIENT_LIMITS;

//! Macro for constructing the version field of NV_GPU_PERF_CLIENT_LIMITS_V1
#define NV_GPU_PERF_CLIENT_LIMITS_VER1  MAKE_NVAPI_VERSION(NV_GPU_PERF_CLIENT_LIMITS_V1,1)
#define NV_GPU_PERF_CLIENT_LIMITS_VER2  MAKE_NVAPI_VERSION(NV_GPU_PERF_CLIENT_LIMITS_V1,2)

//! Macro for constructing the version field of NV_GPU_PERF_CLIENT_LIMITS
#define NV_GPU_PERF_CLIENT_LIMITS_VER   NV_GPU_PERF_CLIENT_LIMITS_VER2

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    NvAPI_GPU_PerfClientLimitsGetStatus
//
//! DESCRIPTION:     This function retrieves the current status/settings
//!                  associated with a set of Perf Client Limits.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 285
//!
//! \param [in]      hPhysicalGPU  GPU selection
//! \param [out]     pLimits       Structure containing the current status of a
//!                                set of Perf Client Limits.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_PerfClientLimitsGetStatus(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_PERF_CLIENT_LIMITS *pLimits);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    NvAPI_GPU_PerfClientLimitsSetStatus
//
//! DESCRIPTION:     This function sets the status/settings
//!                  associated with a set of Perf Client Limits.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 285
//!
//! \param [in]      hPhysicalGPU  GPU selection
//! \param [out]     pLimits       Structure containing the desired status of a
//!                                set of Perf Client Limits.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_PerfClientLimitsSetStatus(__in NvPhysicalGpuHandle hPhysicalGpu, __in  NV_GPU_PERF_CLIENT_LIMITS *pLimits);

//! @}


//! \addtogroup gpupstate
//! @{

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    NvAPI_GPU_PerfLimitsSetStatus
//
//! DESCRIPTION:     This function sets the status/settings
//!                  associated with a set of Perf Client Limits.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 295
//!
//! \param [in]      hPhysicalGPU  GPU selection
//! \param [out]     pLimits       Structure containing the desired status of a
//!                                set of Perf Client Limits.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \retval ::NVAPI_INVALID_USER_PRIVILEGE - The caller does not have administrative privileges
//!
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_PerfLimitsSetStatus(__in NvPhysicalGpuHandle hPhysicalGpu, __in  NV_GPU_PERF_LIMITS_STATUS *pLimits);

//! @}





//! \ingroup gpugpio
//! Used in NV_GPU_GPIO_LEGAL_PINS.
#define NVAPI_GPIO_SIZE_QUERY_ARRAY 0x00000020


//! \ingroup gpugpio
//! Used in NV_GPU_GPIO_PIN_DATA.
typedef enum 
{
    NVAPI_GPIO_DIRECTION_INPUT,
    NVAPI_GPIO_DIRECTION_OUTPUT
} NVAPI_GPIO_DIRECTION;


//! \ingroup gpugpio
//! Used in NvAPI_GPU_GPIOQueryLegalPins().
typedef struct
{
    NvU32         version;
    NvU32         gpioPinCount;
    NvU32         gpioLegalPins[NVAPI_GPIO_SIZE_QUERY_ARRAY];
} NV_GPU_GPIO_LEGAL_PINS;


//! \ingroup gpugpio
//! Macro for generating the version for structure NV_GPU_GPIO_LEGAL_PINS
#define NV_GPU_GPIO_LEGAL_PINS_VER MAKE_NVAPI_VERSION(NV_GPU_GPIO_LEGAL_PINS,1)


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GPIOQueryLegalPins
//
//! DESCRIPTION:   This function returns the number of available GPIO customer asyncrw instances.
//!
//! HOW TO USE:    
//!                - NV_GPU_GPIO_LEGAL_PINS gpioLegalPins = {0};       
//!                - gpioLegalPins.version = NV_GPU_GPIO_LEGAL_PINS_VER;
//!                - ret = NvAPI_GPU_GPIOQueryLegalPins(hPhysicalGpu, &gpioLegalPins); 
//!
//!                On call success:
//!                - The gpioLegalPins.gpioPinCount would contain some integer (for example, on some G96 GPUs it contains 3)  
//!                - The gpioLegalPins.gpioLegalPins array would contain some values (for example, on some G96 GPUs it contains 0xd, 0xe & 0xf, others
//!                  0) to be used in NvAPI_GPU_GPIOReadFromPin() & NvAPI_GPU_GPIOWriteToPin() calls.
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 175
//! 
//!  \param [in]   hPhysicalGpu        GPU selection.
//!  \param [out]  pgpioLegalPins      Pointer to a versioned structure to get the number of the pin(s) associated with the 
//!                                    CUSTOMER_ASYNCRW functions and an array of size NVAPI_GPIO_SIZE_QUERY_ARRAY in 
//!                                    which the legal pin numbers are retrieved. These legal pin numbers are to be used
//!                                    while performing read and write operations on the GPIO port.                 
//!                 
//!  \retval ::NVAPI_OK      
//!  \retval ::NVAPI_ERROR            
//!  \retval ::NVAPI_INVALID_HANDLE   physical GPU not found
//!  \retval ::NVAPI_HANDLE_INVALIDATED 
//!  \retval ::NVAPI_NOT_SUPPORTED 
//!  \retval ::NVAPI_INVALID_ARGUMENT 
//!  \retval ::NVAPI_API_NOT_INITIALIZED 
//!  \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION 
//!
//!  \ingroup gpugpio 
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GPIOQueryLegalPins(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_GPIO_LEGAL_PINS *pgpioLegalPins);


//! ingroup gpugpio
//! Contains GPIO pin, data, and data direction - used in NvAPI_GPU_GPIOReadFromPin() and NvAPI_GPU_GPIOWriteToPin()
typedef struct
{
    NvU32         version;
    NvU32         gpioPinNumber;
    NvU32         gpioDataReadWrite;
    NVAPI_GPIO_DIRECTION         gpioDirection;
} NV_GPU_GPIO_PIN_DATA;


//! \ingroup gpugpio
//! Macro for generating the version of structure NV_GPU_GPIO_PIN_DATA
#define NV_GPU_GPIO_PIN_DATA_VER MAKE_NVAPI_VERSION(NV_GPU_GPIO_PIN_DATA,1)


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GPIOReadFromPin
//
//! DESCRIPTION:  This function reads the data from the specified GPIO pin.
//!
//! HOW TO USE:    First make a NvAPI_GPU_GPIOQueryLegalPins() call. 
//!                - NV_GPU_GPIO_PIN_DATA gpioReadPin = {0};
//!                - gpioReadPin.version = NV_GPU_GPIO_PIN_DATA_VER;
//!                - gpioReadPingpioDirection = NVAPI_GPIO_DIRECTION_INPUT;
//!                - gpioReadPin.gpioPinNumber = any legal pin data from gpioLegalPins array after successful call to NvAPI_GPU_GPIOQueryLegalPins() 
//!                - ret = NvAPI_GPU_GPIOReadFromPin(hPhysicalGpu, &gpioReadPin);
//!
//!                On call success:
//!                - The gpioReadPingpioDataReadWrite would contain the data value read (0 or 1) from the specified pin.
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 175
//!
//!  \param [in]  hPhysicalGpu   GPU selection.
//!  \param       pgpioReadPin   Pointer to a versioned structure to pass the GPIO pin number from which the data is
//!                              to be read, the GPIO direction and the variable in which the data is collected.
//!                              The gpioPinNumber parameter is selected from pgpioLegalPins array by calling 
//!                              NvAPI_GPU_GPIOQueryLegalPins().   
//!
//!  \retval ::NVAPI_OK 
//!  \retval ::NVAPI_ERROR 
//!  \retval ::NVAPI_INVALID_HANDLE 
//!  \retval ::NVAPI_HANDLE_INVALIDATED
//!  \retval ::NVAPI_INVALID_ARGUMENT 
//!  \retval ::NVAPI_API_NOT_INITIALIZED
//!  \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION 
//!  \ingroup gpugpio   
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GPIOReadFromPin(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_GPIO_PIN_DATA *pgpioReadPin);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GPIOWriteToPin
//
//! DESCRIPTION:   This function writes data to the specified GPIO pin.
//!
//! HOW TO USE:    First make NvAPI_GPU_GPIOQueryLegalPins() call. 
//!                - NV_GPU_GPIO_PIN_DATA gpioWritePin = {0};
//!                - gpioWritePin.version = NV_GPU_GPIO_PIN_DATA_VER;
//!                - gpioWritePingpioDirection = NVAPI_GPIO_DIRECTION_OUTPUT;
//!                - gpioWritePingpioReadPin.gpioPinNumber = any legal pin data from gpioLegalPins array after successful call to NvAPI_GPU_GPIOQueryLegalPins() 
//!                - gpioWritePin.gpioDataReadWrite = any bit value (0 or 1)
//!                - ret = NvAPI_GPU_GPIOReadFromPin(hPhysicalGpu, &gpioReadPin);
//!
//!                On call success:
//!                - The gpioWritePingpioDataReadWrite value (0 or 1) is written to the specified pin.    
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 175
//!
//! \param [in]  hPhysicalGpu(IN)    GPU selection.
//! \param       pgpioWritePin       Pointer to a versioned structure to pass gpio pin number to which the data is
//!                                  to be written, the GPIO direction and the data value. The gpioPinNumber parameter
//!                                  is selected from pgpioLegalPins array by calling NvAPI_GPU_GPIOQueryLegalPins.   
//! 
//! \retval ::NVAPI_OK 
//! \retval ::NVAPI_ERROR 
//! \retval ::NVAPI_INVALID_HANDLE 
//! \retval ::NVAPI_HANDLE_INVALIDATED
//! \retval ::NVAPI_INVALID_ARGUMENT 
//! \retval ::NVAPI_API_NOT_INITIALIZED
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION 
//!
//! \ingroup gpugpio                 
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GPIOWriteToPin(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_GPIO_PIN_DATA *pgpioWritePin);




/////////////////////////////////////////////////////////////////////////////// 
// 
// FUNCTION NAME: NvAPI_GPU_GetHDCPSupportStatus 
//
//! \fn NvAPI_GPU_GetHDCPSupportStatus(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_GET_HDCP_SUPPORT_STATUS *pGetHDCPSupportStatus)
//! DESCRIPTION: This function returns a GPU's HDCP support status. 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 175
//!
//!  \retval ::NVAPI_OK 
//!  \retval ::NVAPI_ERROR 
//!  \retval ::NVAPI_INVALID_ARGUMENT 
//!  \retval ::NVAPI_HANDLE_INVALIDATED 
//!  \retval ::NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE 
//!  \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION 
// 
////////////////////////////////////////////////////////////////////////////////
    

//! \addtogroup gpu
//! @{


//! HDCP fuse states - used in NV_GPU_GET_HDCP_SUPPORT_STATUS
typedef enum _NV_GPU_HDCP_FUSE_STATE
{
    NV_GPU_HDCP_FUSE_STATE_UNKNOWN  = 0,
    NV_GPU_HDCP_FUSE_STATE_DISABLED = 1,
    NV_GPU_HDCP_FUSE_STATE_ENABLED  = 2,
} NV_GPU_HDCP_FUSE_STATE;


//! HDCP key sources - used in NV_GPU_GET_HDCP_SUPPORT_STATUS
typedef enum _NV_GPU_HDCP_KEY_SOURCE
{
    NV_GPU_HDCP_KEY_SOURCE_UNKNOWN    = 0,
    NV_GPU_HDCP_KEY_SOURCE_NONE       = 1,
    NV_GPU_HDCP_KEY_SOURCE_CRYPTO_ROM = 2,
    NV_GPU_HDCP_KEY_SOURCE_SBIOS      = 3,
    NV_GPU_HDCP_KEY_SOURCE_I2C_ROM    = 4,
    NV_GPU_HDCP_KEY_SOURCE_FUSES      = 5,
} NV_GPU_HDCP_KEY_SOURCE;


//! HDCP key source states - used in NV_GPU_GET_HDCP_SUPPORT_STATUS
typedef enum _NV_GPU_HDCP_KEY_SOURCE_STATE
{
    NV_GPU_HDCP_KEY_SOURCE_STATE_UNKNOWN = 0,
    NV_GPU_HDCP_KEY_SOURCE_STATE_ABSENT  = 1,
    NV_GPU_HDCP_KEY_SOURCE_STATE_PRESENT = 2,
} NV_GPU_HDCP_KEY_SOURCE_STATE;


//! HDPC support status - used in NvAPI_GPU_GetHDCPSupportStatus()
typedef struct 
{
    NvU32                        version;               //! Structure version constucted by macro #NV_GPU_GET_HDCP_SUPPORT_STATUS
    NV_GPU_HDCP_FUSE_STATE       hdcpFuseState;         //! GPU's HDCP fuse state
    NV_GPU_HDCP_KEY_SOURCE       hdcpKeySource;         //! GPU's HDCP key source
    NV_GPU_HDCP_KEY_SOURCE_STATE hdcpKeySourceState;    //! GPU's HDCP key source state    
} NV_GPU_GET_HDCP_SUPPORT_STATUS;


//! Macro for constructing the version for structure NV_GPU_GET_HDCP_SUPPORT_STATUS
#define NV_GPU_GET_HDCP_SUPPORT_STATUS_VER MAKE_NVAPI_VERSION(NV_GPU_GET_HDCP_SUPPORT_STATUS,1)


//! @}


//!  \ingroup gpu 
NVAPI_INTERFACE NvAPI_GPU_GetHDCPSupportStatus(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_GET_HDCP_SUPPORT_STATUS *pGetHDCPSupportStatus);




//! \ingroup gpu
//! Used in NvAPI_GetHdcpHdmiDiagnostics().
typedef struct
{
    NvU32 version;                          //!< Structure version

    //! HDCP diagnostic information
    struct
    {
        NvU32 bGpuCapable              : 1; //!< GPU is HDCP-capable (no errors detected, everything present)
        NvU32 bGpuFusePresent          : 1; //!< GPU HDCP fuse register set

        NvU32 bDfpCapable              : 1; //!< Display is HDCP-capable
        NvU32 bDfpAllowed              : 1; //!< VBIOS allows HDCP on display
        NvU32 bDfpDualLink             : 1; //!< Is attach point dual-link capable

        NvU32 bRomError                : 1; //!< HDCP hardware detected an error with the rom
        NvU32 bDownstreamChecksumError : 1; //!< Set if hardware reports that its checksum BIST of its downstream HDCP keys failed

        NV_HDCP_PACKET packet;              //!< HDCP packet of information:
                                            //!< Only the following parts of the HDCP packet are populated:
                                            //!< - bStatus, hdcpStatus, cS, kP, aN, aKsv, dKsv, vP, mP, numBKSVs,
                                            //!< - bKsvList (bKsv, first 1 or 2 indices of bKsvList).
                                            //!< Use the packet.flFlags property to check which fields are valid/invalid.
    } hdcp;

    //! HDMI diagnostic information for display
    struct
    {
        NvU32 bGpuCapable              : 1; //!< GPU is HDMI capable (indicates fuses are set)

        NvU32 bDfpCapable              : 1; //!< Display is HDMI capable
        NvU32 bDfpAllowed              : 1; //!< VBIOS allows HDMI on display
        NvU32 bDfpDualLink             : 1; //!< Is display dual-link capable
    } hdmi;

} NV_HDCP_HDMI_DIAGNOSTICS;


//! \ingroup gpu
//! Macro for constructing the version field for NV_GET_HDCP_HDMI_DIAGNOSTICS.
#define NV_GET_HDCP_HDMI_DIAGNOSTICS_VER MAKE_NVAPI_VERSION(NV_HDCP_HDMI_DIAGNOSTICS,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetHdcpHdmiDiagnostics
//
//!  DESCRIPTION: This API returns diagnostic information on display HDCP and HDMI capabilities.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 180
//!
//! \retval ::NVAPI_OK                            completed request
//! \retval ::NVAPI_ERROR                         miscellaneous error occurred
//! \retval ::NVAPI_INVALID_ARGUMENT              pGetGpuHdcpSupportStatus is NULL
//! \retval ::NVAPI_HANDLE_INVALIDATED            handle passed has been invalidated (see user guide)
//! \retval ::NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  handle passed is not a physical GPU handle
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION   the version of the INFO struct is not supported
//! \retval ::NVAPI_EXPECTED_DIGITAL_FLAT_PANEL   outputId is not associated with digital flat panel.
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetHdcpHdmiDiagnostics(NvPhysicalGpuHandle hPhysicalGpu, NvU32 displayId, NV_HDCP_HDMI_DIAGNOSTICS *pHdcpHdmiDiagnostics);






///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetACPIIdFromOutputId
//
//! \code
//! PARAMETERS:      hPhysicalGpu(IN)        - GPU selection.
//!                  pOutputId(IN)           - pointer to the array of OutputIds with max size 16
//!                  uOutputIdCount(IN)      - Number of OutputIds in the OutputId array
//!                  pACPIid(OUT)            - pointer to the array of ACPIIds with max size 16
//!                   
//! DESCRIPTION: Returns corresponding ACPI Ids for the given Display OutputIds
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! RETURN STATUS: 
//!                  NVAPI_OK - completed request
//!                  NVAPI_ERROR - miscellaneous error occurred
//!                  NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//!                  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//!                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//! \endcode
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetACPIIdFromOutputId(NvPhysicalGpuHandle hPhysicalGpu, NvU32 pOutputId[NVAPI_MAX_ACPI_IDS], NvU32 uOutputIdCount, NvU32 pACPIid[NVAPI_MAX_ACPI_IDS] );

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetOutputIdFromACPIId
//
//! \code
//! PARAMETERS:      hPhysicalGpu(IN)        - GPU selection.
//!                  pACPIid(IN)             - pointer to the array of ACPIIds with max size 16
//!                  uACPIidCount(IN)        - Number of ACPIids in the ACPIId array
//!                  pOutputId(OUT)          - pointer to the array of OutputIds with max size 16
//!
//! DESCRIPTION: Returns corresponding ACPIId for the given Display OutputId
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! RETURN STATUS: 
//!                  NVAPI_OK - completed request
//!                  NVAPI_ERROR - miscellaneous error occurred
//!                  NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//!                  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//!                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//! \endcode
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetOutputIdFromACPIId(NvPhysicalGpuHandle hPhysicalGpu, NvU32 pACPIid[NVAPI_MAX_ACPI_IDS], NvU32 uACPIidCount, NvU32 pOutputId[NVAPI_MAX_ACPI_IDS]);



//! \ingroup sysdps
//! Used in NvAPI_SYS_GetDisplayPowerSavingState() and NvAPI_SYS_SetDisplayPowerSavingState().
typedef enum
{
    NV_DISPLAY_POWER_SAVING_NOT_SUPPORTED = -1,
    NV_DISPLAY_POWER_SAVING_DISABLED = 0,
    NV_DISPLAY_POWER_SAVING_ENABLED = 1
} NV_DISPLAY_POWER_SAVING;

///////////////////////////////////////////////////////////////////////////////
//
// Notes about Display Power Saving feature :
//
// This feature works only on LVDS panels and requires that to be active.
// The feature is system specific and can be controlled independent
// of whether the LVDS panel is active.
//
// To control the nvDPS through NVAPI interface, the following registry value
// has to be added:
// only for internal use - DWORD nvDPSSettings = 0x786002B in the same location where BINARY RMGpuId exists.
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_SYS_GetDisplayPowerSavingState
//
//! DESCRIPTION:    This API queries the current Display Power Saving state.
//!
//! HOW TO USE:     
//!                 - NV_DISPLAY_POWER_SAVING State;
//!                 - ret = NvAPI_SYS_GetDisplayPowerSavingState(&State);
//!                 - On call success:
//!                 - State would either be NV_DISPLAY_POWER_SAVING_ENABLED or NV_DISPLAY_POWER_SAVING_DISABLED
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \param  pState  Pointer to NV_DISPLAY_POWER_SAVING variable receiving Power Saving State
//!
//! \retval ::NVAPI_OK 
//! \retval ::NVAPI_ERROR 
//! \retval ::NVAPI_NOT_SUPPORTED       Display Power Saving feature is not available on the target hardware,
//! \retval ::NVAPI_INVALID_ARGUMENT 
//! \retval ::NVAPI_API_NOT_INTIALIZED 
//! \retval ::NVAPI_HANDLE_INVALIDATED 
//!
//! \ingroup sysdps
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_GetDisplayPowerSavingState(NV_DISPLAY_POWER_SAVING *pState);





///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_SYS_SetDisplayPowerSavingState
//
//! DESCRIPTION:    This API sets the current Display Power Saving state.
//!
//! HOW TO USE:     
//!                 - NV_DISPLAY_POWER_SAVING State = either NV_DISPLAY_POWER_SAVING_ENABLED or NV_DISPLAY_POWER_SAVING_DISABLED;
//!                 - ret = NvAPI_SYS_SetDisplayPowerSavingState(State);
//!                 - On call success:
//!                 - Display Power Saving feature would be enabled or disabled
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \param   State  NV_DISPLAY_POWER_SAVING_DISABLED or NV_DISPLAY_POWER_SAVING_ENABLED
//!
//! \retval ::NVAPI_OK 
//! \retval ::NVAPI_ERROR 
//! \retval ::NVAPI_NOT_SUPPORTED  Display Power Saving feature is not available on the target hardware
//! \retval ::NVAPI_INVALID_ARGUMENT 
//! \retval ::NVAPI_API_NOT_INTIALIZED 
//! \retval ::NVAPI_HANDLE_INVALIDATED 
//!
//! \ingroup sysdps
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_SetDisplayPowerSavingState(NV_DISPLAY_POWER_SAVING State);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetSupportedSLIViews
//! DESCRIPTION:     This API, based on the connected state obtained from NvAPI_GPU_GetConnectedSLIOutputs(),
//!                  enumerates the supported NVIDIA display views when SLI is active.
//!                  If SLI is not active then this API returns all the supported nView modes. \n
//!                  Note : If a client make the call using a GPU handle with no 
//!                         connected monitors, then this API returns ::NVAPI_NOT_SUPPORTED.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//! 
//! \param [in]     hPhysicalGpu  GPU selection
//! \param [out]    pTargetViews  Array of supported views. Can be NULL to retrieve the pViewCount first.
//! \param [in,out] pViewCount    Count of supported views.
//!
//! \retval ::NVAPI_OK 
//! \retval ::NVAPI_ERROR 
//! \retval ::NVAPI_INVALID_ARGUMENT 
//! \retval ::NVAPI_NOT_SUPPORTED 
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetSupportedSLIViews(NvPhysicalGpuHandle hPhysicalGpu, NV_TARGET_VIEW_MODE pTargetViews[NVAPI_MAX_VIEW_MODES], NvU32 *pViewCount);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_SetTopologyFocusDisplayAndView
//! DESCRIPTION:     This API works on the active display GPU and lets the calling application switch
//!                  the focus display. It accepts path information to specify single, Clone or Dualview. \n
//!                  Note : If SLI is not active then this API returns ::NVAPI_NO_ACTIVE_SLI_TOPOLOGY.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]     hLogicalGPU              Active logical gpu topology containing more than one physical gpus.
//! \param [in]     focusDisplayOutputId     Connected display output Id on the target GPU which should be focused.
//! \param [in]     pPathInfo                Pointer to NV_VIEW_PATH_INFO, specifying device properties in this view.
//!                                          The first device entry in the array is the physical primary.
//!                                          The device entry with the lowest source ID is the desktop primary.
//! \param [in]     displayView              Display view selected from NV_TARGET_VIEW_MODE.
//!
//! \retval ::NVAPI_OK  
//! \retval ::NVAPI_ERROR 
//! \retval ::NVAPI_INVALID_ARGUMENT 
//! \retval ::NVAPI_NO_ACTIVE_SLI_TOPOLOGY  SLI is not active on this device.
//!
//! \ingroup gputopology
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetTopologyFocusDisplayAndView(NvLogicalGpuHandle hLogicalGPU, NvU32 focusDisplayOutputId, NV_DISPLAY_PATH_INFO *pPathInfo, NV_TARGET_VIEW_MODE displayView);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetDriverModel
//
//! DESCRIPTION: This API sets the driver model(pDriverModel) corresponding to the specified GPU.
//!              - Win7: For G84 GPUs and higher  0x00001100 (corresponds to WDDM 1.1)
//!              - Win7: For all other GPUs       0x00001000 (corresponds to WDDM 1.0)
//!              - Windows Vista: All GPUs        0x00001000 (corresponds to WDDM 1.0)
//!              - WindowsXP:                     Not Supported
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]     hPhysicalGpu      GPU selection.
//! \param [out]    pDriverModel      pointer to the Driver Model
//!
//! \retval ::NVAPI_OK 
//! \retval ::NVAPI_ERROR 
//! \retval ::NVAPI_HANDLE_INVALIDATED 
//! \retval ::NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE 
//! \retval ::NVAPI_INVALID_ARGUMENT 
//! \retval ::NVAPI_INVALID_HANDLE 
//! \retval ::NVAPI_API_NOT_INTIALIZED 
//! \retval ::NVAPI_NOT_SUPPORTED   Only for Win7 & Vista
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetDriverModel(NvPhysicalGpuHandle hPhysicalGpu, NvU32* pDriverModel);





//! \addtogroup gpucuda
//! @{

//! defgroup nvcomp_gpu_top NVIDIA Compute GPU Topology Flags
//! @{   
#define NV_COMPUTE_GPU_TOPOLOGY_PHYSICS_CAPABLE            NV_BIT(0)   //!< This is Read only GPU flag - Physics capable GPU.
#define NV_COMPUTE_GPU_TOPOLOGY_PHYSICS_ENABLE            NV_BIT(1)   //!< This is Read/Write GPU flag - indicates GPU is already enabled for physics.
                                                                    //! Application can use this flag to request physics to be enabled on this GPU.
                                                                    //! No ENABLE flag indicates DISABLE Physics on this GPU.
#define NV_COMPUTE_GPU_TOPOLOGY_PHYSICS_DEDICATED        NV_BIT(2)   //!< This is Read only GPU flag - Physics enabled GPU which is *dedicated* for physics indicates
                                                                    //! this compute capable GPU was automatically made usable for Physx on CUDA.
#define NV_COMPUTE_GPU_TOPOLOGY_PHYSICS_RECOMMENDED     NV_BIT(3)   //!< This is Read only GPU flag - Physics GPU which is recommended by the driver.                                                          
#define NV_COMPUTE_GPU_TOPOLOGY_CUDA_AVAILABLE            NV_BIT(4)   //!<This is Read only GPU flag-GPU is capable and !disabled and  it is in IDM if needed. This is useful to CUDA client apps. 


#define NV_COMPUTE_GPU_PRIVATE_MASK                        0xFFFF0000  
#define NV_COMPUTE_GPU_TOPOLOGY_CUDA_CAPABLE            NV_BIT(16)  //!< This is Read only GPU flag - GPU physically can do compute regardless of IDM state or disabled state 
#define NV_COMPUTE_GPU_TOPOLOGY_CUDA_DISABLED            NV_BIT(17)  //!< This is Read only GPU flag - GPU is Disabled for CUDA apps via SRS 825
#define NV_COMPUTE_GPU_TOPOLOGY_IDM_ENABLED                NV_BIT(18)  //!< This is Read only GPU flag - No longer used
#define NV_COMPUTE_GPU_TOPOLOGY_IDM_ACTIVE                NV_BIT(19)  //!< This is Read only GPU flag - No longer used
#define NV_COMPUTE_GPU_TOPOLOGY_CUDA_HYBRID_DISABLED    NV_BIT(20)  //!< This is Read only GPU flag - CUDA is unavailable on this GPU while in the current hybrid mode
#define NV_COMPUTE_GPU_TOPOLOGY_PHYSICS_AVAILABLE       NV_BIT(21)  //!< This is Read only GPU flag - PhysX is able to use this GPU (PhysX is installed, etc) 

//! @}


//! Used in NvAPI_GPU_CudaEnumComputeCapableGpus(), NvAPI_GPU_PhysxSetState(), and NvAPI_GPU_PhysxQueryRecommendedState().
typedef struct
{
    NvU32 version;  //!< Structure version
    NvU32 gpuCount; //!< Total number of compute-capable GPUs

    struct
    {
        NvPhysicalGpuHandle  hPhysicalGpu;      //!< Compute-capable physical GPU handle
        NvU32                flags;             //!< One or more flags from \ref nvcomp_gpu_top

    } computeGpus[NVAPI_MAX_GPU_PER_TOPOLOGY];  //!< Array of compute-capable physical GPUs.

} NV_COMPUTE_GPU_TOPOLOGY_V1;


typedef struct _NV_COMPUTE_GPU
{
     NvPhysicalGpuHandle  hPhysicalGpu;      //!< Compute-capable physical GPU handle
     NvU32                flags;             //!< One or more flags from \ref nvcomp_gpu_top

} NV_COMPUTE_GPU;

typedef struct _NV_COMPUTE_GPU_TOPOLOGY_V2
{
    NvU32 version;  //!< Structure version
    NvU32 gpuCount; //!< Size of array
    NV_COMPUTE_GPU *computeGpus;  //!< Array of compute-capable physical GPUs (allocate memory of size of Physical gpucount of system).

} NV_COMPUTE_GPU_TOPOLOGY_V2;

//! Macro for constructing the version field of NV_COMPUTE_GPU_TOPOLOGY
#define NV_COMPUTE_GPU_TOPOLOGY_VER1  MAKE_NVAPI_VERSION(NV_COMPUTE_GPU_TOPOLOGY_V1,1)

#define NV_COMPUTE_GPU_TOPOLOGY_VER  MAKE_NVAPI_VERSION(NV_COMPUTE_GPU_TOPOLOGY_V2,2)
typedef NV_COMPUTE_GPU_TOPOLOGY_V2 NV_COMPUTE_GPU_TOPOLOGY;

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_GPU_CudaEnumComputeCapableGpus
//
//! DESCRIPTION:   This API enumerates one or more compute-capable GPUs.
//!                Compute-capable GPUs are not necessarily GPUs that are usable with CUDA. Applications can make a GPU "compute-capable" by:
//!                  - Enabling PhysX using NvAPI_GPU_PhysxSetState() OR
//!                  - Enabling at least one display using NvAPI_CreateDisplayFromUnAttachedDisplay() on the unattached display handle for the compute GPU
//!
//! \deprecated  Do not use this function - it is deprecated in release 319. Instead, use NvAPI_CUDA_EnumComputeCapableByTopology.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \param [out]      pPhysicsTopo  An array of compute-capable GPUs.
//!
//! \retval ::NVAPI_OK     Completed request. The gpuCount indicates if one or more compute-capable GPUs are 
//!                        found. gpuCount >= 1 if atleast one compute-capable GPU is found.
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION  Structure version is not supported, initialize to NV_COMPUTE_GPU_TOPOLOGY_VER.
//! \retval ::NVAPI_ERROR                        Enumeration of the GPUs failed. Make sure at least one NVIDIA GPU exists in the system.
//!
//! \ingroup gpucuda
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 319. Instead, use NvAPI_CUDA_EnumComputeCapableByTopology.")
NVAPI_INTERFACE NvAPI_GPU_CudaEnumComputeCapableGpus(__inout NV_COMPUTE_GPU_TOPOLOGY *pComputeTopo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_CUDA_EnumComputeCapableByTopology
//
//! DESCRIPTION:    This API needs both GPU topology and display topology, since our recommendation include which displays are lit and which display is the GDI primary.
//!                 Because SLI state affects how the final display topology look like, it is assumed predicted display topology will be provided
//!
//!                 NOTE: It is two pass API
//!						  Pass1: Call with computeGpus set to NULL to get gpuCount size
//!                       Pass2: Allocate memory to computeGpus of size gpuCount to get the info
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param[IN/OUT]  computeTopo    -  An array of compute capable gpus.
//! \param[IN]      gpuTopology    -  An array of NV_GPU_VALID_GPU_TOPOLOGIES
//! \param[IN]      pathInfoCount  -  Number of elements in pathInfo array
//! \param[IN]      pathInfo       -  The pathInfo must only contain the source and target mappings ,as well as sourcemodeinfo.
//!
//! \return			This API can return any of the error codes enumerated in
//!					#NvAPI_Status.  If there are return error codes with specific
//!					meaning for this API, they are listed below.
//! \endcode
//! \ingroup gpucuda
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_CUDA_EnumComputeCapableByTopology(__inout NV_COMPUTE_GPU_TOPOLOGY *computeTopo, __in_opt NV_GPU_VALID_GPU_TOPOLOGIES *gpuTopology, __in NvU32 pathInfoCount, __in_opt NV_DISPLAYCONFIG_PATH_INFO *pathInfo );






//! \ingroup gpudeepidle
//! @{


//! Used in NvAPI_GPU_GetDeepIdleState() and NvAPI_GPU_SetDeepIdleState().
typedef enum 
{ 
    NV_DEEP_IDLE_NOT_SUPPORTED = -1, 
    NV_DEEP_IDLE_DISABLE      = 0, 
    NV_DEEP_IDLE_ENABLE       = 1 
} NV_DEEP_IDLE_STATE;



///////////////////////////////////////////////////////////////////////////////
//
// Notes about GPU Deep Idle feature :
//
// This feature currently works only in simulation mode on G9x via a registry key.
// In the simulation mode, the clocks will be lowered but there won't be a true
// "deep idle" state.
//
// To control the GPU Deep Idle through NVAPI interface, the following registry value
// has to be added:
// only for internal use - DWORD DeepIdleSim = 0 (disable simulation) or 1 (enable simulation)
//                                             in the location where RmGpuId for dGPU exists.   
// 
/////////////////////////////////////////////////////////////////////////////// 

//! SUPPORTED OS:  Windows XP and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_GPU_GetDeepIdleState
//
//! \code
//! PARAMETERS:     hLogicalGpu(IN) - logical GPU selection
//!                 pState(OUT) - Pointer to NV_DEEP_IDLE_STATE variable receiving GPU Deep Idle State
//!
//! DESCRIPTION:    This API queries the current GPU Deep Idle state
//!
//!
//! HOW TO USE:     NV_DEEP_IDLE_STATE State;
//!                 ret = NvAPI_GPU_GetDeepIdleState(hLogicalGpu, &State);
//!                 On call success:
//!                 State would either be NV_DEEP_IDLE_ENABLE or NV_DEEP_IDLE_DISABLE 
//! 
//! RETURN STATUS: 
//!                 NVAPI_OK - completed request
//!                 NVAPI_ERROR - miscellaneous error occurred
//!                 NVAPI_NOT_SUPPORTED - GPU Deep Idle feature is not available on the target hardware
//!                 NVAPI_INVALID_HANDLE - logical GPU not found
//!                 NVAPI_INVALID_ARGUMENT - invalid argument passed
//!                 NVAPI_API_NOT_INTIALIZED - nvapi not initialized
//!                 NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//!                 NVAPI_EXPECTED_LOGICAL_GPU_HANDLE - handle passed is not a logical GPU handle  
//! \endcode 
/////////////////////////////////////////////////////////////////////////////// 
NVAPI_INTERFACE NvAPI_GPU_GetDeepIdleState(NvLogicalGpuHandle hLogicalGpu, NV_DEEP_IDLE_STATE *pState);

//! SUPPORTED OS:  Windows XP and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_GPU_SetDeepIdleState
//
//! \code
//! PARAMETERS:     hLogicalGpu(IN) - logical GPU selection
//!                 pState(IN) - NV_DEEP_IDLE_STATE variable inidicating the state to be set
//!
//! DESCRIPTION:    This API sets the GPU Deep Idle state
//!
//! HOW TO USE:     NV_DEEP_IDLE State = either NV_DEEP_IDLE_ENABLE or NV_DEEP_IDLE_DISABLE;
//!                 ret = NvAPI_GPU_SetDeepIdleState(hLogicalGpu, State);
//!                 On call success:
//!                 GPU Deep Idle feature would either be enabled or disabled
//!
//! RETURN STATUS:
//!                 NVAPI_OK - completed request
//!                 NVAPI_ERROR - miscellaneous error occurred
//!                 NVAPI_NOT_SUPPORTED - GPU Deep Idle feature is not available on the target hardware
//!                 NVAPI_INVALID_HANDLE - logical GPU not found
//!                 NVAPI_INVALID_ARGUMENT - invalid argument passed
//!                 NVAPI_API_NOT_INTIALIZED - nvapi not initialized
//!                 NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//!                 NVAPI_EXPECTED_LOGICAL_GPU_HANDLE - handle passed is not a logical GPU handle 
//! \endcode 
/////////////////////////////////////////////////////////////////////////////// 
NVAPI_INTERFACE NvAPI_GPU_SetDeepIdleState(NvLogicalGpuHandle hLogicalGpu, NV_DEEP_IDLE_STATE State);

//! @}



//! SUPPORTED OS:  Windows Vista and higher
//!

//! \ingroup gpudeepidle
//! @{

typedef enum 
{ 
    NV_DEEP_IDLE_STATISTICS_MODE_NH,    //!< No heads
    NV_DEEP_IDLE_STATISTICS_MODE_VE,    //!< Vblank extended
    NV_DEEP_IDLE_STATISTICS_MODE_SSC,   //!< SSC Mode
    NV_DEEP_IDLE_STATISTICS_MODE_FO     //!< FB Off
} NV_DEEP_IDLE_STATISTICS_MODE;

typedef struct
{
    NvU32   version;                    //!< Structure version
    NvU32   attempts;                   //!< Number of attempts made to enter Deep Idle
    NvU32   entries;                    //!< Number of successful entries into Deep Idle
    NvU32   exits;                      //!< Number of exits out of Deep Idle
    NvU32   time;                       //!< Amount of time in microseconds spent in Deep Idle
    NvU32   maxEntryLatency;            //!< maximum latency (in microseconds) for entering Deep Idle
    NvU32   maxExitLatency;             //!< maximum latency (in microseconds) for exiting Deep Idle
    NvU32   veFrames;                   //!< number of frames spent in Deep Idle (VE mode only)
    NvU32   veVblankExits;              //!< number of Deep Idle exits due to end of vblank (VE mode only)
    NvU32   veDeepL1Exits;              //!< number of Deep Idle exits due to Deep L1 exit (VE mode only)
} NV_DEEP_IDLE_STATISTICS;

//! Macro for constructing the version field of ::NV_DEEP_IDLE_STATISTICS
#define NV_DEEP_IDLE_STATISTICS_VER MAKE_NVAPI_VERSION(NV_DEEP_IDLE_STATISTICS,1)

/////////////////////////////////////////////////////////////////////////////// 
// 
// FUNCTION NAME:  NvAPI_GPU_SetDeepIdleStatisticsMode
//
//! \code
//! PARAMETERS:     hPhysicalGpu(IN) - GPU selection
//!                 Mode(IN)         - NV_DEEP_IDLE_STATISTICS_MODE variable indicating which flavor of Deep Idle for which to collect information
//!                 bReset(IN)       - Boolean indicating whether or not all current statistics for the specified mode should be reset to 0
//!
//! DESCRIPTION:    This API returns statistics about GPU Deep Idle activity
//!
//! HOW TO USE:     When gathering Deep Idle statistics, call this function first to specify
//!                 the Deep Idle flavor of interest and clear previous statistics if desired.
//!
//! RETURN STATUS:
//!                 NVAPI_OK - completed request
//!                 NVAPI_ERROR - miscellaneous error occurred
//!                 NVAPI_NOT_SUPPORTED - GPU Deep Idle feature is not available on the target hardware
//!                 NVAPI_INVALID_HANDLE - logical GPU not found
//!                 NVAPI_INVALID_ARGUMENT - invalid argument passed
//!                 NVAPI_API_NOT_INTIALIZED - nvapi not initialized
//!                 NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//!                 NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE- hPhysicalGpu is not a physical GPU handle.
//! \endcode
/////////////////////////////////////////////////////////////////////////////// 
NVAPI_INTERFACE NvAPI_GPU_SetDeepIdleStatisticsMode(NvPhysicalGpuHandle hPhysicalGpu, NV_DEEP_IDLE_STATISTICS_MODE Mode, NvU32 bReset);

//! SUPPORTED OS:  Windows Vista and higher
//!
/////////////////////////////////////////////////////////////////////////////// 
// 
// FUNCTION NAME:  NvAPI_GPU_GetDeepIdleStatistics
//
//! \code
//! PARAMETERS:     hPhysicalGpu(IN) - GPU selection
//!                 pStatistics(OUT) - NV_DEEP_IDLE_STATISTICS variable containing Deep Idle activity information
//!
//! DESCRIPTION:    This API returns statistics about GPU Deep Idle activity
//!
//! HOW TO USE:     Call this function to get the current statistics information for the Deep Idle
//!                 flavor that was specified in the call to NvAPI_GPU_SetDeepIdleStatisticsMode.
//!
//! RETURN STATUS:
//!                 NVAPI_OK - completed request
//!                 NVAPI_ERROR - miscellaneous error occurred
//!                 NVAPI_NOT_SUPPORTED - GPU Deep Idle feature is not available on the target hardware
//!                 NVAPI_INVALID_HANDLE - logical GPU not found
//!                 NVAPI_INVALID_ARGUMENT - invalid argument passed
//!                 NVAPI_API_NOT_INTIALIZED - nvapi not initialized
//!                 NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//!                 NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE- hPhysicalGpu is not a physical GPU handle.
//! \endcode
/////////////////////////////////////////////////////////////////////////////// 
NVAPI_INTERFACE NvAPI_GPU_GetDeepIdleStatistics(NvPhysicalGpuHandle hPhysicalGpu, NV_DEEP_IDLE_STATISTICS *pStatistics);

//! @}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetTachReading
//
//!   DESCRIPTION: This API retrieves the fan speed tachometer reading for the specified physical GPU.
//!
//!   HOW TO USE:   
//!                 - NvU32 Value = 0;
//!                 - ret = NvAPI_GPU_GetTachReading(hPhysicalGpu, &Value);  
//!                 - On call success:
//!                 - Value contains the tachometer reading
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \param [in]    hPhysicalGpu   GPU selection.
//! \param [out]   pValue         Pointer to a variable to get the tachometer reading
//!
//! \retval ::NVAPI_OK - completed request
//! \retval ::NVAPI_ERROR - miscellaneous error occurred
//! \retval ::NVAPI_NOT_SUPPORTED - functionality not supported 
//! \retval ::NVAPI_API_NOT_INTIALIZED - nvapi not initialized
//! \retval ::NVAPI_INVALID_ARGUMENT - invalid argument passed
//! \retval ::NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//! \retval ::NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//!
//! \ingroup gpucooler
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetTachReading(NvPhysicalGpuHandle hPhysicalGPU, NvU32 *pValue);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetThermalTable
//
//! \fn NvAPI_GPU_GetThermalTable(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_THERMAL_TABLE *pThermalTable)
//! \code
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! DESCRIPTION:     Returns the list of thermal table entries for this GPU.
//!                      ttVersion - version of thermal table 
//!                      numEntries - number of thermal table entries returned
//!
//!
//! RETURN STATUS: 
//!    NVAPI_OK - completed request, *pTable contains the thermal table entries
//!    NVAPI_ERROR - miscellaneous error occurred
//!    NVAPI_NOT_SUPPORTED - not available on the target hardware
//!    NVAPI_INVALID_ARGUMENT - pThermalTable is NULL
//!    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//!    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//!    NVAPI_INCOMPATIBLE_STRUCT_VERSION - NV_THERMAL_TABLE structure version mismatch
//! \endcode
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gputhermal
#define NVAPI_GPU_THERMAL_TABLE_MAX_ENTRIES (256)

//! \ingroup gputhermal
typedef struct
{
    NvU32   version;            //!< Structure version
    NvU32   flags;              //!< call with 0, reserved for future extensions 
    NvU32   ttVersion;
    NvU32   numEntries;
    NvU32   entryList[NVAPI_GPU_THERMAL_TABLE_MAX_ENTRIES];
} NV_GPU_THERMAL_TABLE;

//! \ingroup gputhermal
//! Macro for constructing the version field of ::NV_GPU_THERMAL_TABLE
#define NV_GPU_THERMAL_TABLE_VER MAKE_NVAPI_VERSION(NV_GPU_THERMAL_TABLE,1)

//! \ingroup gputhermal
NVAPI_INTERFACE NvAPI_GPU_GetThermalTable(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_THERMAL_TABLE *pThermalTable);




//! \ingroup gpucooler
//! @{

typedef enum
{
    NV_FAN_SENSE_NOTSUPPORTED = 0, //!< fan sense not supported
    NV_FAN_SENSE_SUPPORTED = 1,    //!< fan sense supported
} NV_FAN_SENSE;

typedef struct
{
    NvU32   version;
    NvU32   coolerCount;
    NV_FAN_SENSE   supportFlag[NVAPI_MAX_COOLERS_PER_GPU];
} NV_GPU_FAN_SPIN_SENSE;

//! Macro for constructing the version field of ::NV_GPU_FAN_SPIN_SENSE
#define NV_GPU_FAN_SPIN_SENSE_VER MAKE_NVAPI_VERSION(NV_GPU_FAN_SPIN_SENSE, 1)

//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME : NvAPI_GPU_QueryFanSpinSenseSupport
//
//! \code  
//! PARAMETERS    : hPhysicalGpu(IN)       - GPU selection 
//!                 coolerIndexRequest(IN) - Index of the cooler (0 to NVAPI_MAX_COOLERS_PER_GPU-1) to retrieve info if 
//!                                          any particular is of interest otherwise to retrieve info for all the cooler,
//!                                          set coolerIndex to NVAPI_COOLER_TARGET_ALL.                                           
//!                 pSpinSense(OUT)        - Pointer to the versioned structure NV_GPU_FAN_SPIN_SENSE in which the 
//!                                          total count of the coolers associated with the GPU and their individual
//!                                          fan spin sense support flags are retrieved.
//!
//! DESCRIPTION   : This function will return the fan spin sense info for a particular or all the coolers associated with a GPU.
//!
//! HOW TO USE    : NV_GPU_FAN_SPIN_SENSE spinSense = {0};
//!                 coolerIndexRequest = NVAPI_COOLER_TARGET_ALL;
//!                 spinSense.version = NV_GPU_FAN_SPIN_SENSE_VER;
//!                 ret = NvAPI_GPU_QueryFanSpinSenseSupport(hPhysicalGpu, &spinSense);
//!                 on call success:
//!                 spinSense.count indicates the number of coolers associated with the GPU.
//!                 spinSense.supportFlag array would contain the flag(1 = supported, 0 = not) for each of the 
//!                 coolers associated with the GPU.                  
//!                 
//! RETURN STATUS:
//!                 NVAPI_OK - completed request
//!                 NVAPI_ERROR - miscellaneous error occurred
//!                 NVAPI_NOT_SUPPORTED - this feature is not supported on this GPU
//!                 NVAPI_INVALID_HANDLE - physical GPU not found
//!                 NVAPI_INVALID_ARGUMENT - invalid arugument passed
//!                 NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//!                 NVAPI_API_NOT_INITIALIZED - nvapi not initialized
//!                 NVAPI_INCOMPATIBLE_STRUCT_VERSION - structure passed not initialized with proper version data
//! \endcode
///////////////////////////////////////////////////////////////////////////////    
NVAPI_INTERFACE NvAPI_GPU_QueryFanSpinSenseSupport(NvPhysicalGpuHandle hPhysicalGpu, NvU32 coolerIndexRequest, NV_GPU_FAN_SPIN_SENSE *pSpinSense);

//! @}




///////////////////////////////////////////////////////////////////////////////
//             
// FUNCTION NAME: NvAPI_GPU_CreateStringHashFromPhysicalGpu
//
//! \code
//! PARAMETERS:    hPhysicalGpu (IN)   - GPU selection.
//!                nSize (IN)          - size of pre-allocated string
//!                szHash (OUT)        - pointer to pre-allocated string array.
//!                                      If a value is written to the array it
//!                                      will be NULL-terminated.
//!                  
//! SUPPORTED OS:  Windows XP
//!
//! DESCRIPTION:   This function creates a string hash that represents a
//!                given physical GPU for the purpose of controlling which
//!                GPU is used as the OpenGL multimon-buffer master GPU.
//!
//! HOW TO USE:    The string is stored in the app profile.  Later, when
//!                an OGL app starts up, NvAPI_GPU_ConvertStringHashToPhysicalGpu
//!                converts the string back into a GPU handle.
//!                     
//! RETURN STATUS: 
//!                NVAPI_OK - completed request
//!                NVAPI_ERROR - miscellaneous error occurred
//!                NVAPI_INVALID_ARGUMENT - invalid input parameter
//!                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - hPhysicalGpu is not a physical GPU handle.
//!                NVAPI_STRING_TOO_SMALL - szHash is too small because the hash'd string exceeds (nSize+1) characters
//! \endcode
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_CreateStringHashFromPhysicalGpu(NvPhysicalGpuHandle hPhysicalGpu, NvU32 nSize, NvAPI_String szHash);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_ConvertStringHashToPhysicalGpu
//
//! \code
//! PARAMETERS:    szHash (OUT)        - pointer to null-terminated string hash
//!                hPhysicalGpu (OUT)  - GPU selection
//!                  
//! SUPPORTED OS:  Windows XP
//!
//! DESCRIPTION:   This function converts to a physical GPU handle from a
//!                string hash that was created by
//!                NvAPI_GPU_CreateStringHashFromPhysicalGpu.  If the exact GPU
//!                is not present then the "best match" GPU will be selected.
//!
//! RETURN STATUS: 
//!                NVAPI_OK - completed request
//!                NVAPI_ERROR - miscellaneous error occurred
//!                NVAPI_INVALID_ARGUMENT - invalid input parameter
//!                NVAPI_MATCHING_DEVICE_NOT_FOUND - none of the present devices are a close-enough match to szHash
//! \endcode
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_ConvertStringHashToPhysicalGpu(NvAPI_String szHash, NvPhysicalGpuHandle hPhysicalGpu);





///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GPU_QueryDPTopology
//
//
//! DESCRIPTION:  This API returns the DPMST topology information for a given connector.
//! HOW TO USE:   
//!           -# For each PhysicalGpu, make a call to get the connected displayId's using NvAPI_GPU_GetConnectedDisplayIds()
//!           -# If we found any DPMST connector for the particular displayId, then try to do the step3
//!           -# To find, number of nodes available under one displayId of DPMST topology use NvAPI_GPU_QueryDPTopology() bypassing pNodes as NULL
//!           -# On success allocate memory for pNodes based on pNumOfNodes returned and call NvAPI_GPU_QueryDPTopology() to get the nodes' details
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]     displayId   This is the displayId of the DPMST connector to which the topology is rooted.
//! \param [in,out] pNodes      Pointer to an array of NV_DP_NODE_INFO structures, where each entry represents one node on the DPMST topology
//! \param [in,out] pNumOfNodes When pNodes is NULL, this is treated as out parameter, and if the function successfully returns, will hold the 
//!                             total number of nodes in the DPMST topology.
//!                             When pNodes in NOT NULL, this is treated as both IN and OUT parameter. 
//!                             On the input path, this will hold the total size of the array that pNodes is pointing to.
//!                             On the output path, this will hold the actual number of nodes in the DPMST topology. If this actual 
//!                             value is greater than the input value, the API will return NVAPI_INSUFFICIENT_BUFFER.
//!
//! 
//! \retval ::NVAPI_INSUFFICIENT_BUFFER  When the actual number of nodes in the topology exceed the number of elements allocated for pNodes. 
//! \retval ::NVAPI_DPMST_CHANGED        The DPMST topology has changed midway while fetching the details. Please retry again.
//! 
//! \ingroup gputopology
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_QueryDPTopology(__in NvU32 displayId, __inout_ecount_full_opt(*pNumOfNodes) NV_DP_NODE_INFO* pNodes, __inout NvU32* pNumOfNodes);




#define MAX_PCLK_RANGES 10

//! \addtogroup gpuclock
//! @{

//! Used in NV_SET_PCLK and NV_GET_PCLK.
typedef struct
{
    NvU32           uMaxPixClk;                         //!< Maximum Upper Frequency
    NvU32           uMinPixClk;                         //!< Minimum Upper Frequency
} NV_PCLK_RANGE;


//! Used in NvAPI_GPU_GetPixelClockRange().
typedef struct
{
    NvU32           uOrgPixelClock;                     //!< Original Frequency in Hz
    NvU32           uCurrPixelClock;                    //!< Frequency in Hz
    NvU32           uCurrSpreadSpectrum;                //!< Spread Spectrum Range in Hz
    NV_PCLK_RANGE   uFineAdjustBounds;                  //!< Optional: Upper/Lower bounds
                                                        //!< If not present then only 
                                                        //!< course adjustment is supported. 
    NV_PCLK_RANGE   uCourseAdjustBounds;                //!< Timing Shift Upper/Lower
} NV_GET_PCLK;


//! Used in NvAPI_GPU_SetPixelClockRange().
typedef struct
{
    NV_PCLK_RANGE   uAllowedRanges[MAX_PCLK_RANGES];    //!< Allowed List
    NV_PCLK_RANGE   uDisallowedRanges[MAX_PCLK_RANGES]; //!< Disallowed List
} NV_SET_PCLK;


//! @}


///////////////////////////////////////////////////////////////////////////////
//
// GPS (previously known as OptimusBoost) APIs
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_GPS_GetPowerSteeringStatus
//! \fn            NvAPI_GPS_GetPowerSteeringStatus(__out NV_GPS_PS_STATUS *pPowerSteeringStatus)
//!
//! DESCRIPTION:   This API retrieves the current power steering status.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param[out]    pPowerSteeringStatus
//!                    0 = Power steering disabled
//!                    1 = PowerSteering enabled
//!                    2 = not supported on this platform
//!
//! \return        This API can return any of the error codes enumerated in #NvAPI_Status. 
//!                If there are return error codes with specific meaning for this API, 
//!                they are listed below.
//!
//! \retval        NVAPI_OK - completed request
//! \retval        NVAPI_ERROR - miscellaneous error occurred
//! \retval        NVAPI_NOT_SUPPORTED - GPS feature is not available on the target hardware
//! \retval        NVAPI_INVALID_ARGUMENT - invalid argument passed
//! \retval        NVAPI_API_NOT_INTIALIZED - nvapi not initialized
//!
///////////////////////////////////////////////////////////////////////////////

//! \ingroup nvpmapi 
typedef enum {
    NV_GPS_PS_DISABLED      = 0,
    NV_GPS_PS_ENABLED       = 1,
    NV_GPS_PS_NOT_SUPPORTED = 2
} NV_GPS_PS_STATUS;

//! \ingroup nvpmapi 
NVAPI_INTERFACE NvAPI_GPS_GetPowerSteeringStatus(__out NV_GPS_PS_STATUS *pPowerSteeringStatus);   


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    NvAPI_GPS_SetPowerSteeringStatus
//
//! DESCRIPTION:     This API enables or disables GPS power steering.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//!\ param[in]       PowerSteeringStatus
//!                      0 = Power steering disabled
//!                      1 = PowerSteering enabled
//!                      any other value - not invalid
//!
//! \return        This API can return any of the error codes enumerated in #NvAPI_Status. 
//!                If there are return error codes with specific meaning for this API, 
//!                they are listed below.
//!
//! \retval        NVAPI_OK - completed request
//! \retval        NVAPI_ERROR - miscellaneous error occurred
//! \retval        NVAPI_NOT_SUPPORTED - GPS feature is not available on the target hardware
//! \retval        NVAPI_INVALID_ARGUMENT - invalid argument passed
//! \retval        NVAPI_API_NOT_INTIALIZED - nvapi not initialized
//!
//! \ingroup nvpmapi 
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPS_SetPowerSteeringStatus(__in NV_GPS_PS_STATUS PowerSteeringStatus);   


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    NvAPI_GPS_GetFrmData
//! \fn              NvAPI_GPS_GetFrmData(__inout NV_GPS_GET_FRM_DATA *pFrmData)
//
//! DESCRIPTION:     This API will fetch FRM related parameters.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param[out]    frmSampleData - Contains frame specific data.
//! \param[out]    nextSampleNumber - Sample number contain sample number on which next
//!                frame data is entered. Also with this we get to know till what point 
//!                array is filled.
//!
//! \return        This API can return any of the error codes enumerated in #NvAPI_Status. 
//!                If there are return error codes with specific meaning for this API, 
//!                they are listed below.
//!
//! \retval        NVAPI_OK - completed request
//! \retval        NVAPI_NOT_SUPPORTED - GPS feature is not available on the target hardware
//!
//! \ingroup nvpmapi 
///////////////////////////////////////////////////////////////////////////////
//! \ingroup nvpmapi   
// This size should be in sync with size of buffer in RM. 
#define MAX_GPS_FRM_BUFFER_SIZE   64

typedef struct _NV_GPS_GET_FRM_DATA_NODE
{
    NvU16 frameTime;
    NvU16 renderTime;
    NvU16 targetTime;
    NvU8  clientID;
    NvU8  sampleNumber;
} NV_GPS_GET_FRM_DATA_NODE;

//! \ingroup nvpmapi
typedef struct _NV_GPS_GET_FRM_DATA
{
    NvU32   version;                             //!< Version of this structure
    NvU8  nextSampleNumber;                      //!< contain sample number on which next frame data will entered.
    NV_GPS_GET_FRM_DATA_NODE frmSampleData[MAX_GPS_FRM_BUFFER_SIZE];

} NV_GPS_GET_FRM_DATA_V1;

//! \ingroup nvpmapi 
typedef NV_GPS_GET_FRM_DATA_V1      NV_GPS_GET_FRM_DATA;

//! \ingroup nvpmapi
#define NV_GPS_GET_FRM_DATA_VER_1   MAKE_NVAPI_VERSION(NV_GPS_GET_FRM_DATA,1)

//! \ingroup nvpmapi
#define NV_GPS_GET_FRM_DATA_VER     NV_GPS_GET_FRM_DATA_VER_1

NVAPI_INTERFACE NvAPI_GPS_GetFrmData(__inout NV_GPS_GET_FRM_DATA *pFrmData); 


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPS_SetVPStateCap 
//
//! DESCRIPTION:    This API sets the Virtual P state cap
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//! \param[in]     newCap - Requested New Virtual P State Cap
//!
//! \return        This API can return any of the error codes enumerated in #NvAPI_Status. 
//!                If there are return error codes with specific meaning for this API, 
//!                they are listed below.
//!
//! \retval        NVAPI_OK - completed request
//! \retval        NVAPI_ERROR - miscellaneous error occurred
//! \retval        NVAPI_NOT_SUPPORTED - GPS is not available on the target hardware
//! \retval        NVAPI_INVALID_ARGUMENT - invalid argument passed
//! \retval        NVAPI_API_NOT_INTIALIZED - nvapi not initialized
//!
//! \ingroup nvpmapi 
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPS_SetVPStateCap(__in NvPhysicalGpuHandle hPhysicalGpu,
                                        __in NvU32 newCap); 


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_GPS_GetVPStateCap 
//
//! DESCRIPTION:   This API retrieves the current Virtual P State Cap.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param[out]    pCurCap - Current Virtual P State Cap
//!
//! \return        This API can return any of the error codes enumerated in #NvAPI_Status. 
//!                If there are return error codes with specific meaning for this API, 
//!                they are listed below.
//!
//! \retval        NVAPI_OK - completed request
//! \retval        NVAPI_ERROR - miscellaneous error occurred
//! \retval        NVAPI_NOT_SUPPORTED - GPS feature is not available on the target hardware
//! \retval        NVAPI_INVALID_ARGUMENT - invalid argument passed
//! \retval        NVAPI_API_NOT_INTIALIZED - nvapi not initialized
//!
//! \ingroup nvpmapi 
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPS_GetVPStateCap(__in  NvPhysicalGpuHandle hPhysicalGpu,
                                        __out NvU32 *pCurCap);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_GPS_GetThermalLimit 
//! \fn            NvAPI_GPS_GetThermalLimit(__inout NV_GPS_GET_THERMAL_LIMIT_PARM *pParams)
//!
//! DESCRIPTION:   This API retrieves the information on the limit for the requested sensor.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param[in/out]  pParams -- pointer to parameter block
//!
//! \return        This API can return any of the error codes enumerated in #NvAPI_Status. 
//!                If there are return error codes with specific meaning for this API, 
//!                they are listed below.
//!
//! \retval        NVAPI_OK - completed request
//!
///////////////////////////////////////////////////////////////////////////////

//! \ingroup nvpmapi 
typedef enum {
    NV_GPS_SENSOR_INDEX_TGPU_LIMIT             =  9,
    NV_GPS_SENSOR_INDEX_PDTS_LIMIT             = 10,
    NV_GPS_SENSOR_INDEX_SFAN_LIMIT             = 11,
    NV_GPS_SENSOR_INDEX_SKNT_LIMIT             = 12,
    NV_GPS_SENSOR_INDEX_CPUE_LIMIT             = 13,
    NV_GPS_SENSOR_INDEX_TMP1_LIMIT             = 14,
    NV_GPS_SENSOR_INDEX_TMP2_LIMIT             = 15
} NV_GPS_SENSOR_INDEX;

//! \ingroup nvpmapi 
typedef enum {
    NV_GPS_THERM_LIMIT_SRC_USER_LIMITED        = 1,
    NV_GPS_THERM_LIMIT_SRC_SBIOS_LIMITED       = 2,
    NV_GPS_THERM_LIMIT_SRC_SBIOS_UNLIMITED     = 3,
    NV_GPS_THERM_LIMIT_SRC_SBIOS_NOT_SUPPORTED = 4,
    NV_GPS_THERM_LIMIT_SRC_USER_DISABLED       = 5
} NV_GPS_THERM_LIMIT_SRC;

//! \ingroup nvpmapi
#define NV_GPS_THERM_LIMIT_SBIOS_LIMITED         0
//! \ingroup nvpmapi
#define NV_GPS_THERM_LIMIT_NOT_LIMITED           1

//! \ingroup nvpmapi 
typedef struct _NV_GPS_GET_THERMAL_LIMIT_PARM {

    // IN
    NvU32   version;                       //!< Version of this structure
    NV_GPS_SENSOR_INDEX sensorIndex;       //!< Id of the sensor to retrieve the current thermal limit from.
                                           //!<     refer to enum NV_GPS_SENSOR_INDEX above.
    
    
    // OUT
    NvU32                   limit;         //!< 0 = no limit
                                           //!< any other value -- current thermal limit.
    NvU32                   lowerBound;    //!< Minimum value permitted for thermal limit.
    NvU32                   upperBound;    //!< Maximim value permitted for thermal limit.
    NV_GPS_THERM_LIMIT_SRC  limitSource;   //!< specifies what is determining the limit for the specified sensor.
                                           //!<     refer to enum NV_GPS_THERM_LIMIT_SRC above.
} NV_GPS_GET_THERMAL_LIMIT_PARM_V1;

//! \ingroup nvpmapi 
typedef NV_GPS_GET_THERMAL_LIMIT_PARM_V1      NV_GPS_GET_THERMAL_LIMIT_PARM;
//! \ingroup nvpmapi 
#define NV_GPS_GET_THERMAL_LIMIT_PARM_VER_1   MAKE_NVAPI_VERSION(NV_GPS_GET_THERMAL_LIMIT_PARM_V1,1)
//! \ingroup nvpmapi 
#define NV_GPS_GET_THERMAL_LIMIT_PARM_VER     NV_GPS_GET_THERMAL_LIMIT_PARM_VER_1

//! \ingroup nvpmapi 
NVAPI_INTERFACE NvAPI_GPS_GetThermalLimit(__inout NV_GPS_GET_THERMAL_LIMIT_PARM *pParams);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPS_SetThermalLimit 
//! \fn             NvAPI_GPS_SetThermalLimit(__in NV_GPS_SET_THERMAL_LIMIT_PARM *pParams)
//!
//! DESCRIPTION:    This API sets the thermal limit for the specified sensor.
//!
//! \since Release: 290
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param[in,out]  pParams -- pointer to parameter block
//!
//! \return        This API can return any of the error codes enumerated in #NvAPI_Status. 
//!                If there are return error codes with specific meaning for this API, 
//!                they are listed below.
//!
//! \retval        NVAPI_OK - completed request
//!
///////////////////////////////////////////////////////////////////////////////

//! \ingroup nvpmapi 
typedef struct _NV_GPS_SET_THERMAL_LIMIT_PARM {

    // IN
    NvU32   version;                   //!< Version of this structure
    NV_GPS_SENSOR_INDEX sensorIndex;   //!< Id of the sensor whose limit we are setting.
                                       //!<     refer to enum NV_GPS_SENSOR_INDEX above.
    NvU32    newLimit;                 //!< the new limit to apply to the sensor.
    
    // OUT
                                    
} NV_GPS_SET_THERMAL_LIMIT_PARM_V1;

//! \ingroup nvpmapi 
typedef NV_GPS_SET_THERMAL_LIMIT_PARM_V1      NV_GPS_SET_THERMAL_LIMIT_PARM;
//! \ingroup nvpmapi 
#define NV_GPS_SET_THERMAL_LIMIT_PARM_VER_1   MAKE_NVAPI_VERSION(NV_GPS_SET_THERMAL_LIMIT_PARM_V1,1)
//! \ingroup nvpmapi 
#define NV_GPS_SET_THERMAL_LIMIT_PARM_VER     NV_GPS_SET_THERMAL_LIMIT_PARM_VER_1

//! \ingroup nvpmapi 
NVAPI_INTERFACE NvAPI_GPS_SetThermalLimit(__in NV_GPS_SET_THERMAL_LIMIT_PARM *pParams);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPS_Ctrl 
//! \fn             NvAPI_GPS_Ctrl(__inout NV_GPS_CTRL_PARM *pParams)
//!
//! DESCRIPTION:    This API provides control functions for GPS.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param[in]     cmd      -- indicates which control command to execute
//! \param[in]     input[]  -- input for the specified command, exact nature of the data is dependent on the command.
//! \param[out]    result[] -- result for the specified command, exact nature of the data is dependent on the command.
//!
//! \return        This API can return any of the error codes enumerated in #NvAPI_Status. 
//!
///////////////////////////////////////////////////////////////////////////////

//! \ingroup nvpmapi 
typedef enum {
    NvGpsGetPowerSteeringStatus         =  0,     //!<   result[0] -- current power stearing status.
    NvGpsSetPowerSteeringStatus         =  1,     //!<   input[0]  -- new power steering value.
    NvGpsGetThermLimit                  =  2,     //!<   input[0]  -- sensor id.
                                                  //!<   result[0] -- current limit.
                                                  //!<   result[1] -- min limit value.
                                                  //!<   result[2] -- max limit value.
                                                  //!<   result[3] -- limit source.
    NvGpsSetThermLimit                  =  3,     //!<   input[0]  -- sensor id.
                                                  //!<   input[1]  -- new limit.
    NvGpsGetTempCtrlDownNDelta          =  4,     //!<   input[0]  -- sensor id.
                                                  //!<   result[0] -- current delta.
    NvGpsSetTempCtrlDownNDelta          =  5,     //!<   input[0]  -- sensor id.
                                                  //!<   input[1]  -- new delta.
    NvGpsGetTempCtrlHoldDelta           =  6,     //!<   input[0]  -- sensor id.
                                                  //!<   result[0] -- current delta.
    NvGpsSetTempCtrlHoldDelta           =  7,     //!<   input[0]  -- sensor id.
                                                  //!<   input[1]  -- new delta.
    NvGpsGetTempCtrlUpDelta             =  8,     //!<   input[0]  -- sensor id.
                                                  //!<   result[0] -- current delta.
    NvGpsSetTempCtrlUpDelta             =  9,     //!<   input[0]  -- sensor id.
                                                  //!<   input[1]  -- new delta.
    NvGpsGetTempCtrlEngageDelta         = 10,     //!<   input[0]  -- sensor id.
                                                  //!<   result[0] -- current delta.
    NvGpsSetTempCtrlEngageDelta         = 11,     //!<   input[0]  -- sensor id.
                                                  //!<   input[1]  -- new delta.
    NvGpsGetTempCtrlDisengageDelta      = 12,     //!<   input[0]  -- sensor id.
                                                  //!<   result[0] -- current delta.
    NvGpsSetTempCtrlDisengageDelta      = 13,     //!<   input[0]  -- sensor id.
                                                  //!<   input[1]  -- new delta.
    NvGpuGetEngadgeThresholdUp          = 14,     //!<   result[0] -- current engage threshold.
    NvGpuSetEngadgeThresholdUp          = 15,     //!<   input[0]  -- new engage threshold.
    NvGpuGetDisengageThresholdDown      = 16,     //!<   result[0] -- current disengage threshold.
    NvGpuSetDisengageThresholdDown      = 17,     //!<   input[0]  -- new disengage threshold.
    NvCpuGetHystHigh                    = 18,     //!<   result[0] -- current hysteresis upper limit.
    NvCpuSetHystHigh                    = 19,     //!<   input[0]  -- new hysteresis upper limit.
    NvCpuGetHystLow                     = 20,     //!<   result[0] -- current  hysteresis lower limit.
    NvCpuSetHystLow                     = 21,     //!<   input[0]  -- new hysteresis lower limit.
    NvGpsGetTempCtrl                    = 22,     //!<   result[0] -- current temp ctrl setting.
    NvGpsSetTempCtrl                    = 23,     //!<   input[0]  -- new temp ctrl setting.
    NvCpuGetUtilAvgNum                  = 24,     //!<   result[0] -- current number of samples to average.
    NvCpuSetUtilAvgNum                  = 25,     //!<   input[0]  -- new number of samples to average.
    NvGpsGetPerfCounter                 = 26,     //!<   input[0]  -- counter id being requested.
                                                  //!<   input[1]  -- next expected poll cycle in ms (0 = not expecting to poll).
                                                  //!<   result[0] -- current value for requested counter.
    NvGpsCallAcpi                       = 27,     //!<   input[0]  -- ACPI Command
                                                  //!<   input[1]  -- ACPI Command input parameter
                                                  //!<   result[0] -- ACPI command response 1
                                                  //!<   result[1] -- ACPI command response 2
    NvGpsSetIGpuTurbo                   = 28,     //!<   input[0]  -- new igpu turbo state (bool for enabled/disabled)
    NvGpsGetHystHighAc                  = 55,     //!<   result[0] -- current hysteresis upper limit, on AC
    NvGpsSetHystHighAc                  = 56,     //!<   input[0]  -- new hysteresis upper limit, on AC
    NvGpsGetHystLowAc                   = 57,     //!<   result[0] -- current hysteresis lower limit, on AC
    NvGpsSetHystLowAc                   = 58,     //!<   input[0]  -- new hysteresis lower limit, on AC
    NvGpsGetHystHighBatt                = 59,     //!<   result[0] -- current hysteresis upper limit, on DC
    NvGpsSetHystHighBatt                = 60,     //!<   input[0]  -- new hyteresis upper limit, on DC
    NvGpsGetHystLowBatt                 = 61,     //!<   result[0] -- current hysteresis lower limit, on DC
    NvGpsSetHystLowBatt                 = 62,     //!<   input[0]  -- new hysteresis lower limit, on DC
    NvGpsGetHystHighBBoost              = 63,     //!<   result[0] -- current hysteresis upper limit, on BatteryBoost
    NvGpsSetHystHighBBoost              = 64,     //!<   input[0]  -- new hysteresis upper limit, on BatteryBoost
    NvGpsGetHystLowBBoost               = 65,     //!<   result[0] -- current hysteresis lower limit, on BatteryBoost
    NvGpsSetHystLowBBoost               = 66      //!<   input[0]  -- new hysteresis lower limit, on BatteryBoost
} NV_GPS_CTRL_CMD;

//! \ingroup nvpmapi 
typedef struct _NV_GPS_CTRL_PARM_V1
{
    // IN
    NvU32   version;                   //!< Version of this structure
    NV_GPS_CTRL_CMD cmd;               //!< the command the GPS control system should execute
                                       //!<     refer to enum NV_GPS_CTRL_CMD above.
    NvS32    input[2];                 //!< the input to use for the command specified in cmd.
    
    // OUT
    NvS32    result[4];                //!< the result/output from executing the specified command.
                                    
} NV_GPS_CTRL_PARM_V1;

//! \ingroup nvpmapi 
typedef NV_GPS_CTRL_PARM_V1      NV_GPS_CTRL_PARM;
//! \ingroup nvpmapi 
#define NV_GPS_CTRL_PARM_VER_1   MAKE_NVAPI_VERSION(NV_GPS_CTRL_PARM_V1,1)
//! \ingroup nvpmapi 
#define NV_GPS_CTRL_PARM_VER     NV_GPS_CTRL_PARM_VER_1
NVAPI_INTERFACE NvAPI_GPS_Ctrl(__inout NV_GPS_CTRL_PARM *pParams);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPS_CallACPI 
//! \fn             NvAPI_GPS_CallACPI(__inout NV_GPS_ACPI_PARM *pParams)
//!
//! DESCRIPTION:    This API calls the specified ACPI command for testing purposes.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param[in]     cmd      -- indicates which control command to execute
//! \param[in]     input[]  -- input for the specified command, exact nature of the data is dependent on the command.
//! \param[out]    result[] -- result for the specified command, exact nature of the data is dependent on the command.
//!                            number of entries in array result depends on the size of struct PSS_ENTRY and value of ACPI_PSS_ENTRY_MAX.
//!                            while the former is 6 NvU32 long, the later is 32. 
//!                            thus, MAX_GPS_ACPI_RESULT_BUFFER cannot be smaller than 192
//!
//! \return        This API can return any of the error codes enumerated in #NvAPI_Status. 
//!
///////////////////////////////////////////////////////////////////////////////

//! \ingroup nvpmapi 
#define MAX_GPS_ACPI_RESULT_BUFFER  192

//! \ingroup nvpmapi 
typedef struct _NV_GPS_ACPI_PARM_V1
{
    // IN
    NvU32   version;                             //!< Version of this structure
    NvU32   cmd;                                 //!< the ACPI command the GPS control system should execute -
                                                 //!<     refer to GPS spec.
    NvU32   input;                               //!< the input to use for the command specified in cmd.
    
    // OUT
    NvU32   resultSz;                            //!< size of the result buffer for the specified command.
    NvU32   result[MAX_GPS_ACPI_RESULT_BUFFER];  //!< the result/output from executing the specified command.

} NV_GPS_ACPI_PARM_V1;

//! \ingroup nvpmapi 
typedef NV_GPS_ACPI_PARM_V1      NV_GPS_ACPI_PARM;

//! \ingroup nvpmapi 
#define NV_GPS_ACPI_PARM_VER_1   MAKE_NVAPI_VERSION(NV_GPS_ACPI_PARM_V1,1)

//! \ingroup nvpmapi 
#define NV_GPS_ACPI_PARM_VER     NV_GPS_ACPI_PARM_VER_1

//! \ingroup nvpmapi 
NVAPI_INTERFACE NvAPI_GPS_CallACPI(__inout NV_GPS_ACPI_PARM *pParams);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPS_GetPerfSensors
//! \fn             NvAPI_GPS_GetPerfSensors(__inout NV_GPS_PERFSENSORS_PARM *pParams)
//!
//! \since Release: 290
//!
//! DESCRIPTION:    This API returns various counters that indicate the state of GPS, Thermal controller, and power steering
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param[in,out]  pParams -- pointer to parameter block
//!
//! \return        This API can return any of the error codes enumerated in #NvAPI_Status. 
//!
///////////////////////////////////////////////////////////////////////////////

//! \ingroup nvpmapi 
//! @{


#define GPS_PSC_PS_TC_DYNAMIC_SENSOR_BLOCK 0
#define GPS_PSC_PS_TC_CPU_UTIL_SENSOR_BLOCK 2
#define GPS_PSC_ACPI_SENSOR_BLOCK 3

typedef enum {
    GPS_PSC_SB0_PS_SID           =      0,   //!< Power Steering Sample Id
    GPS_PSC_SB0_PS_ENABLE        =      1,   //!< Power steering enabled
    GPS_PSC_SB0_CPU_PSTATE_CAP   =      5,   //!< CPU PState Cap
    GPS_PSC_SB0_CPU_TSTATE_CAP   =      7,   //!< CPU TState Cap
    GPS_PSC_SB0_GPU_UTIL         =      9,   //!< GPU Utilization
    GPS_PSC_SB0_GPU_TEMP         =     15,   //!< current GPU temp
    GPS_PSC_SB0_TC_TRGT_TEMP     =     16,   //!< Thermal Controller Target temp
    GPS_PSC_SB0_PM1_STATE_AVAIL  =     18,   //!< PM1 availability
    GPS_PSC_SB0_TDP_IDX          =     19,   //!< TDP PState index
    GPS_PSC_SB0_GPU_VPSTATE      =     24,   //!< current GPU VPState
    GPS_PSC_SB0_GPU_VPSTATE_CAP  =     25,   //!< GPU VPState Cap
    GPS_PSC_SB0_TGPU_CURR_VALUE  =     26,   //!< current GPU temp
} GPS_PSC_SB0_INDEX;
//! @}

//! \ingroup nvpmapi 
typedef struct _NV_GPS_GET_PERF_SENSOR_COUNTERS_PARAM_V1 {

    // IN
    NvU32    version;                   //!< Version of this structure
    NvU32    objHndl;                   //!< object handle
    NvU16    blockId;                   //!< Id of the BLock to return
    NvU32    nextExpectedSampleTime;    //!< a relative time period in ms
                                        //!< indicating when the 
                                        //!< application next expects to 
                                        //!< sample the counters. This is 
                                        //!< used as a hint to try to 
                                        //!< optimize the collection of 
                                        //!< the sensor data to minimize 
                                        //!< overhead when the function is 
                                        //!< called again. If it is not 
                                        //!< known when the next expected 
                                        //!< sampling will be done, or you 
                                        //!< do not expect to do any more 
                                        //!< sampling a value of 0 should 
                                        //!< be used. (other values may 
                                        //!< result in extra sensor 
                                        //!< sampling)

    NvU32    countersReq;               //!< Bitmap of counters within       
                                        //!< specified block to return

    // OUT
    NvU32    countersReturned;          //!< Bitmap of counters populated 
                                        //!< within the returned block
    NvU32    counterBlock[32];          //!< Returned counters. Counters 
                                        //!< not indicated as returned in
                                        //!< the CountersReturned bitmap
                                        //!< are undefined

} NV_GPS_GET_PERF_SENSOR_COUNTERS_PARAM_V1;

//! \ingroup nvpmapi 
typedef NV_GPS_GET_PERF_SENSOR_COUNTERS_PARAM_V1      NV_GPS_GET_PERF_SENSOR_COUNTERS_PARAM;
//! \ingroup nvpmapi 
#define NV_GPS_GET_PERF_SENSOR_COUNTERS_PARAM_VER_1   MAKE_NVAPI_VERSION(NV_GPS_GET_PERF_SENSOR_COUNTERS_PARAM_V1,1)
//! \ingroup nvpmapi 
#define NV_GPS_GET_PERF_SENSOR_COUNTERS_PARAM_VER     NV_GPS_GET_PERF_SENSOR_COUNTERS_PARAM_VER_1

//! \ingroup nvpmapi 
NVAPI_INTERFACE NvAPI_GPS_GetPerfSensors(__inout NV_GPS_GET_PERF_SENSOR_COUNTERS_PARAM *pParams);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPS_GetPerfSensorsInternal
//! \fn             NvAPI_GPS_GetPerfSensorsInternal(__inout NV_GPS_PERFSENSORS_PARM *pParams)
//!
//! \since Release: 290
//!
//! DESCRIPTION:    This API is identical to the NvAPI_GPS_GetPerfSensors, except it is private, and returns an extended set of counters.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param[in]     objHndl  -- handle for object that may be required to get sensorData -- currently not used.
//! \param[in]     blockId  -- Id for the block of 32 counters to be retrieved.
//! \param[in]     nextExpectedSampleTime -- the time in ms indicating when the next expected call
//!                for the sensor block will be made. This is used as a hint for scheduling future
//!                reads of the sensors. Set to 0 if this is unknown, or no next call is expected.
//! \param[in]     countersReq -- a bitmask indicating which counters within the block are being requested.
//! \param[out]    countersReturned -- a bitmask indicating which counters have been returned.
//! \param[out]    counterBlock -- an array of 32 counters containing the counters 
//!                indicated in the countersReturned parameter.
//
//! \return        This API can return any of the error codes enumerated in #NvAPI_Status. 
//!
///////////////////////////////////////////////////////////////////////////////

//! \ingroup nvpmapi 
//! @{
typedef enum {
    GPS_PSC_EXT_SB0_PS_SID                =  0,   //!< Power Steering Sample Id
    GPS_PSC_EXT_SB0_PS_ENABLE             =  1,   //!< Power steering enabled
    GPS_PSC_EXT_SB0_CPU_TEMP              =  2,   //!< current CPU temp
    GPS_PSC_EXT_SB0_PS_CPU_CORE_UTIL_MAX  =  3,   //!< CPU utilization of busiest core
    GPS_PSC_EXT_SB0_CPU_PSTATE            =  4,   //!< current CPU PState
    GPS_PSC_EXT_SB0_CPU_PSTATE_CAP        =  5,   //!< CPU PState Cap
    GPS_PSC_EXT_SB0_CPU_TSTATE            =  6,   //!< current CPU TState
    GPS_PSC_EXT_SB0_CPU_TSTATE_CAP        =  7,   //!< CPU TState Cap
    GPS_PSC_EXT_SB0_PPC_LIMIT             =  8,   //!< current programmed PPC Limit
    GPS_PSC_EXT_SB0_GPU_UTIL              =  9,   //!< GPU Utilization
    GPS_PSC_EXT_SB0_GPU_CORE_UTIL         = 10,   //!< GPU Core utilization
    GPS_PSC_EXT_SB0_GPU_FB_UTIL           = 11,   //!< Frame buffer Utilization
    GPS_PSC_EXT_SB0_GPU_VIDEO_UTIL        = 12,   //!< Video utilization
    GPS_PSC_EXT_SB0_TC_SID                = 13,   //!< Thermal controller sample Id
    GPS_PSC_EXT_SB0_TC_ENABLE             = 14,   //!< Thermal controller enabled
    GPS_PSC_EXT_SB0_GPU_TEMP              = 15,   //!< current GPU temp
    GPS_PSC_EXT_SB0_TC_TRGT_TEMP          = 16,   //!< Thermal Controller Target temp
    GPS_PSC_EXT_SB0_PM1_SID               = 17,   //!< PM1 Sample Id
    GPS_PSC_EXT_SB0_PM1_STATE_AVAIL       = 18,   //!< PM1 availability
    GPS_PSC_EXT_SB0_TDP_IDX               = 19,   //!< TDP PState index
    GPS_PSC_EXT_SB0_MS_SID                = 20,   //!< Misc Sample Id
    GPS_PSC_EXT_SB0_IGP_TURBO_STATUS      = 21,   //!< IGP Turbo enabled
    GPS_PSC_EXT_SB0_GPU_GPC_CLK           = 22,   //!< current GPC clock
    GPS_PSC_EXT_SB0_GPU_NVDD              = 23,   //!< 
    GPS_PSC_EXT_SB0_GPU_FSTATE            = 24,   //!< current GPU FState
    GPS_PSC_EXT_SB0_GPU_FSTATE_CAP        = 25,   //!< GPU FState Cap
    GPS_PSC_EXT_SB0_TGPU_CURR_VALUE       = 26,   //!< current GPU temp
    GPS_PSC_EXT_SB0_PS_APERF_CPU_FREQ     = 28,   //!< CPU Freq as reported via aperf
    GPS_PSC_EXT_SB0_PS_MSR_CPU_FREQ       = 29,   //!< CPU Freq as reported via MSR
    GPS_PSC_EXT_SB0_PS_EXP_CPU_FREQ       = 30,   //!< CPU Freq as reported via Pstate tbl
} GPS_PSC_EXT_SB0_INDEX;

typedef enum {
    GPS_PSC_EXT_SB1_PS_SID                =  0,   //!< Power Steering Sample Id
    GPS_PSC_EXT_SB1_PS_SAMPLE_PERIOD_MS   =  1,   //!< Power steering polling interval
    GPS_PSC_EXT_SB1_PS_ENGAGE_TEMP_DELTA  =  2,   //!< Power steering engage temp delta
    GPS_PSC_EXT_SB1_PS_CPU_MIN_FREQ_MHZ   =  3,   //!< Power steering Min CPU freq
    GPS_PSC_EXT_SB1_PS_CPU_MAX_FREQ_MHZ   =  4,   //!< Power steering Max CPU freq
    GPS_PSC_EXT_SB1_PS_CPU_HYST_HIGH      =  5,   //!< Power steering upper hysteresis limit
    GPS_PSC_EXT_SB1_PS_CPU_HYST_LOW       =  6,   //!< Power steering lower hysteresis limit
    GPS_PSC_EXT_SB1_PS_CPU_C0_CORE_THRESH =  7,   //!< Power steering CPU utilization Threshold
    GPS_PSC_EXT_SB1_PS_CPU_UTIL_AVG_NUM   =  8,   //!< Power steering number of utilization samples to average
    GPS_PSC_EXT_SB1_TC_SID                = 12,   //!< Thermal Controller Sample Id
    GPS_PSC_EXT_SB1_TC_SAMPLE_PERIOD_MS   = 13,   //!< Thermal Controller polling interval
    GPS_PSC_EXT_SB1_TC_ENGAGE_TEMP        = 14,   //!< Thermal Controller engage temp
    GPS_PSC_EXT_SB1_TC_DISENGAGE_TEMP     = 15,   //!< Thermal Controller disengage temp
    GPS_PSC_EXT_SB1_TC_DOWN_N_THRESH      = 16,   //!< Thermal Controller Down N Threshold
    GPS_PSC_EXT_SB1_TC_HOLD_THRESH        = 17,   //!< Thermal Controller Hold Threshold
    GPS_PSC_EXT_SB1_TC_UP_THRESH          = 18,   //!< Thermal Controller Up Threshold
} GPS_PSC_EXT_SB1_INDEX;

typedef enum {
    GPS_PSC_EXT_SB3_TGPU_CURR_VALUE       =  0,   //!< PShareStatus current GPU temp
    GPS_PSC_EXT_SB3_PDTS_CURR_VALUE       =  1,   //!< PShareStatus current CPU temp
    GPS_PSC_EXT_SB3_SFAN_CURR_VALUE       =  2,   //!< PShareStatus current fan speed
    GPS_PSC_EXT_SB3_SKNT_CURR_VALUE       =  3,   //!< PShareStatus current skin temp
    GPS_PSC_EXT_SB3_CPUE_CURR_VALUE       =  4,   //!< PShareStatus current CPU energy
    GPS_PSC_EXT_SB3_TMP1_CURR_VALUE       =  5,   //!< PShareStatus current tmp 1 counter
    GPS_PSC_EXT_SB3_TMP2_CURR_VALUE       =  6,   //!< PShareStatus current tmp 2 counter
    GPS_PSC_EXT_SB3_TGPU_LIMIT            =  8,   //!< PShareStatus GPU temp limit
    GPS_PSC_EXT_SB3_PDTS_LIMIT            =  9,   //!< PShareStatus CPU temp limit
    GPS_PSC_EXT_SB3_FAN_LIMIT             = 10,   //!< PShareStatus fan speed limit
    GPS_PSC_EXT_SB3_SKNT_LIMIT            = 11,   //!< PShareStatus skin temp limit
    GPS_PSC_EXT_SB3_CPUE_LIMIT            = 12,   //!< PShareStatus CPU energy limit
    GPS_PSC_EXT_SB3_TMP1_LIMIT            = 13,   //!< PShareStatus tmp 1 counter limit
    GPS_PSC_EXT_SB3_TMP2_LIMIT            = 14,   //!< PShareStatus tmp 2 counter limit
    GPS_PSC_EXT_SB3_TGPU_PERIOD           = 16,   //!< PShareStatus GPU temp min sample interval
    GPS_PSC_EXT_SB3_PDTS_PERIOD           = 17,   //!< PShareStatus CPU temp min sample interval
    GPS_PSC_EXT_SB3_SFAN_PERIOD           = 18,   //!< PShareStatus fan speed min sample interval
    GPS_PSC_EXT_SB3_SKNT_PERIOD           = 19,   //!< PShareStatus skin temp min sample interval
    GPS_PSC_EXT_SB3_CPUE_PERIOD           = 20,   //!< PShareStatus CPU energy min sample interval
    GPS_PSC_EXT_SB3_TMP1_PERIOD           = 21,   //!< PShareStatus tmp 1 counter min sample interval
    GPS_PSC_EXT_SB3_TMP2_PERIOD           = 22,   //!< PShareStatus tmp 2 counter min sample interval
    GPS_PSC_EXT_SB3_AVAIL_SENSOR_MSK      = 24,   //!< PShareStatus sensor available mask
    GPS_PSC_EXT_SB3_IGP_TURBO_STATUS      = 25,   //!< IGP Turbo enabled
    GPS_PSC_EXT_SB3_CPU_CORE_COUNT        = 26,   //!< CPU logical core count
    GPS_PSC_EXT_SB3_CPU_CORE_UTIL_MAX     = 27,   //!< CPU Utilization of busiest core.
} GPS_PSC_EXT_SB3_INDEX;
//! @}

//! \ingroup nvpmapi 
NVAPI_INTERFACE NvAPI_GPS_GetPerfSensorsInternal(__inout NV_GPS_GET_PERF_SENSOR_COUNTERS_PARAM *pParams);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPS_GetPM1Available
//! \fn             NvAPI_GPS_GetPM1Available(__out NvU32 *pAvailable)
//!
//! \since Release: 290
//!
//! DESCRIPTION:    This API retrieves the current PM1 availability
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param[out]    pAvailable -- a boolean indicating if PM1 is available
//
//! \return        This API can return any of the error codes enumerated in #NvAPI_Status. 
//!
///////////////////////////////////////////////////////////////////////////////

//! \ingroup nvpmapi 
NVAPI_INTERFACE NvAPI_GPS_GetPM1Available(__out NvU32 *pAvailable);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPS_SetPM1Available
//! \fn             NvAPI_GPS_SetPM1Available(__in NvU32 Available)
//!
//! \since Release: 290
//!
//! DESCRIPTION:    This API attempts to set the current PM1 availability
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param[out]    Available -- a boolean indicating if PM1 should be made available
//
//! \return        This API can return any of the error codes enumerated in #NvAPI_Status. 
//!
///////////////////////////////////////////////////////////////////////////////

//! \ingroup nvpmapi 
NVAPI_INTERFACE NvAPI_GPS_SetPM1Available(__in NvU32 Available);



//! \ingroup nvpmapi
//! @{
typedef struct
{
    NvU32  version;         //!< Version of the structure.
    NvU32  enabled:1;       //!< Enable/disable GPS WEB.
    NvU32  reserved:31;     //!< Reserved for future use. Must be set to 0.
    NvU32  frameTimeUs;     //!< frame time in microseconds for FRL.
} NV_GPS_WEB_INFO_V1;

typedef NV_GPS_WEB_INFO_V1      NV_GPS_WEB_INFO;
#define NV_GPS_WEB_INFO_VER1    MAKE_NVAPI_VERSION(NV_GPS_WEB_INFO_V1,1)
#define NV_GPS_WEB_INFO_VER     NV_GPS_WEB_INFO_VER1
//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPS_SetWebInfo
//!
//! DESCRIPTION:    This API sets GPS Workload Energy Balancer (WEB) settings.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param[in]      pInfo -- GPS WEB settings, see NV_GPS_WEB_INFO
//
//! \return         This API can return any of the error codes enumerated in #NvAPI_Status. 
//!
//! \ingroup nvpmapi
///////////////////////////////////////////////////////////////////////////////

//! \ingroup nvpmapi 
NVAPI_INTERFACE NvAPI_GPS_SetWebInfo(__in NV_GPS_WEB_INFO *pInfo);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetPixelClockRange
//
//! DESCRIPTION:   This API retrieves the current pixel clock settings from the driver.
//!
//!                  NOTE 1: use hPhysicalGpu=NULL and outputId=0 to specify the
//!                  first internal panel.
//!
//!                  NOTE 2: the outputId must refer to an internal panel
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]    hPhysicalGpu    GPU selection
//! \param [in]    outputId        Display output id
//! \param [out]   pTimings        Current pixel clock settings
//!
//! 
//! \retval ::NVAPI_OK                   completed request
//! \retval ::NVAPI_API_NOT_INITIALIZED  NVAPI not initialized
//! \retval ::NVAPI_ERROR                miscellaneous error occurred
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetPixelClockRange(NvPhysicalGpuHandle hPhysicalGpu, NvU32 outputId, NV_GET_PCLK *pTimings);


typedef struct
{
    NvU32           version;

    // the public interface
    NV_GET_PCLK     publicPclkInfo;

    // the private interface
    NvU32           uCurrMeasuredPixelClock;            // pixel clock retrieved from h/w clock counters in Hz
} NV_GET_PCLK_INTERNAL_V1;

typedef NV_GET_PCLK_INTERNAL_V1 NV_GET_PCLK_INTERNAL;
#define NV_GET_PCLK_INTERNAL_VER1  MAKE_NVAPI_VERSION(NV_GET_PCLK_INTERNAL_V1,1)
#define NV_GET_PCLK_INTERNAL_VER   NV_GET_PCLK_INTERNAL_VER1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetPixelClockRangeInternal
//
//! DESCRIPTION:   This API retrieves the current pixel clock settings from the driver
//!                along with private information found only in the NV_GET_PCLK_INTERNAL structure.  
//!
//!                  NOTE 1: The Display ID must refer to an internal panel.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]    displayId       Display ID
//! \param [out]   pPclkInfo       Current pixel clock settings
//!
//! 
//! \retval ::NVAPI_OK                   completed request
//! \retval ::NVAPI_API_NOT_INITIALIZED  NVAPI not initialized
//! \retval ::NVAPI_ERROR                miscellaneous error occurred
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetPixelClockRangeInternal(NvU32 displayId, NV_GET_PCLK_INTERNAL *pPclkInfo);





///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_SetPixelClockRange
//
//! DESCRIPTION:   This API passes allowed and disallowed pixel clock values to the 
//!                driver.  If the driver finds a potential timing, it sets the modes 
//!                to this timing.
//!
//!                  NOTE: use hPhysicalGpu=NULL and outputId=0 to specify the
//!                  first internal panel.
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]    hPhysicalGpu    GPU selection
//! \param [in]    outputId        Display output id
//! \param [in]    pTimings         Allowed and disallowed pixel clock ranges
//!
//! 
//! \retval ::NVAPI_OK                   completed request
//! \retval ::NVAPI_API_NOT_INITIALIZED  NVAPI not initialized
//! \retval ::NVAPI_ERROR                miscellaneous error occurred
//! \retval ::NVAPI_INVALID_ARGUMENT     no suitable pixel clock was found
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetPixelClockRange(NvPhysicalGpuHandle hPhysicalGpu, NvU32 outputId, NV_SET_PCLK *pTimings);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetECCStatusInfo
//
//! \fn NvAPI_GPU_GetECCStatusInfo(NvPhysicalGpuHandle hPhysicalGpu, 
//!                                           NV_GPU_ECC_STATUS_INFO *pECCStatusInfo);
//! DESCRIPTION:     This function returns ECC memory status information.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \param [in]      hPhysicalGpu      A handle identifying the physical GPU for which ECC 
//!                                    status information is to be retrieved.
//! \param [out]     pECCStatusInfo    A pointer to an ECC status structure.
//! 
//! \retval ::NVAPI_OK                  The request was completed successfully.
//! \retval ::NVAPI_ERROR               An unknown error occurred.
//! \retval ::NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE The provided GPU handle is not a physical GPU handle.
//! \retval ::NVAPI_INVALID_HANDLE      The provided GPU handle is invalid.
//! \retval ::NVAPI_HANDLE_INVALIDATED  The provided GPU handle is no longer valid.
//! \retval ::NVAPI_INVALID_POINTER     An invalid argument pointer was provided.
//! \retval ::NVAPI_NOT_SUPPORTED       The request is not supported.
//! \retval ::NVAPI_API_NOT_INTIALIZED  NvAPI was not yet initialized.
//
///////////////////////////////////////////////////////////////////////////////

//! \addtogroup gpuecc
//! Used in NV_GPU_ECC_STATUS_INFO.
typedef enum _NV_ECC_CONFIGURATION
{
    NV_ECC_CONFIGURATION_NOT_SUPPORTED = 0,
    NV_ECC_CONFIGURATION_DEFERRED,           //!< Changes require a POST to take effect
    NV_ECC_CONFIGURATION_IMMEDIATE,          //!< Changes can optionally be made to take effect immediately
} NV_ECC_CONFIGURATION;

//! \ingroup gpuecc
//! Used in NvAPI_GPU_GetECCStatusInfo().
typedef struct
{
    NvU32                 version;               //!< Structure version
    NvU32                 isSupported : 1;       //!< ECC memory feature support
    NV_ECC_CONFIGURATION  configurationOptions;  //!< Supported ECC memory feature configuration options
    NvU32                 isEnabled : 1;         //!< Active ECC memory setting
} NV_GPU_ECC_STATUS_INFO;

//! \ingroup gpuecc
//! Macro for constructing the version field of NV_GPU_ECC_STATUS_INFO
#define NV_GPU_ECC_STATUS_INFO_VER MAKE_NVAPI_VERSION(NV_GPU_ECC_STATUS_INFO,1)

//! \ingroup gpuecc
NVAPI_INTERFACE NvAPI_GPU_GetECCStatusInfo(NvPhysicalGpuHandle hPhysicalGpu, 
                                           NV_GPU_ECC_STATUS_INFO *pECCStatusInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetECCErrorInfo
//
//! \fn NvAPI_GPU_GetECCErrorInfo(NvPhysicalGpuHandle hPhysicalGpu, 
//!                                          NV_GPU_ECC_ERROR_INFO *pECCErrorInfo);
//!
//! DESCRIPTION:     This function returns ECC memory error information.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \param [in]      hPhysicalGpu  A handle identifying the physical GPU for
//!                                which ECC error information is to be
//!                                retrieved.
//! \param [out]     pECCErrorInfo A pointer to an ECC error structure.
//! 
//! \retval ::NVAPI_OK  The request was completed successfully.
//! \retval ::NVAPI_ERROR  An unknown error occurred.
//! \retval ::NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  The provided GPU handle is not a physical GPU handle.
//! \retval ::NVAPI_INVALID_ARGUMENT  incorrect param value
//! \retval ::NVAPI_INVALID_POINTER  An invalid argument pointer was provided.
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION  structure version is not supported, initialize to NV_GPU_ECC_ERROR_INFO_VER.
//! \retval ::NVAPI_HANDLE_INVALIDATED  The provided GPU handle is no longer valid.
//! \retval ::NVAPI_NOT_SUPPORTED  The request is not supported.
//! \retval ::NVAPI_API_NOT_INTIALIZED  NvAPI was not yet initialized.
//
///////////////////////////////////////////////////////////////////////////////


//! \ingroup gpuecc
//! Used in NvAPI_GPU_GetECCErrorInfo()/
typedef struct
{
    NvU32   version;             //!< Structure version
    struct {
        NvU64  singleBitErrors;  //!< Number of single-bit ECC errors detected since last boot
        NvU64  doubleBitErrors;  //!< Number of double-bit ECC errors detected since last boot
    } current;
    struct {
        NvU64  singleBitErrors;  //!< Number of single-bit ECC errors detected since last counter reset
        NvU64  doubleBitErrors;  //!< Number of double-bit ECC errors detected since last counter reset
    } aggregate;
} NV_GPU_ECC_ERROR_INFO;

//! \ingroup gpuecc
//! Macro for constructing the version field of NV_GPU_ECC_ERROR_INFO
#define NV_GPU_ECC_ERROR_INFO_VER MAKE_NVAPI_VERSION(NV_GPU_ECC_ERROR_INFO,1)

//! \ingroup gpuecc
NVAPI_INTERFACE NvAPI_GPU_GetECCErrorInfo(NvPhysicalGpuHandle hPhysicalGpu, 
                                          NV_GPU_ECC_ERROR_INFO *pECCErrorInfo);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetECCErrorInfoEx
//
//! \fn NvAPI_GPU_GetECCErrorInfoEx(NvPhysicalGpuHandle hPhysicalGpu, NVAPI_GPU_ECC_STATUS_FLAGS_TYPE filter, 
//!                                          NV_GPU_ECC_ERROR_INFO *pECCErrorInfo)
//! \code
//! PARAMETERS:      hPhysicalGpu (IN) - A handle identifying the physical GPU for
//!                                      which ECC error information is to be
//!                                      retrieved.
//!                            filter (IN) - A NVAPI_GPU_ECC_STATUS_FLAGS_TYPE value indicating the choice of filter to be applied
//!                  pECCErrorInfo (OUT) - A pointer to an ECC error structure.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! DESCRIPTION:     This function returns ECC memory error information.
//!
//! RETURN STATUS: 
//!    NVAPI_OK - The request was completed successfully.
//!    NVAPI_ERROR - An unknown error occurred.
//!    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - The provided GPU handle is not a physical GPU handle.
//!    NVAPI_INVALID_ARGUMENT - incorrect param value
//!    NVAPI_INVALID_POINTER - An invalid argument pointer was provided.
//!    NVAPI_INCOMPATIBLE_STRUCT_VERSION - structure version is not supported, initialize to NV_GPU_ECC_ERROR_INFO_VER.
//!    NVAPI_HANDLE_INVALIDATED - The provided GPU handle is no longer valid.
//!    NVAPI_NOT_SUPPORTED - The request is not supported.
//!    NVAPI_API_NOT_INTIALIZED - NvAPI was not yet initialized.
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpuecc
typedef enum _NVAPI_GPU_ECC_STATUS_FLAGS_TYPE
{
    NVAPI_GPU_ECC_STATUS_FLAGS_TYPE_FILTERED    = 0x00000000,    //!< This is the default and the only value that can be passed from the public NvAPI_GPU_GetECCErrorInfo api
    NVAPI_GPU_ECC_STATUS_FLAGS_TYPE_RAW            = 0x00000001    //!< All errors as they are obtained from the hardware itself, unfiltered.
    
} NVAPI_GPU_ECC_STATUS_FLAGS_TYPE;

//! \ingroup gpuecc
NVAPI_INTERFACE NvAPI_GPU_GetECCErrorInfoEx(NvPhysicalGpuHandle hPhysicalGpu, NVAPI_GPU_ECC_STATUS_FLAGS_TYPE filter, 
                                          NV_GPU_ECC_ERROR_INFO *pECCErrorInfo);






///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_ResetECCErrorInfo
//
//! DESCRIPTION:     This function resets ECC memory error counters.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \param [in]     hPhysicalGpu     A handle identifying the physical GPU for
//!                                  which ECC error information is to be
//!                                  cleared.
//! \param [in]     bResetCurrent    Reset the current ECC error counters.
//! \param [in]     bResetAggregate  Reset the aggregate ECC error counters.
//! 
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \retval ::NVAPI_INVALID_USER_PRIVILEGE       - The caller does not have administrative privileges
//!
//! \ingroup gpuecc
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_ResetECCErrorInfo(NvPhysicalGpuHandle hPhysicalGpu, NvU8 bResetCurrent,
                                            NvU8 bResetAggregate);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetECCConfigurationInfo
//
//! \fn NvAPI_GPU_GetECCConfigurationInfo(NvPhysicalGpuHandle hPhysicalGpu, 
//!                             NV_GPU_ECC_CONFIGURATION_INFO *pECCConfigurationInfo);
//! DESCRIPTION:     This function returns ECC memory configuration information.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \param [in]      hPhysicalGpu  A handle identifying the physical GPU for
//!                                which ECC configuration information
//!                               is to be retrieved.
//! \param [out]     pECCConfigurationInfo  A pointer to an ECC 
//!                                                configuration structure.
//! 
//! \retval ::NVAPI_OK  The request was completed successfully.
//! \retval ::NVAPI_ERROR  An unknown error occurred.
//! \retval ::NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE  The provided GPU handle is not a physical GPU handle.
//! \retval ::NVAPI_INVALID_HANDLE  The provided GPU handle is invalid.
//! \retval ::NVAPI_HANDLE_INVALIDATED  The provided GPU handle is no longer valid.
//! \retval ::NVAPI_INVALID_POINTER  An invalid argument pointer was provided.
//! \retval ::NVAPI_NOT_SUPPORTED  The request is not supported.
//! \retval ::NVAPI_API_NOT_INTIALIZED  NvAPI was not yet initialized.
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpuecc
//! Used in NvAPI_GPU_GetECCConfigurationInfo(). 
typedef struct
{
    NvU32  version;                 //! Structure version
    NvU32  isEnabled : 1;           //! Current ECC configuration stored in non-volatile memory
    NvU32  isEnabledByDefault : 1;  //! Factory default ECC configuration (static)
} NV_GPU_ECC_CONFIGURATION_INFO;

//! \ingroup gpuecc
//! Macro for consstructing the verion field of NV_GPU_ECC_CONFIGURATION_INFO
#define NV_GPU_ECC_CONFIGURATION_INFO_VER MAKE_NVAPI_VERSION(NV_GPU_ECC_CONFIGURATION_INFO,1)

//! \ingroup gpuecc
NVAPI_INTERFACE NvAPI_GPU_GetECCConfigurationInfo(NvPhysicalGpuHandle hPhysicalGpu, 
                                                  NV_GPU_ECC_CONFIGURATION_INFO *pECCConfigurationInfo);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_SetECCConfiguration
//
//! DESCRIPTION:     This function updates the ECC memory configuration setting.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \param [in]      hPhysicalGpu    A handle identifying the physical GPU for
//!                                  which to update the ECC configuration
//!                                  setting.
//! \param [in]      bEnable         The new ECC configuration setting.
//! \param [in]      bEnableImmediately   Request that the new setting take effect immediately.
//! 
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \retval ::NVAPI_INVALID_CONFIGURATION  - Possibly SLI is enabled. Disable SLI and retry.
//! \retval ::NVAPI_INVALID_USER_PRIVILEGE - The caller does not have administrative privileges
//!
//! \ingroup gpuecc
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetECCConfiguration(NvPhysicalGpuHandle hPhysicalGpu, NvU8 bEnable,
                                              NvU8 bEnableImmediately);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_InjectECCErrors
//
//! \code
//! PARAMETERS:      hPhysicalGpu (IN) - A handle identifying the physical GPU for
//!                                      which to inject ECC errors.
//!                  singleBitErrors (IN) - The number of single-bit ECC errors
//!                                         to inject.
//!                  doubleBitErrors (IN) - The number of double-bit ECC errors
//!                                         to inject.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:     This function injects artificial ECC errors into the ECC error
//!                  history maintained by the RM.
//!
//! RETURN STATUS: 
//!    NVAPI_OK - The request was completed successfully.
//!    NVAPI_ERROR - An unknown error occurred.
//!    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - The provided GPU handle is not a physical GPU handle.
//!    NVAPI_INVALID_HANDLE - The provided GPU handle is invalid.
//!    NVAPI_HANDLE_INVALIDATED - The provided GPU handle is no longer valid.
//!    NVAPI_NOT_SUPPORTED - The request is not supported.
//!    NVAPI_API_NOT_INTIALIZED - NvAPI was not yet initialized.
//! \endcode
//! \ingroup gpuecc
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_GPU_InjectECCErrors(NvPhysicalGpuHandle hPhysicalGpu,
                                          NvU64 singleBitErrors, NvU64 doubleBitErrors);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_CUDA_PhysxSetState
//
//! \code
//! DESCRIPTION:    This function enables GPU-acceleration for PhysX on a 
//!                 given GPU, or switches PhysX over to the CPU.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:     hPhysicalGpu(IN)      - The physical GPU of a GPU which 
//!                                         will do the PhysX acceleration, 
//!                                         or if NULL, switch to using CPU.
//!
//! RETURN STATUS: 
//!    NVAPI_OK                           - completed request. The gpuCount indicates if one or more physics capable GPU got enabled for physics.
//!    NVAPI_ERROR                        - Unable to update the Physx driver state. Install the Physx driver component.
//!    NVAPI_INVALID_ARGUMENT             - Invalid gpuCount or no physx GPU enabled in pPhysicsTopo passed into this API.
//!    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - hPhysicalGpu is not a physical GPU handle.
//!    NVAPI_NOT_SUPPORTED                - The GPU selected is not PhysX-capable, or a compatible version of PhysX is not installed.
//! \endcode
//! \ingroup gpucuda
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_CUDA_PhysxSetState(NvPhysicalGpuHandle hPhysicalGpu);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_GPU_GetMaxSourceCount
//
//! \code
//! DESCRIPTION:    This function retrieves the maximum number of sources that
//!                 the given hardware, GPU and driver is capable of driving, 
//!                 regardless of SLI or IDM states.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:     hPhysicalGpu(IN)      - Handle to a physical GPU
//!                 maxSourceCount(OUT)   - The number of sources drivable
//!
//! RETURN STATUS: 
//!    NVAPI_OK                           - completed request. 
//!    NVAPI_ERROR                        - miscellaneous error occurred
//!    NVAPI_INVALID_ARGUMENT             - Invalid input parameter
//!    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - hPhysicalGpu is not a physical GPU handle.
//! \endcode
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetMaxSourceCount(NvPhysicalGpuHandle hPhysicalGpu, NvU32* maxSourceCount);




//! \ingroup gpucuda
typedef struct
{
                NvU32 version;                        //!< version field

                NvU32 cudaAccessible : 1;             //!< GPU is CUDA accessible, able to be communicated with for CUDA rendering
                NvU32 cudaCapable : 1;                //!< GPU is CUDA capable, meets minimum requirements
                NvU32 cudaDisabled : 1;               //!< CUDA is disabled by profile
                NvU32 cudaBlockedHybrid : 1;          //!< CUDA is unavailable on this GPU while in the current hybrid mode
                NvU32 cudaReserved : 4;               //!< Reserved for future CUDA flags

                NvU32 physxAvailable : 1;             //!< PhysX is able to use this GPU (PhysX is installed, etc)
                NvU32 physxCapable : 1;               //!< Board meets minimum hardware requirements for PhysX to function
                NvU32 physxEnabled : 1;               //!< PhysX is current selected for this GPU
                NvU32 physxReserved : 5;              //!< Reserved for future PhysX flags

                NvU32 idmEnabled : 1;                 //!< No longer applicable, will always return 0.
                NvU32 idmActive : 1;                  //!< No longer applicable, will always return 0.
                NvU32 reserved : 14;                  //!< Reserved, must be 0
} NV_GPU_COMPUTE_CAPS;

//! Macro for constructing the version field of NV_GPU_COMPUTE_CAPS 
#define NV_GPU_COMPUTE_CAPS_VER             MAKE_NVAPI_VERSION(NV_GPU_COMPUTE_CAPS, 1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_GPU_QueryComputeCaps
//
//! \code
//! DESCRIPTION:    This API enumerates one or more GPUs to report CUDA and PhysX caps for all physical GPUs  
//!                 This API will support new capability like cuda capability,cuda accessibility,cuda disability of physical gpu along with 
//!                 physx capability ,physx is enabled on a physical gpu which is already addressed by NvAPI_GPU_CudaEnumComputeCapableGpus. 
//!                 It will *NOT* support a concept of PhsyX recommended  
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:     hPhysicalGpu(IN):handle to physical gpu
//!                 pComputeCaps(OUT):list of gpu CUDA/Physx caps
//!
//! RETURN STATUS: 
//!    NVAPI_OK                          - Success gpu CUDA/Physx caps are reported properly                                          
//!    NVAPI_INCOMPATIBLE_STRUCT_VERSION - structure version is not supported, initialize to NV_GPU_COMPUTE_CAPS_VER.
//!    NVAPI_ERROR                       - Enumeration of the GPU caps failed. 
//!
//! \endcode
//! \ingroup gpucuda
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_QueryComputeCaps(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_COMPUTE_CAPS* pComputeCaps);  



///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GPU_QueryGpuFlags
//
//! \fn NvAPI_GPU_QueryGpuFlags(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_FLAGS *pGpuFlags)
//! \code
//! DESCRIPTION:   Returns the GPU flags for this GPU.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! PARAMETERS:    hPhysicalGpu(IN)  : The handle of the GPU we query the flags for.
//!                pGpuFlags(OUT)    : This structure contains the GPU flags.
//! RETURN STATUS:
//!                 NVAPI_OK - completed request
//!                  NVAPI_API_NOT_INTIALIZED - NVAPI not initialized
//!                  NVAPI_ERROR - miscellaneous error occurred
//!                  NVAPI_INVALID_ARGUMENT - Invalid input parameter.
//!                  NVAPI_INVALID_HANDLE -Invalid hPhysicalGpu handle
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! ingroup gpu
typedef struct
{
    NvU32 version;                      //!< [00:31] Structure version

    NvU32 bIsInUse:1;                   //!< [32:32] There are client references to the GPU in the form of device class instantiations.
    NvU32 bIsLinkedToSliDevice:1;       //!< [33:33] The GPU is linked into an active SLI device.
    NvU32 bIsSysconConnected:1;         //!< [34:34] The GPU is associated with a system controller.
    NvU32 bIsMobile:1;                  //!< [35:35] The GPU is a mobile GPU.
    NvU32 bIsBootMaster:1;              //!< [36:36] The GPU is the boot master GPU.
    NvU32 bIsQuadro:1;                  //!< [37:37] The GPU is a Quadro
    NvU32 bIsHackedDevId:1;             //!< [38:38] Obsolete
    NvU32 bIsPanAndScanSupported:1;     //!< [39:39] Whether Pan And Scan is supported on this GPU.
    NvU32 bIsCloneToFitSupported:1;     //!< [40:40] Whether Clone To Fit is supported on this GPU.
    NvU32 bIsVRRSupported:1;            //!< [40:40] Whether variable refreshRate is supported on this GPU.
    NvU32 reserved:22;                  //!< [41:63] reserved
} NV_GPU_FLAGS_V1;

//! ingroup gpu
typedef NV_GPU_FLAGS_V1 NV_GPU_FLAGS;

//! ingroup gpu
#define NV_GPU_FLAGS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_FLAGS_V1,1)

//! ingroup gpu
#define NV_GPU_FLAGS_VER   NV_GPU_FLAGS_VER_1

//! \ingroup gpu
NVAPI_INTERFACE NvAPI_GPU_QueryGpuFlags(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_FLAGS *pGpuFlags);





//! \ingroup gpu
//! @{

//! Enum for Event IDs
typedef enum
{
    NV_EVENT_TYPE_NONE = 0,
    NV_EVENT_TYPE_FAN_SPEED_CHANGE = 1,
    NV_EVENT_TYPE_THERMAL_CHANGE = 2,
} NV_EVENT_TYPE;

typedef enum
{
    UNKNOWN_LEVEL  = 0,
    NORMAL_LEVEL   = 1,
    WARNING_LEVEL  = 2, 
    CRITICAL_LEVEL = 3,
} NV_EVENT_LEVEL;

//! Callback for thermal
typedef void (__cdecl *NVAPI_CALLBACK_THERMALEVENT)(NvPhysicalGpuHandle gpuHandle, NV_EVENT_LEVEL thermalLevel, void *callbackParam);

//! Callback for fan speed
typedef void (__cdecl *NVAPI_CALLBACK_FANSPEEDEVENT)(NvPhysicalGpuHandle gpuHandle, NV_EVENT_LEVEL fanSpeedLevel, void *callbackParam);

//! Core NV_EVENT_REGISTER_CALLBACK structure declaration
typedef struct
{
    NvU32                 version;          //!< version field to ensure minimum version compatibility
    NV_EVENT_TYPE         eventId;          //!< ID of the event being sent
    void                  *callbackParam;   //!< This value will be passed back to the callback function when an event occurs
    union
    {
        NVAPI_CALLBACK_THERMALEVENT  nvThermalCallback;   //!< Callback function pointer for thermal                               
        NVAPI_CALLBACK_FANSPEEDEVENT nvFanSpeedCallback;  //!< Callback function pointer for fanSpeed
        
    }nvCallBackFunc;
    
} NV_EVENT_REGISTER_CALLBACK, *PNV_EVENT_REGISTER_CALLBACK;

//! Macro for constructing the version field of ::NV_EVENT_REGISTER_CALLBACK
#define NV_EVENT_REGISTER_CALLBACK_VERSION        MAKE_NVAPI_VERSION(NV_EVENT_REGISTER_CALLBACK,1);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Event_RegisterCallback
//
//! DESCRIPTION:   This API registers the process for events. This API should be called for each eventcallback.
//!                The handle returned to the client will be common across all eventCallbacks.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  eventCallback  Pointer to NV_EVENT_REGISTER_CALLBACK structure to call
//!                             on new events
//! \param [out] phClient       Handle to client for use with 
//!                             unregister function
//!
//! \retval ::NVAPI_OK - completed request
//! \retval ::NVAPI_API_NOT_INTIALIZED - NvAPI not initialized
//! \retval ::NVAPI_INVALID_ARGUMENT - Invalid argument
//! \retval ::NVAPI_ERROR - miscellaneous error occurred
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Event_RegisterCallback(PNV_EVENT_REGISTER_CALLBACK eventCallback,
                                             NvEventHandle* phClient);
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Event_UnregisterCallback
//
//! DESCRIPTION:   This API unregister an event handle. 
//!                This API should be called only once per process(irrespective of the number of callbacks registered).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]    hClient  Handle associated with this listeners
//!                         event queue. Same as returned from
//!                         NvAPI_Event_RegisterCallback().
//!
//! \retval ::NVAPI_OK - completed request
//! \retval ::NVAPI_API_NOT_INTIALIZED - NvAPI not initialized
//! \retval ::NVAPI_INVALID_ARGUMENT - Invalid argument
//! \retval ::NVAPI_ERROR - miscellaneous error occurred
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Event_UnregisterCallback(NvEventHandle hClient);



/////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetCurrentThermalLevel
//
//
//! DESCRIPTION:   This API returns the current Level (Normal, Medium or 
//!                Critical) of the thermal sensor.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \param [in]    nvGPUHandle       Physical GPU handle.
//! \param [out]   pThermalLevel     Returns Thermal Level. 
//!
//! \retval ::NVAPI_OK                                 - Success
//! \retval ::NVAPI_API_NOT_INTIALIZED                 - NvAPI not initialized
//! \retval ::NVAPI_INVALID_ARGUMENT                   - Invalid argument
//! \retval ::NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE       - Invalid GPU handle
//! \retval ::NVAPI_NOT_SUPPORTED                      - API not supported
//! \retval ::NVAPI_ERROR                              - miscellaneous error occurred
//!
//! \ingroup gputhermal
/////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetCurrentThermalLevel(NvPhysicalGpuHandle nvGPUHandle, NV_EVENT_LEVEL *pThermalLevel);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_GPU_GetCurrentFanSpeedLevel
//
//! DESCRIPTION:   This API returns the current fan speed Level (Normal, Medium or 
//!                Critical).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \param [in]   nvGPUHandle     Physical GPU handle.
//! \param [out]  pFanSpeedLevel  Returns fan speed Level. 
//!
//! \retval ::NVAPI_OK                                 Success
//! \retval ::NVAPI_API_NOT_INTIALIZED                 NvAPI not initialized
//! \retval ::NVAPI_INVALID_ARGUMENT                   Invalid argument
//! \retval ::NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE       Invalid GPU handle
//! \retval ::NVAPI_NOT_SUPPORTED                      API not supported
//! \retval ::NVAPI_ERROR                              Miscellaneous error occurred
//!
//! \ingroup gpucooler
/////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetCurrentFanSpeedLevel(NvPhysicalGpuHandle nvGPUHandle, NV_EVENT_LEVEL *pFanSpeedLevel);




typedef struct 
{
    NvU32 version;                    // Version of the structure.
    
    NvU32              boardID;       // Board Id.
    NvAPI_ShortString  chipSKU;       // SKU of the chip.
    NvAPI_ShortString  chipSKUMod;    // SKU Modifier.
    NvAPI_ShortString  project;       // Project(Board) number.
    NvAPI_ShortString  projectSKU;    // Project(Board) SKU number.
    NvAPI_ShortString  cdp;           // Collaborative Design Project Number. 
} NV_GPU_SKU_INFO_V1;

typedef NV_GPU_SKU_INFO_V1     NV_GPU_SKU_INFO;

#define NV_GPU_SKU_INFO_VER1   MAKE_NVAPI_VERSION(NV_GPU_SKU_INFO_V1, 1)
#define NV_GPU_SKU_INFO_VER    NV_GPU_SKU_INFO_VER1

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GPU_GetSKUInfo
//
//! DESCRIPTION:     This API returns the SKU information for the specified GPU.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \param [in]      hPhysicalGpu(IN)  : The handle of the GPU for the which caller wants the SKU info.
//! \param [out]     pGpuSKUInfo(OUT)  : This structure contains the GPU SKU information.
//! 
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \retval ::NVAPI_INVALID_USER_PRIVILEGE       - The caller does not have administrative privileges
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetSKUInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_SKU_INFO *pGpuSKUInfo);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GPU_GetBrandType
//
//! \fn NvAPI_GPU_GetBrandType(NvPhysicalGpuHandle physicalGpu, NV_GPU_BRAND_TYPE *gpuBrandType)
//! \code
//! DESCRIPTION:     Returns the Brand type for the GPU.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! DESCRIPTION:     This API, when called with a valid physical gpu handle as Input, lets caller know the Brand type of that Gpu.
//!
//! PARAMETERS:      physicalGpu(IN)   : The handle of the GPU for the which caller wants to get the Brand Type.
//!                  gpuBrandType(OUT) : The brand type for the GPU ; one of the values from enum NV_GPU_BRAND_TYPE.
//!
//! RETURN STATUS:
//!                  NVAPI_OK                           : Completed the request. *gpuBrandType contains the GPU Brand Type.
//!                  NVAPI_ERROR                        : Miscellaneous error occurred.
//!                  NVAPI_API_NOT_INITIALIZED          : NVAPI not initialized.
//!                  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE : Invalid Gpu handle.
//!                  NVAPI_INVALID_POINTER              : Invalid gpuBrandType pointer
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu
typedef enum
{
    NV_GPU_BRAND_TYPE_UNKNOWN    = 0,
    NV_GPU_BRAND_TYPE_GEFORCE    = 1,
    NV_GPU_BRAND_TYPE_QUADRO     = 2,
    NV_GPU_BRAND_TYPE_QUADRO_AD  = 3,
    NV_GPU_BRAND_TYPE_QUADRO_NVS = 4,
    NV_GPU_BRAND_TYPE_NVIDIA_NVS = 5,
    NV_GPU_BRAND_TYPE_TESLA      = 6,
    NV_GPU_BRAND_TYPE_TESLA_Q    = 7,
}NV_GPU_BRAND_TYPE;


//! \ingroup gpu
NVAPI_INTERFACE NvAPI_GPU_GetBrandType(NvPhysicalGpuHandle physicalGpu, NV_GPU_BRAND_TYPE *gpuBrandType);



//! \ingroup gpu
typedef struct
{
    NvU32  version;              //!< version of this structure
    NvU32  width;                //!< width of the input texture
    NvU32  height;               //!< height of the input texture
    float* blendingTexture;      //!< array of floating values building an intensity RGB texture
} NV_SCANOUT_INTENSITY_DATA_V1;

//! \ingroup gpu
typedef struct
{
    NvU32  version;              //!< version of this structure
    NvU32  width;                //!< width of the input texture
    NvU32  height;               //!< height of the input texture
    float* blendingTexture;      //!< array of floating values building an intensity RGB texture
    float* offsetTexture;        //!< array of floating values building an offset texture
    NvU32  offsetTexChannels;    //!< number of channels per pixel in the offset texture
} NV_SCANOUT_INTENSITY_DATA_V2;

typedef NV_SCANOUT_INTENSITY_DATA_V2 NV_SCANOUT_INTENSITY_DATA;

//! \ingroup gpu
#define NV_SCANOUT_INTENSITY_DATA_VER1    MAKE_NVAPI_VERSION(NV_SCANOUT_INTENSITY_DATA_V1, 1)
#define NV_SCANOUT_INTENSITY_DATA_VER2    MAKE_NVAPI_VERSION(NV_SCANOUT_INTENSITY_DATA_V2, 2)
#define NV_SCANOUT_INTENSITY_DATA_VER      NV_SCANOUT_INTENSITY_DATA_VER2

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_GPU_SetScanoutIntensity
//
//!   DESCRIPTION: This API enables and sets up per-pixel intensity feature on the specified display.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]   displayId              combined physical display and GPU identifier of the display to apply the intensity control.
//! \param [in]   scanoutIntensityData   the intensity texture info.
//! \param [out]  pbSticky(OUT)           indicates whether the settings will be kept over a reboot.
//!
//! \retval ::NVAPI_INVALID_ARGUMENT Invalid input parameters.
//! \retval ::NVAPI_API_NOT_INITIALIZED NvAPI not initialized.
//! \retval ::NVAPI_NOT_SUPPORTED Interface not supported by the driver used, or only supported on selected GPUs
//! \retval ::NVAPI_INVALID_ARGUMENT Invalid input data.
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION NV_SCANOUT_INTENSITY_DATA structure version mismatch.
//! \retval ::NVAPI_OK Feature enabled.
//! \retval ::NVAPI_ERROR Miscellaneous error occurred.
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetScanoutIntensity(NvU32 displayId, NV_SCANOUT_INTENSITY_DATA* scanoutIntensityData, int *pbSticky);


//! \ingroup gpu
typedef struct _NV_SCANOUT_INTENSITY_STATE_DATA
{
    NvU32  version;                                 //!< version of this structure
    NvU32  bEnabled;                                //!< intensity is enabled or not
} NV_SCANOUT_INTENSITY_STATE_DATA;

//! \ingroup gpu
#define NV_SCANOUT_INTENSITY_STATE_VER    MAKE_NVAPI_VERSION(NV_SCANOUT_INTENSITY_STATE_DATA, 1)

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_GPU_GetScanoutIntensityState
//
//!   DESCRIPTION: This API queries current state of the intensity feature on the specified display.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]     displayId                       combined physical display and GPU identifier of the display to query the configuration.
//! \param [in,out] scanoutIntensityStateData       intensity state data.
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \retval ::NVAPI_INVALID_ARGUMENT Invalid input parameters.
//! \retval ::NVAPI_API_NOT_INITIALIZED NvAPI not initialized.
//! \retval ::NVAPI_NOT_SUPPORTED Interface not supported by the driver used, or only supported on selected GPUs.
//! \retval ::NVAPI_OK Feature enabled.
//! \retval ::NVAPI_ERROR Miscellaneous error occurred.
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetScanoutIntensityState(__in NvU32 displayId, __inout NV_SCANOUT_INTENSITY_STATE_DATA* scanoutIntensityStateData);


//! \ingroup gpu
typedef enum
{
    NV_GPU_WARPING_VERTICE_FORMAT_TRIANGLESTRIP_XYUVRQ = 0,
    NV_GPU_WARPING_VERTICE_FORMAT_TRIANGLES_XYUVRQ     = 1,
} NV_GPU_WARPING_VERTICE_FORMAT;

//! \ingroup gpu
typedef struct
{
    NvU32  version;                                 //!< version of this structure
    float* vertices;                                //!< width of the input texture
    NV_GPU_WARPING_VERTICE_FORMAT vertexFormat;     //!< format of the input vertices
    int    numVertices;                             //!< number of the input vertices
    NvSBox* textureRect;                            //!< rectangle in desktop coordinates describing the source area for the warping
} NV_SCANOUT_WARPING_DATA;

//! \ingroup gpu
#define NV_SCANOUT_WARPING_VER    MAKE_NVAPI_VERSION(NV_SCANOUT_WARPING_DATA, 1)


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_GPU_SetScanoutWarping
//
//!   DESCRIPTION: This API enables and sets up the warping feature on the specified display.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]    displayId               Combined physical display and GPU identifier of the display to apply the intensity control
//! \param [in]    scanoutWarpingData      The warping data info
//! \param [out]   pbSticky                Indicates whether the settings will be kept over a reboot.
//!
//! \retval ::NVAPI_INVALID_ARGUMENT Invalid input parameters.
//! \retval ::NVAPI_API_NOT_INITIALIZED NvAPI not initialized.
//! \retval ::NVAPI_NOT_SUPPORTED Interface not supported by the driver used, or only supported on selected GPUs
//! \retval ::NVAPI_INVALID_ARGUMENT Invalid input data.
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION NV_SCANOUT_WARPING_DATA structure version mismatch.
//! \retval ::NVAPI_OK Feature enabled.
//! \retval ::NVAPI_ERROR Miscellaneous error occurred.
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_GPU_SetScanoutWarping(NvU32 displayId, NV_SCANOUT_WARPING_DATA* scanoutWarpingData, int* piMaxNumVertices, int* pbSticky);


//! \ingroup gpu
typedef struct _NV_SCANOUT_WARPING_STATE_DATA
{
    NvU32  version;                                  //!< version of this structure
    NvU32  bEnabled;                                 //!< warping is enabled or not
} NV_SCANOUT_WARPING_STATE_DATA;

//! \ingroup gpu
#define NV_SCANOUT_WARPING_STATE_VER    MAKE_NVAPI_VERSION(NV_SCANOUT_WARPING_STATE_DATA, 1)

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_GPU_GetScanoutWarpingState
//
//!   DESCRIPTION: This API queries current state of the warping feature on the specified display.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]     displayId                      combined physical display and GPU identifier of the display to query the configuration.
//! \param [in,out] scanoutWarpingStateData        warping state data.
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \retval ::NVAPI_INVALID_ARGUMENT Invalid input parameters.
//! \retval ::NVAPI_API_NOT_INITIALIZED NvAPI not initialized.
//! \retval ::NVAPI_NOT_SUPPORTED Interface not supported by the driver used, or only supported on selected GPUs.
//! \retval ::NVAPI_OK Feature enabled.
//! \retval ::NVAPI_ERROR Miscellaneous error occurred.
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetScanoutWarpingState(__in NvU32 displayId, __inout NV_SCANOUT_WARPING_STATE_DATA* scanoutWarpingStateData);

typedef enum
{
    NV_GPU_SCANOUT_COMPOSITION_PARAMETER_WARPING_RESAMPLING_METHOD      = 0
} NV_GPU_SCANOUT_COMPOSITION_PARAMETER;

//! This enum defines a collection of possible scanout composition values that can be used to configure 
//! possible scanout composition settings.  (Currently the only parameter defined is the WARPING_RESAMPLING_METHOD).
typedef enum
{
    NV_GPU_SCANOUT_COMPOSITION_PARAMETER_SET_TO_DEFAULT = 0,                                  // Set parameter to default value.
    // WARPING_RESAMPLING_METHOD section:
    NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_WARPING_RESAMPLING_METHOD_BILINEAR                       = 0x100,
    NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_WARPING_RESAMPLING_METHOD_BICUBIC_TRIANGULAR             = 0x101,
    NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_WARPING_RESAMPLING_METHOD_BICUBIC_BELL_SHAPED            = 0x102,
    NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_WARPING_RESAMPLING_METHOD_BICUBIC_BSPLINE                = 0x103,
    NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_WARPING_RESAMPLING_METHOD_BICUBIC_ADAPTIVE_TRIANGULAR    = 0x104,
    NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_WARPING_RESAMPLING_METHOD_BICUBIC_ADAPTIVE_BELL_SHAPED   = 0x105,
    NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_WARPING_RESAMPLING_METHOD_BICUBIC_ADAPTIVE_BSPLINE       = 0x106
} NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE;

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_GPU_SetScanoutCompositionParameter
//
//!   DESCRIPTION: This API sets various parameters that configure the scanout composition feature on the specified display.
//!                (currently there is only one configurable parameter defined: WARPING_RESAMPLING_METHOD, 
//!                 but this function is designed to support the addition of parameters as needed.)
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]    displayId               Combined physical display and GPU identifier of the display to apply the intensity control
//! \param [in]    parameter               The scanout composition parameter to be set
//! \param [in]    parameterValue          The data to be set for the specified parameter
//! \param [in]    pContainer              Additional container for data associated with the specified parameter
//!
//! \retval ::NVAPI_INVALID_ARGUMENT Invalid input parameters.
//! \retval ::NVAPI_API_NOT_INITIALIZED NvAPI not initialized.
//! \retval ::NVAPI_NOT_SUPPORTED Interface not supported by the driver used, or only supported on selected GPUs
//! \retval ::NVAPI_INVALID_ARGUMENT Invalid input data.
//! \retval ::NVAPI_OK Feature enabled.
//! \retval ::NVAPI_ERROR Miscellaneous error occurred.
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_GPU_SetScanoutCompositionParameter(NvU32 displayId, NV_GPU_SCANOUT_COMPOSITION_PARAMETER parameter, 
                                                         NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE parameterValue, float *pContainer);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_GPU_GetScanoutCompositionParameter
//
//!   DESCRIPTION: This API queries current state of one of the various scanout composition parameters on the specified display.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]     displayId           combined physical display and GPU identifier of the display to query the configuration.
//! \param [in]     parameter           scanout composition parameter to by queried.
//! \param [out] parameterData          scanout composition parameter data.
//! \param [out]   pContainer           Additional container for returning data associated with the specified parameter
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \retval ::NVAPI_INVALID_ARGUMENT Invalid input parameters.
//! \retval ::NVAPI_API_NOT_INITIALIZED NvAPI not initialized.
//! \retval ::NVAPI_NOT_SUPPORTED Interface not supported by the driver used, or only supported on selected GPUs.
//! \retval ::NVAPI_OK Feature enabled.
//! \retval ::NVAPI_ERROR Miscellaneous error occurred.
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetScanoutCompositionParameter(__in NvU32 displayId, __in NV_GPU_SCANOUT_COMPOSITION_PARAMETER parameter, 
                                                         __out NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE *parameterData, __out float *pContainer);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_GPU_GetScanoutConfiguration
//
//!   DESCRIPTION: This API queries the desktop and scanout portion of the specified display.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]     displayId          combined physical display and GPU identifier of the display to query the configuration.
//! \param [in,out] desktopRect        desktop area of the display in desktop coordinates.
//! \param [in,out] scanoutRect        scanout area of the display relative to desktopRect.
//!
//! \retval ::NVAPI_INVALID_ARGUMENT Invalid input parameters.
//! \retval ::NVAPI_API_NOT_INITIALIZED NvAPI not initialized.
//! \retval ::NVAPI_NOT_SUPPORTED Interface not supported by the driver used, or only supported on selected GPUs.
//! \retval ::NVAPI_OK Feature enabled.
//! \retval ::NVAPI_ERROR Miscellaneous error occurred.
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetScanoutConfiguration(NvU32 displayId, NvSBox* desktopRect, NvSBox* scanoutRect);



//! \ingroup gpu
//! Used in NvAPI_GPU_GetScanoutConfigurationEx().
typedef struct _NV_SCANOUT_INFORMATION
{
    NvU32      version;                 //!< Structure version, needs to be initialized with NV_SCANOUT_INFORMATION_VER.

    NvSBox     sourceDesktopRect;       //!< Operating system display device rect in desktop coordinates displayId is scanning out from.
    NvSBox     sourceViewportRect;      //!< Area inside the sourceDesktopRect which is scanned out to the display.
    NvSBox     targetViewportRect;      //!< Area inside the rect described by targetDisplayWidth/Height sourceViewportRect is scanned out to.
    NvU32      targetDisplayWidth;      //!< Horizontal size of the active resolution scanned out to the display.
    NvU32      targetDisplayHeight;     //!< Vertical size of the active resolution scanned out to the display.
    NvU32      cloneImportance;         //!< If targets are cloned views of the sourceDesktopRect the cloned targets have an importance assigned (0:primary,1 secondary,...).
    NV_ROTATE  sourceToTargetRotation;  //!< Rotation performed between the sourceViewportRect and the targetViewportRect.
} NV_SCANOUT_INFORMATION;

#define NV_SCANOUT_INFORMATION_VER  MAKE_NVAPI_VERSION(NV_SCANOUT_INFORMATION,1)

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_GPU_GetScanoutConfigurationEx
//
//!   DESCRIPTION: This API queries the desktop and scanout portion of the specified display.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//! \since Release: 331
//!
//! \param [in]     displayId            combined physical display and GPU identifier of the display to query the configuration.
//! \param [in,out] pScanoutInformation  desktop area to displayId mapping information.
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetScanoutConfigurationEx(__in NvU32 displayId, __inout NV_SCANOUT_INFORMATION *pScanoutInformation);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetAdapterIdFromPhysicalGpu
//
//!   DESCRIPTION: This API returns the OS-AdapterID from physicalGpu Handle. OS-AdapterID
//!                is the Adapter ID that is used by Win7 CCD APIs.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]    hPhysicalGpu   PhysicalGpu Handle
//! \param [out]   pOSAdapterId   Returns OS-AdapterId, it is typed as void * to
//!                               avoid dependency with windows.h. User must type cast it to LUID.
//!
//! \retval ::NVAPI_INVALID_ARGUMENT pOSAdapterId is NULL; hPhysicalGpu is invalid
//! \retval ::NVAPI_OK *pOSAdapterId contains valid data.
//! \retval ::NVAPI_NOT_SUPPORTED  This API is not supported on the system.
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetAdapterIdFromPhysicalGpu(NvPhysicalGpuHandle hPhysicalGpu, void *pOSAdapterId);


//! Used in NvAPI_GPU_GetPerfDecreaseInfo.
//! Bit masks for knowing the exact reason for performance decrease
typedef enum _NVAPI_GPU_PERF_DECREASE
{
    NV_GPU_PERF_DECREASE_NONE                        = 0,          //!< No Slowdown detected
    NV_GPU_PERF_DECREASE_REASON_THERMAL_PROTECTION   = 0x00000001, //!< Thermal slowdown/shutdown/POR thermal protection
    NV_GPU_PERF_DECREASE_REASON_POWER_CONTROL        = 0x00000002, //!< Power capping / pstate cap 
    NV_GPU_PERF_DECREASE_REASON_AC_BATT              = 0x00000004, //!< AC->BATT event
    NV_GPU_PERF_DECREASE_REASON_API_TRIGGERED        = 0x00000008, //!< API triggered slowdown
    NV_GPU_PERF_DECREASE_REASON_INSUFFICIENT_POWER   = 0x00000010, //!< Power connector missing
    NV_GPU_PERF_DECREASE_REASON_UNKNOWN              = 0x80000000, //!< Unknown reason
} NVAPI_GPU_PERF_DECREASE;


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetPerfDecreaseInfo
//
//! DESCRIPTION:   This function retrieves - in NvU32 variable - reasons for the current performance decrease.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//! \param [in]      hPhysicalGPU    (IN)    - GPU for which performance decrease is to be evaluated.
//! \param [out]  pPerfDecrInfo    (OUT)    - Pointer to a NvU32 variable containing performance decrease info
//!
//! \return      This API can return any of the error codes enumerated in #NvAPI_Status. 
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetPerfDecreaseInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NvU32 *pPerfDecrInfo);


//! \ingroup gpu 
typedef struct
{
    NvU32                version;                                //!< The structure version.
    NvU32               thermalMask;                             //!< [out] contains bitmasked value from one or more NVAPI_GPU_PERF_DECREASE enums
    NvU32               pstateMask;                                //!< [out] contains bitmasked value from one or more NVAPI_GPU_PERF_DECREASE enums
} NV_PERF_DECREASE_INFO_V1;

//! \ingroup gpu 
typedef NV_PERF_DECREASE_INFO_V1    NV_PERF_DECREASE_INFO;

//! \ingroup gpu
#define NV_PERF_DECREASE_INFO_VER1  MAKE_NVAPI_VERSION(NV_PERF_DECREASE_INFO_V1,1)

//! \ingroup gpu
#define NV_PERF_DECREASE_INFO_VER   NV_PERF_DECREASE_INFO_VER1


//! Used in NvAPI_GPU_GetPerfDecreaseInfo_Internal.
//! Bit masks for knowing the exact reason for Performance decrease
typedef enum _NVAPI_PVT_GPU_PERF_DECREASE
{
    NV_PVT_GPU_PERF_DECREASE_NONE                        = 0,          //!< No Slowdown detected
    NV_PVT_GPU_PERF_DECREASE_REASON_THERMAL_SHUTDOWN     = 0x00000001, //!< System slowdown/shutdown
    NV_PVT_GPU_PERF_DECREASE_REASON_THERMAL_PROTECTION   = 0x00000002, //!< POR thermal protection
    NV_PVT_GPU_PERF_DECREASE_REASON_AVERAGE_POWER        = 0x00000004, //!< Power capping - Slow/Pstate cap
    NV_PVT_GPU_PERF_DECREASE_REASON_PEAK_POWER           = 0x00000008, //!< Power capping - Moderately Fast.
    NV_PVT_GPU_PERF_DECREASE_REASON_INSUFFICIENT_POWER   = 0x00000010, //!< Power connector missing
    NV_PVT_GPU_PERF_DECREASE_REASON_AC_BATT              = 0x00000020, //!< AC->BATT event
    NV_PVT_GPU_PERF_DECREASE_REASON_API_TRIGGERED        = 0x00000040, //!< API triggered slowdown
    NV_PVT_GPU_PERF_DECREASE_REASON_UNKNOWN              = 0x80000000, //!< Unknown reason
} NVAPI_PVT_GPU_PERF_DECREASE;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetPerfDecreaseInfo_Internal
//
//! DESCRIPTION:   This function retrieves - in the form of two masks - reasons for the current perf decrease.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//! \param [in]      hPhysicalGPU    (IN)    - GPU for which performance decrease is to be evaluated.
//! \param [out]  pPerfInfo        (OUT)    - Pointer to a structure containing performance decrease info
//!
//! \return      This API can return any of the error codes enumerated in #NvAPI_Status. 
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetPerfDecreaseInfo_Internal(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_PERF_DECREASE_INFO *pPerfInfo);


//! \ingroup gpu
typedef enum _NV_GPU_ILLUMINATION_ATTRIB
{
    NV_GPU_IA_LOGO_BRIGHTNESS  = 0,
    NV_GPU_IA_SLI_BRIGHTNESS   = 1,
} NV_GPU_ILLUMINATION_ATTRIB;


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_QueryIlluminationSupport
//
//! \fn NvAPI_GPU_QueryIlluminationSupport(__inout  NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM *pIlluminationSupportInfo)
//! DESCRIPTION:   This function reports if the specified illumination attribute is supported.
//!
//! \note Only a single GPU can manage an given attribute on a given HW element,
//!       regardless of how many are attatched. I.E. only one GPU will be used to control
//!       the brightness of the LED on an SLI bridge, regardless of how many are physicaly attached.
//!       You should enumerate thru the GPUs with this call to determine which GPU is managing the attribute.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! \since Version: 300.05
//!
//! \param [in]  hPhysicalGpu        Physical GPU handle
//! \param       Attribute           An enumeration value specifying the Illumination attribute to be querried
//! \param [out] pSupported          A boolean indicating if the attribute is supported.
//! 
//! \return See \ref nvapistatus for the list of possible return values.
//
//////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu                 
typedef struct _NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1 {

    // IN
    NvU32   version;						//!< Version of this structure
    NvPhysicalGpuHandle hPhysicalGpu;		//!< The handle of the GPU that you are checking for the specified attribute.
                                            //!< note that this is the GPU that is managing the attribute.
                                            //!< Only a single GPU can manage an given attribute on a given HW element,
                                            //!< regardless of how many are attatched.
                                            //!< I.E. only one GPU will be used to control the brightness of the LED on an SLI bridge,
                                            //!< regardless of how many are physicaly attached.
                                            //!< You enumerate thru the GPUs with this call to determine which GPU is managing the attribute.
    NV_GPU_ILLUMINATION_ATTRIB Attribute;   //!< An enumeration value specifying the Illumination attribute to be querried.
                                            //!<     refer to enum \ref NV_GPU_ILLUMINATION_ATTRIB.
    
    // OUT
    NvU32    bSupported;                    //!< A boolean indicating if the attribute is supported.
                                    
} NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1;

//! \ingroup gpu 
typedef NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1      NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM;
//! \ingroup gpu 
#define NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_VER_1   MAKE_NVAPI_VERSION(NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1,1)
//! \ingroup gpu 
#define NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_VER     NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_VER_1

//! \ingroup gpu 
NVAPI_INTERFACE NvAPI_GPU_QueryIlluminationSupport(__inout NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM *pIlluminationSupportInfo);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetIllumination
//
//! \fn NvAPI_GPU_GetIllumination(NV_GPU_GET_ILLUMINATION_PARM *pIlluminationInfo)
//! DESCRIPTION:   This function reports value of the specified illumination attribute.
//!
//! \note Only a single GPU can manage an given attribute on a given HW element,
//!       regardless of how many are attatched. I.E. only one GPU will be used to control
//!       the brightness of the LED on an SLI bridge, regardless of how many are physicaly attached.
//!       You should enumerate thru the GPUs with the \ref NvAPI_GPU_QueryIlluminationSupport call to
//!       determine which GPU is managing the attribute.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! \since Version: 300.05
//!
//! \param [in]  hPhysicalGpu        Physical GPU handle
//! \param       Attribute           An enumeration value specifying the Illumination attribute to be querried
//! \param [out] Value               A DWORD containing the current value for the specified attribute.
//!                                  This is specified as a percentage of the full range of the attribute
//!                                  (0-100; 0 = off, 100 = full brightness)
//! 
//! \return See \ref nvapistatus for the list of possible return values. Return values of special interest are:
//!             NVAPI_INVALID_ARGUMENT The specified attibute is not known to the driver.
//!             NVAPI_NOT_SUPPORTED:   The specified attribute is not supported on the specified GPU
//
//////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu                 
typedef struct _NV_GPU_GET_ILLUMINATION_PARM_V1 {

    // IN
    NvU32   version;						//!< Version of this structure
    NvPhysicalGpuHandle hPhysicalGpu;		//!< The handle of the GPU that you are checking for the specified attribute.
                                            //!< Note that this is the GPU that is managing the attribute.
                                            //!< Only a single GPU can manage an given attribute on a given HW element,
                                            //!< regardless of how many are attatched.
                                            //!< I.E. only one GPU will be used to control the brightness of the LED on an SLI bridge,
                                            //!< regardless of how many are physicaly attached.
                                            //!< You enumerate thru the GPUs with this call to determine which GPU is managing the attribute.
    NV_GPU_ILLUMINATION_ATTRIB Attribute;   //!< An enumeration value specifying the Illumination attribute to be querried.
                                            //!< refer to enum \ref NV_GPU_ILLUMINATION_ATTRIB.
    
    // OUT
    NvU32    Value;                         //!< A DWORD that will contain the current value of the specified attribute.
                                            //! This is specified as a percentage of the full range of the attribute
                                            //! (0-100; 0 = off, 100 = full brightness)
                                    
} NV_GPU_GET_ILLUMINATION_PARM_V1;

//! \ingroup gpu 
typedef NV_GPU_GET_ILLUMINATION_PARM_V1      NV_GPU_GET_ILLUMINATION_PARM;
//! \ingroup gpu 
#define NV_GPU_GET_ILLUMINATION_PARM_VER_1   MAKE_NVAPI_VERSION(NV_GPU_GET_ILLUMINATION_PARM_V1,1)
//! \ingroup gpu 
#define NV_GPU_GET_ILLUMINATION_PARM_VER     NV_GPU_GET_ILLUMINATION_PARM_VER_1

//! \ingroup gpu 
NVAPI_INTERFACE NvAPI_GPU_GetIllumination(NV_GPU_GET_ILLUMINATION_PARM *pIlluminationInfo);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_SetIllumination
//
//! \fn NvAPI_GPU_SetIllumination(NV_GPU_SET_ILLUMINATION_PARM *pIlluminationInfo)
//! DESCRIPTION:   This function sets the value of the specified illumination attribute.
//!
//! \note Only a single GPU can manage an given attribute on a given HW element,
//!       regardless of how many are attatched. I.E. only one GPU will be used to control
//!       the brightness of the LED on an SLI bridge, regardless of how many are physicaly attached.
//!       You should enumerate thru the GPUs with the \ref NvAPI_GPU_QueryIlluminationSupport call to
//!       determine which GPU is managing the attribute.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! \since Version: 300.05
//!
//! \param [in]  hPhysicalGpu        Physical GPU handle
//! \param       Attribute           An enumeration value specifying the Illumination attribute to be set
//! \param       Value               The new value for the specified attribute.
//!                                  This should be specified as a percentage of the full range of the attribute
//!                                  (0-100; 0 = off, 100 = full brightness)
//!                                  If a value is specified outside this range, NVAPI_INVALID_ARGUMENT will be returned.
//! 
//! \return See \ref nvapistatus for the list of possible return values. Return values of special interest are:
//!             NVAPI_INVALID_ARGUMENT	The specified attibute is not known to the driver, or the specified value is out of range.
//!             NVAPI_NOT_SUPPORTED     The specified attribute is not supported on the specified GPU.
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup gpu                
typedef struct _NV_GPU_SET_ILLUMINATION_PARM_V1 {

    // IN
    NvU32   version;						//!< Version of this structure
    NvPhysicalGpuHandle hPhysicalGpu;		//!< The handle of the GPU that you are checking for the specified attribute.
                                            //!< Note that this is the GPU that is managing the attribute.
                                            //!< Only a single GPU can manage an given attribute on a given HW element,
                                            //!< regardless of how many are attatched.
                                            //!< I.E. only one GPU will be used to control the brightness of the LED on an SLI bridge,
                                            //!< regardless of how many are physicaly attached.
                                            //!< You enumerate thru the GPUs with this call to determine which GPU is managing the attribute.
    NV_GPU_ILLUMINATION_ATTRIB Attribute;   //!< An enumeration value specifying the Illumination attribute to be querried.
                                            //!< refer to enum \ref NV_GPU_ILLUMINATION_ATTRIB.
    NvU32    Value;                         //!< A DWORD containing the new value for the specified attribute.
                                            //!< This should be specified as a percentage of the full range of the attribute
                                            //!< (0-100; 0 = off, 100 = full brightness)
                                            //!< If a value is specified outside this range, NVAPI_INVALID_ARGUMENT will be returned.
    
    // OUT
                                    
} NV_GPU_SET_ILLUMINATION_PARM_V1;

//! \ingroup gpu 
typedef NV_GPU_SET_ILLUMINATION_PARM_V1      NV_GPU_SET_ILLUMINATION_PARM;
//! \ingroup gpu 
#define NV_GPU_SET_ILLUMINATION_PARM_VER_1   MAKE_NVAPI_VERSION(NV_GPU_SET_ILLUMINATION_PARM_V1,1)
//! \ingroup gpu 
#define NV_GPU_SET_ILLUMINATION_PARM_VER     NV_GPU_SET_ILLUMINATION_PARM_VER_1

//! \ingroup gpu 
NVAPI_INTERFACE NvAPI_GPU_SetIllumination(NV_GPU_SET_ILLUMINATION_PARM *pIlluminationInfo);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_VCD_GetThermalInfo
//
//!   DESCRIPTION: This API returns thermal information from the Visual Computing Device.
//!                One or more NVAPI_THERMAL_TARGET_VCD target thermal information can be retrieved (See::NV_THERMAL_TARGET).
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 180
//!
//! \param [in]   nvComputingHandle  The enumerated Visual Computing Device handle retrieved from NvAPI_EnumVisualComputingDevices().
//! \param [out]  pThermalSettings   Contains the Visual Computing Device thermal information returned in pThermalSettings.
//!                                  pThermalSettings->version has to be set to NV_GPU_THERMAL_SETTINGS_VER for the API to succeed.
//!                                  One or more NVAPI_THERMAL_TARGET_VCD target thermal information can be retrieved.
//!
//! \retval ::NVAPI_INVALID_ARGUMENT          nvComputingHandle or pThermalSettings is NULL
//! \retval ::NVAPI_OK                        Information successfully in pThermalSettings.
//! \retval ::NVAPI_ERROR
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND  The queried Graphics system does not have any Visual Computing Device.
//!
//! \ingroup viscompapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_VCD_GetThermalInfo(NvVisualComputingDeviceHandle nvComputingHandle, NV_GPU_THERMAL_SETTINGS *pThermalSettings);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_VCD_GetCoolerSettings
//
//!   DESCRIPTION: This API returns cooler information from the Visual Computing Device.
//!                One or more NVAPI_COOLER_TARGET_VCD target cooler settings can be retrieved (See ::NVAPI_COOLER_TARGET).
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 180
//!
//! \param [in]    nvComputingHandle  The enumerated Visual Computing Device handle retrieved from NvAPI_EnumVisualComputingDevices().
//! \param [out]   pCoolerInfo        The Visual Computing Device cooler information returned in pCoolerInfo.
//!                                   pCoolerInfo->version has to be set to NV_GPU_GETCOOLER_SETTINGS_VER for the API to succeed.
//! \param [out]   requestedFanLevel  Percent of cooling capacity requested by the internal fan controller.
//!                                   This is typically a function of exhaust temperature and/or chip temperature.
//!
//! \retval ::NVAPI_INVALID_ARGUMENT         nvComputingHandle or pCoolerInfo is NULL
//! \retval ::NVAPI_OK                       Information successfully in pCoolerInfo.
//! \retval ::NVAPI_ERROR
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND  The queried Graphics system does not have any Visual Computing Device.
//!
//! \ingroup viscompapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_VCD_GetCoolerSettings(NvVisualComputingDeviceHandle nvComputingHandle, NV_GPU_GETCOOLER_SETTINGS *pCoolerInfo, NvU32 * pRequestedFanLevel);


//! \ingroup sysgeneral
//! Used in NvAPI_SYS_ACPI_GetValues(). 
typedef struct
{
    NvU32 version;                      //!< input: Structure version, must always be NV_ACPI_METHOD_DATA_SET_VER
    NvU16 bufferSize;                   //!< input/output: Size of valid data in the buffer
    NvU8 buffer[NV_MXM_BLOCK_SIZE];     //!< input/output: Data buffer
} NV_ACPI_METHOD_DATA_SET_V1;


//! \ingroup sysgeneral
//! Used in NV_ACPI_METHOD_DATA_SET.
//! @{ 
typedef NV_ACPI_METHOD_DATA_SET_V1      NV_ACPI_METHOD_DATA_SET;
#define NV_ACPI_METHOD_DATA_SET_VER1    MAKE_NVAPI_VERSION(NV_ACPI_METHOD_DATA_SET, 1)
#define NV_ACPI_METHOD_DATA_SET_VER     NV_ACPI_METHOD_DATA_SET_VER1
//! @}


//! \ingroup sysgeneral
//! Used in NvAPI_SYS_ACPI_GetValues(). 
typedef enum _NV_ACPI_METHOD_ID
{
    NVAPI_ACPI_METHOD_MXM2X_MXMI = 0,       //!< MXM 2.x: Return Spec Support Level
    NVAPI_ACPI_METHOD_MXM2X_MXMS,           //!< MXM 2.x: Return the MXM Structure (SIS)
    NVAPI_ACPI_METHOD_DSM_MXM3X_MXSS,       //!< MXM 3.x: Supported Sub-Functions
    NVAPI_ACPI_METHOD_DSM_MXM3X_MXMI,       //!< MXM 3.x: Platform MXM Capabilities
    NVAPI_ACPI_METHOD_DSM_MXM3X_MXMS,       //!< MXM 3.x: Get the MXM Structure (SIS)
    NVAPI_ACPI_METHOD_DSM_MXM3X_MXPP,       //!< MXM 3.x: Get/Set Platform Policies
    NVAPI_ACPI_METHOD_DSM_MXM3X_MXDP,       //!< MXM 3.x: Get/Set Display Config
    NVAPI_ACPI_METHOD_DSM_MXM3X_MDTL,       //!< MXM 3.x: Get Display Toggle List
    NVAPI_ACPI_METHOD_DSM_MXM3X_MXCB,       //!< MXM 3.x: Query/Call System Callbacks
    NVAPI_ACPI_METHOD_DOD,                  //!< Get DOD ID List
    NVAPI_ACPI_METHOD_MXMX,                 //!< Select Display Data Channel
    NVAPI_ACPI_METHOD_MXDS,                 //!< Select Display Output Channel
    NVAPI_ACPI_METHOD_DSM_MXM3X_EVENTLIST,  //!< MXM 3.x: Get flexible notifiers list
    NVAPI_ACPI_METHOD_DSM_GPS,              //!< GPS Supported Sub-Functions
    NVAPI_ACPI_METHOD_DSM_JT,               //!< JT Supported Sub-Functions

    // MUST BE THE LAST ONE!!!  Don't add any new ID after this!!!
    NVAPI_ACPI_NUM_SUPPORTED_METHODS        //!< # of ACPI methods exported to NVAPI
} NV_ACPI_METHOD_ID;



///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_SYS_ACPI_GetValues
//
//!   DESCRIPTION: This API executes Advanced Configuration and Power Interface (ACPI) methods and gets returned data.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 180
//!
//! \param [in]    hPhysicalGpu    GPU selection.
//! \param [in]    acpiMethod      ACPI method ID.
//! \param [out]   pBuf            Contains one or more data returned by the ACPI
//!
//! \retval  :: RETURN STATUS: NVAPI_OK: execution succeeded
//! \retval  ::    NVAPI_NOT_SUPPORTED: queried ACPI method is NOT supported
//! \retval  ::                 NVAPI_INVALID_ARGUMENT: method ID not recognized
//! \retval  ::                 NVAPI_ERROR: failed to retrieve supported info
//!
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_ACPI_GetValues(__in NvPhysicalGpuHandle hPhysicalGpu, __in NV_ACPI_METHOD_ID acpiMethod, __inout NV_ACPI_METHOD_DATA_SET *pBuf);



///////////////////////////////////////////////////////////////////////////////
// POWERMIZER APIs
//
// Provides the ability to Limit PowerMizer's Maximum Performance.
// Grants access on Adaptive Clocking turn on and off.
// PowerMizer can be either Soft Limited or Hard Limited.
// Soft Limit can be exceeded by the adaptive systems in the GPU if there is a need.
// Hard Limit cannot be exceeded even if there is a need to exceed this limit.
//
//////////////////////////////////////////////////////////////////////////////

//! \ingroup powermizerapi
//! Used in NvAPI_GPU_GetPowerMizerInfo() and NvAPI_GPU_GetPowerMizerInfo()
typedef enum _NV_LEVEL_INFO
{
    NVAPI_PWR_MZR_HARD_LIMIT_MAX           = 0x00000001,       //!< Power Mizer Maximum Performance for Hard limit
    NVAPI_PWR_MZR_HARD_LIMIT_BAL           = 0x00000002,       //!< Power Mizer Balanced Performance for Hard limit
    NVAPI_PWR_MZR_MAX_BATT                 = 0x00000003,       //!< Power Mizer Maximum Battery Performance
    NVAPI_PWR_MZR_SOFT_LIMIT_MAX           = 0x00000004,       //!< Power mizer Maximum performance for Soft limit
    NVAPI_PWR_MZR_SOFT_LIMIT_BAL           = 0x00000005,       //!< Power mizer Balanced performance for Soft limit
    NVAPI_ADC_OFF                          = 0x00000006,       //!< Adaptive Clocking Disable
    NVAPI_ADC_ON                           = 0x00000007,       //!< Adaptive Clocking Enable
} NV_LEVEL_INFO;


//! \ingroup powermizerapi
//! Used in NvAPI_GPU_GetPowerMizerInfo() and NvAPI_GPU_GetPowerMizerInfo()
typedef enum _NV_PWR_SOURCE_INFO
{
    NVAPI_PWR_SOURCE_AC                                 = 0x00000001,       //!<  Power source AC
    NVAPI_PWR_SOURCE_BATT                               = 0x00000002,       //!<  Power source Battery
} NV_PWR_SOURCE_INFO;

//! \ingroup powermizerapi
//! Used in NvAPI_GPU_GetPowerMizerInfo() and NvAPI_GPU_GetPowerMizerInfo()
typedef enum _NV_SELECT_INFO
{
    NVAPI_INDEX_PWR_MZR_HARD                            = 0x00000001,       //!<  To set/get PowerMizer Hard limits. Hard Limits modifies the hardware limits. 
    NVAPI_INDEX_PWR_MZR_SOFT                            = 0x00000002,       //!<  To set/get PowerMizer Soft limits. Soft Limits sets the application preference and could be exceeded upto Hard limits if required by the system.
    NVAPI_INDEX_ADC                                     = 0x00000003,       //!<  To set/get Adaptive Clocking parameters where the driver automatically selects the limits. 
} NV_SELECT_INFO;


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:    NvAPI_GPU_GetPowerMizerInfo
//
//!  This function gets 
//!              - the PowerMizer Maximum Limit for both Battery or AC 
//!              - the Adaptive Clocking status for Battery or AC 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 100
//!
//! \param [in]  hPhysicalGPU         GPU selection.
//! \param [in]  powerSourceInfo      Power source selection with one of the values from ::NV_PWR_SOURCE_INFO.
//! \param [in]  select               PowerMizer type selection with one of the values from ::NV_SELECT_INFO.
//! \param [out] pLevelInfo           Pointer to return value 
//!
//!  
//! \retval  NVAPI_OK                 Completed request
//! \retval  NVAPI_NOT_SUPPORTED      Power Mizer Not supported.
//! \retval  NVAPI_ERROR              Invalid return to API.
//! \ingroup powermizerapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetPowerMizerInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_PWR_SOURCE_INFO powerSourceInfo,
                                          NV_SELECT_INFO select, NV_LEVEL_INFO *pLevelInfo);
///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:    NvAPI_GPU_SetPowerMizerInfo
//
//!  This function sets 
//!              - the PowerMizer Maximum Limit for both Battery and/or AC 
//!              - the Adaptive Clocking status for Battery or AC  
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 100
//!
//! \param [in]  hPhysicalGpu              GPU selection.
//! \param [in]  powerSourceInfo           Power source selection with one of the values from ::NV_PWR_SOURCE_INFO.
//! \param [in]  select                    PowerMizer type selection with one of the values from ::NV_SELECT_INFO.
//! \param [out] levelInfo                 Level that has to be set on PwrMzr /Adaptive clocking 
//!
//! \retval      NVAPI_OK                  Completed request
//! \retval      NVAPI_NOT_SUPPORTED       PowerMizer not supported
//! \retval      NVAPI_INVALID_ARGUMENT    Invalid arguments
//!
//! \ingroup     powermizerapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetPowerMizerInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_PWR_SOURCE_INFO powerSourceInfo, 
                                            NV_SELECT_INFO select, NV_LEVEL_INFO levelInfo);


//! \ingroup gpu
typedef enum _NV_VIRTUALIZATION_MODE
{
    NV_VIRTUALIZATION_MODE_NONE = 0,
    NV_VIRTUALIZATION_MODE_NMOS = 1,
    NV_VIRTUALIZATION_MODE_VGX  = 2
} NV_VIRTUALIZATION_MODE;

//! \ingroup gpu
typedef struct _NV_GPU_VIRTUALIZATION_INFO
{
    NvU32                    version;                      //!< Structure version

    NV_VIRTUALIZATION_MODE   virtualizationMode;           //!< one of NV_VIRTUALIZATION_MODE.
    NvU32                    reserved;                     //!< reserved for future use. Should be set to ZERO.
} NV_GPU_VIRTUALIZATION_INFO_V1;

//! \ingroup gpu
typedef NV_GPU_VIRTUALIZATION_INFO_V1     NV_GPU_VIRTUALIZATION_INFO;

//! \ingroup gpu
#define NV_GPU_VIRTUALIZATION_INFO_VER1   MAKE_NVAPI_VERSION(NV_GPU_VIRTUALIZATION_INFO_V1,1)

//! \ingroup gpu
#define NV_GPU_VIRTUALIZATION_INFO_VER    NV_GPU_VIRTUALIZATION_INFO_VER1


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetVirtualizationInfo
//
//!   DESCRIPTION: This API returns virtualization information of the system
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in,out] pVirtualizationInfo         Pointer to NV_GPU_VIRTUALIZATION_INFO structure. 
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetVirtualizationInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_VIRTUALIZATION_INFO *pVirtualizationInfo);


//! \ingroup gpu

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_QueryIsGRIDDisplayless
//
//!  This function is used to check if specified GPU is a Displayless GRID GPU.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]  hPhysicalGpu          Physical GPU Handle.
//! \param [out] pIsGridDisplayless    Flag that returns 1 if GPU is a Displayless GRID GPU. Else returns 0. 
//!
//! \since Release: 346
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//! \retval  NVAPI_INVALID_ARGUMENT              hPhysicalGpu or pIsGridCapable is NULL.
//! \retval  NVAPI_OK                           *pIsGridDisplayless contains flag whether GPU is Displayless GRID.
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_QueryIsGRIDDisplayless(__in NvPhysicalGpuHandle hPhysicalGpu, __out NvU32 *pIsGridDisplayless);


//! \ingroup gpu
//! @{

typedef enum _NV_GPU_POWER_STATE
{
    NV_GPU_POWER_STATE_ERROR   =  0,
    NV_GPU_POWER_STATE_ON,
    NV_GPU_POWER_STATE_GOLD,
    NV_GPU_POWER_STATE_EXITING_GOLD,
    NV_GPU_POWER_STATE_ENTERING_GOLD,
    NV_GPU_POWER_STATE_WAITING_FOR_SVC,
    NV_GPU_POWER_STATE_GC6,
    NV_GPU_POWER_STATE_EXITING_GC6,
    NV_GPU_POWER_STATE_ENTERING_GC6,
} NV_GPU_POWER_STATE;

#define NV_GPU_STATE_CHANGE_LOG_COUNT 32

typedef struct _NV_GPU_GC6_STATISTICS 
{
    NvU32 version;  //!<NV_GPU_GC6_STATISTICS struct version
    
    NvU32 GC6TimeoutValue;   
    NvU32 GC6TransitionCount;
    
    NvU32 minTimeInGC6Ms;
    NvU32 maxTimeInGC6Ms;
    NvU32 avgTimeInGC6Ms;
    NvU32 totTimeInGC6Ms;
    
    NvU32 minTimeEnteringGC6Ms;
    NvU32 maxTimeEnteringGC6Ms;
    NvU32 avgTimeEnteringGC6Ms;
    NvU32 totTimeEnteringGC6Ms;
    
    NvU32 minTimeExitingGC6Ms;
    NvU32 maxTimeExitingGC6Ms;
    NvU32 avgTimeExitingGC6Ms;
    NvU32 totTimeExitingGC6Ms;
    
    NvU64 clearTime;     //!< The time stats were last cleared
    NvU64 currentTime;   
    NvU32 timeIncrement;
    
    NvS32 GC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
    NvS32 enteringGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
    NvS32 exitingGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];

}NV_GPU_GC6_STATISTICS_V1;
    
#define NV_GPU_GC6_STATISTICS_VER1   MAKE_NVAPI_VERSION(NV_GPU_GC6_STATISTICS_V1,1)

typedef struct _NV_GPU_GC6_STATISTICS_V2 
{
    NvU32 version;  //!<NV_GPU_GC6_STATISTICS struct version
    
    NvU32 GC6TimeoutValue;   
    NvU32 GC6TransitionCount;
    
    NvU32 minTimeInGC6Ms;
    NvU32 maxTimeInGC6Ms;
    NvU32 avgTimeInGC6Ms;
    NvU32 totTimeInGC6Ms;
    
    NvU32 minTimeEnteringGC6Ms;
    NvU32 maxTimeEnteringGC6Ms;
    NvU32 avgTimeEnteringGC6Ms;
    NvU32 totTimeEnteringGC6Ms;
    
    NvU32 minTimeExitingGC6Ms;
    NvU32 maxTimeExitingGC6Ms;
    NvU32 avgTimeExitingGC6Ms;
    NvU32 totTimeExitingGC6Ms;
    
    NvU64 clearTime;     //!< The time stats were last cleared
    NvU64 currentTime;   
    NvU32 timeIncrement;

    NvS32 GC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
    NvS32 enteringGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
    NvS32 exitingGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];

    NV_GPU_POWER_STATE state;

}NV_GPU_GC6_STATISTICS_V2;

#define NV_GPU_GC6_STATISTICS_VER2   MAKE_NVAPI_VERSION(NV_GPU_GC6_STATISTICS_V2,2)

typedef struct _NV_GPU_GC6_STATISTICS_V3 
{
    NvU32 version;  //!<NV_GPU_GC6_STATISTICS struct version
    
    NvU32 GC6TimeoutValue;   
    NvU32 GC6TransitionCount;
    
    NvU32 minTimeInGC6Ms;
    NvU32 maxTimeInGC6Ms;
    NvU32 avgTimeInGC6Ms;
    NvU32 totTimeInGC6Ms;
    
    NvU32 minTimeEnteringGC6Ms;
    NvU32 maxTimeEnteringGC6Ms;
    NvU32 avgTimeEnteringGC6Ms;
    NvU32 totTimeEnteringGC6Ms;
    
    NvU32 minTimeExitingGC6Ms;
    NvU32 maxTimeExitingGC6Ms;
    NvU32 avgTimeExitingGC6Ms;
    NvU32 totTimeExitingGC6Ms;
    
    NvU64 clearTime;     //!< The time stats were last cleared
    NvU64 currentTime;   
    NvU32 timeIncrement;

    NvS32 GC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
    NvS32 enteringGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
    NvS32 exitingGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];

    NV_GPU_POWER_STATE state;
    
    NvU32 maxTimeEnteringGC6RM;
    NvU32 minTimeEnteringGC6RM;
    NvU32 totTimeEnteringGC6RM;
    
    NvU32 maxTimeExitingGC6RM;
    NvU32 minTimeExitingGC6RM;
    NvU32 totTimeExitingGC6RM;
    
    NvU32 maxStateLoadGC6;
    NvU32 minStateLoadGC6;
    NvU32 totStateLoadGC6;
    
    NvU32 maxStateUnloadGC6;
    NvU32 minStateUnloadGC6;
    NvU32 totStateUnloadGC6;
    
    NvU32 maxPowerOnTimeGC6;
    NvU32 minPowerOnTimeGC6;
    NvU32 totPowerOnTimeGC6;
    
    NvU32 maxPowerOffTimeGC6;
    NvU32 minPowerOffTimeGC6;
    NvU32 totPowerOffTimeGC6;
    
    NvU32 maxSCIPowerOnTimeGC6;
    NvU32 minSCIPowerOnTimeGC6;
    NvU32 totSCIPowerOnTimeGC6;
    
    NvU32 maxSCIPowerOffTimeGC6;
    NvU32 minSCIPowerOffTimeGC6;
    NvU32 totSCIPowerOffTimeGC6;
    
    NvU32 maxDevinitTimeGC6;
    NvU32 minDevinitTimeGC6;
    NvU32 totDevinitTimeGC6;
    
    NvU32 maxPMUBootstrapTimeGC6;
    NvU32 minPMUBootstrapTimeGC6;
    NvU32 totPMUBootstrapTimeGC6;

}NV_GPU_GC6_STATISTICS_V3;

#define NV_GPU_GC6_STATISTICS_VER3   MAKE_NVAPI_VERSION(NV_GPU_GC6_STATISTICS_V3,3)

typedef struct _NV_GPU_GC6_STATISTICS_V4
{
    NvU32 version;  //!<NV_GPU_GC6_STATISTICS struct version
    
    NvU32 GC6TimeoutValue;   
    NvU32 GC6TransitionCount;
    
    NvU32 minTimeInGC6Ms;
    NvU32 maxTimeInGC6Ms;
    NvU32 avgTimeInGC6Ms;
    NvU32 totTimeInGC6Ms;
    
    NvU32 minTimeEnteringGC6Ms;
    NvU32 maxTimeEnteringGC6Ms;
    NvU32 avgTimeEnteringGC6Ms;
    NvU32 totTimeEnteringGC6Ms;
    
    NvU32 minTimeExitingGC6Ms;
    NvU32 maxTimeExitingGC6Ms;
    NvU32 avgTimeExitingGC6Ms;
    NvU32 totTimeExitingGC6Ms;
    
    NvU64 clearTime;     //!< The time stats were last cleared
    NvU64 currentTime;   
    NvU32 timeIncrement;

    NvS32 GC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
    NvS32 enteringGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
    NvS32 exitingGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];

    NV_GPU_POWER_STATE state;
    
    NvU32 maxTimeEnteringGC6RM;
    NvU32 minTimeEnteringGC6RM;
    NvU32 totTimeEnteringGC6RM;
    
    NvU32 maxTimeExitingGC6RM;
    NvU32 minTimeExitingGC6RM;
    NvU32 totTimeExitingGC6RM;
    
    NvU32 maxStateLoadGC6;
    NvU32 minStateLoadGC6;
    NvU32 totStateLoadGC6;
    
    NvU32 maxStateUnloadGC6;
    NvU32 minStateUnloadGC6;
    NvU32 totStateUnloadGC6;
    
    NvU32 maxPowerOnTimeGC6;
    NvU32 minPowerOnTimeGC6;
    NvU32 totPowerOnTimeGC6;
    
    NvU32 maxPowerOffTimeGC6;
    NvU32 minPowerOffTimeGC6;
    NvU32 totPowerOffTimeGC6;
    
    NvU32 maxSCIPowerOnTimeGC6;
    NvU32 minSCIPowerOnTimeGC6;
    NvU32 totSCIPowerOnTimeGC6;
    
    NvU32 maxSCIPowerOffTimeGC6;
    NvU32 minSCIPowerOffTimeGC6;
    NvU32 totSCIPowerOffTimeGC6;
    
    NvU32 maxDevinitTimeGC6;
    NvU32 minDevinitTimeGC6;
    NvU32 totDevinitTimeGC6;
    
    NvU32 maxPMUBootstrapTimeGC6;
    NvU32 minPMUBootstrapTimeGC6;
    NvU32 totPMUBootstrapTimeGC6;

    NvU32 minTimeInIdleToEnterGC6Ms;
    NvU32 maxTimeInIdleToEnterGC6Ms;
    NvU32 avgTimeInIdleToEnterGC6Ms;
    NvU32 totTimeInIdleToEnterGC6Ms;

}NV_GPU_GC6_STATISTICS_V4;

#define NV_GPU_GC6_STATISTICS_VER4   MAKE_NVAPI_VERSION(NV_GPU_GC6_STATISTICS_V4,4)

typedef NV_GPU_GC6_STATISTICS_V4     NV_GPU_GC6_STATISTICS;

#define NV_GPU_GC6_STATISTICS_VER    NV_GPU_GC6_STATISTICS_VER4


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetGC6Statistics
//
//! DESCRIPTION:    This API call is used to get the Graphics C-state6 statistics from the Driver.
//!                 If call succeeds,  "pGpuGC6Stats" points to the GC6 Statistics.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]     hPhysicalGpu  - Physical GPU Handle. 
//! \param [out]    pGpuGC6Stats  - Pointer to the NV_GPU_GC6_STATISTICS data. 
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetGC6Statistics(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_GC6_STATISTICS *pGpuGC6Stats);

//! @}


//! \ingroup gpu
//! @{

typedef enum _NV_GPU_GC6_CONTROL_OP
{
    CLEAR_STATS         = 0,
    SET_STATS_ENABLED,
    SET_STATS_DISABLED,
    IS_GC6_SUPPORTED,
    IS_GC6_ENABLED,
} NV_GPU_GC6_CONTROL_OP;

typedef enum _NV_GPU_GC6_CONTROL_STATUS
{
    SUCCESS             = 0,
    FEATURE_DISABLED,
    CANNOT_ENABLE_STATS,
    STATS_DISABLED,
    FAILED,
} NV_GPU_GC6_CONTROL_STATUS;

typedef struct _NV_GPU_GC6_CONTROL
{
    NvU32                      version;       //!<NV_GPU_GC6_CONTROL struct version
    NV_GPU_GC6_CONTROL_OP      controlOp;     //!<Structure specifies control operation to be performed
    NV_GPU_GC6_CONTROL_STATUS  controlStatus; //!<Enum to signal status to the caller
}NV_GPU_GC6_CONTROL_V1;

#define NV_GPU_GC6_CONTROL_VER1   MAKE_NVAPI_VERSION(NV_GPU_GC6_CONTROL_V1,1)

typedef NV_GPU_GC6_CONTROL_V1     NV_GPU_GC6_CONTROL;

#define NV_GPU_GC6_CONTROL_VER    NV_GPU_GC6_CONTROL_VER1


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GC6Control
//
//! DESCRIPTION:    This API call is used to control Certain statistics related features of GC6
//!                 If call succeeds,  "pGpuGC6Control" points to the GC6 Control Feature Return Status.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]     hPhysicalGpu    - Physical GPU Handle. 
//! \param [out]    pGpuGC6Control  - Pointer to the NV_GPU_GC6_CONTROL data. 
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GC6Control(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_GC6_CONTROL *pGpuGC6Control);

//! @}

//! \ingroup gpu
//! @{

// ****** Start - Adaptive Power Specific Structures ****** //
typedef struct _NV_GPU_LPWR_AP_THRESHOLD_STATISTICS
{
    NvU32 counterBin0;
    NvU32 counterBin1;
    NvU32 counterBin2;
    NvU32 counterBin3;
    NvU32 counterBin4;
    NvU32 counterBin5;
    NvU32 counterBin6;
    NvU32 counterBin7;
    NvU32 counterBin8;
    NvU32 counterBin9;
    NvU32 counterBin10;
    NvU32 counterBin11;
    NvU32 counterBin12;
    NvU32 counterBin13;
    NvU32 counterBin14;
    NvU32 counterBin15;
    NvU32 counterDefault;

    // Reserving for future use in AP to avoid exponential version increase
    NvU32 rsvd[16];
}NV_GPU_LPWR_AP_THRESHOLD_STATISTICS;

typedef enum _NV_GPU_LPWR_AP_SUB_ID
{
    AP_SUB_FEATURE_ID_NONE = 0,
    GET_ALL_THRESHOLD_COUNTERS,
} NV_GPU_LPWR_AP_SUB_ID;

typedef struct _NV_GPU_LPWR_AP_STATISTICS
{
    NV_GPU_LPWR_AP_SUB_ID  subId;
    union
    {
        NV_GPU_LPWR_AP_THRESHOLD_STATISTICS thresholds;
    }stats;
} NV_GPU_LPWR_AP_STATISTICS;

// ****** END - Adaptive Power Specific Structures ****** //

// ****** START - Generic API Structures ******//
typedef enum _NV_GPU_LPWR_FEATURE_ID
{
    FEATURE_ID_NONE = 0,
    ADAPTIVE_POWER,
} NV_GPU_LPWR_FEATURE_ID;

typedef union _NV_GPU_LPWR_FEATURE_STATISTICS
{
    NV_GPU_LPWR_AP_STATISTICS    ap;
} NV_GPU_LPWR_FEATURE_STATISTICS;

typedef struct _NV_GPU_LPWR_STATISTICS
{
    NvU32                           version;                //!<NV_GPU_LPWR_STATISTICS struct version
    NV_GPU_LPWR_FEATURE_ID          featureId;              //!<LPWR Feature for which stats are needed
    NV_GPU_LPWR_FEATURE_STATISTICS  pLpwrFeatureStatistics; //!<Union to get Feature Specific structure
} NV_GPU_LPWR_STATISTICS_V1;

#define NV_GPU_LPWR_STATISTICS_VER1   MAKE_NVAPI_VERSION(NV_GPU_LPWR_STATISTICS_V1,1)

typedef NV_GPU_LPWR_STATISTICS_V1     NV_GPU_LPWR_STATISTICS;

#define NV_GPU_LPWR_STATISTICS_VER    NV_GPU_LPWR_STATISTICS_VER1

// ****** END - Generic API Structures ******//


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetLpwrStatistics
//
//! DESCRIPTION:    This API call is used to get the Low Power Feature statistics from the Driver.
//!                 If call succeeds,  Statistics are contained in following manner.
//!                 pLpwrFeatureStatistics.apStats points to AP Statistics
//!
//! NVAPI USAGE :
//!                 Before calling NvAPI, following MUST to be populated :
//!                     pGpuLpwrStatistics.featureID       - Define Feature Name For which Call is being Made
//!                     featureSpecificStructure.controlOp - Define the operation that needs to be performed
//!                                                          (Check Feature Specific Enum Declarations for more information)
//!
//! NVAPI NAMING CONVENTIONS FOR EXPANSION :
//!                 Additonal feature IDs must be named only by feature Name in BLOCK Letters (e.g. MSCG, ADAPTIVE_POWER etc.)
//!                 Additonal sub feature IDs must be named based on utility. Feature Name need not be appended.
//!                 union for new feature reference must be feature name itself. (e.g. ap)
//!                 union for statistic structures must be named "stats" always. (There will be one stats union inside every feature specific structure)
//!                 union elements inside feature specific statistic structures must named based on utility only. no feature / sub feature name needs to be appended.(e.g. thresholds)
//!
//!                 Following the above convention, any stat can easily referenced without naming redundancy.
//!                        e.g. (to refer to ap threshold stats : pGpuLpwrStatistics.ap.stats.thresholds.counter#)
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]       hPhysicalGpu        - Physical GPU Handle.
//! \param [inout]    pGpuLpwrStatistics  - Pointer to the NV_GPU_LPWR_STATISTICS data
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!             NVAPI_INVALID_ARGUMENT    : Incorrect Feature ID selected
//!             NVAPI_INVALID_COMBINATION : Incorrect Sub-Feature ID selected
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetLpwrStatistics(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_LPWR_STATISTICS *pGpuLpwrStatistics);

//! @}

//! \ingroup gpu
//! @{

// ****** Adaptive Power Features ****** //

typedef enum _NV_GPU_LPWR_AP_FEATURE_ID
{
    NV_GPU_LPWR_AP_FEATURE_ID_GRAPHICS = 0,
    NV_GPU_LPWR_AP_FEATURE_ID_DI, 

    //!<Add any new features before NV_GPU_LPWR_AP_FEATURE_ID_MAX
    NV_GPU_LPWR_AP_FEATURE_ID_MAX,
} NV_GPU_LPWR_AP_FEATURE_ID;

#define NV_GPU_LPWR_AP_CFG_HISTOGRAM_BIN_N    16

// ****** Adaptive Power Statistics Structure ****** //

typedef struct _NV_GPU_LPWR_AP_STATS
{
    // NV_GPU_LPWR_AP_STATS struct version
    NvU32                      version;

    // AP Feature for which stats are needed
    NV_GPU_LPWR_AP_FEATURE_ID  featureId;

    // Boolean representing whether parent feature is enabled or not
    NvU8                       bParentEnable;

    // Boolean representing whether AP is active or not
    NvU8                       bActive;

    // Idle filter represented by histogram bin index
    NvU8                       idleFilterX;

    // Reserved variable, can be used in future
    NvU8                       rsvd1;

    // Total predicted power saving cycles.
    NvS32                      powerSavingHCycles;

    // Counts how many times AP gave us -ve power benefits
    NvU32                      badDecisionCount;

    // Number of times OBJAP needs to skip AP iterations
    NvU32                      skipCount;

    NvU16                      bin[NV_GPU_LPWR_AP_CFG_HISTOGRAM_BIN_N];

    // Counters to store threshold updation statistics
    NvU32                      thresholdCounter[NV_GPU_LPWR_AP_CFG_HISTOGRAM_BIN_N];
    NvU32                      defaultThresholdCounter;

    // Actual current idle threshold set by RM for AGC5
    NvU32                      currentIdleThreshold;

    // Reserving for future use in AP to avoid exponential version increase
    NvU32                      rsvd2[16];

} NV_GPU_LPWR_AP_STATS_V1;

#define NV_GPU_LPWR_AP_STATS_VER1   MAKE_NVAPI_VERSION(NV_GPU_LPWR_AP_STATS_V1,1)

typedef NV_GPU_LPWR_AP_STATS_V1     NV_GPU_LPWR_AP_STATS;

#define NV_GPU_LPWR_AP_STATS_VER    NV_GPU_LPWR_AP_STATS_VER1


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_LpwrApGetStatistics
//
//! DESCRIPTION:    This API call is used to get the AP statistics from the Driver.
//!                 If call succeeds,  Statistics are contained in NV_GPU_LPWR_AP_STATS structure.
//!                 This API first makes a call with 'READ_PARAMS_FROM_PMU' parameter which brings
//!                 the stats from PMU to RM and is cached there for further use. The subsequent 
//!                 from this API is serviced by these cached values from RM
//!
//! NVAPI USAGE :
//!                 Before calling NvAPI, following MUST be populated :
//!                     pGpuLpwrApStats->featureID          - Define Feature Name For which Call is being Made
//!                     pGpuLpwrApStats->version            - Define STatstics structure version
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]       hPhysicalGpu    - Physical GPU Handle.
//! \param [inout]    pGpuLpwrApStats - Pointer to the NV_GPU_LPWR_AP_STATS data
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!             NVAPI_INVALID_ARGUMENT    : Incorrect Feature ID selected
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_LpwrApGetStatistics(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_LPWR_AP_STATS *pGpuLpwrApStats);

//! @}


//! \ingroup gpu
//! @{

typedef enum _NV_GPU_LPWR_PG_FEATURE_ID
{
    NV_GPU_LPWR_PG_FEATURE_ID_GR_ELPG = 0,
    NV_GPU_LPWR_PG_FEATURE_ID_MSCG, 
    //!<Add any new features before NV_GPU_LPWR_PG_FEATURE_ID_MAX
    NV_GPU_LPWR_PG_FEATURE_ID_MAX,
} NV_GPU_LPWR_PG_FEATURE_ID;

typedef struct _NV_GPU_LPWR_PG_ENABLE
{
    NV_GPU_LPWR_PG_FEATURE_ID   featureId;         //!<PG Feature to enable/disable
    NvU8                        bEnable;           //!<Enable/disable
    NvU8                        reserved1[3];      //!<Future Use
    NvU32                       reserved2[7];      //!<Future use
} NV_GPU_LPWR_PG_ENABLE;

//Number of sub-features to be collected per feature
#define NV_GPU_LPWR_PG_ENABLE_MAX_PARAM_PER_FEATURE          1
#define NV_GPU_LPWR_PG_ENABLE_PARAM_MAX_FEATURE_LIST_SIZE    8

typedef struct _NV_GPU_LPWR_PG_ENABLE_PARAM
{
    NvU32                            version;                                                           //!<NV_GPU_LPWR_PG_ENABLE struct version
    NV_GPU_LPWR_PG_ENABLE            FeatureList[NV_GPU_LPWR_PG_ENABLE_PARAM_MAX_FEATURE_LIST_SIZE];    //!<List of features, keeping max size as 8
    NvU32                            size;                                                              //!<Number of features, client should specify actual size of featureList
} NV_GPU_LPWR_PG_ENABLE_PARAM_V1;

#define NV_GPU_LPWR_PG_ENABLE_PARAM_VER1   MAKE_NVAPI_VERSION(NV_GPU_LPWR_PG_ENABLE_PARAM_V1,1)

#define NV_GPU_LPWR_PG_ENABLE_PARAM_VER    NV_GPU_LPWR_PG_ENABLE_PARAM_VER1

typedef NV_GPU_LPWR_PG_ENABLE_PARAM_V1     NV_GPU_LPWR_PG_ENABLE_PARAM;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_LpwrPgEnable
//
//! DESCRIPTION:    This API call is used to enable/disable PG group LPWR features.
//!                 If call succeeds,  "pGpuLpwrPgEnable" returns RM_OK
//!                 This api is only applicable to PMU-offloaded-PG, it is not applicable for CPU-PG
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]     hPhysicalGpu     - Physical GPU Handle. 
//! \param [in]     pGpuLpwrPgEnableParam - Pointer to the NV_GPU_LPWR_PG_ENABLE_PARAM data. 
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_LpwrPgEnable(__in NvPhysicalGpuHandle hPhysicalGpu, __in NV_GPU_LPWR_PG_ENABLE_PARAM *pGpuLpwrPgEnableParam);

//! @}

//! \ingroup gpu
//! @{

// ****** Start - DIDLE Structures ****** //

typedef enum _NV_GPU_LPWR_DIDLE_FEATURE_ID
{
    NV_GPU_LPWR_DIDLE_FEATURE_ID_DIOS = 0,
    //!<Add any new features before NV_GPU_LPWR_DIDLE_FEATURE_ID_MAX
    NV_GPU_LPWR_DIDLE_FEATURE_ID_MAX,
} NV_GPU_LPWR_DIDLE_FEATURE_ID;

typedef struct _NV_GPU_LPWR_DIDLE_SUPPORT
{
    NV_GPU_LPWR_DIDLE_FEATURE_ID     featureId;              //!<Deep Idle Feature for which stats are needed
    NvU8                             bSupport;               //!<Feature supported or not
    NvU8                             reserved1[3];           //!<Future Use
    NvU32                            PStateSupportMask;      //!<Supported P-States for the feature
    NvU32                            reserved2[6];           //!<Future Use
} NV_GPU_LPWR_DIDLE_SUPPORT;

//Number of sub-features to be collected per feature
#define NV_GPU_LPWR_DIDLE_SUPPORT_MAX_PARAM_PER_FEATURE    1
#define NV_GPU_LPWR_DIDLE_SUPPORT_MAX_FEATURE_LIST_SIZE    8

typedef struct _NV_GPU_LPWR_DIDLE_SUPPORT_PARAM
{
    NvU32                            version;                                                           //!<NV_GPU_LPWR_DIDLE_SUPPORT struct version
    NV_GPU_LPWR_DIDLE_SUPPORT        FeatureList[NV_GPU_LPWR_DIDLE_SUPPORT_MAX_FEATURE_LIST_SIZE];      //!<List of features
    NvU32                            size;                                                              //!<Number of features
}NV_GPU_LPWR_DIDLE_SUPPORT_PARAM_V1;

#define NV_GPU_LPWR_DIDLE_SUPPORT_PARAM_VER1   MAKE_NVAPI_VERSION(NV_GPU_LPWR_DIDLE_SUPPORT_PARAM_V1,1)

#define NV_GPU_LPWR_DIDLE_SUPPORT_PARAM_VER    NV_GPU_LPWR_DIDLE_SUPPORT_PARAM_VER1

typedef NV_GPU_LPWR_DIDLE_SUPPORT_PARAM_V1     NV_GPU_LPWR_DIDLE_SUPPORT_PARAM;

// ****** END - DIDLE Structures ******//


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_LpwrDidleGetSupport
//
//! DESCRIPTION:    This API call is used to get the DIDLE support from the Driver.
//!
//! NVAPI USAGE :
//!                 Before calling NvAPI, following MUST to be populated :
//!                     pGpuDidleSupport.featureID       - Define Feature Name For which Call is being Made
//!
//! NVAPI NAMING CONVENTIONS FOR EXPANSION :
//!                 Additonal feature IDs must be named only by feature Name in BLOCK Letters (e.g. DIOS, DISSC etc.)
//!                 Additional data can be collected by using the reserved space.
//!
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]       hPhysicalGpu             - Physical GPU Handle.
//! \param [inout]    pGpuDidleSupport         - Pointer to the NV_GPU_LPWR_DIDLE_SUPPORT_PARAM data
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!             NVAPI_INVALID_ARGUMENT    : Incorrect Feature ID selected
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_LpwrDidleGetSupport(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_LPWR_DIDLE_SUPPORT_PARAM *pGpuDidleSupport);

//! @}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_ForceGC6Exit
//
//! DESCRIPTION:     This API call disables GC6.                  
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]     hPhysicalGpu  - Physical GPU Handle. 
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_ForceGC6Exit(__in NvPhysicalGpuHandle hPhysicalGpu);

//! \ingroup gpu
//! @{


typedef enum _NV_GCX_GET_WAKEUP_REASON_POWER_STATE
{
    NV_GCX_GET_WAKEUP_REASON_POWER_STATE_UNKNOWN       = 0x0,
    NV_GCX_GET_WAKEUP_REASON_POWER_STATE_GC6           = 0x1,
    NV_GCX_GET_WAKEUP_REASON_POWER_STATE_GC5MINUS_SSC  = 0x2,
}NV_GCX_GET_WAKEUP_REASON_POWER_STATE;

typedef enum _NV_GCX_GET_WAKEUP_REASON_EXIT_TYPE
{
    NV_GCX_GET_WAKEUP_REASON_EXIT_TYPE_GC5_SSC_UNKNOWN  = 0x0,
    NV_GCX_GET_WAKEUP_REASON_EXIT_TYPE_GC5_SSC_EXIT    = 0x1,
    NV_GCX_GET_WAKEUP_REASON_EXIT_TYPE_GC5_SSC_ABORT   = 0x2,
}NV_GCX_GET_WAKEUP_REASON_EXIT_TYPE;

typedef enum _NV_GCX_GET_WAKEUP_REASON_DEEP_L1_TYPE
{
    NV_GCX_GET_WAKEUP_REASON_DEEP_L1_TYPE_UNKNOWN              = 0x0,
    NV_GCX_GET_WAKEUP_REASON_DEEP_L1_TYPE_GC5_SSC_WITH_DEEP_L1 = 0x2,
    NV_GCX_GET_WAKEUP_REASON_DEEP_L1_TYPE_GC5_SSC_WITH_L1_1    = 0x3,
    NV_GCX_GET_WAKEUP_REASON_DEEP_L1_TYPE_GC5_SSC_WITH_L1_2    = 0x4,
}NV_GCX_GET_WAKEUP_REASON_DEEP_L1_TYPE;

typedef struct _NV_GPU_GCX_GET_WAKEUP_REASON_INFO_V1
{
    NvU32  version;                                          //!< NV_GPU_GCX_GET_WAKEUP_REASON_INFO structure version.

    NV_GCX_GET_WAKEUP_REASON_POWER_STATE  selectPowerState;  //!< [IN] The state for which wakeup reason(s) are being requested.
    NvU32                                 statId;            //!< [OUT] RM fill the id the statistic going to be fetched(count).
    NV_GCX_GET_WAKEUP_REASON_EXIT_TYPE    gc5ExitType;       //!< [OUT] Valid only for power state - NV_GCX_GET_WAKEUP_REASON_POWER_STATE_GC5MINUS_SSC.
    NV_GCX_GET_WAKEUP_REASON_DEEP_L1_TYPE deepL1Type;        //!< [OUT] SSC can be done with deepL1, L1.1, L1.2.

    //!< [OUT] Following gc5AbortCode_x members are valid only for power state - NV_GCX_GET_WAKEUP_REASON_POWER_STATE_GC5MINUS_SSC.
    NvU32  gc5AbortCode_DeepL1EntryTimeOut     : 1;          //!< DeepL1 not entered within expected Timeout.
    NvU32  gc5AbortCode_DeepL1Exit             : 1;          //!< DeepL1 exit.
    NvU32  gc5AbortCode_MSCGAbort              : 1;          //!< MSCG aborted.
    NvU32  gc5AbortCode_RTOSAbort              : 1;          //!< RTOS sent Abort to GCX task.
    NvU32  gc5AbortCode_AzaliaActive           : 1;          //!< Azalia active.
    NvU32  gc5AbortCode_HostNotIdle            : 1;          //!< Host not idle
    NvU32  gc5AbortCode_PendingPMCIntr         : 1;          //!< Pending PMC Interrupt.
    NvU32  gc5AbortCode_PendingSCIIntr         : 1;          //!< Pending SCI Interrupt
    NvU32  gc5AbortCode_ThermI2CSBusy          : 1;          //!< Therm I2C slave not idle.
    NvU32  gc5AbortCode_SpeculativePTimerAlarm : 1;          //!< Speculative abort for ptimer alarm.
    NvU32  gc5AbortCode_LateDeepL1Exit         : 1;          //!< "Late" Deep L1 exit - after disabling internal events from causing deep L1 wakeups
    NvU32  reserved                            : 21;

    //!< [OUT] The interrupt logged by SCI while we were in GCx state. This is a verbatim copy of SCI_INTERRUPT_STATUS registers.
    //!< Valid for both GC5 and GC6 power states.
    NvU32  sciIntr0;                                         
    NvU32  sciIntr1;

    //!< [OUT] Verbatim copy of PMC_INTR registers in the event of a GC5 abort.
    //!< Following pmcIntrx data is valid only for power state - NV_GCX_GET_WAKEUP_REASON_POWER_STATE_GC5MINUS_SSC.
    NvU32  pmcIntr0;
    NvU32  pmcIntr1;
}NV_GPU_GCX_GET_WAKEUP_REASON_INFO_V1;

typedef NV_GPU_GCX_GET_WAKEUP_REASON_INFO_V1     NV_GPU_GCX_GET_WAKEUP_REASON_INFO;

#define NV_GPU_GCX_GET_WAKEUP_REASON_INFO_VER1   MAKE_NVAPI_VERSION(NV_GPU_GCX_GET_WAKEUP_REASON_INFO_V1, 1)
#define NV_GPU_GCX_GET_WAKEUP_REASON_INFO_VER    NV_GPU_GCX_GET_WAKEUP_REASON_INFO_VER1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetGCXWakeUpReasonInfo
//
//! DESCRIPTION:    This API call is used to get the reason of wakeup/abort for GC5/GC6M power states.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]     hPhysicalGpu             - Physical GPU Handle. 
//! \param [inout]  pGpuGCXWakeUpReasonInfo  - Pointer to the NV_GPU_GCX_GET_WAKEUP_REASON_INFO data. 
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with specific meaning for this API, they are listed below.
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetGCXWakeUpReasonInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_GCX_GET_WAKEUP_REASON_INFO *pGpuGCXWakeUpReasonInfo);

//! @}



//! \ingroup gpu
typedef struct _NV_REF_COUNT_ACCESS_PARAM_V1
{
    NvU32                     version;              //!< version info
    NvU8					  incrementRefCount: 1; //!< Setting this field will increment the reference count
    NvU8                      reserved: 7;          //!< Must be 0
}NV_REF_COUNT_ACCESS_PARAM_V1;

//! \ingroup gpu
typedef NV_REF_COUNT_ACCESS_PARAM_V1       NV_REF_COUNT_ACCESS_PARAM;
//! \ingroup gpu
#define NV_REF_COUNT_ACCESS_PARAM_VER_1    MAKE_NVAPI_VERSION(NV_REF_COUNT_ACCESS_PARAM_V1,1)
//! \ingroup gpu
#define NV_REF_COUNT_ACCESS_PARAM_VER     NV_REF_COUNT_ACCESS_PARAM_VER_1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:     NvAPI_GPU_AccessRefCount
//
//! DESCRIPTION:      This API causes the system to increment or decrement Jefferson Technology/coproc reference count. 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]        hPhysicalGpu       - Handle for Physical GPU Handle for which the reference Count is accessed. Added only for future use. 
//! \param [in]        pRefCountParams    - In Pointer to the NV_REF_COUNT_ACCESS_PARAM
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup gpu   
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_AccessRefCount(__in NvPhysicalGpuHandle hPhysicalGpu, __in NV_REF_COUNT_ACCESS_PARAM* pRefCountParams);


//! \ingroup gpu
typedef struct _NV_PCIE_LTR_INFO_V1
{
    NvU32                     version;                      //!< version info

    NvU8                      bLtrRegkeyOverride :1;        //!< Boolean to check if LTR SW is disabled via regkey. Output only.
    NvU8                      bRootPortLtrSupported :1;     //!< Boolean to check if LTR supported is advertised by Root Port. Output only.
    NvU8                      bGpuLtrSupported :1;          //!< Boolean to check if LTR supported is advertised by GPU. Output only.
    NvU8                      reserved :5;                  //!< Reserved.
    NvU16                     snoopLatencyValue;            //!< Maximum Tolerable Snoop Latency Value. Input/Output.
    NvU8                      snoopLatencyScale;            //!< Maximum Tolerable Snoop Latency Scale. Input/Output.
    NvU16                     noSnoopLatencyValue;          //!< Maximum Tolerable No Snoop Latency Value. Input/Output.
    NvU8                      noSnoopLatencyScale;          //!< Maximum Tolerable No Snoop Latency Scale. Input/Output.
} NV_PCIE_LTR_INFO_V1;

//! \ingroup gpu
typedef NV_PCIE_LTR_INFO_V1       NV_PCIE_LTR_INFO;
//! \ingroup gpu
#define NV_PCIE_LTR_INFO_VER_1    MAKE_NVAPI_VERSION(NV_PCIE_LTR_INFO_V1,1)
//! \ingroup gpu
#define NV_PCIE_LTR_INFO_VER      NV_PCIE_LTR_INFO_VER_1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:     NvAPI_GPU_GetPCIELtrInfo
//
//! DESCRIPTION:      This API gets the current Latency Tolerance Reporting latency values. 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]        hPhysicalGpu       - Handle for Physical GPU Handle for which we want the LTR values. 
//! \param [out]       pPexLtrInfo        - In Pointer to the NV_PCIE_LTR_INFO
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup gpu   
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetPCIELtrInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_PCIE_LTR_INFO* pPexLtrInfo);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:     NvAPI_GPU_SetPCIELtrInfo
//
//! DESCRIPTION:      This API sets the PEX Latency Tolerance Reporting value to be sent to the Root Port. 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]        hPhysicalGpu       - Handle for Physical GPU Handle for which the LTR values should be set. 
//! \param [in]        pPexLtrInfo        - In Pointer to the NV_PCIE_LTR_INFO
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup gpu   
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetPCIELtrInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __in NV_PCIE_LTR_INFO* pPexLtrInfo);


typedef enum _NV_UEFI_IMAGE_PRESENCE
{
    NV_UEFI_IMAGE_YES	= 0,							//!< "Yes"- There is a usable UEFI image in the rom. 
    NV_UEFI_IMAGE_NO,									//!< "No"- There is no UEFI image in the ROM file. 
    NV_UEFI_IMAGE_NO_HIDDEN,							//!< "No (hidden)"- There is a UEFI image in the rom file, but it is after an image which has Last Indicator set to 1. 
    NV_UEFI_IMAGE_PLACEHOLDER							//!< "Placeholder"- There is a dummy UEFI placeholder which can later be updated to a valid UEFI image. 
}NV_UEFI_IMAGE_PRESENCE;

typedef struct _NV_UEFI_INFO_V1
{
    NvU32					version;

    NV_UEFI_IMAGE_PRESENCE	UEFIPresence;				//!< Indicates the presence of a UEFI image in the ROM.
    NvU8					isUEFIused;					//!< 1 indicates UEFI mode and 0 indicates the legacy mode.
    NvU32					UEFI_GOP_Version;			//!< UEFI(Unified Extensible Firmware Interface) GOP (Graphics Output Protocol) driver's Version.
    NvU32					changelist;					//!< Changelist number.
    NvAPI_ShortString		signerIdentity;				//!< UEFI image signer's identity.
    NvAPI_ShortString		date;						//!< Date, in the mmddyyyy format, when the changelist was committed.
}NV_UEFI_INFO_V1;

typedef NV_UEFI_INFO_V1			NV_UEFI_INFO;			//!< Currently used version
#define NV_UEFI_INFO_VER1	    MAKE_NVAPI_VERSION(NV_UEFI_INFO_V1,1)
#define NV_UEFI_INFO_VER		NV_UEFI_INFO_VER1

///////////////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_GPU_GetUEFIInfo
//
//! DESCRIPTION: This API gets information about the UEFI(Unified Extensible Firmware Interface) 
//!				 image for the specified GPU.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]		hPhysicalGpu	- (NvPhysicalGpuHandle) Specifies the GPU whose image is to be read.
//!		   [inout]  uefiInfo		- (NV_UEFI_INFO) Contains information extracted from the UEFI image.
//!		   
//!
//! \return : This API can return any of the error codes enumerated in #NvAPI_Status. 
//!  If there are return error codes with specific meaning for this API, they are listed below.
//!	 
//! \ingroup sysgeneral
////////////////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetUEFIInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_UEFI_INFO *uefiInfo);


//! \ingroup gpucuda

//! Used in NvAPI_GPU_GetComputePrecisionInfo() and NvAPI_GPU_SetComputePrecision().
typedef enum 
{ 
    NV_SINGLE_PRECISION          = 0, 
    NV_DOUBLE_PRECISION          = 1 
} NV_COMPUTE_PRECISION;

typedef struct _NV_COMPUTE_PRECISION_INFO_V1
{
    NvU32 version;
    
    NV_COMPUTE_PRECISION     maxSupportedPrecision;    //!< Indicates the max compute precision the GPU is capable of.
    NV_COMPUTE_PRECISION     currPrecision;			   //!< The current compute precision set on the GPU. 
}NV_COMPUTE_PRECISION_INFO_V1;

typedef NV_COMPUTE_PRECISION_INFO_V1		NV_COMPUTE_PRECISION_INFO;			//!< Currently used version
#define NV_COMPUTE_PRECISION_INFO_VER1	    MAKE_NVAPI_VERSION(NV_COMPUTE_PRECISION_INFO_V1,1)
#define NV_COMPUTE_PRECISION_INFO_VER		NV_COMPUTE_PRECISION_INFO_VER1

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:  NvAPI_GPU_GetComputePrecisionInfo
//
//! DESCRIPTION:   This API gets the compute precision information of the specified GPU.
//
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]	     hPhysicalGpu	         - (NvPhysicalGpuHandle) Specifies the GPU, for which we want to query the precision information.
//!		   [inout]   computePrecisionInfo	 - (NV_COMPUTE_PRECISION_INFO) Contains the compute precision information of the GPU, whose handle is passed. 
//!		   
//! \return : This API can return any of the error codes enumerated in #NvAPI_Status. 
//!  If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup gpucuda  	 
////////////////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetComputePrecisionInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_COMPUTE_PRECISION_INFO *computePrecisionInfo);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:  NvAPI_GPU_SetComputePrecision
//
//! DESCRIPTION:   This API is used to change the compute precision on the specified GPU. If the GPU, whose physical handle is passed,
//!                is part of a SLI group then this call will set the passed compute precision value for all the compute precision capable GPUs 
//!				   in that SLI group.
//
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]	   hPhysicalGpu	       - (NvPhysicalGpuHandle) Specifies the GPU for which we want to change the compute precision.
//!		   [in]    computePrecision    - (NV_COMPUTE_PRECISION) Contains the compute precision value to be set. Valid states that can be
//!								         passed as inputs are NV_SINGLE_PRECISION and NV_DOUBLE_PRECISION.
//!		   
//! \return : This API can return any of the error codes enumerated in #NvAPI_Status. 
//!  If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup gpucuda	 
////////////////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetComputePrecision(__in NvPhysicalGpuHandle hPhysicalGpu, __in NV_COMPUTE_PRECISION computePrecision);

//! \ingroup gpu

#define NV_GPU_INFOROM_IMAGE_VERSION_LEN 16

typedef struct _NV_INFOROM_IMAGE_INFO_V1
{
    NvU32	version;
    
    NvU8	InfoROM_image_version[NV_GPU_INFOROM_IMAGE_VERSION_LEN];		//!< This parameter returns the version of the InfoROM image as a NULL-terminated character
                                                                            //!< string of the form "XXXX.XXXX.XX.XX" where each 'X' is an integer character.
}NV_INFOROM_IMAGE_INFO_V1;

typedef NV_INFOROM_IMAGE_INFO_V1			NV_INFOROM_IMAGE_INFO;			//!< Currently used version
#define NV_INFOROM_IMAGE_INFO_VER1			MAKE_NVAPI_VERSION(NV_INFOROM_IMAGE_INFO_V1,1)
#define NV_INFOROM_IMAGE_INFO_VER			NV_INFOROM_IMAGE_INFO_VER1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetInfoROMData
//
//!   DESCRIPTION: This API returns data parsed from the InfoROM image.The inforom is a small,
//!				   persistent store of configuration and state data for the GPU. All inforom
//!				   version fields are numerical.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in,out] pImageData 
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \ingroup 
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetInfoROMData(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_INFOROM_IMAGE_INFO *pInfoROMInfo);

//! \ingroup gpu

typedef enum _NV_GPU_OPTIMIZATION_MODE
{
    NV_GPU_OPTIMIZATION_MODE_NONE           = 0,
    NV_GPU_OPTIMIZATION_MODE_DEFAULT        = 1,
    NV_GPU_OPTIMIZATION_MODE_COMPUTE        = 2,
    NV_GPU_OPTIMIZATION_MODE_SPARSE_TEXTURE = 3,
}NV_GPU_OPTIMIZATION_MODE;

typedef struct _NV_GPU_GET_OPTIMIZATION_DATA_V1
{
    NvU32 version;

    NvPhysicalGpuHandle      hPhysicalGpu; 
    NV_GPU_OPTIMIZATION_MODE defaultOptimizationMode; //!< Default optimization mode for the GPU.
    NV_GPU_OPTIMIZATION_MODE currentOptimizationMode; //!< Currently applied optimization mode for the GPU.
}NV_GPU_GET_OPTIMIZATION_DATA_V1;

typedef NV_GPU_GET_OPTIMIZATION_DATA_V1          NV_GPU_GET_OPTIMIZATION_DATA;
#define NV_GPU_GET_OPTIMIZATION_DATA_VER1        MAKE_NVAPI_VERSION(NV_GPU_GET_OPTIMIZATION_DATA_V1, 1)
#define NV_GPU_GET_OPTIMIZATION_DATA_VER         NV_GPU_GET_OPTIMIZATION_DATA_VER1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetOptimizationData
//
//!   DESCRIPTION: This API returns GPU optimization data for all the supported GPUs in the system. This API is supported on Vista & above and on Quadro GPUs.
//
//! USAGE:         Sequence of calls which caller should make to get the information.
//!                1. First call NvAPI_GPU_GetOptimizationData() with gpuOptimizationData as NULL to get the count.
//!                2. Allocate memory for GPU optimization data (NV_GPU_GET_OPTIMIZATION_DATA) array depending on the value of count.
//!                3. Call NvAPI_GPU_GetOptimizationData() again with the pointer to the memory allocated to get the 
//!                   GPU optimization data for all the supported GPUs in the system.
//!                   
//!                Note : 
//!                1. count should never be NULL, else the API will fail with NVAPI_INVALID_POINTER.
//!                2. If the memory allocated is less than what is required to return all the timings, this API will return the
//!                   amount of information which can fit in user provided buffer and API will return NVAPI_INSUFFICIENT_BUFFER.
//!                3. Caller can allocate and pass in large enough buffer in the first call itself to avoid calling the API multiple
//!                   times to get the count then the actual data.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [inout] gpuOptimizationData - Pointer to the array of NV_GPU_GET_OPTIMIZATION_DATA structure.
//!        [inout] count               - Number of elements in the gpuOptimizationData array. This would be equal to the the number 
//!                                      of GPUs supporting optimization. 
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \ingroup 
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetOptimizationData(__inout_ecount_part_opt(*count, *count) NV_GPU_GET_OPTIMIZATION_DATA *gpuOptimizationData, __inout NvU32 *count);

//! \ingroup gpu

typedef struct _NV_GPU_SET_OPTIMIZATION_DATA_V1
{
    NvU32   version;

    NvPhysicalGpuHandle      hPhysicalGpu; 
    NV_GPU_OPTIMIZATION_MODE setOptimizationMode;
}NV_GPU_SET_OPTIMIZATION_DATA_V1;

typedef NV_GPU_SET_OPTIMIZATION_DATA_V1          NV_GPU_SET_OPTIMIZATION_DATA;
#define NV_GPU_SET_OPTIMIZATION_DATA_VER1        MAKE_NVAPI_VERSION(NV_GPU_SET_OPTIMIZATION_DATA_V1, 1)
#define NV_GPU_SET_OPTIMIZATION_DATA_VER         NV_GPU_SET_OPTIMIZATION_DATA_VER1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_SetOptimizationData
//
//!   DESCRIPTION: This API sets the GPU optimization data for GPUs specified by caller. This API is supported on Vista & above and on Quadro GPUs.
//
//!   Notes : 
//!           1. If any of the GPU specified in gpuOptimizationData is part of any SLI group, the settings will get set for all the GPUs in the SLI group,
//!              even if the GPUs are not specified in the input. Callers can also pass in all the GPUs in the SLI group, but its not necessary.
//!           2. This API will also reload the driver on the specified GPUs, once the optimization data is set properly on all specified GPUs.
//!           3. If more than one GPUs of a SLI group are specified, optimization modes (setOptimizationMode) for all them should match, otherwise the 
//!              the return NVAPI_INVALID_ARGUMENT error.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]    gpuOptimizationData - Pointer to the array of NV_GPU_SET_OPTIMIZATION_DATA structure.
//!        [in]    count               - Number of elements in the gpuOptimizationData array. 
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \ingroup 
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetOptimizationData(__in_ecount(count) NV_GPU_SET_OPTIMIZATION_DATA *gpuOptimizationData, __in NvU32 count);

//! \ingroup gpufan
//! @{

#define NV_GPU_FAN_COOLER_MAX_COOLERS_V1 32

/*!
 * Enumeration of fan cooler types.
 */
typedef enum _NV_GPU_FAN_COOLER_TYPE
{
    NV_GPU_FAN_COOLER_TYPE_ACTIVE,
    NV_GPU_FAN_COOLER_TYPE_ACTIVE_PWM,
    NV_GPU_FAN_COOLER_TYPE_ACTIVE_PWM_TACH_CORR,
} NV_GPU_FAN_COOLER_TYPE;

/*!
 * Enumeration of fan cooler control unit type.
 */
typedef enum _NV_GPU_FAN_COOLER_CONTROL_UNIT_TYPE
{
    NV_GPU_FAN_COOLER_CONTROL_UNIT_TYPE_NONE,
    NV_GPU_FAN_COOLER_CONTROL_UNIT_TYPE_PWM,
    NV_GPU_FAN_COOLER_CONTROL_UNIT_TYPE_RPM,
} NV_GPU_FAN_COOLER_CONTROL_UNIT_TYPE;

/*!
 * Used in \ref NV_GPU_FAN_COOLER_INFO_V1
 * Describes the static information of fan cooler type ACTIVE.
 */
typedef struct _NV_GPU_FAN_COOLER_INFO_DATA_ACTIVE
{
    /*!
     * Tachometer GPIO Function.
     */
    NvU32   gpioFuncTach;

    /*!
     * Tachometer Rate (PPR).
     */
    NvU8    tachRate;

    /*!
     * Tachometer is present and supported.
     * Supported: 1, Unsupported: 0.
     */
    NvU32   bTachSupported : 1;

    /*!
     * Reserved bits.
     */
    NvU32   rsvd : 31;

    /*!
     * Control unit used (by policy) to drive this cooler as
     * \ref NV_GPU_FAN_COOLER_CONTROL_UNIT_TYPE
     */
    NV_GPU_FAN_COOLER_CONTROL_UNIT_TYPE    controlUnit;
} NV_GPU_FAN_COOLER_INFO_DATA_ACTIVE;

/*!
 * Used in \ref NV_GPU_FAN_COOLER_INFO_V1
 * Describes the static information of fan cooler type ACTIVE_PWM.
 */
typedef struct _NV_GPU_FAN_COOLER_INFO_DATA_ACTIVE_PWM
{
    /*!
     * NV_GPU_FAN_COOLER_INFO_DATA_ACTIVE super class.
     * This should always be the first member!
     */
    NV_GPU_FAN_COOLER_INFO_DATA_ACTIVE active;

    /*!
     * Fan GPIO Function.
     */
    NvU32  gpioFuncFan;

    /*!
     * PWM frequency. Units: Hz
     */
    NvU32  freq;

    /*!
     * RM_PMU_THERM_EVENT_<xyz> bitmask triggering MAX Fan speed (if engaged).
     */
    NvU32  maxFanEvtMask;

    /*!
     * MIN time [ms] to spend at MAX Fan speed to prevent trashing at slowdown.
     */
    NvU16  maxFanMinTimems;
} NV_GPU_FAN_COOLER_INFO_DATA_ACTIVE_PWM;

/*!
 * Used in \ref NV_GPU_FAN_COOLER_INFO_V1
 * Describes the static information of fan cooler type ACTIVE_PWM_TACH_CORR.
 */
typedef struct _NV_GPU_FAN_COOLER_INFO_DATA_ACTIVE_PWM_TACH_CORR
{
    /*!
     * NV_GPU_FAN_COOLER_INFO_DATA_ACTIVE_PWM super class.
     * This should always be the first member!
     */
    NV_GPU_FAN_COOLER_INFO_DATA_ACTIVE_PWM activePwm;
} NV_GPU_FAN_COOLER_INFO_DATA_ACTIVE_PWM_TACH_CORR;

/*!
 * Used in \ref NV_GPU_FAN_COOLER_INFO_PARAMS_V1.
 * Describes the static information of fan coolers
 */
typedef struct _NV_GPU_FAN_COOLER_INFO_V1
{
    /*!
     * Fan cooler type.
     */
    NV_GPU_FAN_COOLER_TYPE type;

    /*!
     * Reserved bytes for possible future extension of this struct.
     */
    NvU8                   rsvd[32];

    /*!
     * Union of fan cooler info data. Interpreted as per
     * @ref NV_GPU_FAN_COOLER_INFO_V1::type
     */
    union
    {
        //
        // Need to be careful when add/expanding types in this union. If any type
        // exceeds sizeof(rsvd) then rsvd has failed its purpose.
        //
        NV_GPU_FAN_COOLER_INFO_DATA_ACTIVE                active;
        NV_GPU_FAN_COOLER_INFO_DATA_ACTIVE_PWM            activePwm;
        NV_GPU_FAN_COOLER_INFO_DATA_ACTIVE_PWM_TACH_CORR  activePwmTachCorr;
        /*!
         * Reserved bytes for possible future extension of this struct.
         */
        NvU8               rsvd[32];
    } data;

} NV_GPU_FAN_COOLER_INFO_V1;

/*!
 * Used in \ref NvAPI_GPU_FanCoolerGetInfo.
 * Describes the fan coolers and their static info available on the given GPU.
 */
typedef struct _NV_GPU_FAN_COOLER_INFO_PARAMS_V1
{
    /*!
     * Version of structure. Must always be first member.
     */
    NvU32                     version;

    /*!
     * Mask of entries corresponding to available \ref NV_GPU_FAN_COOLER_TYPE.
     */
    NvU32                     coolerMask;

    /*!
     * Reserved bytes for possible future extension of this struct.
     */
    NvU8                      rsvd[32];

    /*!
     * Array of fan cooler entries. Index in array corresponds to set bits in 
     * \ref NV_GPU_FAN_COOLER_INFO_PARAMS_V1::coolerMask.
     */
    NV_GPU_FAN_COOLER_INFO_V1 coolers[NV_GPU_FAN_COOLER_MAX_COOLERS_V1];
} NV_GPU_FAN_COOLER_INFO_PARAMS_V1;

#define NV_GPU_FAN_COOLER_INFO_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_FAN_COOLER_INFO_PARAMS_V1, 1)
#define NV_GPU_FAN_COOLER_INFO_PARAMS_VER   NV_GPU_FAN_COOLER_INFO_PARAMS_VER_1
typedef NV_GPU_FAN_COOLER_INFO_PARAMS_V1    NV_GPU_FAN_COOLER_INFO_PARAMS;

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_FanCoolerGetInfo
//
//! DESCRIPTION:  This API returns static information about fan coolers on the
//!               given GPU.
//
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version: 319.xx
//! \param [in]  hPhysicalGpu    The physical GPU handle
//! \param [out] pFanCoolerInfo  Pointer to structure containing static
//!                              information about fan coolers.
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status.
//!          If there are return error codes with specific meaning for this API,
//!          they are listed below.
//! \ingroup gpufan
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_FanCoolerGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_FAN_COOLER_INFO_PARAMS *pFanCoolerInfo);

//! \ingroup gpufan
//! @{

/*!
 * Used in \ref NV_GPU_FAN_COOLER_STATUS_V1
 * Describes the status of fan cooler type ACTIVE.
 */
typedef struct _NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_V1
{
    /*!
     * Current RPM.
     */
    NvU32 rpmCurr;

    /*!
     * Minimum fan level, as UFXP percentage (computed from driving RPM or PWM
     * value normalized to max).
     * Format: Unsigned Fixed Point Integer 16.16
     */
    NvU32 levelMin;

    /*!
     * Maximum fan level, as UFXP percentage (computed from driving RPM or PWM
     * value normalized to max. Between 0.0 to 1.0).
     * Format: Unsigned Fixed Point Integer 16.16
     */
    NvU32 levelMax;

    /*!
     * Current (dynamic) fan level, as UFXP percentage (computed from driving
     * RPM or PWM value normalized to max).
     * Format: Unsigned Fixed Point Integer 16.16
     */
    NvU32 levelCurrent;

    /*!
     * Target (currently requested, static) fan level, as UFXP percentage
     * (computed from driving RPM or PWM value normalized to max).
     * Format: Unsigned Fixed Point Integer 16.16
     */
    NvU32 levelTarget;
} NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_V1;

/*!
 * Used in \ref NV_GPU_FAN_COOLER_STATUS_V1
 * Describes the status  of fan cooler type ACTIVE_PWM.
 */
typedef struct _NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_PWM_V1
{
    /*!
     * NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_V1 super class.
     * This should always be the first member!
     */
    NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_V1   active;

    /*!
     * Current Electrical Fan Speed (%).
     * Format: Unsigned Fixed Point Integer 16.16
     */
    NvU32                                  pwmCurr;
} NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_PWM_V1;

/*!
 * Used in \ref NV_GPU_FAN_COOLER_STATUS_V1
 * Describes the status of fan cooler type ACTIVE_PWM_TACH_CORR.
 */
typedef struct _NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_PWM_TACH_CORR_V1
{
    /*!
     * NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_PWM_V1 super class.
     * This should always be the first member!
     */
    NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_PWM_V1   activePwm;

    /*!
     * Last RPM reading used for tach correction.
     */
    NvU32                                         rpmLast;

    /*!
     * Target RPM requested by tach correction.
     */
    NvU32                                         rpmTarget;
} NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_PWM_TACH_CORR_V1;


/*!
 * Used in \ref NV_GPU_FAN_COOLER_STATUS_PARAMS_V1.
 * Describes the status of fan coolers
 */
typedef struct _NV_GPU_FAN_COOLER_STATUS_V1
{
    /*!
     * Fan cooler type.
     */
    NV_GPU_FAN_COOLER_TYPE type;

    /*!
     * Reserved bytes for possible future extension of this struct.
     */
    NvU8                   rsvd[32];

    /*!
     * Union of fan cooler status data. Interpreted as per
     * @ref NV_GPU_FAN_COOLER_STATUS_V1::type
     */
    union
    {
        //
        // Need to be careful when add/expanding types in this union. If any type
        // exceeds sizeof(rsvd) then rsvd has failed its purpose.
        //
        NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_V1               active;
        NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_PWM_V1           activePwm;
        NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_PWM_TACH_CORR_V1 activePwmTachCorr;
        /*!
         * Reserved bytes for possible future extension of this struct.
         */
        NvU8               rsvd[32];
    } data;
} NV_GPU_FAN_COOLER_STATUS_V1;

/*!
 * Used in \ref NvAPI_GPU_FanCoolerGetStatus.
 * Describes the fan coolers status available on the given GPU.
 */
typedef struct _NV_GPU_FAN_COOLER_STATUS_PARAMS_V1
{
    /*!
     * Version of structure. Must always be first member.
     */
    NvU32                       version;

    /*!
     * Mask of entries corresponding to available @ref NV_GPU_FAN_COOLER_TYPE
     * requested by client.
     */
    NvU32                       coolerMask;

    /*!
     * Reserved bytes for possible future extension of this struct.
     */
    NvU8                        rsvd[32];

    /*!
     * Array of fan cooler entries. Index in array corresponds to set bits in 
     * \ref NV_GPU_FAN_COOLER_STATUS_PARAMS_V1::coolerMask.
     */
    NV_GPU_FAN_COOLER_STATUS_V1 coolers[NV_GPU_FAN_COOLER_MAX_COOLERS_V1];
} NV_GPU_FAN_COOLER_STATUS_PARAMS_V1;

/*!
 * Used in \ref NV_GPU_FAN_COOLER_STATUS_V2
 * Describes the status  of fan cooler type ACTIVE_PWM.
 */
typedef struct _NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_PWM_V2
{
    /*!
     * NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_V1 super class.
     * This should always be the first member!
     */
    NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_V1   active;

    /*!
     * Current Electrical Fan Speed (%).
     * Format: Unsigned Fixed Point Integer 16.16
     */
    NvU32                                     pwmCurr;

    /*!
     * PWM requested to ACTIVE_PWM FAN_COOLER.
     * Format: Unsigned Fixed Point Integer 16.16
     */
    NvU32                                     pwmRequested;

    /*!
     * Set while PWM Fan is in MAX-ed state.
     */
    NvU8                                      bMaxFanActive;
} NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_PWM_V2;

/*!
 * Used in \ref NV_GPU_FAN_COOLER_STATUS_V2
 * Describes the status of fan cooler type ACTIVE_PWM_TACH_CORR.
 */
typedef struct _NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_PWM_TACH_CORR_V2
{
    /*!
     * NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_PWM_V2 super class.
     * This should always be the first member!
     */
    NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_PWM_V2   activePwm;

    /*!
     * Last RPM reading used for tach correction.
     */
    NvU32                                         rpmLast;

    /*!
     * Target RPM requested by tach correction.
     */
    NvU32                                         rpmTarget;

    /*!
     * Actual measured PWM used for applying floor limit offset on Gemini fan
     * sharing designs.
     */
    NvU32                                         pwmActual;
} NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_PWM_TACH_CORR_V2;

/*!
 * Used in \ref NV_GPU_FAN_COOLER_STATUS_PARAMS_V2.
 * Describes the status of fan coolers
 */
typedef struct _NV_GPU_FAN_COOLER_STATUS_V2
{
    /*!
     * Fan cooler type.
     */
    NV_GPU_FAN_COOLER_TYPE type;

    /*!
     * Reserved bytes for possible future extension of this struct.
     */
    NvU8                   rsvd[32];

    /*!
     * Union of fan cooler status data. Interpreted as per
     * @ref NV_GPU_FAN_COOLER_STATUS_V2::type
     */
    union
    {
        //
        // Need to be careful when add/expanding types in this union. If any type
        // exceeds sizeof(rsvd) then rsvd has failed its purpose.
        //
        NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_V1               active;
        NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_PWM_V2           activePwm;
        NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_PWM_TACH_CORR_V2 activePwmTachCorr;
        /*!
         * Reserved bytes for possible future extension of this struct.
         */
        NvU8               rsvd[96];
    } data;
} NV_GPU_FAN_COOLER_STATUS_V2;

/*!
 * Used in \ref NvAPI_GPU_FanCoolerGetStatus.
 * Describes the fan coolers status available on the given GPU.
 */
typedef struct _NV_GPU_FAN_COOLER_STATUS_PARAMS_V2
{
    /*!
     * Version of structure. Must always be first member.
     */
    NvU32                       version;

    /*!
     * Mask of entries corresponding to available @ref NV_GPU_FAN_COOLER_TYPE
     * requested by client.
     */
    NvU32                       coolerMask;

    /*!
     * Reserved bytes for possible future extension of this struct.
     */
    NvU8                        rsvd[32];

    /*!
     * Array of fan cooler entries. Index in array corresponds to set bits in 
     * \ref NV_GPU_FAN_COOLER_STATUS_PARAMS_V2::coolerMask.
     */
    NV_GPU_FAN_COOLER_STATUS_V2 coolers[NV_GPU_FAN_COOLER_MAX_COOLERS_V1];
} NV_GPU_FAN_COOLER_STATUS_PARAMS_V2;

#define NV_GPU_FAN_COOLER_STATUS_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_FAN_COOLER_STATUS_PARAMS_V1, 1)
#define NV_GPU_FAN_COOLER_STATUS_PARAMS_VER_2 MAKE_NVAPI_VERSION(NV_GPU_FAN_COOLER_STATUS_PARAMS_V2, 2)
#define NV_GPU_FAN_COOLER_STATUS_PARAMS_VER   NV_GPU_FAN_COOLER_STATUS_PARAMS_VER_2
typedef NV_GPU_FAN_COOLER_STATUS_PARAMS_V2    NV_GPU_FAN_COOLER_STATUS_PARAMS;

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_FanCoolerGetStatus
//
//! DESCRIPTION:  This API returns status of fan coolers on the
//!               given GPU.
//
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version: 319.xx
//! \param [in]  hPhysicalGpu      The physical GPU handle
//! \param [out] pFanCoolerStatus  Pointer to structure containing status
//!                                information about fan coolers.
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status.
//!          If there are return error codes with specific meaning for this API,
//!          they are listed below.
//! \ingroup gpufan
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_FanCoolerGetStatus(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_FAN_COOLER_STATUS_PARAMS *pFanCoolerStatus);

//! \ingroup gpufan
//! @{

/*!
 * Used in \ref NV_GPU_FAN_COOLER_CONTROL_V1
 * Describes the status of fan cooler type ACTIVE.
 */
typedef struct _NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_V1
{
    /*!
     * Minimum RPM.
     */
    NvU32 rpmMin;

    /*!
     * Acoustic Maximum RPM.
     */
    NvU32 rpmMax;

    /*!
     * Reflects the state of fan level (normalized %) override.
     * Active: 1, Inactive: 0
     *
     * Level override has highest priority since it was selected that
     * the parent classes has precedence over children.
     */
    NvU32                                  bLevelSimActive : 1;

    /*!
     * Reserved bits.
     */
    NvU32                                  rsvd : 31;

    /*!
     * Override value for fan level (normalized %).
     * Applicable only when \ref bLevelSimActive == 1.
     * Format: Unsigned Fixed Point Integer 16.16
     */
    NvU32                                  levelSim;
} NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_V1;

/*!
 * Used in \ref NV_GPU_FAN_COOLER_CONTROL_V1
 * Describes the status  of fan cooler type ACTIVE_PWM.
 */
typedef struct _NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_PWM_V1
{
    /*!
     * NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_V1 super class.
     * This should always be the first member!
     */
    NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_V1  active;

    /*!
     * Electrical Minimum Fan Speed (%).
     * Format: Unsigned Fixed Point Integer 16.16
     */
    NvU32                                     pwmMin;

    /*!
     * Electrical Maximum Fan Speed (%).
     * Format: Unsigned Fixed Point Integer 16.16
     */
    NvU32                                     pwmMax;

    /*!
     * Reflects the state of Electrical Fan Speed (PWM) override.
     * Active: 1, Inactive: 0
     *
     * PWM override has lower priority than parent's class level override since
     * it was selected that the parent classes has precedence over children.
     */
    NvU32                                     bPwmSimActive : 1;

    /*!
     * Reserved bits.
     */
    NvU32                                     rsvd : 31;

    /*!
     * Override value for Electrical Fan Speed (%).
     * Applicable only when \ref bPwmSimActive == 1.
     * Format: Unsigned Fixed Point Integer 16.16
     */
    NvU32                                     pwmSim;
} NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_PWM_V1;

/*!
 * Used in \ref NV_GPU_FAN_COOLER_CONTROL_V1
 * Describes the status of fan cooler type ACTIVE_PWM_TACH_CORR.
 */
typedef struct _NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_PWM_TACH_CORR_V1
{
    /*!
     * NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_PWM_V1 super class.
     * This should always be the first member!
     */
    NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_PWM_V1  activePwm;

    /*!
     * Tachometer Feedback Proportional Gain. Fixed point uint (0.16)
     * Format: Signed Fixed Point Integer 16.16
     */
    NvS32                                         propGain;

    /*!
     * Reflects the state of RPM override.
     * Active: 1, Inactive: 0
     *
     * RPM override has lower priority than both level and PWM overrides since
     * it was selected that the parent classes has precedence over children.
     */
    NvU32                                         bRpmSimActive : 1;

    /*!
     * Reserved bits.
     */
    NvU32                                         rsvd : 31;

    /*!
     * Override value for RPM settings.
     * Applicable only when \ref bRpmSimActive == 1.
     */
    NvU32                                         rpmSim;
} NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_PWM_TACH_CORR_V1;

/*!
 * Used in \ref NV_GPU_FAN_COOLER_CONTROL_PARAMS_V1.
 * Describes the control data of fan coolers
 */
typedef struct _NV_GPU_FAN_COOLER_CONTROL_V1
{
    /*!
     * Fan cooler type.
     */
    NV_GPU_FAN_COOLER_TYPE type;

    /*!
     * Reserved bytes for possible future extension of this struct.
     */
    NvU8                   rsvd[32];

    /*!
     * Union of fan cooler status data. Interpreted as per
     * \ref NV_GPU_FAN_COOLER_CONTROL_V1::type
     */
    union
    {
        //
        // Need to be careful when add/expanding types in this union. If any type
        // exceeds sizeof(rsvd) then rsvd has failed its purpose.
        //
        NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_V1                active;
        NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_PWM_V1            activePwm;
        NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_PWM_TACH_CORR_V1  activePwmTachCorr;
        /*!
         * Reserved bytes for possible future extension of this struct.
         */
        NvU8               rsvd[32];
    } data;
} NV_GPU_FAN_COOLER_CONTROL_V1;

/*!
 * Used in \ref NvAPI_GPU_FanCoolerGetControl.
 * Describes the fan coolers' control data available on the given GPU.
 */
typedef struct _NV_GPU_FAN_COOLER_CONTROL_PARAMS_V1
{
    /*!
     * Version of structure. Must always be first member.
     */
    NvU32                       version;

    /*!
     * Mask of entries corresponding to available @ref NV_GPU_FAN_COOLER_TYPE
     * requested by client.
     */
    NvU32                       coolerMask;

    /*!
     * Bit field specifying the set of values to retrieve
     * - default (1)
     * - currently active (0).
     */
    NvU32                       retrieveDefault : 1;
    NvU32                       reservedField : 31;

    /*!
     * Reserved bytes for possible future extension of this struct.
     */
    NvU8                        rsvd[32];

    /*!
     * Array of fan cooler entries. Index in array corresponds to set bits in 
     * @ref NV_GPU_FAN_COOLER_CONTROL_PARAMS_V1::coolerMask.
     */
    NV_GPU_FAN_COOLER_CONTROL_V1 coolers[NV_GPU_FAN_COOLER_MAX_COOLERS_V1];
} NV_GPU_FAN_COOLER_CONTROL_PARAMS_V1;

/*!
 * Used in \ref NV_GPU_FAN_COOLER_CONTROL_V2
 * Describes the status  of fan cooler type ACTIVE_PWM.
 */
typedef struct _NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_PWM_V2
{
    /*!
     * NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_V1 super class.
     * This should always be the first member!
     */
    NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_V1  active;

    /*!
     * Electrical Minimum Fan Speed (%).
     * Format: Unsigned Fixed Point Integer 16.16
     */
    NvU32                                     pwmMin;

    /*!
     * Electrical Maximum Fan Speed (%).
     * Format: Unsigned Fixed Point Integer 16.16
     */
    NvU32                                     pwmMax;

    /*!
     * Reflects the state of Electrical Fan Speed (PWM) override.
     * Active: 1, Inactive: 0
     *
     * PWM override has lower priority than parent's class level override since
     * it was selected that the parent classes has precedence over children.
     */
    NvU32                                     bPwmSimActive : 1;

    /*!
     * Reserved bits.
     */
    NvU32                                     rsvd : 31;

    /*!
     * Override value for Electrical Fan Speed (%).
     * Applicable only when \ref bPwmSimActive == 1.
     * Format: Unsigned Fixed Point Integer 16.16
     */
    NvU32                                     pwmSim;

    /*!
     * MAX Fan speed settings (PWM rate in percents).
     */
    NvU32                                     maxFanPwm;
} NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_PWM_V2;

/*!
 * Used in \ref NV_GPU_FAN_COOLER_CONTROL_V2
 * Describes the status of fan cooler type ACTIVE_PWM_TACH_CORR.
 */
typedef struct _NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_PWM_TACH_CORR_V2
{
    /*!
     * NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_PWM_V2 super class.
     * This should always be the first member!
     */
    NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_PWM_V2  activePwm;

    /*!
     * Tachometer Feedback Proportional Gain. Fixed point uint (0.16)
     * Format: Signed Fixed Point Integer 16.16
     */
    NvS32                                         propGain;

    /*!
     * Reflects the state of RPM override.
     * Active: 1, Inactive: 0
     *
     * RPM override has lower priority than both level and PWM overrides since
     * it was selected that the parent classes has precedence over children.
     */
    NvU32                                         bRpmSimActive : 1;

    /*!
     * Reserved bits.
     */
    NvU32                                         rsvd : 31;

    /*!
     * Override value for RPM settings.
     * Applicable only when \ref bRpmSimActive == 1.
     */
    NvU32                                         rpmSim;

    /*!
     * An absolute offset (in PWM percents) from actual/measured PWM speed, used
     * on systems exploiting fan-sharing, preventing tachometer driven policies
     * to reduce PWM speed to @ref pwmMin (see bug 1398842).
     */
    NvU32                                         pwmFloorLimitOffset;
} NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_PWM_TACH_CORR_V2;

/*!
 * Used in \ref NV_GPU_FAN_COOLER_CONTROL_PARAMS_V2.
 * Describes the control data of fan coolers
 */
typedef struct _NV_GPU_FAN_COOLER_CONTROL_V2
{
    /*!
     * Fan cooler type.
     */
    NV_GPU_FAN_COOLER_TYPE type;

    /*!
     * Reserved bytes for possible future extension of this struct.
     */
    NvU8                   rsvd[32];

    /*!
     * Union of fan cooler status data. Interpreted as per
     * \ref NV_GPU_FAN_COOLER_CONTROL_V2::type
     */
    union
    {
        //
        // Need to be careful when add/expanding types in this union. If any type
        // exceeds sizeof(rsvd) then rsvd has failed its purpose.
        //
        NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_V1                active;
        NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_PWM_V2            activePwm;
        NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_PWM_TACH_CORR_V2  activePwmTachCorr;
        /*!
         * Reserved bytes for possible future extension of this struct.
         */
        NvU8               rsvd[96];
    } data;
} NV_GPU_FAN_COOLER_CONTROL_V2;

/*!
 * Used in \ref NvAPI_GPU_FanCoolerGetControl.
 * Describes the fan coolers' control data available on the given GPU.
 */
typedef struct _NV_GPU_FAN_COOLER_CONTROL_PARAMS_V2
{
    /*!
     * Version of structure. Must always be first member.
     */
    NvU32                       version;

    /*!
     * Mask of entries corresponding to available @ref NV_GPU_FAN_COOLER_TYPE
     * requested by client.
     */
    NvU32                       coolerMask;

    /*!
     * Bit field specifying the set of values to retrieve
     * - default (1)
     * - currently active (0).
     */
    NvU32                       retrieveDefault : 1;
    NvU32                       reservedField : 31;

    /*!
     * Reserved bytes for possible future extension of this struct.
     */
    NvU8                        rsvd[32];

    /*!
     * Array of fan cooler entries. Index in array corresponds to set bits in 
     * @ref NV_GPU_FAN_COOLER_CONTROL_PARAMS_V2::coolerMask.
     */
    NV_GPU_FAN_COOLER_CONTROL_V2 coolers[NV_GPU_FAN_COOLER_MAX_COOLERS_V1];
} NV_GPU_FAN_COOLER_CONTROL_PARAMS_V2;

#define NV_GPU_FAN_COOLER_CONTROL_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_FAN_COOLER_CONTROL_PARAMS_V1, 1)
#define NV_GPU_FAN_COOLER_CONTROL_PARAMS_VER_2 MAKE_NVAPI_VERSION(NV_GPU_FAN_COOLER_CONTROL_PARAMS_V2, 2)
#define NV_GPU_FAN_COOLER_CONTROL_PARAMS_VER   NV_GPU_FAN_COOLER_CONTROL_PARAMS_VER_2
typedef NV_GPU_FAN_COOLER_CONTROL_PARAMS_V2    NV_GPU_FAN_COOLER_CONTROL_PARAMS;

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_FanCoolerGetControl
//
//! DESCRIPTION:  This API returns control information of fan coolers on the
//!               given GPU.
//
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version: 319.xx
//! \param [in]  hPhysicalGpu      The physical GPU handle
//! \param [out] pFanCoolerControl Pointer to structure containing control
//!                                information about fan coolers.
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status.
//!          If there are return error codes with specific meaning for this API,
//!          they are listed below.
//! \ingroup gpufan
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_FanCoolerGetControl(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_FAN_COOLER_CONTROL_PARAMS *pFanCoolerControl);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_FanCoolerSetControl
//
//! DESCRIPTION:  This API sets control information of fan coolers on the
//!               given GPU.
//
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version: 319.xx
//! \param [in]  hPhysicalGpu      The physical GPU handle
//! \param [in] pFanCoolerControl Pointer to structure containing control
//!                                information about fan coolers.
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status.
//!          If there are return error codes with specific meaning for this API,
//!          they are listed below.
//! \ingroup gpufan
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_FanCoolerSetControl(__in NvPhysicalGpuHandle hPhysicalGpu, __in NV_GPU_FAN_COOLER_CONTROL_PARAMS *pFanCoolerControl);

//! \ingroup gpufan
//! @{

#define NV_GPU_FAN_POLICY_MAX_POLICIES_V1      32

/*!
 * Enumeration of Fan Policies. Unique identifiers for different Fan
 * Policies being enforced on the GPU.
 */
typedef enum _NV_GPU_FAN_POLICY_TYPE
{
    NV_GPU_FAN_POLICY_TYPE_IIR_TJ_FIXED_DUAL_SLOPE_PWM  = 0x00000000,
} NV_GPU_FAN_POLICY_TYPE;

/*!
 * Used in \ref NV_GPU_FAN_POLICY_INFO_V1. Structure representing 
 * static information associated with a IIR_TJ_FIXED_DUAL_SLOPE_PWM.
 */
typedef struct _NV_GPU_FAN_POLICY_INFO_DATA_IIR_TJ_FIXED_DUAL_SLOPE_PWM
{
    /*!
     * Policy control selection.
     */
    NvU8    bUsePwm;

    /*!
     * Specifies whether Fan Stop sub-policy is supported.
     */
    NvU8    bFanStopSupported;

    /*!
     * Fan Start Min Hold Time - (ms). Minimum time to spend at Electrical Fan
     * Speed Min to prevent fan overshoot after being re-started.
     */
    NvU16   fanStartMinHoldTimems;

    /*!
     * Power Topology Index in the Power Topology Table. If the value is 0xFF,
     * only GPU Tj needs to be considered for Fan Stop sub-policy.
     */
    NvU8    fanStopPowerTopologyIdx;

    /*!
     * Specifies whether Fan Stop sub-policy is enabled by default.
     */
    NvU8    bFanStopEnableDefault;
} NV_GPU_FAN_POLICY_INFO_DATA_IIR_TJ_FIXED_DUAL_SLOPE_PWM;

/*!
 * Used in \ref NV_GPU_FAN_POLICIY_INFO_PARAMS_V1. Structure of static
 * information describing a FAN_POLICY, which specifies a fan policy to
 * enforce on the GPU.
 */
typedef struct _NV_GPU_FAN_POLICY_INFO_V1
{
    /*!
     * Fan policy type.
     */
    NV_GPU_FAN_POLICY_TYPE type;

    /*!
     * Index into the Fan Cooler Table.
     */
    NvU8 fanCoolerIndex;

    /*!
     * Sampling period. Units: milliseconds.
     */
    NvU16 fanSamplingPeriodms;

    /*!
     * Reserve bytes, so can add to the structure later w/o needed to add a new version.
     */
    NvU8 rsvd[32];

    /*!
     * Union of type-specific data. Interpreted based on \ref type value.
     */
    union
    {
        /*!
         * IIR_TJ_FIXED_DUAL_SLOPE_PWM FAN_POLICY
         */
        NV_GPU_FAN_POLICY_INFO_DATA_IIR_TJ_FIXED_DUAL_SLOPE_PWM fanIIRTFDSP;

        /*!
        * Reserve bytes, so can add to the structure later w/o needed to add a new version.
        */
        NvU8 rsvd[32];
    }data;
} NV_GPU_FAN_POLICY_INFO_V1;

/*!
 * Used in \ref NvAPI_GPU_FanPolicyGetInfo.
 *
 * Describes the set of Fan Policies which are controlling GPU Fan.
 */
typedef struct _NV_GPU_FAN_POLICIY_INFO_PARAMS_V1
{
    /*!
     * Version of structure. Must always be first.
     */
    NvU32 version;

    /*!
     * Mask of FAN_POLICY entries specified on this GPU.
     */
    NvU32 policyMask;

    /*!
     * Fan Policy index for fan policy controlling the GPU fan.
     */
    NvU8  gpuPolicyIdx;

    /*!
     * Reserve bytes, so can add to the structure later w/o needed to add a new version.
     */
    NvU8  rsvd[31];

    /*!
     * Array of FAN_POLICY entries.  Has valid indexes corresponding to
     * the bits set in \ref policyMask.
     */
    NV_GPU_FAN_POLICY_INFO_V1
        policies[NV_GPU_FAN_POLICY_MAX_POLICIES_V1];
} NV_GPU_FAN_POLICIY_INFO_PARAMS_V1;

#define NV_GPU_FAN_POLICY_INFO_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_FAN_POLICIY_INFO_PARAMS_V1,1)
#define NV_GPU_FAN_POLICY_INFO_PARAMS_VER   NV_GPU_FAN_POLICY_INFO_PARAMS_VER_1

typedef NV_GPU_FAN_POLICIY_INFO_PARAMS_V1   NV_GPU_FAN_POLICY_INFO_PARAMS;

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    NvAPI_GPU_FanPolicyGetInfo()
//
//! DESCRIPTION: Retrieves information about the FAN_POLICY support on the
//!              GPU.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 319
//!
//! \param [in]  hPhysicalGPU   GPU selection
//! \param [out] pFanPolicyInfo Structure containing the description of FAN_POLICYs.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gpufan
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_FanPolicyGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_FAN_POLICY_INFO_PARAMS *pFanPolicyInfo);

//! \ingroup gpufan
//! @{

/*!
 * Used in \ref NV_GPU_FAN_POLICY_STATUS_V1. Structure representing the 
 * dynamic state associated with a IIR_TJ_FIXED_DUAL_SLOPE_PWM FAN_POLICY.
 */
typedef struct _NV_GPU_FAN_POLICY_STATUS_DATA_IIR_TJ_FIXED_DUAL_SLOPE_PWM
{
    /*!
     * Current Short Term Average Temperature (C).
     * Format: Signed Fixed Point Integer 10.22
     */
    NvS32  fanTjAvgShortTerm;

    /*!
     * Current Long Term Average Temperature (C).
     * Format: Signed Fixed Point Integer 10.22
     */
    NvS32  fanTjAvgLongTerm;

    /*!
     * Target PWM (in percents), used when @ref INFO::bUsePwm is set.
     * Format: Unsigned Fixed Point Integer 16.16.
     */
    NvU32  targetPwm;

    /*!
     * Target RPM, used when @ref INFO::bUsePwm is not set.
     */
    NvU32  targetRpm;

    /*!
     * Current GPU Tj.
     */
    NvS32  tjCurrent;

    /*!
     * Filtered PWR_CHANNEL value, used when Fan Stop sub-policy is enabled.
     */
    NvU32  filteredPwrmW;

    /*!
     * Whether the fan stop feature isactive
     */
    NvU8   bFanStopActive;
} NV_GPU_FAN_POLICY_STATUS_DATA_IIR_TJ_FIXED_DUAL_SLOPE_PWM;

/*!
 * Used in \ref NV_GPU_FAN_POLICY_STATUS_PARAMS_V1. Structure representing 
 * the dynamic state of FAN_POLICY.
 */
typedef struct _NV_GPU_FAN_POLICY_STATUS_V1
{
    /*!
     * Fan policy type.
     */
    NV_GPU_FAN_POLICY_TYPE type;

    /*!
     *Reserve bytes, so can add to the structure later w/o needed to add a new version.
     */
    NvU8  rsvd[32];

    /*!
     * Union of type-specific data. Interpreted based on \ref type value.
     */
    union
    {
        /*!
         * IIR_TJ_FIXED_DUAL_SLOPE_PWM FAN_POLICY
         */
        NV_GPU_FAN_POLICY_STATUS_DATA_IIR_TJ_FIXED_DUAL_SLOPE_PWM  fanIIRTFDSP;

        /*!
         *Reserve bytes, so can add to the structure later w/o needed to add a new version.
        */
        NvU8  rsvd[32];
    }data;
} NV_GPU_FAN_POLICY_STATUS_V1;

/*!
 * Used in \ref NvAPI_GPU_FanPolicyGetStatus.
 *
 * Describes/specifies the current status of Fan Policies which
 * are controlling GPU fan.
 */
typedef struct _NV_GPU_FAN_POLICY_STATUS_PARAMS_V1
{
    /*!
     * Version of structure. Must always be first.
     */
    NvU32 version;

    /*!
     * Mask of FAN_POLICY entries requested by the client.
     */
    NvU32 policyMask;

    /*!
     * Reserve bytes, so can add to the structure later w/o needed to add a new version.
     */
    NvU8  rsvd[32];

    /*!
     * Array of FAN_POLICY entries. Has valid indexes corresponding to
     * the bits set in \ref policyMask.
     */
    NV_GPU_FAN_POLICY_STATUS_V1
        policies[NV_GPU_FAN_POLICY_MAX_POLICIES_V1];
} NV_GPU_FAN_POLICY_STATUS_PARAMS_V1;

#define NV_GPU_FAN_POLICY_STATUS_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_FAN_POLICY_STATUS_PARAMS_V1,1)
#define NV_GPU_FAN_POLICY_STATUS_PARAMS_VER   NV_GPU_FAN_POLICY_STATUS_PARAMS_VER_1

typedef NV_GPU_FAN_POLICY_STATUS_PARAMS_V1    NV_GPU_FAN_POLICY_STATUS_PARAMS;

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    NvAPI_GPU_FanPolicyGetStatus()
//
//! DESCRIPTION:     Retrieves the current dynamic state of a set of FAN_POLICY
//!                  entries on the GPU.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version:  319
//!
//! \param [in]      hPhysicalGPU       GPU selection
//! \param [in/out]  pFanPoliciesStatus Structure containing the state of a set of FAN_POLICYs.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gpufan
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_FanPolicyGetStatus(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_FAN_POLICY_STATUS_PARAMS *pFanPoliciesStatus);

//! \ingroup gpufan
//! @{

#define NV_GPU_FAN_POLICY_IIR_TJ_FIXED_DUAL_SLOPE_PWM_FAN_CURVE_PTS     3

/*!
 * Structure representing the control parameters associated with a
 * IIR_TJ_FIXED_DUAL_SLOPE_PWM FAN_POLICY.
 */
typedef struct _NV_GPU_FAN_POLICY_CONTROL_DATA_IIR_TJ_FIXED_DUAL_SLOPE_PWM_V1
{
    /*!
     * Minimum IIR Gain.
     * Format: Signed Fixed Point Integer 16.16
     */
    NvS32       fanIIRGainMin;

    /*!
     * Maximum IIR Gain.
     * Format: Signed Fixed Point Integer 16.16
     */
    NvS32       fanIIRGainMax;

    /*!
     * Short Term IIR Gain.
     * Format: Signed Fixed Point Integer 16.16
     */
    NvS32       fanIIRGainShortTerm;

    /*!
     * IIR Filter Power.
     */
    NvU8        fanIIRFilterPower;

    /*!
     * IIR Long Term Sampling Ratio.
     */
    NvU8        fanIIRLongTermSamplingRatio;

    /*!
     * IIR Filter Lower Width (C). Units: 1/256 C.
     * Format: Signed Fixed Point Integer 24.8
     */
    NvS32       fanIIRFilterWidthUpper;

    /*!
     * IIR Filter Upper Width (C). Units: 1/256 C.
     * Format: Signed Fixed Point Integer 24.8
     */
    NvS32       fanIIRFilterWidthLower;

    struct
    {
        /*!
         * Tj Fan Curve Point (C). Units: 1/256 C.
         * Format: Signed Fixed Point Integer 24.8
         */
        NvS32   fanTj;

        /*!
         * PWM Fan Curve Point. Units: percent.
         * Format: Unsigned Fixed Point Integer 16.16
         */
        NvU32   fanPwm;

        /*!
         * RPM Fan Curve Point.
         */
        NvU32   fanRpm;
    } fanCurvePts[NV_GPU_FAN_POLICY_IIR_TJ_FIXED_DUAL_SLOPE_PWM_FAN_CURVE_PTS];
} NV_GPU_FAN_POLICY_CONTROL_DATA_IIR_TJ_FIXED_DUAL_SLOPE_PWM_V1;

/*!
 * Used in \ref NV_GPU_FAN_POLICY_CONTROL_PARAMS_V1.  Structure repsenting the
 * control/policy parameters of a FAN_POLICY entry.
 */
typedef struct _NV_GPU_FAN_POLICY_CONTROL_V1
{
    /*!
     * NV_GPU_FAN_POLICY_TYPE_<xyz>.
     */
    NV_GPU_FAN_POLICY_TYPE type;

    /*!
     * Reserve bytes, so can add to the structure later w/o needed to add a new version
     */
    NvU8  rsvd[32];

     /*!
     * Union of type-specific data. Interpreted based on \ref type value.
     */
    union
    {
        /*!
         * IIR_TJ_FIXED_DUAL_SLOPE_PWM FAN_POLICY
         */
        NV_GPU_FAN_POLICY_CONTROL_DATA_IIR_TJ_FIXED_DUAL_SLOPE_PWM_V1  fanIIRTFDSP;

        /*!
         * Reserve bytes, so can add to the structure later w/o needed to add a new version
        */ 
        NvU8  rsvd[80];
    }data;
} NV_GPU_FAN_POLICY_CONTROL_V1;

/*!
 * Used in \ref NvAPI_GPU_FanPolicyGetControl, \ref NvAPI_GPU_FanPolicySetControl.
 * Structure representing the control/policy parameters associated with a set of
 * FAN_POLICY entries in the GPU's FAN_POLICY.
 */
typedef struct _NV_GPU_FAN_POLICY_CONTROL_PARAMS_V1
{
    /*!
     * Version of structure. Must always be first.
     */
    NvU32 version;

     /*!
     * Mask of FAN_POLICY entries requested by the client.
     */
    NvU32 policyMask;

    /*!
     * Bit field specifying the set of values to retrieve
     * - default (1)
     * - currently active (0).
     */
    NvU32                       retrieveDefault : 1;
    NvU32                       reservedField : 31;

    /*!
     * Reserve 32 bytes, so can add to the structure later w/o needed to add a new version.
     */
    NvU8  rsvd[32];

    /*!
     * Array of FAN_POLICY entries.  Has valid indexes corresponding to
     * the bits set in \ref policyMask.
     */
    NV_GPU_FAN_POLICY_CONTROL_V1
        policies[NV_GPU_FAN_POLICY_MAX_POLICIES_V1];
} NV_GPU_FAN_POLICY_CONTROL_PARAMS_V1;

/*!
 * Structure representing the control parameters associated with a
 * IIR_TJ_FIXED_DUAL_SLOPE_PWM FAN_POLICY.
 */
typedef struct _NV_GPU_FAN_POLICY_CONTROL_DATA_IIR_TJ_FIXED_DUAL_SLOPE_PWM_V2
{
    /*!
     * Minimum IIR Gain.
     * Format: Signed Fixed Point Integer 16.16
     */
    NvS32       fanIIRGainMin;

    /*!
     * Maximum IIR Gain.
     * Format: Signed Fixed Point Integer 16.16
     */
    NvS32       fanIIRGainMax;

    /*!
     * Short Term IIR Gain.
     * Format: Signed Fixed Point Integer 16.16
     */
    NvS32       fanIIRGainShortTerm;

    /*!
     * IIR Filter Power.
     */
    NvU8        fanIIRFilterPower;

    /*!
     * IIR Long Term Sampling Ratio.
     */
    NvU8        fanIIRLongTermSamplingRatio;

    /*!
     * IIR Filter Lower Width (C). Units: 1/256 C.
     * Format: Signed Fixed Point Integer 24.8
     */
    NvS32       fanIIRFilterWidthUpper;

    /*!
     * IIR Filter Upper Width (C). Units: 1/256 C.
     * Format: Signed Fixed Point Integer 24.8
     */
    NvS32       fanIIRFilterWidthLower;

    struct
    {
        /*!
         * Tj Fan Curve Point (C). Units: 1/256 C.
         * Format: Signed Fixed Point Integer 24.8
         */
        NvS32   fanTj;

        /*!
         * PWM Fan Curve Point. Units: percent.
         * Format: Unsigned Fixed Point Integer 16.16
         */
        NvU32   fanPwm;

        /*!
         * RPM Fan Curve Point.
         */
        NvU32   fanRpm;
    } fanCurvePts[NV_GPU_FAN_POLICY_IIR_TJ_FIXED_DUAL_SLOPE_PWM_FAN_CURVE_PTS];

    /*!
     * Specifies whether Fan Stop sub-policy needs to be enabled.
     */
    NvU8        bFanStopEnable;

    /*!
     * Fan Stop Lower Temperature Limit - Tj (C). Fan will be stopped when GPU
     * Tj falls below this temperature limit.
     */
    NvS32       fanStopTempLimitLower;

    /*!
     * Fan Start Upper Temperature Limit - Tj (C). Fan will be re-started when
     * GPU Tj is at or above this temperature limit.
     */
    NvS32       fanStartTempLimitUpper;

    /*!
     * Fan Stop Lower Power Limit - (mW). Fan will be stopped when both power
     * (specified by @ref fanStopPowerTopologyIdx) and GPU Tj (specified by
     * @ref fanStopTempLimitLower) fall below their respective limits.
     */
    NvU32       fanStopPowerLimitLowermW;

    /*!
     * Fan Start Upper Power Limit - (mW). Fan will be re-started when either
     * power (specified by @ref fanStopPowerTopologyIdx) or GPU Tj (specified
     * by @ref fanStartTempLimitUpper) is at or above their respective limits.
     */
    NvU32       fanStartPowerLimitUppermW;

    /*!
     * Fan Stop IIR Power Gain. The gain value is used for filtering power
     * (specified by @ref fanStopPowerTopologyIdx) before being compared
     * against @ref fanStopPowerLimitLower and @ref fanStartPowerLimitUpper.
     */
    NvS32       fanStopIIRGainPower;
} NV_GPU_FAN_POLICY_CONTROL_DATA_IIR_TJ_FIXED_DUAL_SLOPE_PWM_V2;

/*!
 * Used in \ref NV_GPU_FAN_POLICY_CONTROL_PARAMS_V2.  Structure repsenting the
 * control/policy parameters of a FAN_POLICY entry.
 */
typedef struct _NV_GPU_FAN_POLICY_CONTROL_V2
{
    /*!
     * NV_GPU_FAN_POLICY_TYPE_<xyz>.
     */
    NV_GPU_FAN_POLICY_TYPE type;

    /*!
     * Reserve bytes, so can add to the structure later w/o needed to add a new version
     */
    NvU8  rsvd[32];

     /*!
     * Union of type-specific data. Interpreted based on \ref type value.
     */
    union
    {
        /*!
         * IIR_TJ_FIXED_DUAL_SLOPE_PWM FAN_POLICY
         */
        NV_GPU_FAN_POLICY_CONTROL_DATA_IIR_TJ_FIXED_DUAL_SLOPE_PWM_V2  fanIIRTFDSP;

        /*!
         * Reserve bytes, so can add to the structure later w/o needed to add a new version
        */ 
        NvU8  rsvd[128];
    }data;
} NV_GPU_FAN_POLICY_CONTROL_V2;

/*!
 * Used in \ref NvAPI_GPU_FanPolicyGetControl, \ref NvAPI_GPU_FanPolicySetControl.
 * Structure representing the control/policy parameters associated with a set of
 * FAN_POLICY entries in the GPU's FAN_POLICY.
 */
typedef struct _NV_GPU_FAN_POLICY_CONTROL_PARAMS_V2
{
    /*!
     * Version of structure. Must always be first.
     */
    NvU32 version;

     /*!
     * Mask of FAN_POLICY entries requested by the client.
     */
    NvU32 policyMask;

    /*!
     * Bit field specifying the set of values to retrieve
     * - default (1)
     * - currently active (0).
     */
    NvU32                       retrieveDefault : 1;
    NvU32                       reservedField : 31;

    /*!
     * Reserve 32 bytes, so can add to the structure later w/o needed to add a new version.
     */
    NvU8  rsvd[32];

    /*!
     * Array of FAN_POLICY entries.  Has valid indexes corresponding to
     * the bits set in \ref policyMask.
     */
    NV_GPU_FAN_POLICY_CONTROL_V2
        policies[NV_GPU_FAN_POLICY_MAX_POLICIES_V1];
} NV_GPU_FAN_POLICY_CONTROL_PARAMS_V2;

#define NV_GPU_FAN_POLICY_CONTROL_PARAMS_VER_1  MAKE_NVAPI_VERSION(NV_GPU_FAN_POLICY_CONTROL_PARAMS_V1,1)
#define NV_GPU_FAN_POLICY_CONTROL_PARAMS_VER_2  MAKE_NVAPI_VERSION(NV_GPU_FAN_POLICY_CONTROL_PARAMS_V2,2)
#define NV_GPU_FAN_POLICY_CONTROL_PARAMS_VER    NV_GPU_FAN_POLICY_CONTROL_PARAMS_VER_2

typedef NV_GPU_FAN_POLICY_CONTROL_PARAMS_V2     NV_GPU_FAN_POLICY_CONTROL_PARAMS;

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    NvAPI_GPU_FanPolicyGetControl()
//
//! DESCRIPTION:     This function retrieves the current control/policy of a set
//!                  of FAN_POLICY entries in the RM's FAN_POLICY
//!                  functionality.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version:  319
//!
//! \param [in]      hPhysicalGPU    GPU selection
//! \param [in/out]  pFanPolicyControl
//!     Structure containing the current control/policy of a set of
//!     FAN_POLICY entries.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gpufan
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_FanPolicyGetControl(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_FAN_POLICY_CONTROL_PARAMS *pFanPolicyControl);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    NvAPI_GPU_FanPolicySetControl()
//
//! DESCRIPTION:     This function requests the control/policy of a set
//!                  of FAN_POLICY entries in the RM's FAN_POLICY
//!                  functionality.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version:  319
//!
//! \param [in]      hPhysicalGPU    GPU selection
//! \param [in]      pFanPolicyControl
//!     Structure containing the requested control/policy of a set of
//!     FAN_POLICY entries.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gpufan
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_FanPolicySetControl(__in NvPhysicalGpuHandle hPhysicalGpu, __in NV_GPU_FAN_POLICY_CONTROL_PARAMS *pFanPolicyControl);

//! \ingroup gpufan
//! @{

#define NV_GPU_FAN_TEST_MAX_TESTS_V1    32

/*!
 * Enumeration of Fan Tests. Unique identifiers for different Fan
 * Tests for Fan 2.0.
 */
typedef enum _NV_GPU_FAN_TEST_TYPE
{
    NV_GPU_FAN_TEST_TYPE_INVALID       = 0x00000000,
    NV_GPU_FAN_TEST_TYPE_COOLER_SANITY = 0x00000001,
} NV_GPU_FAN_TEST_TYPE;

/*!
 * Used in \ref NV_GPU_FAN_TEST_INFO_V1. Structure representing 
 * static information associated with a COOLER_SANITY type.
 */
typedef struct _NV_GPU_FAN_TEST_INFO_DATA_COOLER_SANITY
{
    /*!
     * Fan Cooler table index.
     */
    NvU8    coolerTableIdx;

    /*!
     * Error tolerance in percentage.
     */
    NvU8    measurementTolerancePct;

    /*!
     * Convergence Time in millisecond.
     */
    NvU16   convergenceTimems;
} NV_GPU_FAN_TEST_INFO_DATA_COOLER_SANITY;

/*!
 * Used in \ref NV_GPU_FAN_TEST_INFO_PARAMS_V1. Structure of static
 * information describing a FAN_TEST, which is used for Fan 2.0 testing.
 */
typedef struct _NV_GPU_FAN_TEST_INFO_V1
{
    /*!
     * Fan Test type.
     */
    NV_GPU_FAN_TEST_TYPE type;

    /*!
     * Reserve bytes, so can add to the structure later w/o needed to add a new version.
     */
    NvU8 rsvd[32];

    /*!
     * Union of type-specific data. Interpreted based on \ref type value.
     */
    union
    {
        /*!
         * COOLER_SANITY test.
         */
        NV_GPU_FAN_TEST_INFO_DATA_COOLER_SANITY coolerSanity;

        /*!
        * Reserve bytes, so can add to the structure later w/o needed to add a new version.
        */
        NvU8 rsvd[32];
    }data;
} NV_GPU_FAN_TEST_INFO_V1;

/*!
 * Used in \ref NvAPI_GPU_FanTestGetInfo.
 *
 * Describes the set of Fan Tests which are used for test Fan 2.0
 */
typedef struct _NV_GPU_FAN_TEST_INFO_PARAMS_V1
{
    /*!
     * Version of structure. Must always be first.
     */
    NvU32 version;

    /*!
     * Mask of FAN_TEST entries.
     */
    NvU32 testMask;

    /*!
     * Reserve bytes, so can add to the structure later w/o needed to add a new version.
     */
    NvU8 rsvd[32];

    /*!
     * Array of FAN_TEST entries.  Has valid indexes corresponding to
     * the bits set in \ref testMask.
     */
    NV_GPU_FAN_TEST_INFO_V1
        test[NV_GPU_FAN_TEST_MAX_TESTS_V1];
} NV_GPU_FAN_TEST_INFO_PARAMS_V1;

#define NV_GPU_FAN_TEST_INFO_PARAMS_VER_1   MAKE_NVAPI_VERSION(NV_GPU_FAN_TEST_INFO_PARAMS_V1,1)
#define NV_GPU_FAN_TEST_INFO_PARAMS_VER     NV_GPU_FAN_TEST_INFO_PARAMS_VER_1

typedef NV_GPU_FAN_TEST_INFO_PARAMS_V1      NV_GPU_FAN_TEST_INFO_PARAMS;

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    NvAPI_GPU_FanTestGetInfo()
//
//! DESCRIPTION: Retrieves information about the FAN_TEST that are supported
//!              for Fan 2.0.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 319
//!
//! \param [in]  hPhysicalGPU   GPU selection
//! \param [out] pFanTestInfo   Structure containing the description of FAN_TESTs.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gpufan
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_FanTestGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_FAN_TEST_INFO_PARAMS *pFanTestInfo);

//! \ingroup gputhermal
//! @{

#define NV_GPU_THERMAL_THERM_DEVICE_MAX_V1              32

/*!
 * Enumeration of Device class.
 */
typedef enum _NV_GPU_THERMAL_THERM_DEVICE_CLASS
{
    NV_GPU_THERMAL_THERM_DEVICE_CLASS_INVALID      =   0x00,
    NV_GPU_THERMAL_THERM_DEVICE_CLASS_GPU          =   0x01,
    NV_GPU_THERMAL_THERM_DEVICE_CLASS_I2C_ADM1032  =   0x41,
    NV_GPU_THERMAL_THERM_DEVICE_CLASS_I2C_MAX6649  =   0x43,
    NV_GPU_THERMAL_THERM_DEVICE_CLASS_I2C_TMP411   =   0x44,
    NV_GPU_THERMAL_THERM_DEVICE_CLASS_I2C_ADT7461  =   0x45    
} NV_GPU_THERMAL_THERM_DEVICE_CLASS;

/*!
 * Structure of static information specific to I2C devices.
 */
typedef struct _NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C
{
    /*!
     * Specifies the I2C Device Index in the DCB I2C Devices Table.
     */
    NvU8        i2cDevIdx;
} NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C;

/*!
 * Structure of static information specific to I2C ADT7461 device.
 */
typedef struct _NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C_ADT7461
{
    /*!
     * I2C Device information.
     */
     NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C   i2c;
} NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C_ADT7461;

/*!
 * Structure of static information specific to I2C TMP411 device.
 */
typedef struct _NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C_TMP411
{
    /*!
     * I2C Device information.
     */
     NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C   i2c;
} NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C_TMP411;

/*!
 * Structure of static information specific to I2C MAX6649 device.
 */
typedef struct _NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C_MAX6649
{
    /*!
     * I2C Device information.
     */
     NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C   i2c;
} NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C_MAX6649;

/*!
 * Structure of static information specific to I2C ADM1032 device.
 */
typedef struct _NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C_ADM1032
{
    /*!
     * I2C Device information.
     */
     NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C   i2c;
} NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C_ADM1032;

/*!
 * Used in \ref NV_GPU_THERMAL_THERM_DEVICE_INFO_PARAMS_V1. Structure of static
 * information describing a THERM_DEVICE, which specifies a thermal device to
 * enforce on the GPU.
 */
typedef struct _NV_GPU_THERMAL_THERM_DEVICE_INFO_V1
{
    /*!
     * Thermal device class.
     */
    NV_GPU_THERMAL_THERM_DEVICE_CLASS devClass;

    /*!
     * Reserve 32 bytes, so can add to the structure later w/o 
     * needed to add a new version.
     */
    NvU8                              rsvd[32];

    /*!
     * Union of type-specific data. Interpreted based on 
     * \ref devClass value.
     */
    union
    {
        /*!
         * THERMAL_DEVICE_CLASS
         */        
        NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C_ADM1032 adm1032;
        NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C_MAX6649 max6649;
        NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C_TMP411  tmp411;
        NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C_ADT7461 adt7461;

        /*!
         * Reserve 16 bytes, so can add to the structure later w/o needed 
         * to add a new version.
         */
        NvU8 rsvd[16];
    } data;
} NV_GPU_THERMAL_THERM_DEVICE_INFO_V1;

/*!
 * Used in \ref NvAPI_GPU_ThermDeviceGetInfo.
 *
 * Describes the set of Therm Device which are controlling GPU.
 */
typedef struct _NV_GPU_THERMAL_THERM_DEVICE_INFO_PARAMS_V1
{
    /*!
     * Version of structure. Must always be first.
     */
    NvU32 version;

    /*!
     * Mask of THERM_DEVICE entries specified on this GPU.
     */
    NvU32 deviceMask;

    /*!
     * Reserve 32 bytes, so can add to the structure later w/o 
     * needed to add a new version.
     */
    NvU8 rsvd[32];

    /*!
     * Array of THERM_DEVICE entries.  Has valid indexes corresponding to
     * the bits set in \ref deviceMask.
     */
    NV_GPU_THERMAL_THERM_DEVICE_INFO_V1
        device[NV_GPU_THERMAL_THERM_DEVICE_MAX_V1];
} NV_GPU_THERMAL_THERM_DEVICE_INFO_PARAMS_V1;

#define NV_GPU_THERMAL_THERM_DEVICE_INFO_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_THERMAL_THERM_DEVICE_INFO_PARAMS_V1,1)
#define NV_GPU_THERMAL_THERM_DEVICE_INFO_PARAMS_VER   NV_GPU_THERMAL_THERM_DEVICE_INFO_PARAMS_VER_1

typedef NV_GPU_THERMAL_THERM_DEVICE_INFO_PARAMS_V1    NV_GPU_THERMAL_THERM_DEVICE_INFO_PARAMS;

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    NvAPI_GPU_ThermDeviceGetInfo()
//
//! DESCRIPTION: Retrieves information about the THERM_DEVICE support on the
//!              GPU.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 331
//!
//! \param [in]  hPhysicalGPU   GPU selection
//! \param [out] pThermDeviceInfo Structure containing the description of THERM_DEVICEs.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_ThermDeviceGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_THERMAL_THERM_DEVICE_INFO_PARAMS *pThermDeviceInfo);

//! \ingroup gputhermal
//! @{

#define NV_GPU_THERMAL_THERM_CHANNEL_TYPE_MAX_TYPE_V1       0x05

/*!
 * Enumeration of Thermal Channel Classes
 */
typedef enum _NV_GPU_THERMAL_CHANNEL_CLASS
{
    NV_GPU_THERMAL_THERM_CHANNEL_CLASS_INVALID = 0x00,
    NV_GPU_THERMAL_THERM_CHANNEL_CLASS_DEVICE
} NV_GPU_THERMAL_THERM_CHANNEL_CLASS;

/*!
 * Enumeration of Thernmal Channel. Unique identifiers for different Thermal
 * Channel being enforced on the GPU.
 */
typedef enum _NV_GPU_THERMAL_THERM_CHANNEL_TYPE
{
    NV_GPU_THERMAL_THERM_CHANNEL_TYPE_GPU_AVG = 0x00,
    NV_GPU_THERMAL_THERM_CHANNEL_TYPE_GPU_MAX,
    NV_GPU_THERMAL_THERM_CHANNEL_TYPE_BOARD,
    NV_GPU_THERMAL_THERM_CHANNEL_TYPE_MEMORY,
    NV_GPU_THERMAL_THERM_CHANNEL_TYPE_PWR_SUPPLY
} NV_GPU_THERMAL_THERM_CHANNEL_TYPE;

/*!
 * Enumeration of Channel's Relative Location.
 */
typedef enum _NV_GPU_THERMAL_THERM_CHANNEL_REL_LOC
{
    NV_GPU_THERMAL_THERM_CHANNEL_REL_LOC_INT = 0x00,
    NV_GPU_THERMAL_THERM_CHANNEL_REL_LOC_EXT
} NV_GPU_THERMAL_THERM_CHANNEL_REL_LOC;

/*!
 * Enumeration of Channel's target GPU.
 */
typedef enum _NV_GPU_THERMAL_THERM_CHANNEL_TGT_GPU
{
    NV_GPU_THERMAL_THERM_CHANNEL_TGT_GPU_0 = 0x00,
    NV_GPU_THERMAL_THERM_CHANNEL_TGT_GPU_1,
    NV_GPU_THERMAL_THERM_CHANNEL_TGT_GPU_2,
    NV_GPU_THERMAL_THERM_CHANNEL_TGT_GPU_3
} NV_GPU_THERMAL_THERM_CHANNEL_TGT_GPU;

/*!
 * Structure representing the attributes specific to THERM_CHANNEL_DEVICE.
 */
typedef struct _NV_GPU_THERMAL_THERM_CHANNEL_INFO_DATA_DEVICE
{
    /*!
     * Index into the Thermal Device Table for the THERM_DEVICE from which this
     * THERM_CHANNEL should query temperature value.
     */
    NvU8    thermDevIdx;

    /*!
     * Provider index to query temperature value.
     */
    NvU8    thermDevProvIdx;
} NV_GPU_THERMAL_THERM_CHANNEL_INFO_DATA_DEVICE;

/*!
 * Used in \ref NV_GPU_THERMAL_THERM_CHANNEL_INFO_PARAMS_V1. Structure of static
 * information describing a THERM_CHANNEL, which specifies a thermal channel to
 * enforce on the GPU.
 */
typedef struct _NV_GPU_THERMAL_THERM_CHANNEL_INFO_V1
{
    /*!
     * Thermal Channel class.
     */
    NV_GPU_THERMAL_THERM_CHANNEL_CLASS   chClass;

    /*!
     * Thermal Channel type.
     */
    NV_GPU_THERMAL_THERM_CHANNEL_TYPE    chType;

    /*!
     * Thermal Channel type.
     */
    NV_GPU_THERMAL_THERM_CHANNEL_REL_LOC relLoc;

    /*!
     * Thermal Channel type.
     */
    NV_GPU_THERMAL_THERM_CHANNEL_TGT_GPU tgtGPU;

    /*!
     * Temperature scaling, this value is in SFXP24_8 format.
     */
    NvS32                                scaling;

    /*!
     * Temperature offset, this value is in SFXP24_8 format.
     */
    NvS32                                offset;

    /*!
     * Minimum temperature for a channel, this value is in SFXP24_8 format.
     */ 
    NvS32                                minTemp;

    /*!
     * Maximum temperature for a channel, this value is in SFXP24_8 format.
     */
    NvS32                                maxTemp;

    /*!
     * Temp sim capability of the channel.
     */
    NvU8                                 bIsTempSimSupported;

    /*!
     * @ref NV2080_CTRL_THERMAL_THERM_CHANNEL_FLAGS_CHANNEL_<xyz>.
     */
    NvU8                                 flags;

    /*!
     * Reserve 32 bytes, so can add to the structure later w/o 
     * needed to add a new version.
     */
    NvU8                                 rsvd[32];

    /*!
     * Union of type-specific data. Interpreted based on 
     * \ref chClass value.
     */
    union
    {
        /*!
         * DEVICE class data
         */
        NV_GPU_THERMAL_THERM_CHANNEL_INFO_DATA_DEVICE device;

        /*!
        * Reserve 16 bytes, so can add to the structure later w/o needed 
        * to add a new version.
        */
        NvU8 rsvd[16];
    } data;
} NV_GPU_THERMAL_THERM_CHANNEL_INFO_V1;

/*!
 * Used in \ref NvAPI_GPU_ThermChannelGetInfo.
 *
 * Describes the set of Therm Channel which are controlling GPU channel.
 */
typedef struct _NV_GPU_THERMAL_THERM_CHANNEL_INFO_PARAMS_V1
{
    /*!
     * Version of structure. Must always be first.
     */
    NvU32 version;

    /*!
     * Mask of THERM_CHANNEL entries specified on this GPU.
     */
    NvU32 channelMask;

    /*!
     * Reserve 32 bytes, so can add to the structure later w/o 
     * needed to add a new version.
     */
    NvU8 rsvd[32];

    /*!
     * Array of THERM_CHANNEL entries.  Has valid indexes corresponding to
     * the bits set in \ref channelMask.
     */
    NV_GPU_THERMAL_THERM_CHANNEL_INFO_V1
        channel[NV_GPU_THERMAL_THERM_CHANNEL_TYPE_MAX_TYPE_V1];
} NV_GPU_THERMAL_THERM_CHANNEL_INFO_PARAMS_V1;

#define NV_GPU_THERMAL_THERM_CHANNEL_INFO_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_THERMAL_THERM_CHANNEL_INFO_PARAMS_V1,1)
#define NV_GPU_THERMAL_THERM_CHANNEL_INFO_PARAMS_VER   NV_GPU_THERMAL_THERM_CHANNEL_INFO_PARAMS_VER_1

typedef NV_GPU_THERMAL_THERM_CHANNEL_INFO_PARAMS_V1    NV_GPU_THERMAL_THERM_CHANNEL_INFO_PARAMS;

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    NvAPI_GPU_ThermChannelGetInfo()
//
//! DESCRIPTION: Retrieves information about the THERM_CHANNEL support on the
//!              GPU.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 331
//!
//! \param [in]  hPhysicalGPU   GPU selection
//! \param [out] pThermChannelInfo Structure containing the description of THERM_CHANNELs.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_ThermChannelGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_THERMAL_THERM_CHANNEL_INFO_PARAMS *pThermChannelInfo);

//! \ingroup gputhermal
//! @{

/*!
 * Used in \ref NV_GPU_THERMAL_THERM_CHANNEL_STATUS_PARAMS_V1. Structure  
 * representing the dynamic state of THERM_CHANNEL.
 */
typedef struct _NV_GPU_THERMAL_THERM_CHANNEL_STATUS_V1
{
    /*!
     * Current temperature of the channel, this value is in SFXP24_8 format.
     */
    NvS32   currentTemp;
} NV_GPU_THERMAL_THERM_CHANNEL_STATUS_V1;

/*!
 * Used in \ref NvAPI_GPU_ThermChannelGetStatus.
 *
 * Describes/specifies the current status of Therm Channel which
 * are controlling GPU channel.
 */
typedef struct _NV_GPU_THERMAL_THERM_CHANNEL_STATUS_PARAMS_V1
{
    /*!
     * Version of structure. Must always be first.
     */
    NvU32 version;

    /*!
     * Mask of THERM_CHANNEL entries requested by the client.
     */
    NvU32 channelMask;

    /*!
     * Reserve 32 bytes, so can add to the structure later w/o needed 
     * to add a new version.
     */
    NvU8  rsvd[32];

    /*!
     * Array of THERM_CHANNEL entries. Has valid indexes corresponding to
     * the bits set in \ref channelMask.
     */
    NV_GPU_THERMAL_THERM_CHANNEL_STATUS_V1
        channel[NV_GPU_THERMAL_THERM_CHANNEL_TYPE_MAX_TYPE_V1];
} NV_GPU_THERMAL_THERM_CHANNEL_STATUS_PARAMS_V1;

#define NV_GPU_THERMAL_THERM_CHANNEL_STATUS_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_THERMAL_THERM_CHANNEL_STATUS_PARAMS_V1,1)
#define NV_GPU_THERMAL_THERM_CHANNEL_STATUS_PARAMS_VER   NV_GPU_THERMAL_THERM_CHANNEL_STATUS_PARAMS_VER_1

typedef NV_GPU_THERMAL_THERM_CHANNEL_STATUS_PARAMS_V1    NV_GPU_THERMAL_THERM_CHANNEL_STATUS_PARAMS;

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    NvAPI_GPU_ThermChannelGetStatus()
//
//! DESCRIPTION:     Retrieves the current dynamic state of a set of THERM_CHANNEL
//!                  entries on the GPU.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version:  331
//!
//! \param [in]      hPhysicalGPU       GPU selection
//! \param [in/out]  pThermChannelStatus Structure containing the state of a set of THERM_CHANNELs.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_ThermChannelGetStatus(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_THERMAL_THERM_CHANNEL_STATUS_PARAMS *pThermChannelStatus);

//! \ingroup gputhermal
//! @{

/*!
 * Used in \ref NV_GPU_THERMAL_THERM_CHANNEL_CONTROL_PARAMS_V1.
 * Structure repsenting the control/channel parameters of a 
 * THERM_CHANNEL entry.
 */
typedef struct _NV_GPU_THERMAL_THERM_CHANNEL_CONTROL_V1
{
    /*!
     * Reflects the state of current temperature override.
     */
    NvU8    bTempSimEnable;

    /*!
     * Override the current temperature.
     * Applicable only when @ref bTempSimEnable == NV_TRUE.
     * This value is in SFXP24_8 format.
     */
    NvS32   targetTemp;

    /*!
     * Reserve 32 bytes, so can add to the structure later w/o needed to add a new version
     */
    NvU8    rsvd[32];

} NV_GPU_THERMAL_THERM_CHANNEL_CONTROL_V1;

/*!
 * Used in \ref NvAPI_GPU_ThermChannelGetControl/NvAPI_GPU_ThermChannelSetControl. 
 * Structure representing the control/channel parameters associated with a  
 * set of THERM_CHANNEL entries in the GPU's THERM_CHANNEL.
 */
typedef struct _NV_GPU_THERMAL_THERM_CHANNEL_CONTROL_PARAMS_V1
{
    /*!
     * Version of structure. Must always be first.
     */
    NvU32   version;

     /*!
     * Mask of THERM_CHANNEL entries requested by the client.
     */
    NvU32   channelMask;

    /*!
     * Reserve 32 bytes, so can add to the structure later w/o needed 
     * to add a new version.
     */
    NvU8    rsvd[32];

    /*!
     * Array of THERM_CHANNEL entries.  Has valid indexes corresponding to
     * the bits set in \ref channelMask.
     */
    NV_GPU_THERMAL_THERM_CHANNEL_CONTROL_V1
        channel[NV_GPU_THERMAL_THERM_CHANNEL_TYPE_MAX_TYPE_V1];
} NV_GPU_THERMAL_THERM_CHANNEL_CONTROL_PARAMS_V1;

#define NV_GPU_THERMAL_THERM_CHANNEL_CONTROL_PARAMS_VER_1  MAKE_NVAPI_VERSION(NV_GPU_THERMAL_THERM_CHANNEL_CONTROL_PARAMS_V1,1)
#define NV_GPU_THERMAL_THERM_CHANNEL_CONTROL_PARAMS_VER    NV_GPU_THERMAL_THERM_CHANNEL_CONTROL_PARAMS_VER_1

typedef NV_GPU_THERMAL_THERM_CHANNEL_CONTROL_PARAMS_V1     NV_GPU_THERMAL_THERM_CHANNEL_CONTROL_PARAMS;

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    NvAPI_GPU_ThermChannelGetControl()
//
//! DESCRIPTION:     This function retrieves the current control/channel of a set
//!                  of THERM_CHANNEL entries in the RM's THERM_CHANNEL
//!                  functionality.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version:  331
//!
//! \param [in]      hPhysicalGPU    GPU selection
//! \param [in/out]  pThermChannelControl
//!     Structure containing the current control/channel of a set of
//!     THERM_CHANNEL entries.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_ThermChannelGetControl(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_THERMAL_THERM_CHANNEL_CONTROL_PARAMS *pThermChannelControl);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    NvAPI_GPU_ThermChannelSetControl()
//
//! DESCRIPTION:     This function requests the control/channel of a set
//!                  of THERM_CHANNEL entries in the RM's THERM_CHANNEL
//!                  functionality.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Version:  331
//!
//! \param [in]      hPhysicalGPU    GPU selection
//! \param [in]      pThermChannelControl
//!     Structure containing the requested control/channel of a set of
//!     THERM_CHANNEL entries.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_ThermChannelSetControl(__in NvPhysicalGpuHandle hPhysicalGpu, __in NV_GPU_THERMAL_THERM_CHANNEL_CONTROL_PARAMS *pThermChannelControl);



#define NVAPI_PMGR_VOLTAGE_REQUEST_CLIENT_PSTATE                      0x00
#define NVAPI_PMGR_VOLTAGE_REQUEST_CLIENT_GPC2CLK                     0x01
#define NVAPI_PMGR_VOLTAGE_REQUEST_CLIENT_PEX                         0x02
#define NVAPI_PMGR_VOLTAGE_REQUEST_CLIENT_DP_HBR2_WAR_SOR0            0x03
#define NVAPI_PMGR_VOLTAGE_REQUEST_CLIENT_DP_HBR2_WAR_SOR1            0x04
#define NVAPI_PMGR_VOLTAGE_REQUEST_CLIENT_DP_HBR2_WAR_SOR2            0x05
#define NVAPI_PMGR_VOLTAGE_REQUEST_CLIENT_DP_HBR2_WAR_SOR3            0x06
#define NVAPI_PMGR_VOLTAGE_REQUEST_CLIENT_DISPCLK                     0x07
#define NVAPI_PMGR_VOLTAGE_REQUEST_CLIENT_PIXELCLK                    0x08
#define NVAPI_PMGR_VOLTAGE_REQUEST_CLIENT_DEBUG                       0x09
#define NVAPI_PMGR_VOLTAGE_REQUEST_CLIENT_EXISTING                    0xFF

#define NVAPI_PMGR_VOLTAGE_REQUEST_CLIENT_NUM_CLIENTS_V1              (NVAPI_PMGR_VOLTAGE_REQUEST_CLIENT_DP_HBR2_WAR_SOR3 + 1)
#define NVAPI_PMGR_VOLTAGE_REQUEST_CLIENT_NUM_CLIENTS_V2              (NVAPI_PMGR_VOLTAGE_REQUEST_CLIENT_DEBUG + 1)

#define NVAPI_PMGR_VOLTAGE_REQUEST_CLIENT_NUM_CLIENTS                 NVAPI_PMGR_VOLTAGE_REQUEST_CLIENT_NUM_CLIENTS_V2


typedef struct _NV_GPU_PMGR_VOLTAGE_REQUEST_ARBITER_DATA_V1
{
    NvU32 version;

    NvS32 globalVoltageOffsetuV;  //!< Global voltage offset to be applied to final arbitrated target voltage.
                                  //!< This offset will be applied to the output of all clients' requests to the arbiter. 
                                  //!< This alters the value of the final arbitrated voltage.
    NvS32 clientVoltageOffsetsuV[NVAPI_PMGR_VOLTAGE_REQUEST_CLIENT_NUM_CLIENTS_V1];
                                  //!< Array of voltage offsets per client, to be applied per client target voltage in uV. 
                                  //!< Each client gets its offset added to the output of all of its requests to the arbiter. 
                                  //!< This alters the value of the target voltage of only that client for which it is specified. 
}NV_GPU_PMGR_VOLTAGE_REQUEST_ARBITER_DATA_V1;

typedef struct _NV_GPU_PMGR_VOLTAGE_REQUEST_ARBITER_DATA_V2
{
    NvU32 version;

    NvS32 globalVoltageOffsetuV;  //!< Global voltage offset to be applied to final arbitrated target voltage.
                                  //!< This offset will be applied to the output of all clients' requests to the arbiter. 
                                  //!< This alters the value of the final arbitrated voltage.
    NvS32 clientVoltageOffsetsuV[NVAPI_PMGR_VOLTAGE_REQUEST_CLIENT_NUM_CLIENTS_V2];
                                  //!< Array of voltage offsets per client, to be applied per client target voltage in uV. 
                                  //!< Each client gets its offset added to the output of all of its requests to the arbiter. 
                                  //!< This alters the value of the target voltage of only that client for which it is specified. 
}NV_GPU_PMGR_VOLTAGE_REQUEST_ARBITER_DATA_V2;

#define NV_GPU_PMGR_VOLTAGE_REQUEST_ARBITER_DATA_VER1     MAKE_NVAPI_VERSION(NV_GPU_PMGR_VOLTAGE_REQUEST_ARBITER_DATA_V1, 1)
#define NV_GPU_PMGR_VOLTAGE_REQUEST_ARBITER_DATA_VER2     MAKE_NVAPI_VERSION(NV_GPU_PMGR_VOLTAGE_REQUEST_ARBITER_DATA_V2, 2)
#define NV_GPU_PMGR_VOLTAGE_REQUEST_ARBITER_DATA_VER      NV_GPU_PMGR_VOLTAGE_REQUEST_ARBITER_DATA_VER2

typedef NV_GPU_PMGR_VOLTAGE_REQUEST_ARBITER_DATA_V2       NV_GPU_PMGR_VOLTAGE_REQUEST_ARBITER_DATA;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    NvAPI_GPU_GetPMGRVoltageRequestArbiterValues()
//
//! DESCRIPTION:     This function retrieves the voltage request arbiter values.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Version:  340
//!
//! \param [in]      hPhysicalGPU                 GPU selection
//! \param [in]      pVoltageRequestArbiterData   Pointer to the structure containing the data.
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status.  If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetPMGRVoltageRequestArbiterValues(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_PMGR_VOLTAGE_REQUEST_ARBITER_DATA *pVoltageRequestArbiterData);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    NvAPI_GPU_SetPMGRVoltageRequestArbiterValues()
//
//! DESCRIPTION:     This function sets the voltage request arbiter values.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Version:  340
//!
//! \param [in]      hPhysicalGPU                 GPU selection
//! \param [in]      pVoltageRequestArbiterData   Pointer to the structure containing the data.
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status.  If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup gpu
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetPMGRVoltageRequestArbiterValues(__in NvPhysicalGpuHandle hPhysicalGpu, __in NV_GPU_PMGR_VOLTAGE_REQUEST_ARBITER_DATA *pVoltageRequestArbiterData);


typedef enum _NV_VBIOS_SOURCE_TYPE
{
    NV_VBIOS_SRC_TYPE_UNSET                           = 0x00,
    NV_VBIOS_SRC_TYPE_NOT_FOUND                       = 0x01,
    NV_VBIOS_SRC_TYPE_REGISTRY                        = 0x02,
    NV_VBIOS_SRC_TYPE_SW                              = 0x03,
    NV_VBIOS_SRC_TYPE_GPUMGR_CACHE                    = 0x04,
    NV_VBIOS_SRC_TYPE_INSTANCE_MEMORY                 = 0x05,
    NV_VBIOS_SRC_TYPE_ACPI_ROM                        = 0x06,
    NV_VBIOS_SRC_TYPE_ROM                             = 0x07,
    NV_VBIOS_SRC_TYPE_SBIOS                           = 0x08
} NV_VBIOS_SOURCE_TYPE;

#define NV_BIOS_MAX_SUBIMAGES                           0x08

typedef struct _NV_VBIOS_SOURCE_INFO
{
    NvU8    status;

    NvU8    nImages;
    NvU8    bLastImage[NV_BIOS_MAX_SUBIMAGES];
    NvU32   offset[NV_BIOS_MAX_SUBIMAGES];
    NvU32   imageLength[NV_BIOS_MAX_SUBIMAGES];

    NvU32   superImageLength;
    NvU32   romSig;
    NvU32   pciDataSig;
} NV_VBIOS_SOURCE_INFO;

typedef struct _NV_VBIOS_EXTRACTION_INFO_V1
{
    NvU32   version;            //!< Structure version

    NV_VBIOS_SOURCE_TYPE      source;              //!< Source for the VBIOS image.
    NV_VBIOS_SOURCE_INFO      srcInfoReg;          //!< State for the registry.
    NV_VBIOS_SOURCE_INFO      srcInfoCachedVbios;  //!< State for the VBIOS cache
    NV_VBIOS_SOURCE_INFO      srcInfoInstanceMem;  //!< State for instance memory
    NV_VBIOS_SOURCE_INFO      srcInfoRom;          //!< State for the ROM.
    NV_VBIOS_SOURCE_INFO      srcInfoAcpiRom;      //!< State for the ACPI ROM.
    NV_VBIOS_SOURCE_INFO      srcInfoSbios;        //!< State for the SBIOS.
    NV_VBIOS_INFO_STATUS      statusExpansionRom;  //!< State of extraction for the expansion ROM.
} NV_VBIOS_EXTRACTION_INFO_V1;

typedef NV_VBIOS_EXTRACTION_INFO_V1    NV_VBIOS_EXTRACTION_INFO;

#define NV_VBIOS_EXTRACTION_INFO_VER1  MAKE_NVAPI_VERSION(NV_VBIOS_EXTRACTION_INFO_V1,1)
#define NV_VBIOS_EXTRACTION_INFO_VER   NV_VBIOS_EXTRACTION_INFO_VER1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetVbiosExtractionInfo
//
//!  This function returns the VBIOS extraction information from this GPU.
//!
//! \param [in]      hPhysicalGPU                GPU selection
//! \param [out]     pNvapiVbiosExtractionInfo   VBIOS Extraction Info object retrieved from RM
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 340
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetVbiosExtractionInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_VBIOS_EXTRACTION_INFO *pNvapiVbiosExtractionInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetVbiosStatusString
//
//! DESCRIPTION: Converts an VBIOS status code into a string
//!
//! \param [in]      status (IN ) - A valid NV_VBIOS_INFO_STATUS status code
//! \param [out]     szDesc (OUT) - The corresponding error code string
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 340
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetVbiosStatusString(__in NV_VBIOS_INFO_STATUS status, __out NvAPI_ShortString szDesc);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetRasterBackendCount
//
//! This function retrieves the number of raster backend units (aka ROPs) in the GPU.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! TCC_SUPPORTED
//!
//! \since Release: 349
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetRasterBackendCount(NvPhysicalGpuHandle hPhysicalGpu,NvU32 *pCount);

//! \ingroup gpu
//! Hash size.
#define NV_ECID_HASH_SIZE_IN_BYTES                    (32)

//! \ingroup gpu
//! Signed buffer size
#define NV_SIGNED_ECID_RSA_1024_BUF_SIZE              (0x00000080) //!< 128 Bytes
#define NV_SIGNED_ECID_RSA_2048_BUF_SIZE              (0x00000100) //!< 256 Bytes

//! \ingroup gpu
//! Signing algorithms
typedef enum
{ 
    NV_ECID_SIGNALGO_RSA_1024 = 1,
    NV_ECID_SIGNALGO_RSA_2048 = 2
} NV_ECID_SIGNALGO;

//! \ingroup gpu
//! GPU ECID data.
typedef struct _NV_GPU_ECID
{
    NvU8                ecidSha2Hash[NV_ECID_HASH_SIZE_IN_BYTES]; //! SHA hashed ECID value.
} NV_GPU_ECID;

//! GPU DEVICE INFO data.
typedef struct _NV_GPU_DEVICE_INFO
{
    NvU16       vendorId;        //!< GPU Vendor identifier
    NvU16       deviceId;        //!< GPU Device Id
    NvU16       subSystemId;     //!< GPU SubSystem identifier
    NvU16       subVendorId;     //!< GPU SubVendor identifier
    NvU16       revisionId;      //!< GPU Revison Number
    NvU16       chipId;          //!< GPU Chip information
} NV_GPU_DEVICE_INFO;

//! \ingroup gpu
//! Input matrix to the RSA signing API.
typedef struct _NV_SIGN_GPUID_INPUT
{
    NvU8                    Nonce[16];       //!< 16 Byte random number to be passed by the client.
    NvU32                   ProgramId;       //!< 4 Byte Program Id to be passed by the client.
    NvU32                   SessionId;       //!< 4 Byte Session Id to be passed by the client.
    NV_ECID_SIGNALGO        SignAlgo;        //!< The algo to be used for signing of payload.
}NV_SIGN_GPUID_INPUT;

//! \ingroup gpu
//! Encrypted public key info
typedef struct _NV_ENCRYPTED_KEY_INFO
{
    NvU8                    *encryptedKey;         //!< The encrypted public key to be send from the server.
    NvU32                   encryptedKeySize;      //!< Size of the encrypted public key buffer.
} NV_ENCRYPTED_KEY_INFO;

typedef struct _NV_SIGNED_GPUID_V1
{
    NvU32					version;			//!< IN - Structure version
    NV_SIGN_GPUID_INPUT     input;				//!< IN

    // The reset of the data is OUT
    NV_GPU_ECID				ecid;	            //!< Actual ECID data.
    NvU32                   uCodeVersion;       //!< Version of the uCode used.
    NvU32                   reserved;           //!< Reserved.

    // The signedPayLoad will depend on the input algorithm (input.SignAlgo) value
    union
    {
        NvU8	RSA_1024_BUF[NV_SIGNED_ECID_RSA_1024_BUF_SIZE];	//!< Valid if input.SignAlgo == NVAPI_GFE_SIGN_ECID_SIGNALGO_RSA_1024
        NvU8	RSA_2048_BUF[NV_SIGNED_ECID_RSA_2048_BUF_SIZE];	//!< Valid if input.SignAlgo == NVAPI_GFE_SIGN_ECID_SIGNALGO_RSA_2048
    } signedPayload;
    // Do not add anything here. Any additions to the structures, should be added before the union
}NV_SIGNED_GPUID_V1;

typedef struct _NV_SIGNED_GPUID_V2
{
    NvU32                   version;            //!< IN - Structure version
    NV_SIGN_GPUID_INPUT     input;              //!< IN

    // The rest of the data is OUT
    NV_GPU_ECID             ecid;               //!< Actual ECID data.
    NV_GPU_DEVICE_INFO      deviceInfo;         //!< Actual Device Info data.
    NvU32                   uCodeVersion;       //!< Version of the uCode used.

    // The signedPayLoad will depend on the input algorithm (input.SignAlgo) value
    union
    {
        NvU8	RSA_1024_BUF[NV_SIGNED_ECID_RSA_1024_BUF_SIZE];	//!< Valid if input.SignAlgo == NVAPI_GFE_SIGN_ECID_SIGNALGO_RSA_1024
        NvU8	RSA_2048_BUF[NV_SIGNED_ECID_RSA_2048_BUF_SIZE];	//!< Valid if input.SignAlgo == NVAPI_GFE_SIGN_ECID_SIGNALGO_RSA_2048
    } signedPayload;
    // Do not add anything here. Any additions to the structures, should be added before the union
}NV_SIGNED_GPUID_V2;

typedef NV_SIGNED_GPUID_V2 NV_SIGNED_GPUID;

#define NV_SIGNED_GPUID_VER1   MAKE_NVAPI_VERSION(NV_SIGNED_GPUID_V1, 1)
#define NV_SIGNED_GPUID_VER2   MAKE_NVAPI_VERSION(NV_SIGNED_GPUID_V2, 2)
#define NV_SIGNED_GPUID_VER    NV_SIGNED_GPUID_VER2

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetSignedGPUID
//
//!   DESCRIPTION:   This function call returns the GPU's ECID hash value, Device info and a signed payload. 
//!                  
//!   How to use: 
//!   A caller to the API is required to pass in the following information:
//!	    - A handle to the GPU to work on
//!     - A pointer NV_ENCRYPTED_KEY_INFO that is an encrypted key (usually the public key of the server). 
//!     - pSignedGpuId->input needs to be filled in with the following data
//!          - 16 byte Nonce
//!          - 4 byte Program ID
//!          - 4 Byte Session ID
//!          - A value defining the signing algorithm of the encrypted private key
//!               
//!   If the API returns success (NVAPI_OK), the following data will be retuned in pSignedGpuId
//!      - hashed ecid of the GPU
//!      - UCode version
//!      - Device Information of the GPU (only in NV_SIGNED_GPUID_V2)
//!      - the signed payload
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      hPhysicalGpu       The GPU handle for which the ECID is to be retrieved.
//! \param [in]      pKeyInfo           Pointer to NV_ENCRYPTED_KEY_INFO structure containing the server's encrypted plublic key.
//! \param [in/out]  pSignedGpuId       Pointer to NV_SIGNED_GPUID. The version and input members need to be filled in. The rest of the members are out params.
//!
//! \return This API can return any of the error codes enumerated in NvAPI_Status. If there are return error codes with specific
//! meaning for this API, they are listed below.
//!
//!	NVAPI_ECID_SIGN_ALGO_UNSUPPORTED	: The specified signing algorithm is not supported. Either an incorrect value was entered or 
//!										  the current installed driver/hardware does not support the input value.
//!	NVAPI_ECID_KEY_VERIFICATION_FAILED	: The encrypted public key verification has failed.
//!		 
//! \ingroup gpu
/////////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetSignedGPUID(__in NvPhysicalGpuHandle hPhysicalGpu, 
                                          __in NV_ENCRYPTED_KEY_INFO *pKeyInfo, 
                                          __inout NV_SIGNED_GPUID *pSignedGpuId);

//! \ingroup gputhermal
//! @{

/*!
 * Used in \ref NV_GPU_THERMAL_HWFS_EVENT_SETTINGS_PARAMS_V1. 
 * Structure for defining a slowdown amount ratio of a numerator and denominator.
 * RM will try to match this ratio to the closest possible supported HW
 * factor whose slowdown is greater than or equal to this ratio.
 */
typedef struct _NV_GPU_SLOWDOWN_AMOUNT
{
    /*!
     * Numerator of the ratio
     */
    NvU32 num;

    /*!
     * Denominator of the ratio.
     */
    NvU32 denom;
} NV_GPU_THERMAL_SLOWDOWN_AMOUNT;

/*!
 * Used in \ref NV_GPU_THERMAL_HWFS_EVENT_SETTINGS_PARAMS_V1
 *
 * Describes all HW failsafe events supported by the
 * NV2080_CTRL_CMD_THERMAL_HWFS_EVENT_SETTINGS_GET & _SET commands
 */
 typedef enum _NV_GPU_THERMAL_HWFS_EVENT
 {
    NV_GPU_THERMAL_HWFS_EVENT_EXT_OVERT,
    NV_GPU_THERMAL_HWFS_EVENT_EXT_ALERT,
    NV_GPU_THERMAL_HWFS_EVENT_EXT_POWER,
    NV_GPU_THERMAL_HWFS_EVENT_OVERT,
    NV_GPU_THERMAL_HWFS_EVENT_ALERT_0H,
    NV_GPU_THERMAL_HWFS_EVENT_ALERT_1H,
    NV_GPU_THERMAL_HWFS_EVENT_ALERT_2H,
    NV_GPU_THERMAL_HWFS_EVENT_ALERT_3H,
    NV_GPU_THERMAL_HWFS_EVENT_ALERT_4H,
    NV_GPU_THERMAL_HWFS_EVENT_ALERT_NEG1H,
    NV_GPU_THERMAL_HWFS_EVENT_THERMAL_0,
    NV_GPU_THERMAL_HWFS_EVENT_THERMAL_1,
    NV_GPU_THERMAL_HWFS_EVENT_THERMAL_2,
    NV_GPU_THERMAL_HWFS_EVENT_THERMAL_3,
    NV_GPU_THERMAL_HWFS_EVENT_THERMAL_4,
    NV_GPU_THERMAL_HWFS_EVENT_THERMAL_5,
    NV_GPU_THERMAL_HWFS_EVENT_THERMAL_6,
    NV_GPU_THERMAL_HWFS_EVENT_THERMAL_7,
    NV_GPU_THERMAL_HWFS_EVENT_THERMAL_8,
    NV_GPU_THERMAL_HWFS_EVENT_THERMAL_9,
    NV_GPU_THERMAL_HWFS_EVENT_THERMAL_10,
    NV_GPU_THERMAL_HWFS_EVENT_THERMAL_11,
    NV_GPU_THERMAL_HWFS_EVENT_DEDICATED_OVERT,
    NV_GPU_THERMAL_HWFS_EVENT_COUNT,
 } NV_GPU_THERMAL_HWFS_EVENT_ID;

/*!
 * Used in \ref NvAPI_GPU_ThermalHwFsGetInfo.
 *
 * Describes the settings of the HW failsafe event.
 */
typedef struct _NV_GPU_THERMAL_HWFS_EVENT_SETTINGS_PARAMS_V1
{
    /*!
     * Version of structure. Must always be first.
     */
    NvU32                          version;

    /*!
     * Reserve bytes, so can add to the structure later w/o needed to add a new version.
     */
    NvU8                           rsvd[32];

    /*!
     * HWFS event's ID as NV2080_CTRL_CMD_THERMAL_HWFS_EVENT_ID_<xyz>
     */
    NV_GPU_THERMAL_HWFS_EVENT_ID   eventId;

    /*!
     * HWFS event's temperatrue threshold (if applicable) in 1/256[C]
     */
    NvS32                          temperature;

    /*!
     * HWFS event's slowdown specified as a fraction (num/denom)
     */
    NV_GPU_THERMAL_SLOWDOWN_AMOUNT slowdown;
} NV_GPU_THERMAL_HWFS_EVENT_SETTINGS_PARAMS_V1;

#define NV_GPU_THERMAL_HWFS_EVENT_SETTINGS_PARAMS_VER1   MAKE_NVAPI_VERSION(NV_GPU_THERMAL_HWFS_EVENT_SETTINGS_PARAMS_V1,1)
#define NV_GPU_THERMAL_HWFS_EVENT_SETTINGS_PARAMS_VER     NV_GPU_THERMAL_HWFS_EVENT_SETTINGS_PARAMS_VER1

typedef NV_GPU_THERMAL_HWFS_EVENT_SETTINGS_PARAMS_V1      NV_GPU_THERMAL_HWFS_EVENT_SETTINGS_PARAMS;

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    NvAPI_GPU_ThermalHwFsGetInfo()
//
//! DESCRIPTION: Retrieves information about the slowdown and shutdown points
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  hPhysicalGPU            GPU selection
//! \param [out] pthermalHwFsEventInfo   Structure representing the settings 
//!                                      of the HW failsafe event.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_ThermalHwFsGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_THERMAL_HWFS_EVENT_SETTINGS_PARAMS *pthermalHwFsEventInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:    NvAPI_GPU_ThermalHwFsSetInfo()
//
//! DESCRIPTION: Sets information about the slowdown and shutdown points
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  hPhysicalGPU            GPU selection
//! \param [out] pthermalHwFsEventInfo   Structure representing the settings 
//!                                      of the HW failsafe event.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_ThermalHwFsSetInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_THERMAL_HWFS_EVENT_SETTINGS_PARAMS *pthermalHwFsEventInfo);


//! \addtogroup gputhermal
//! @{

/*!
 * Enumeration of Fan Policies.  Unique identifiers for different Fan
 * Policies being enforced on the GPU.
 */
typedef enum
{
    NV_GPU_CLIENT_FAN_POLICIES_POLICY_NONE,
    NV_GPU_CLIENT_FAN_POLICIES_POLICY_GPU,
} NV_GPU_CLIENT_FAN_POLICIES_POLICY_ID;

#define NV_GPU_CLIENT_FAN_POLICIES_NUM_POLICIES_MAX    4

typedef struct _NV_GPU_CLIENT_FAN_POLICIES_POLICY_INFO_V1
{
    NvU32                                   version;                       //!< Version of structure. Must always be first.
    NV_GPU_CLIENT_FAN_POLICIES_POLICY_ID    policyId;                      //!< Policy ID. Unique identifier for a policy.
    NvU32                                   fanStopFeatureSupported:1;     //!< Specifies whether the non linear features of Fan are supported or not
    NvU32                                   fanStopFeatureEnableDefault:1; //!< Specifies whether the non linear features of Fan are enabled by default or not
    NvU32                                   reserved               :30;    //!< Bits reserved for future use
} NV_GPU_CLIENT_FAN_POLICIES_POLICY_INFO_V1;

#define NV_GPU_CLIENT_FAN_POLICIES_POLICY_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_FAN_POLICIES_POLICY_INFO_V1,1)
#define NV_GPU_CLIENT_FAN_POLICIES_POLICY_INFO_VER  NV_GPU_CLIENT_FAN_POLICIES_POLICY_INFO_VER1

typedef NV_GPU_CLIENT_FAN_POLICIES_POLICY_INFO_V1   NV_GPU_CLIENT_FAN_POLICIES_POLICY_INFO;


typedef struct _NV_GPU_CLIENT_FAN_POLICIES_INFO_V1
{
    NvU32 version;        //!< Version of structure. Must always be first.
    NvU32 isSupported:1;  //!< Indicates that this GPU support Client Fan Policy Interfaces.
    NvU32 reserved   :31; //!< Bits reserved for future use
    NvU8  numPolicies;    //!< Number of Fan Policies this GPU supports.

    NV_GPU_CLIENT_FAN_POLICIES_POLICY_INFO_V1    policies[NV_GPU_CLIENT_FAN_POLICIES_NUM_POLICIES_MAX];
                          //!< Array of static information for each Fan Policy.  Array has a valid index ranging from 0 to numPolicies - 1.
} NV_GPU_CLIENT_FAN_POLICIES_INFO_V1;

#define NV_GPU_CLIENT_FAN_POLICIES_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_FAN_POLICIES_INFO_V1,1)
#define NV_GPU_CLIENT_FAN_POLICIES_INFO_VER  NV_GPU_CLIENT_FAN_POLICIES_INFO_VER1

typedef NV_GPU_CLIENT_FAN_POLICIES_INFO_V1   NV_GPU_CLIENT_FAN_POLICIES_INFO;

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_ClientFanPoliciesGetInfo
//
//! DESCRIPTION: Accessor for static information describing the public GPU
//!              fan policies
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 343
//!
//! \param [in]  hPhysicalGpu           GPU selection
//! \param [out] pClientFanPoliciesInfo Structure containing the description of the GPU fan policies.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_ClientFanPoliciesGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_CLIENT_FAN_POLICIES_INFO *pClientFanPoliciesInfo);

//! \addtogroup gputhermal
//! @{

typedef struct _NV_GPU_CLIENT_FAN_POLICIES_POLICY_STATUS_V1
{
    NvU32                                   version;                 //!< Version of structure. Must always be first.
    NV_GPU_CLIENT_FAN_POLICIES_POLICY_ID    policyId;                //!< Policy ID. Unique identifier for a policy.
    NvU32                                   fanStopFeatureActive:1;  //!< Whether the fan stop feature isactive
    NvU32                                   reserved            :31; //!< Bits reserved for future use
} NV_GPU_CLIENT_FAN_POLICIES_POLICY_STATUS_V1;

#define NV_GPU_CLIENT_FAN_POLICIES_POLICY_STATUS_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_FAN_POLICIES_POLICY_STATUS_V1,1)
#define NV_GPU_CLIENT_FAN_POLICIES_POLICY_STATUS_VER  NV_GPU_CLIENT_FAN_POLICIES_POLICY_STATUS_VER1

typedef NV_GPU_CLIENT_FAN_POLICIES_POLICY_STATUS_V1   NV_GPU_CLIENT_FAN_POLICIES_POLICY_STATUS;


typedef struct _NV_GPU_CLIENT_FAN_POLICIES_STATUS_V1
{
    NvU32 version;     //!< Version of structure. Must always be first.
    NvU8  numPolicies; //!< Number of Fan Policies this GPU supports.

    NV_GPU_CLIENT_FAN_POLICIES_POLICY_STATUS_V1    policies[NV_GPU_CLIENT_FAN_POLICIES_NUM_POLICIES_MAX];
                       //!< Array of status information for each Fan Policy.  Array has a valid index ranging from 0 to numPolicies - 1.
} NV_GPU_CLIENT_FAN_POLICIES_STATUS_V1;

#define NV_GPU_CLIENT_FAN_POLICIES_STATUS_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_FAN_POLICIES_STATUS_V1,1)
#define NV_GPU_CLIENT_FAN_POLICIES_STATUS_VER  NV_GPU_CLIENT_FAN_POLICIES_STATUS_VER1

typedef NV_GPU_CLIENT_FAN_POLICIES_STATUS_V1   NV_GPU_CLIENT_FAN_POLICIES_STATUS;

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_ClientFanPoliciesGetStatus
//
//! DESCRIPTION: Accessor for  current state of public GPU
//!              fan policies
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 343
//!
//! \param [in]  hPhysicalGpu           GPU selection
//! \param [out] pClientFanPoliciesStatus Structure containing the description of the GPU fan policies.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_ClientFanPoliciesGetStatus(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_CLIENT_FAN_POLICIES_STATUS *pClientFanPoliciesStatus);

//! \addtogroup gputhermal
//! @{

typedef struct _NV_GPU_CLIENT_FAN_POLICIES_POLICY_CONTROL_V1
{
    NvU32                                   version;                 //!< Version of structure. Must always be first.
    NV_GPU_CLIENT_FAN_POLICIES_POLICY_ID    policyId;                //!< Policy ID. Unique identifier for a policy.
    NvU32                                   fanStopFeatureEnable:1;  //!< Specifies whether Fan Stop sub-policy needs to be enabled.
    NvU32                                   reserved            :31; //!< Bits reserved for future use
} NV_GPU_CLIENT_FAN_POLICIES_POLICY_CONTROL_V1;

#define NV_GPU_CLIENT_FAN_POLICIES_POLICY_CONTROL_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_FAN_POLICIES_POLICY_CONTROL_V1,1)
#define NV_GPU_CLIENT_FAN_POLICIES_POLICY_CONTROL_VER  NV_GPU_CLIENT_FAN_POLICIES_POLICY_CONTROL_VER1

typedef NV_GPU_CLIENT_FAN_POLICIES_POLICY_CONTROL_V1   NV_GPU_CLIENT_FAN_POLICIES_POLICY_CONTROL;


typedef struct _NV_GPU_CLIENT_FAN_POLICIES_CONTROL_V1
{
    NvU32 version;       //!< Version of structure. Must always be first.
    NvU8  numPolicies;   //!< Number of Fan Policies this GPU supports.

    NV_GPU_CLIENT_FAN_POLICIES_POLICY_CONTROL_V1    policies[NV_GPU_CLIENT_FAN_POLICIES_NUM_POLICIES_MAX];
                         //!< Array of control information for each Fan Policy.  Array has a valid index ranging from 0 to numPolicies - 1.
} NV_GPU_CLIENT_FAN_POLICIES_CONTROL_V1;

#define NV_GPU_CLIENT_FAN_POLICIES_CONTROL_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_FAN_POLICIES_CONTROL_V1,1)
#define NV_GPU_CLIENT_FAN_POLICIES_CONTROL_VER  NV_GPU_CLIENT_FAN_POLICIES_CONTROL_VER1

typedef NV_GPU_CLIENT_FAN_POLICIES_CONTROL_V1   NV_GPU_CLIENT_FAN_POLICIES_CONTROL;

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_ClientFanPoliciesGetControl
//
//! DESCRIPTION: Accessor for public GPU fan policies
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 343
//!
//! \param [in]  hPhysicalGpu           GPU selection
//! \param [out] pClientFanPoliciesControl Structure containing the description of the GPU fan policies.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_ClientFanPoliciesGetControl(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_CLIENT_FAN_POLICIES_CONTROL *pClientFanPoliciesControl);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_ClientFanPoliciesSetControl
//
//! DESCRIPTION: Mutator for public GPU fan policies
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 343
//!
//! \param [in]  hPhysicalGpu           GPU selection
//! \param [out] pClientFanPoliciesControl Structure containing the description of the GPU fan policies.
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup gputhermal
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_ClientFanPoliciesSetControl(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_CLIENT_FAN_POLICIES_CONTROL *pClientFanPoliciesControl);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_EnumNvidiaDisplayHandle
//
//! This function returns the handle of the NVIDIA display specified by the enum 
//!                index (thisEnum). The client should keep enumerating until it
//!                returns NVAPI_END_ENUMERATION.
//!
//!                Note: Display handles can get invalidated on a modeset, so the calling applications need to
//!                renum the handles after every modeset.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \param [in]  thisEnum      The index of the NVIDIA display.   
//! \param [out] pNvDispHandle Pointer to the NVIDIA display handle.
//!
//! \retval NVAPI_INVALID_ARGUMENT        Either the handle pointer is NULL or enum index too big
//! \retval NVAPI_OK                      Return a valid NvDisplayHandle based on the enum index
//! \retval NVAPI_NVIDIA_DEVICE_NOT_FOUND No NVIDIA device found in the system
//! \retval NVAPI_END_ENUMERATION         No more display device to enumerate
//! \ingroup disphandle
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_EnumNvidiaDisplayHandle(NvU32 thisEnum, NvDisplayHandle *pNvDispHandle);





///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_EnumNvidiaUnAttachedDisplayHandle
//
//! This function returns the handle of the NVIDIA unattached display specified by the enum 
//!                index (thisEnum). The client should keep enumerating until it
//!                returns error.
//!                Note: Display handles can get invalidated on a modeset, so the calling applications need to
//!                renum the handles after every modeset.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \param [in]  thisEnum                  The index of the NVIDIA display.
//! \param [out] pNvUnAttachedDispHandle   Pointer to the NVIDIA display handle of the unattached display.
//!
//! \retval NVAPI_INVALID_ARGUMENT         Either the handle pointer is NULL or enum index too big
//! \retval NVAPI_OK                       Return a valid NvDisplayHandle based on the enum index
//! \retval NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA device found in the system
//! \retval NVAPI_END_ENUMERATION          No more display device to enumerate.
//! \ingroup disphandle
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_EnumNvidiaUnAttachedDisplayHandle(NvU32 thisEnum, NvUnAttachedDisplayHandle *pNvUnAttachedDispHandle);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_CreateDisplayFromUnAttachedDisplay
//
//! This function converts the unattached display handle to an active attached display handle.
//!
//! At least one GPU must be present in the system and running an NVIDIA display driver.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \retval NVAPI_INVALID_ARGUMENT         hNvUnAttachedDisp is not valid or pNvDisplay is NULL.
//! \retval NVAPI_OK                       One or more handles were returned
//! \retval NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_CreateDisplayFromUnAttachedDisplay(NvUnAttachedDisplayHandle hNvUnAttachedDisp, NvDisplayHandle *pNvDisplay);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetAssociatedNVidiaDisplayHandle
//
//!  This function returns the handle of the NVIDIA display that is associated
//!  with the given display "name" (such as "\\.\DISPLAY1").
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \retval NVAPI_INVALID_ARGUMENT         Either argument is NULL
//! \retval NVAPI_OK                      *pNvDispHandle is now valid
//! \retval NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA device maps to that display name
//! \ingroup disphandle
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetAssociatedNvidiaDisplayHandle(const char *szDisplayName, NvDisplayHandle *pNvDispHandle);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DISP_GetAssociatedUnAttachedNvidiaDisplayHandle
//
//!   DESCRIPTION: This function returns the handle of an unattached NVIDIA display that is 
//!                associated with the given display name (such as "\\DISPLAY1"). 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \retval ::NVAPI_INVALID_ARGUMENT          Either argument is NULL.
//! \retval ::NVAPI_OK                       *pNvUnAttachedDispHandle is now valid.
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND   No NVIDIA device maps to that display name.
//!
//! \ingroup disphandle
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_GetAssociatedUnAttachedNvidiaDisplayHandle(const char *szDisplayName, NvUnAttachedDisplayHandle *pNvUnAttachedDispHandle);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetAssociatedNVidiaDisplayName
//
//!  For a given NVIDIA display handle, this function returns a string (such as "\\.\DISPLAY1") to identify the display.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \retval NVAPI_INVALID_ARGUMENT          Either argument is NULL
//! \retval NVAPI_OK                       *pNvDispHandle is now valid
//! \retval NVAPI_NVIDIA_DEVICE_NOT_FOUND   No NVIDIA device maps to that display name
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetAssociatedNvidiaDisplayName(NvDisplayHandle NvDispHandle, NvAPI_ShortString szDisplayName);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetUnAttachedAssociatedDisplayName
//
//!  This function returns the display name given, for example, "\\DISPLAY1", using the unattached NVIDIA display handle
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 95
//!
//! \retval NVAPI_INVALID_ARGUMENT          Either argument is NULL
//! \retval NVAPI_OK                       *pNvDispHandle is now valid
//! \retval NVAPI_NVIDIA_DEVICE_NOT_FOUND   No NVIDIA device maps to that display name
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetUnAttachedAssociatedDisplayName(NvUnAttachedDisplayHandle hNvUnAttachedDisp, NvAPI_ShortString szDisplayName);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_EnableHWCursor
//
//!  This function enables hardware cursor support
//!
//! SUPPORTED OS:  Windows XP
//!
//!  
//!
//! \since Release: 80
//!
//! \return NVAPI_ERROR or NVAPI_OK
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_EnableHWCursor(NvDisplayHandle hNvDisplay);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DisableHWCursor
//
//! This function disables hardware cursor support
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 80
//!
//! \return  NVAPI_ERROR or NVAPI_OK
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DisableHWCursor(NvDisplayHandle hNvDisplay);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetVBlankCounter
//
//!  This function gets the V-blank counter
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \return NVAPI_ERROR or NVAPI_OK
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetVBlankCounter(NvDisplayHandle hNvDisplay, NvU32 *pCounter);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:  NvAPI_SetRefreshRateOverride
//
//!  This function overrides the refresh rate on the given display/outputsMask.
//!  The new refresh rate can be applied right away in this API call or deferred to be applied with the
//!  next OS modeset. The override is good for only one modeset (regardless whether it's deferred or immediate).
//!               
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 80
//!
//!  \param [in] hNvDisplay    The NVIDIA display handle. It can be NVAPI_DEFAULT_HANDLE or a handle
//!                           enumerated from NvAPI_EnumNVidiaDisplayHandle().
//!  \param [in] outputsMask  A set of bits that identify all target outputs which are associated with the NVIDIA 
//!                           display handle to apply the refresh rate override. When SLI is enabled, the
//!                           outputsMask only applies to the GPU that is driving the display output.
//!  \param [in] refreshRate  The override value. "0.0" means cancel the override.
//!  \param [in] bSetDeferred 
//!              - "0": Apply the refresh rate override immediately in this API call.\p
//!              - "1": Apply refresh rate at the next OS modeset.
//!
//!  \retval  NVAPI_INVALID_ARGUMENT hNvDisplay or outputsMask is invalid
//!  \retval  NVAPI_OK               The refresh rate override is correct set
//!  \retval  NVAPI_ERROR            The operation failed
//!  \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetRefreshRateOverride(NvDisplayHandle hNvDisplay, NvU32 outputsMask, float refreshRate, NvU32 bSetDeferred);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetAssociatedDisplayOutputId
//
//! This function gets the active outputId associated with the display handle.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 90
//!
//! \param [in]  hNvDisplay  NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//! \param [out] outputId    The active display output ID associated with the selected display handle hNvDisplay.
//!                          The outputid will have only one bit set. In the case of Clone or Span mode, this will indicate the
//!                          display outputId of the primary display that the GPU is driving. See \ref handles.
//!
//! \retval  NVAPI_OK                      Call successful.
//! \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND No NVIDIA GPU driving a display was found.
//! \retval  NVAPI_EXPECTED_DISPLAY_HANDLE hNvDisplay is not a valid display handle.
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetAssociatedDisplayOutputId(NvDisplayHandle hNvDisplay, NvU32 *pOutputId);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetAssociatedDisplayOutputIdEx
//
//!   DESCRIPTION: This API gets the active outputId associated with the display handle.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]  hNvDisplay   NVIDIA Display selection. It can be ::NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//! \param [out] outputId     The active display output ID associated with the selected display handle hNvDisplay.
//!                           The outputid will have only one bit set. In case of clone or span mode this indicates the display
//!                           outputId of the primary display that the GPU is driving.
//! \param [out] gpuId)       The gpu ID of the physical GPU associated with the selected display handle hNvDisplay.
//!
//! \retval ::NVAPI_OK                       Call successful.
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found.
//! \retval ::NVAPI_EXPECTED_DISPLAY_HANDLE  hNvDisplay is not a valid display handle.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetAssociatedDisplayOutputIdEx(NvDisplayHandle hNvDisplay, NvU32 *pOutputId, NvU32 *pGpuId);







//! \ingroup dispcontrol
//! Used in NvAPI_GetDisplayPortInfo().
typedef struct _NV_DISPLAY_PORT_INFO_V1
{
    NvU32               version;                                  //!< Structure version
    NvU32               dpcd_ver;                                 //!< DPCD version of the monitor
    NV_DP_LINK_RATE     maxLinkRate;                              //!< Maximum supported link rate
    NV_DP_LANE_COUNT    maxLaneCount;                             //!< Maximum supported lane count
    NV_DP_LINK_RATE     curLinkRate;                              //!< Current link rate
    NV_DP_LANE_COUNT    curLaneCount;                             //!< Current lane count
    NV_DP_COLOR_FORMAT  colorFormat;                              //!< Current color format
    NV_DP_DYNAMIC_RANGE dynamicRange;                             //!< Dynamic range
    NV_DP_COLORIMETRY   colorimetry;                              //!< Ignored in RGB space
    NV_DP_BPC           bpc;                                      //!< Current bit-per-component
    NvU32               isDp                                : 1;  //!< If the monitor is driven by a DisplayPort 
    NvU32               isInternalDp                        : 1;  //!< If the monitor is driven by an NV Dp transmitter
    NvU32               isColorCtrlSupported                : 1;  //!< If the color format change is supported
    NvU32               is6BPCSupported                     : 1;  //!< If 6 bpc is supported
    NvU32               is8BPCSupported                     : 1;  //!< If 8 bpc is supported    
    NvU32               is10BPCSupported                    : 1;  //!< If 10 bpc is supported
    NvU32               is12BPCSupported                    : 1;  //!< If 12 bpc is supported        
    NvU32               is16BPCSupported                    : 1;  //!< If 16 bpc is supported
    NvU32               isYCrCb422Supported                 : 1;  //!< If YCrCb422 is supported                                                  
    NvU32               isYCrCb444Supported                 : 1;  //!< If YCrCb444 is supported
    NvU32               isRgb444SupportedOnCurrentMode      : 1;  //!< If Rgb444 is supported on the current mode
    NvU32               isYCbCr444SupportedOnCurrentMode    : 1;  //!< If YCbCr444 is supported on the current mode
    NvU32               isYCbCr422SupportedOnCurrentMode    : 1;  //!< If YCbCr422 is support on the current mode
	NvU32      is6BPCSupportedOnCurrentMode                    : 1;  // if 6 bpc is supported On Current Mode
    NvU32      is8BPCSupportedOnCurrentMode                    : 1;  // if 8 bpc is supported On Current Mode
    NvU32      is10BPCSupportedOnCurrentMode                   : 1;  // if 10 bpc is supported On Current Mode
    NvU32      is12BPCSupportedOnCurrentMode                   : 1;  // if 12 bpc is supported On Current Mode
    NvU32      is16BPCSupportedOnCurrentMode                   : 1;  // if 16 bpc is supported On Current Mode
	NvU32               reserved							: 14;  //!< reserved  
 } NV_DISPLAY_PORT_INFO_V1; 

 typedef NV_DISPLAY_PORT_INFO_V1 NV_DISPLAY_PORT_INFO;

//! Macro for constructing the version field of NV_DISPLAY_PORT_INFO.
#define NV_DISPLAY_PORT_INFO_VER1  MAKE_NVAPI_VERSION(NV_DISPLAY_PORT_INFO,1)
#define NV_DISPLAY_PORT_INFO_VER2  MAKE_NVAPI_VERSION(NV_DISPLAY_PORT_INFO,2)
#define NV_DISPLAY_PORT_INFO_VER   NV_DISPLAY_PORT_INFO_VER2

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetDisplayPortInfo
//
//! \fn NvAPI_GetDisplayPortInfo(__in_opt NvDisplayHandle hNvDisplay, __in NvU32 outputId, __inout NV_DISPLAY_PORT_INFO *pInfo)
//! DESCRIPTION:     This function returns the current DisplayPort-related information on the specified device (monitor).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 165
//!
//! \param [in]     hvDisplay     NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//!                               This parameter is ignored when the outputId is a NvAPI displayId.
//! \param [in]     outputId      This can either be the connection bit mask or the NvAPI displayId. When the legacy connection bit mask is passed, 
//!                               it should have exactly 1 bit set to indicate a single display. If it's "0" then the default outputId from 
//!                               NvAPI_GetAssociatedDisplayOutputId() will be used. See \ref handles.
//! \param [out]    pInfo         The DisplayPort information
//!
//! \retval         NVAPI_OK                Completed request
//! \retval         NVAPI_ERROR             Miscellaneous error occurred
//! \retval         NVAPI_INVALID_ARGUMENT  Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////
//! \ingroup        dispcontrol
NVAPI_INTERFACE NvAPI_GetDisplayPortInfo(__in_opt NvDisplayHandle hNvDisplay, __in NvU32 outputId, __inout NV_DISPLAY_PORT_INFO *pInfo);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SetDisplayPort
//
//! \fn NvAPI_SetDisplayPort(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_DISPLAY_PORT_CONFIG *pCfg)
//! DESCRIPTION:     This function sets up DisplayPort-related configurations.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release:   165
//!
//! \param [in]       hNvDisplay  NVIDIA display handle. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from
//!                               NvAPI_EnumNVidiaDisplayHandle().
//! \param [in]       outputId    This display output ID, when it's "0" it means the default outputId generated from the return of
//!                               NvAPI_GetAssociatedDisplayOutputId(). See \ref handles.
//! \param [in]       pCfg        The display port config structure. If pCfg is NULL, it means to use the driver's default value to setup.
//!
//! \retval           NVAPI_OK                Completed request
//! \retval           NVAPI_ERROR             Miscellaneous error occurred
//! \retval           NVAPI_INVALID_ARGUMENT  Invalid input parameter
///////////////////////////////////////////////////////////////////////////////


//! \ingroup dispcontrol
//! DisplayPort configuration settings - used in NvAPI_SetDisplayPort().
typedef struct
{
    NvU32               version;                     //!< Structure version - 2 is the latest
    NV_DP_LINK_RATE     linkRate;                    //!< Link rate
    NV_DP_LANE_COUNT    laneCount;                   //!< Lane count
    NV_DP_COLOR_FORMAT  colorFormat;                 //!< Color format to set
    NV_DP_DYNAMIC_RANGE dynamicRange;                //!< Dynamic range
    NV_DP_COLORIMETRY   colorimetry;                 //!< Ignored in RGB space
    NV_DP_BPC           bpc;                         //!< Bit-per-component
    NvU32               isHPD               : 1;     //!< If the control panel is making this call due to HPD
    NvU32               isSetDeferred       : 1;     //!< Requires an OS modeset to finalize the setup if set
    NvU32               isChromaLpfOff      : 1;     //!< Force the chroma low_pass_filter to be off
    NvU32               isDitherOff         : 1;     //!< Force to turn off dither
    NvU32               testLinkTrain       : 1;     //!< If testing mode, skip validation
    NvU32               testColorChange     : 1;     //!< If testing mode, skip validation

} NV_DISPLAY_PORT_CONFIG;

//! \addtogroup dispcontrol
//! @{
//! Macro for constructing the version field of NV_DISPLAY_PORT_CONFIG
#define NV_DISPLAY_PORT_CONFIG_VER   MAKE_NVAPI_VERSION(NV_DISPLAY_PORT_CONFIG,2)
//! Macro for constructing the version field of NV_DISPLAY_PORT_CONFIG
#define NV_DISPLAY_PORT_CONFIG_VER_1 MAKE_NVAPI_VERSION(NV_DISPLAY_PORT_CONFIG,1)
//! Macro for constructing the version field of NV_DISPLAY_PORT_CONFIG
#define NV_DISPLAY_PORT_CONFIG_VER_2 MAKE_NVAPI_VERSION(NV_DISPLAY_PORT_CONFIG,2)
//! @}


//! \ingroup          dispcontrol
NVAPI_INTERFACE NvAPI_SetDisplayPort(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_DISPLAY_PORT_CONFIG *pCfg);




//! \ingroup dispcontrol
//! Used in NvAPI_GetHDMISupportInfo().
typedef struct _NV_HDMI_SUPPORT_INFO_V1
{
    NvU32      version;                     //!< Structure version

    NvU32      isGpuHDMICapable       : 1;  //!< If the GPU can handle HDMI
    NvU32      isMonUnderscanCapable  : 1;  //!< If the monitor supports underscan
    NvU32      isMonBasicAudioCapable : 1;  //!< If the monitor supports basic audio
    NvU32      isMonYCbCr444Capable   : 1;  //!< If YCbCr 4:4:4 is supported
    NvU32      isMonYCbCr422Capable   : 1;  //!< If YCbCr 4:2:2 is supported
    NvU32      isMonxvYCC601Capable   : 1;  //!< If xvYCC 601 is supported
    NvU32      isMonxvYCC709Capable   : 1;  //!< If xvYCC 709 is supported
    NvU32      isMonHDMI              : 1;  //!< If the monitor is HDMI (with IEEE's HDMI registry ID)
    NvU32      reserved               : 24; //!< Reserved. 

    NvU32      EDID861ExtRev;               //!< Revision number of the EDID 861 extension
 } NV_HDMI_SUPPORT_INFO_V1; 

typedef struct _NV_HDMI_SUPPORT_INFO_V2
{
    NvU32      version;                      //!< Structure version

    NvU32      isGpuHDMICapable        : 1;  //!< If the GPU can handle HDMI
    NvU32      isMonUnderscanCapable   : 1;  //!< If the monitor supports underscan
    NvU32      isMonBasicAudioCapable  : 1;  //!< If the monitor supports basic audio
    NvU32      isMonYCbCr444Capable    : 1;  //!< If YCbCr 4:4:4 is supported
    NvU32      isMonYCbCr422Capable    : 1;  //!< If YCbCr 4:2:2 is supported
    NvU32      isMonxvYCC601Capable    : 1;  //!< If xvYCC extended colorimetry 601 is supported
    NvU32      isMonxvYCC709Capable    : 1;  //!< If xvYCC extended colorimetry 709 is supported
    NvU32      isMonHDMI               : 1;  //!< If the monitor is HDMI (with IEEE's HDMI registry ID)
    NvU32      isMonsYCC601Capable     : 1;  //!< if sYCC601 extended colorimetry is supported
    NvU32      isMonAdobeYCC601Capable : 1;  //!< if AdobeYCC601 extended colorimetry is supported
    NvU32      isMonAdobeRGBCapable    : 1;  //!< if AdobeRGB extended colorimetry is supported
    NvU32      reserved                : 21; //!< Reserved. 

    NvU32      EDID861ExtRev;                //!< Revision number of the EDID 861 extension
 } NV_HDMI_SUPPORT_INFO_V2; 

#define NV_HDMI_SUPPORT_INFO_VER1  MAKE_NVAPI_VERSION(NV_HDMI_SUPPORT_INFO_V1, 1)
#define NV_HDMI_SUPPORT_INFO_VER2  MAKE_NVAPI_VERSION(NV_HDMI_SUPPORT_INFO_V2, 2)



typedef struct _NV_HDMI_SUPPORT_INFO_V3
{
    NvU32      version;                                 //!< Structure version

    NvU32      isGpuHDMICapable                   : 1;  //!< If the GPU can handle HDMI
    NvU32      isMonUnderscanCapable              : 1;  //!< If the monitor supports underscan
    NvU32      isMonBasicAudioCapable             : 1;  //!< If the monitor supports basic audio
    NvU32      isMonYCbCr444Capable               : 1;  //!< If YCbCr 4:4:4 is supported
    NvU32      isMonYCbCr422Capable               : 1;  //!< If YCbCr 4:2:2 is supported
    NvU32      isMonxvYCC601Capable               : 1;  //!< If xvYCC 601 extended colorimetry is supported
    NvU32      isMonxvYCC709Capable               : 1;  //!< If xvYCC 709 extended colorimetry is supported
    NvU32      isMonHDMI                          : 1;  //!< If the monitor is HDMI (with IEEE's HDMI registry ID)
    NvU32      isMonRgb444Capable                 : 1;  //!< If RGB:4:4:4 is supported    
    NvU32      isMonYCbCr420Capable               : 1;  //!< If YCbCr 4:2:0 is supported (does not mean on all timings), may be driver emulated    
    NvU32      isRgb444SupportedOnCurrentMode     : 1;  //!< If RGB444 can be supported on for some timing; some monitors can go Yuv420 but cannot support the same timing in RGB444
    NvU32      isYCbCr444SupportedOnCurrentMode   : 1;  //!< If YCbCr444 can be supported on for some timing
    NvU32      isYCbCr422SupportedOnCurrentMode   : 1;  //!< If YCbCr422 can be supported on for some timing
    NvU32      isYCbCr420SupportedOnCurrentMode   : 1;  //!< If YCbCr420 can be supported on for some timing
    NvU32      isMonsYCC601Capable                : 1;  //!< if sYCC601 extended colorimetry is supported
    NvU32      isMonAdobeYCC601Capable            : 1;  //!< if AdobeYCC601 extended colorimetry is supported
    NvU32      isMonAdobeRGBCapable               : 1;  //!< if AdobeRGB extended colorimetry is supported
    NvU32      isMonBT2020RGBCapable              : 1;  //!< if BT2020 RGB extended colorimetry is supported
    NvU32      isMonBT2020YCCCapable              : 1;  //!< if BT2020 Y'CbCr extended colorimetry is supported
    NvU32      isMonBT2020cYCCCapable             : 1;  //!< if BT2020 cYCbCr (constant luminance) colorimetry is supported
    NvU32      is8BPCSupported                    : 1;  // if 8 bpc is supported
    NvU32      is10BPCSupported                   : 1;  // if 10 bpc is supported
    NvU32      is12BPCSupported                   : 1;  // if 12 bpc is supported
    NvU32      is16BPCSupported                   : 1;  // if 16 bpc is supported
    NvU32      is8BPCSupportedOnCurrentMode                    : 1;  // if 8 bpc is supported On Current Mode
    NvU32      is10BPCSupportedOnCurrentMode                   : 1;  // if 10 bpc is supported On Current Mode
    NvU32      is12BPCSupportedOnCurrentMode                   : 1;  // if 12 bpc is supported On Current Mode
    NvU32      is16BPCSupportedOnCurrentMode                   : 1;  // if 16 bpc is supported On Current Mode
    NvU32      reserved                           : 4; //!< Reserved. 

    NvU32      EDID861ExtRev;                           //!< Revision number of the EDID 861 extension
} NV_HDMI_SUPPORT_INFO_V3; 

typedef NV_HDMI_SUPPORT_INFO_V3      NV_HDMI_SUPPORT_INFO;
#define NV_HDMI_SUPPORT_INFO_VER3    MAKE_NVAPI_VERSION(NV_HDMI_SUPPORT_INFO_V3, 3)
#define NV_HDMI_SUPPORT_INFO_VER     NV_HDMI_SUPPORT_INFO_VER3



#ifndef NV_HDMI_SUPPORT_INFO_VER

typedef NV_HDMI_SUPPORT_INFO_V2    NV_HDMI_SUPPORT_INFO;
#define NV_HDMI_SUPPORT_INFO_VER   NV_HDMI_SUPPORT_INFO_VER2

#endif


//! SUPPORTED OS:  Windows Vista and higher
//!
///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetHDMISupportInfo
//
//! \fn NvAPI_GetHDMISupportInfo(__in_opt NvDisplayHandle hNvDisplay, __in NvU32 outputId, __inout NV_HDMI_SUPPORT_INFO *pInfo)
//!   This API returns the current infoframe data on the specified device(monitor).
//!
//! \since Release: 95
//!
//! \param [in]  hvDisplay  NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//!                         This parameter is ignored when the outputId is a NvAPI displayId.
//! \param [in]  outputId   This can either be the connection bit mask or the NvAPI displayId. When the legacy connection bit mask is passed, 
//!                         it should have exactly 1 bit set to indicate a single display. If it's "0" then the default outputId from 
//!                         NvAPI_GetAssociatedDisplayOutputId() will be used. See \ref handles.
//! \param [out] pInfo      The monitor and GPU's HDMI support info
//!
//! \retval  NVAPI_OK                Completed request
//! \retval  NVAPI_ERROR             Miscellaneous error occurred
//! \retval  NVAPI_INVALID_ARGUMENT  Invalid input parameter.
///////////////////////////////////////////////////////////////////////////////


//! \ingroup dispcontrol
NVAPI_INTERFACE NvAPI_GetHDMISupportInfo(__in_opt NvDisplayHandle hNvDisplay, __in NvU32 outputId, __inout NV_HDMI_SUPPORT_INFO *pInfo);



//! \ingroup dispcontrol
//! @{

#define NVAPI_HDMI_STEREO_MAX_MODES 256 

//! See ::NV_HDMI_STEREO_MODE.
typedef enum 
{
    NV_HDMI_STEREO_3D_NONE                = 0x00,
    NV_STEREO_NVISION,
    NV_HDMI_STEREO_3D_FRAME_PACKING,
    NV_HDMI_STEREO_3D_FRAME_PACKING_INT,
    NV_HDMI_STEREO_3D_LINE_ALT,
    NV_HDMI_STEREO_3D_SIDE_BY_SIDE_FULL,
    NV_HDMI_STEREO_3D_SIDE_BY_SIDE_HALF_HORIZONTAIL_ODD_LEFT_ODD_RIGHT,
    NV_HDMI_STEREO_3D_SIDE_BY_SIDE_HALF_HORIZONTAIL_ODD_LEFT_EVEN_RIGHT,
    NV_HDMI_STEREO_3D_SIDE_BY_SIDE_HALF_HORIZONTAIL_EVEN_LEFT_ODD_RIGHT,
    NV_HDMI_STEREO_3D_SIDE_BY_SIDE_HALF_HORIZONTAIL_EVEN_LEFT_EVEN_RIGHT,
    NV_HDMI_STEREO_3D_SIDE_BY_SIDE_HALF_QUINCUX_ODD_LEFT_ODD_RIGHT,
    NV_HDMI_STEREO_3D_SIDE_BY_SIDE_HALF_QUINCUX_ODD_LEFT_EVEN_RIGHT,
    NV_HDMI_STEREO_3D_SIDE_BY_SIDE_HALF_QUINCUX_EVEN_LEFT_ODD_RIGHT,
    NV_HDMI_STEREO_3D_SIDE_BY_SIDE_HALF_QUINCUX_EVEN_LEFT_EVEN_RIGHT,
    NV_HDMI_STEREO_3D_FIELD_ALT,
    NV_HDMI_STEREO_3D_L_DEPTH,
    NV_HDMI_STEREO_3D_L_DEPTH_GFX,
    NV_HDMI_STEREO_3D_TOP_BOTTOM,
    NV_HDMI_STEREO_3D_SIDE_BY_SIDE_HALF_HORIZONTAIL,
    NV_HDMI_STEREO_3D_ANY                 = 0xff,

} NV_HDMI_STEREO_TYPE;

//! See ::NV_HDMI_STEREO_MODES_LIST_V1.
typedef struct
{
    NvU16 HVisible;                     //!< Horizontal visible (size of single visible surface)
    NvU16 VVisible;                     //!< Vertical visible   (size of single visible surface)
    NvU16 HActive;                      //!< Horizontal active  (active frame size - i.e. both right & left surfaces, plus any padding)
    NvU16 VActive ;                     //!< Vertical active    (active frame size - i.e. both right & left surfaces, plus any padding)
    NvU16 VActiveSpace[2];              //!< Vertical active space

    NvU16   rr;                         //!< The refresh rate

    NV_HDMI_STEREO_TYPE stereoType;     //!< HDMI Stereo type

} NV_HDMI_STEREO_MODE;

//! See NvAPI_DISP_EnumHDMIStereoModes().
typedef struct
{
    // IN
    NvU32    version;             //!< structure version
    NvU32    displayId;           //!< (IN)Monitor Identifier. Retrieved from NvAPI_SYS_GetDisplayIdFromGpuAndOutputId
    NvU16    enumIndex;           //!< (IN)mode index 0 = 1st HDMI stereo mode
    NvU16    count;               //!< (IN)the max number of modes to return
    NvU32    width;               //!< (IN)visible desktop width, only required when bMatchDimension is true to do optional resolution filtering
    NvU32    height;              //!< (IN)visible desktop height, only required when bMatchDimension is true to do optional resolution filtering
    NvU32    refreshRate;         //!< (IN)desktop refresh rate, only required when bMatchRR is true to do optional refreshrate filtering
    NvU32    bMatchDimension : 1; //!< (IN)if true, return modes that match specified dimensions (height/width)
    NvU32    bMatchRR : 1;        //!< (IN)if true, return modes that match specified refresh rates
    NvU32    bPassThroughMode:1;  //!< (IN)if true, return pass-through capable modes. If false, return modeset capable modes
    NvU32    reserved : 29;       //!< reserved. Must be 0
    // OUT
    NvU16   numberOfModes;        //!< (OUT)number of modes returned
    NV_HDMI_STEREO_MODE modeList[NVAPI_HDMI_STEREO_MAX_MODES];    //!<(OUT) mode list

} NV_HDMI_STEREO_MODES_LIST_V1;

typedef NV_HDMI_STEREO_MODES_LIST_V1 NV_HDMI_STEREO_MODES_LIST;
#define NV_HDMI_STEREO_MODES_LIST_VER1  MAKE_NVAPI_VERSION(NV_HDMI_STEREO_MODES_LIST_V1,1)
#define NV_HDMI_STEREO_MODES_LIST_VER    NV_HDMI_STEREO_MODES_LIST_VER1

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DISP_EnumHDMIStereoModes
//
//! DESCRIPTION:     This API returns HDMI stereo modes supported by the specified monitor with indices between [enumIndex, enumIndex+count].
//!                  numberOfModes returned would be min(count, number of stereo modes available for the monitor).
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in,out]   pHDMIStereoModes  As input, it contains displayID and enumIndex. After successful return, it contains the HDMI stereo mode list.
//!                  
//! \retval ::NVAPI_OK                             Completed request
//! \retval ::NVAPI_END_ENUMERATION                No more entries
//! \retval ::NVAPI_ERROR                          Miscellaneous error occurred
//! \retval ::NVAPI_INVALID_ARGUMENT               Invalid input parameter.
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION    NV_HDMI_STEREO_MODES_LIST structure version mismatch. see pHDMIStereoModes->version.
//! \retval ::NVAPI_ID_OUT_OF_RANGE                Incorrect displayId.
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_EnumHDMIStereoModes(NV_HDMI_STEREO_MODES_LIST *pHDMIStereoModes);

//! @}


//! \ingroup dispcontrol
typedef struct
{
    // IN
    NvU32    version;            //!< structure version
    NV_HDMI_STEREO_TYPE type;    //!< HDMI stereo type. This is for pass-through modes only, returned by NvAPI_DISP_EnumHDMIStereoModes by passing bPassThroughMode true
                                 //!< It can be enabled when it is already in 3D mode as the result of a modeset/dynamic engage and that 3D mode(Height/width/refreshrate) must be supported
                                 //!< Use NV_HDMI_STEREO_3D_NONE to disable
    NvU32    reserved;           //!< reserved

} NV_HDMI_STEREO_SETTINGS_V1;

//! \ingroup dispcontrol
typedef NV_HDMI_STEREO_SETTINGS_V1     NV_HDMI_STEREO_SETTINGS;

//! \ingroup dispcontrol
#define NV_HDMI_STEREO_SETTINGS_VER1   MAKE_NVAPI_VERSION(NV_HDMI_STEREO_SETTINGS_V1,1)

//! \ingroup dispcontrol
#define NV_HDMI_STEREO_SETTINGS_VER    NV_HDMI_STEREO_SETTINGS_VER1

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DISP_SetHDMIStereoSettings
//
//! DESCRIPTION:     This API applies the HDMI stereo settings.
//!                  Currently it is used to set pass-through HDMI modes by specifying NV_HDMI_STEREO_TYPE.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      displayId           Monitor Identifier
//! \param [in]      hdmiStereoSettings  NV_HDMI_STEREO_SETTINGS that needs to be applied
//!
//! \retval ::NVAPI_OK  completed request
//! \retval ::NVAPI_ERROR  miscellaneous error occurred
//! \retval ::NVAPI_INVALID_ARGUMENT  Invalid input parameter.
//! \retval ::NVAPI_ID_OUT_OF_RANGE  Incorrect displayId.
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION  if NV_HDMI_STEREO_SETTINGS structure version mismatches.
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_SetHDMIStereoSettings(NvU32 displayId, NV_HDMI_STEREO_SETTINGS *hdmiStereoSettings);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DISP_GetHDMIStereoSettings
//
//! DESCRIPTION:     This API returns the current HDMI stereo settings.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! \param [in]      displayId           Monitor Identifier
//! \param [in]      hdmiStereoSettings  NV_HDMI_STEREO_SETTINGS -it contains current applied settings on successful return of API
//!
//! \retval ::NVAPI_OK  completed request
//! \retval ::NVAPI_ERROR  miscellaneous error occurred
//! \retval ::NVAPI_INVALID_ARGUMENT  Invalid input parameter.
//! \retval ::NVAPI_INVALID_POINTER   An invalid pointer was passed as an argument (probably NULL).
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION  if NV_HDMI_STEREO_SETTINGS structure version mismatches.
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_GetHDMIStereoSettings(NvU32 displayId, NV_HDMI_STEREO_SETTINGS *hdmiStereoSettings);









//! \ingroup dispcontrol
//! Use in NvAPI_GetInfoFrame(), NvAPI_SetInfoFrame(), NvAPI_GetInfoFrameState(), and NvAPI_SetInfoFrameState().
typedef enum _NV_INFOFRAME_TYPE
{
    NV_INFOFRAME_TYPE_AVI   = 2,
    NV_INFOFRAME_TYPE_SPD   = 3,
    NV_INFOFRAME_TYPE_AUDIO = 4,
    NV_INFOFRAME_TYPE_MS    = 5,
} NV_INFOFRAME_TYPE;


//! Used in \ref NV_INFOFRAME
//! \ingroup dispcontrol
typedef struct
{
    NvU8 type;
    NvU8 version;
    NvU8 length;
} NV_INFOFRAME_HEADER;

//! Since this is for Windows OS so far, we use this bit little endian definition
//! to handle the translation.
//! Used in \ref NV_INFOFRAME
//! \ingroup dispcontrol
typedef struct
{
    // byte 1
    NvU8 channelCount     : 3;
    NvU8 rsvd_bits_byte1  : 1;
    NvU8 codingType       : 4;

    // byte 2
    NvU8 sampleSize       : 2;
    NvU8 sampleRate       : 3;
    NvU8 rsvd_bits_byte2  : 3;

    // byte 3
    NvU8 codingExtensionType  : 5;
    NvU8 rsvd_bits_byte3      : 3;


    // byte 4
    NvU8  speakerPlacement;

    // byte 5
    NvU8 lfePlaybackLevel     : 2;
    NvU8 rsvd_bits_byte5      : 1;
    NvU8 levelShift           : 4;
    NvU8 downmixInhibit       : 1;

    // byte 6~10
    NvU8 rsvd_byte6;
    NvU8 rsvd_byte7;
    NvU8 rsvd_byte8;
    NvU8 rsvd_byte9;
    NvU8 rsvd_byte10;

}NV_AUDIO_INFOFRAME;


//! Used in \ref NV_INFOFRAME
//! \ingroup dispcontrol
typedef struct
{
    // byte 1
    NvU8 scanInfo                : 2;
    NvU8 barInfo                 : 2;
    NvU8 activeFormatInfoPresent : 1;
    NvU8 colorSpace              : 2;
    NvU8 rsvd_bits_byte1         : 1;

    // byte 2
    NvU8 activeFormatAspectRatio : 4;
    NvU8 picAspectRatio          : 2;
    NvU8 colorimetry             : 2;

    // byte 3
    NvU8 nonuniformScaling       : 2;
    NvU8 rgbQuantizationRange    : 2;
    NvU8 extendedColorimetry     : 3;
    NvU8 itContent               : 1;

    // byte 4
    NvU8 vic                     : 7;
    NvU8 rsvd_bits_byte4         : 1;

    // byte 5
    NvU8 pixelRepeat             : 4;
    NvU8 contentTypes            : 2;
    NvU8 yccQuantizationRange    : 2;

    // byte 6~13 
    NvU8 topBarLow;
    NvU8 topBarHigh;
    NvU8 bottomBarLow;
    NvU8 bottomBarHigh;
    NvU8 leftBarLow;
    NvU8 leftBarHigh;
    NvU8 rightBarLow;
    NvU8 rightBarHigh;

} NV_VIDEO_INFOFRAME;

//! \ingroup dispcontrol
//! \sa NvAPI_GetInfoFrame(); NvAPI_SetInfoFrame
typedef struct
{
    NV_INFOFRAME_HEADER    header;
    union
    {
        NV_AUDIO_INFOFRAME audio;
        NV_VIDEO_INFOFRAME video;
    }u;
} NV_INFOFRAME;

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_GetInfoFrame
//
//! DESCRIPTION: This API returns the current infoframe data on the specified device(monitor).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 95
//!
//! \param [in] hNvDisplay      NVIDIA Display selection. It can be #NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//! \param [in] displayId       If Display Id is passed then hNvDisplay need not be specified. 
//!                             If output Id is passed then hNvDisplay needs to be specified. 
//!                             If the value passed is "0" then the default outputId from NvAPI_GetAssociatedDisplayOutputId() will be used. See \ref handles.
//! \param [in] type            The type of infoframe to get. See NV_INFOFRAME_TYPE .
//! \param [out] pInfoFrame     Pointer to the The infoframe data.
//!
//! \return    This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetInfoFrame(__in NvDisplayHandle hNvDisplay, __in NvU32 displayId, __in NV_INFOFRAME_TYPE type, __out NV_INFOFRAME *pInfoFrame);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_SetInfoFrame
//
//! DESCRIPTION: This API returns the current infoframe data on the specified device(monitor).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 95
//!
//! \param [in]  hNvDisplay     NVIDIA Display selection. It can be #NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//! \param [in] displayId       If Display Id is passed then hNvDisplay need not be specified. 
//!                             If output Id is passed then hNvDisplay needs to be specified. 
//!                             If the value passed is "0" then the default outputId from NvAPI_GetAssociatedDisplayOutputId() will be used. See \ref handles.
//! \param [in]  type           The type of infoframe to set. See NV_INFOFRAME_TYPE .
//! \param [in]  pInfoFrame     Pointer to the The infoframe data. NULL means reset to the default value.
//!
//! \return    This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetInfoFrame(__in NvDisplayHandle hNvDisplay, __in NvU32 displayId, __in NV_INFOFRAME_TYPE type, __in NV_INFOFRAME *pInfoFrame);



//! ingroup dispcontrol
//! Used in NvAPI_SetInfoFrameState() and NvAPI_GetInfoFrameState().
typedef struct _NV_INFOFRAME_STATE
{
    NvU32 bDisabled    :    1;       //!< Enable or disable the infoframe when "bDriverCtrl" is 0.
    NvU32 bDriverCtrl  :    1;       //!< If set, let the driver control the infoframe state and ignore "bDisabled".
    NvU32 reserved     :   30;

} NV_INFOFRAME_STATE;

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SetInfoFrameState
//
//! DESCRIPTION:    This API disables or enables the sending of infoframe packets. Currently, this is supported for audio packets only.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 177
//!
//! \param [in] hNvDisplay   NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//! \param [in] displayId    If Display Id is passed then hNvDisplay need not be specified. 
//!                          If output Id is passed then hNvDisplay needs to be specified. 
//!                          If the value passed is "0" then the default outputId from NvAPI_GetAssociatedDisplayOutputId() will be used. See \ref handles.
//! \param [in] type         The type of infoframe to set
//! \param [in] state        state of infoframe to set
//!
//! \return    This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetInfoFrameState(__in NvDisplayHandle hNvDisplay, __in NvU32 displayId, __in NV_INFOFRAME_TYPE type, __in NV_INFOFRAME_STATE *pState);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetInfoFrameState
//
//! DESCRIPTION:    This API gets the state of the infoframe. Currently, this is supported for audio packets only.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 177
//!
//! \param [in]     hNvDisplay  NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//! \param [in]     displayId   If Display Id is passed then hNvDisplay need not be specified. 
//!                             If output Id is passed then hNvDisplay needs to be specified. 
//!                             If the value passed is "0" then the default outputId from NvAPI_GetAssociatedDisplayOutputId() will be used. See \ref handles.
//! \param [in]     type        The type of infoframe of which to get the state
//! \param [out]    state       State of the infoframe
//!
//! \return    This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetInfoFrameState(__in NvDisplayHandle hNvDisplay, __in NvU32 displayId, __in NV_INFOFRAME_TYPE type, __out NV_INFOFRAME_STATE *pState);


//! \ingroup dispcontrol
//! Used in NvAPI_GetInfoFrameStatePvt().
typedef struct _NV_INFOFRAME_STATE_PVT
{
    NV_INFOFRAME_STATE  state;
    NvU32 bInHDMIBlackList :    1;   //!< Ready only. Indicates if the monitor is in the driver's HDMI black list.
    NvU32 reserved         :   31;
} NV_INFOFRAME_STATE_PVT;


//! SUPPORTED OS:  Windows Vista and higher
//!
//! \ingroup dispcontrol
NVAPI_INTERFACE NvAPI_GetInfoFrameStatePvt(__in NvDisplayHandle hNvDisplay, __in NvU32 displayId, __in NV_INFOFRAME_TYPE type, __out NV_INFOFRAME_STATE_PVT *pState);


//! \ingroup dispcontrol

typedef enum
{
    NV_INFOFRAME_CMD_GET_DEFAULT = 0,     //!< Returns the fields in the infoframe with values set by the manufacturer - NVIDIA/OEM.
    NV_INFOFRAME_CMD_RESET,               //!< Sets the fields in the infoframe to auto, and infoframe to the default infoframe for use in a set.    
    NV_INFOFRAME_CMD_GET,                 //!< Get the current infoframe state.
    NV_INFOFRAME_CMD_SET,                 //!< Set the current infoframe state (flushed to the monitor), the values are one time and do not persist.
    NV_INFOFRAME_CMD_GET_OVERRIDE,        //!< Get the override infoframe state, non-override fields will be set to value = AUTO, overridden fields will have the current override values.
    NV_INFOFRAME_CMD_SET_OVERRIDE,        //!< Set the override infoframe state, non-override fields will be set to value = AUTO, other values indicate override; persist across modeset/reboot
    NV_INFOFRAME_CMD_GET_PROPERTY,        //!< get properties associated with infoframe (each of the infoframe type will have properties)
    NV_INFOFRAME_CMD_SET_PROPERTY,        //!< set properties associated with infoframe
} NV_INFOFRAME_CMD;


typedef enum
{
    NV_INFOFRAME_PROPERTY_MODE_AUTO           = 0, //!< Driver determines whether to send infoframes.
    NV_INFOFRAME_PROPERTY_MODE_ENABLE,             //!< Driver always sends infoframe.
    NV_INFOFRAME_PROPERTY_MODE_DISABLE,            //!< Driver never sends infoframe.
    NV_INFOFRAME_PROPERTY_MODE_ALLOW_OVERRIDE,     //!< Driver only sends infoframe when client requests it via infoframe escape call.
} NV_INFOFRAME_PROPERTY_MODE;


//! Returns whether the current monitor is in blacklist or force this monitor to be in blacklist.
typedef enum
{
    NV_INFOFRAME_PROPERTY_BLACKLIST_FALSE = 0,
    NV_INFOFRAME_PROPERTY_BLACKLIST_TRUE,
} NV_INFOFRAME_PROPERTY_BLACKLIST;

typedef struct
{
    NvU32 mode      :  4;
    NvU32 blackList :  2;
    NvU32 reserved  : 10;
    NvU32 version   :  8;
    NvU32 length    :  8;
} NV_INFOFRAME_PROPERTY;

//! Byte1 related
typedef enum
{
    NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO_NODATA    = 0,
    NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO_OVERSCAN,
    NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO_UNDERSCAN,
    NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO_FUTURE,
    NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO_AUTO      = 7
} NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO;


typedef enum
{
    NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA_NOT_PRESENT         = 0,
    NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA_VERTICAL_PRESENT,
    NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA_HORIZONTAL_PRESENT,
    NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA_BOTH_PRESENT,
    NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA_AUTO                = 7
} NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA;

typedef enum
{
    NV_INFOFRAME_FIELD_VALUE_AVI_AFI_ABSENT   = 0,
    NV_INFOFRAME_FIELD_VALUE_AVI_AFI_PRESENT,
    NV_INFOFRAME_FIELD_VALUE_AVI_AFI_AUTO     = 3
} NV_INFOFRAME_FIELD_VALUE_AVI_ACTIVEFORMATINFO;


typedef enum
{
    NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT_RGB      = 0,
    NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT_YCbCr422,
    NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT_YCbCr444,
    NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT_FUTURE,
    NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT_AUTO     = 7
} NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT;

typedef enum
{
    NV_INFOFRAME_FIELD_VALUE_AVI_F17_FALSE = 0,
    NV_INFOFRAME_FIELD_VALUE_AVI_F17_TRUE,
    NV_INFOFRAME_FIELD_VALUE_AVI_F17_AUTO = 3
} NV_INFOFRAME_FIELD_VALUE_AVI_F17;

//! Byte2 related
typedef enum
{
    NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_NO_AFD           = 0,
    NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_RESERVE01,
    NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_RESERVE02,
    NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_RESERVE03,
    NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_LETTERBOX_GT16x9,
    NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_RESERVE05,
    NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_RESERVE06,
    NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_RESERVE07,
    NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_EQUAL_CODEDFRAME = 8,
    NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_CENTER_4x3,
    NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_CENTER_16x9,
    NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_CENTER_14x9,
    NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_RESERVE12,
    NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_4x3_ON_14x9,
    NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_16x9_ON_14x9,
    NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_16x9_ON_4x3,
    NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_AUTO             = 31,
} NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION;


typedef enum
{
    NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME_NO_DATA = 0,
    NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME_4x3,
    NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME_16x9,
    NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME_FUTURE,
    NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME_AUTO    = 7
} NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME;

typedef enum
{
    NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY_NO_DATA                   = 0,
    NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY_SMPTE_170M,
    NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY_ITUR_BT709,
    NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY_USE_EXTENDED_COLORIMETRY,
    NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY_AUTO                      = 7
} NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY;

//! Byte 3 related
typedef enum
{
    NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING_NO_DATA    = 0,
    NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING_HORIZONTAL,
    NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING_VERTICAL,
    NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING_BOTH,
    NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING_AUTO       = 7
} NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING;

typedef enum
{
    NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION_DEFAULT       = 0,
    NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION_LIMITED_RANGE,
    NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION_FULL_RANGE,
    NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION_RESERVED,
    NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION_AUTO          = 7
} NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION;

typedef enum
{
    NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_XVYCC601     = 0,
    NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_XVYCC709,
    NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_SYCC601,
    NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_ADOBEYCC601,
    NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_ADOBERGB,
    NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_RESERVED05,
    NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_RESERVED06,
    NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_RESERVED07,
    NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_AUTO         = 15
} NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY;

typedef enum
{
    NV_INFOFRAME_FIELD_VALUE_AVI_ITC_VIDEO_CONTENT = 0,
    NV_INFOFRAME_FIELD_VALUE_AVI_ITC_ITCONTENT,
    NV_INFOFRAME_FIELD_VALUE_AVI_ITC_AUTO          = 3
} NV_INFOFRAME_FIELD_VALUE_AVI_ITC;

//! Byte 4 related
typedef enum
{
    NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_NONE = 0,
    NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X02,
    NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X03,
    NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X04,
    NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X05,
    NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X06,
    NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X07,
    NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X08,
    NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X09,
    NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X10,
    NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_RESERVED10,
    NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_RESERVED11,
    NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_RESERVED12,
    NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_RESERVED13,
    NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_RESERVED14,
    NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_RESERVED15,
    NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_AUTO         = 31
} NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION;


typedef enum
{
    NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE_GRAPHICS = 0,
    NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE_PHOTO,
    NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE_CINEMA,
    NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE_GAME,
    NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE_AUTO     = 7
} NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE;

typedef enum
{
    NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION_LIMITED_RANGE = 0,
    NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION_FULL_RANGE,
    NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION_RESERVED02,
    NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION_RESERVED03,
    NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION_AUTO          = 7
} NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION;

//! Adding an Auto bit to each field
typedef struct
{
    NvU32 vic                     : 8;
    NvU32 pixelRepeat             : 5;
    NvU32 colorSpace              : 3;
    NvU32 colorimetry             : 3;
    NvU32 extendedColorimetry     : 4;
    NvU32 rgbQuantizationRange    : 3;
    NvU32 yccQuantizationRange    : 3;
    NvU32 itContent               : 2;
    NvU32 contentTypes            : 3;
    NvU32 scanInfo                : 3;
    NvU32 activeFormatInfoPresent : 2;
    NvU32 activeFormatAspectRatio : 5;
    NvU32 picAspectRatio          : 3;
    NvU32 nonuniformScaling       : 3;
    NvU32 barInfo                 : 3;    
    NvU32 top_bar                 : 17;
    NvU32 bottom_bar              : 17;
    NvU32 left_bar                : 17;
    NvU32 right_bar               : 17;
    NvU32 Future17                : 2;
    NvU32 Future47                : 2;
} NV_INFOFRAME_VIDEO;

//! Byte 1 related
typedef enum
{
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_IN_HEADER = 0,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_2,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_3,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_4,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_5,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_6,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_7,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_8,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_AUTO      = 15
} NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT;

typedef enum
{
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_IN_HEADER                  = 0,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_PCM,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_AC3,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_MPEG1,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_MP3,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_MPEG2,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_AACLC,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_DTS,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_ATRAC,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_DSD,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_EAC3,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_DTSHD,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_MLP,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_DST,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_WMAPRO,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_USE_CODING_EXTENSION_TYPE,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_AUTO                      = 31
} NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE;

//! Byte 2 related
typedef enum
{
    NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE_IN_HEADER = 0,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE_16BITS,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE_20BITS,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE_24BITS,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE_AUTO      = 7
} NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE;

typedef enum
{
    NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_IN_HEADER = 0,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_32000HZ,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_44100HZ,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_48000HZ,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_88200KHZ,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_96000KHZ,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_176400KHZ,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_192000KHZ,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_AUTO      = 15
} NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY;



//! Byte 3 related
typedef enum
{
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_USE_CODING_TYPE = 0,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_HEAAC,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_HEAACV2,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_MPEGSURROUND,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE04,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE05,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE06,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE07,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE08,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE09,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE10,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE11,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE12,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE13,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE14,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE15,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE16,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE17,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE18,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE19,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE20,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE21,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE22,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE23,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE24,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE25,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE26,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE27,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE28,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE29,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE30,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE31,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_AUTO           = 63
} NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE;


//! Byte 4 related
typedef enum
{
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_X_X_X_FR_FL           =0,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_X_X_LFE_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_X_FC_X_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_X_FC_LFE_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_RC_X_X_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_RC_X_LFE_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_RC_FC_X_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_RC_FC_LFE_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_RR_RL_X_X_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_RR_RL_X_LFE_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_RR_RL_FC_X_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_RR_RL_FC_LFE_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_RC_RR_RL_X_X_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_RC_RR_RL_X_LFE_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_RC_RR_RL_FC_X_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_RC_RR_RL_FC_LFE_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_RRC_RLC_RR_RL_X_X_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_RRC_RLC_RR_RL_X_LFE_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_RRC_RLC_RR_RL_FC_X_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_RRC_RLC_RR_RL_FC_LFE_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_X_X_X_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_X_X_LFE_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_X_FC_X_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_X_FC_LFE_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_RC_X_X_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_RC_X_LFE_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_RC_FC_X_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_RC_FC_LFE_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_RR_RL_X_X_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_RR_RL_X_LFE_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_RR_RL_FC_X_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_RR_RL_FC_LFE_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_FCH_RR_RL_FC_X_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_FCH_RR_RL_FC_LFE_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_TC_X_RR_RL_FC_X_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_TC_X_RR_RL_FC_LFE_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRH_FLH_RR_RL_X_X_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRH_FLH_RR_RL_X_LFE_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRW_FLW_RR_RL_X_X_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRW_FLW_RR_RL_X_LFE_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_TC_RC_RR_RL_FC_X_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_TC_RC_RR_RL_FC_LFE_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FCH_RC_RR_RL_FC_X_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FCH_RC_RR_RL_FC_LFE_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_TC_FCH_RR_RL_FC_X_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_TC_FCH_RR_RL_FC_LFE_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRH_FLH_RR_RL_FC_X_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRH_FLH_RR_RL_FC_LFE_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRW_FLW_RR_RL_FC_X_FR_FL,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRW_FLW_RR_RL_FC_LFE_FR_FL  = 0X31,
    // all other values should default to auto
    NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_AUTO                        = 0x1FF
} NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION;

//! Byte 5 related
typedef enum
{
    NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL_NO_DATA    = 0,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL_0DB,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL_PLUS10DB,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL_RESERVED03,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL_AUTO       = 7
} NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL;

typedef enum
{
    NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_0DB  = 0,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_1DB,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_2DB,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_3DB,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_4DB,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_5DB,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_6DB,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_7DB,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_8DB,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_9DB,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_10DB,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_11DB,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_12DB,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_13DB,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_14DB,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_15DB,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_AUTO = 31
} NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES;


typedef enum
{
    NV_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX_PERMITTED  = 0,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX_PROHIBITED,
    NV_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX_AUTO       = 3
} NV_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX;

typedef struct
{
    NvU32 codingType          : 5;
    NvU32 codingExtensionType : 6;
    NvU32 sampleSize          : 3;
    NvU32 sampleRate          : 4;
    NvU32 channelCount        : 4;
    NvU32 speakerPlacement    : 9;
    NvU32 downmixInhibit      : 2;
    NvU32 lfePlaybackLevel    : 3;
    NvU32 levelShift          : 5; 
    NvU32 Future12            : 2;
    NvU32 Future2x            : 4;
    NvU32 Future3x            : 4;
    NvU32 Future52            : 2;
    NvU32 Future6             : 9;
    NvU32 Future7             : 9;
    NvU32 Future8             : 9;
    NvU32 Future9             : 9;
    NvU32 Future10            : 9;
} NV_INFOFRAME_AUDIO;

typedef struct
{
    NvU32 version; //!< version of this structure
    NvU16 size;    //!< size of this structure
    NvU8  cmd;     //!< The actions to perform from NV_INFOFRAME_CMD
    NvU8  type;    //!< type of infoframe
    
    union
    {
        NV_INFOFRAME_PROPERTY     property;  //!< This is NVIDIA-specific and corresponds to the property cmds and associated infoframe.
        NV_INFOFRAME_AUDIO        audio;
        NV_INFOFRAME_VIDEO        video;
    } infoframe;
} NV_INFOFRAME_DATA;

//! Macro for constructing the version field of ::NV_INFOFRAME_DATA
#define NV_INFOFRAME_DATA_VER   MAKE_NVAPI_VERSION(NV_INFOFRAME_DATA,1)

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_Disp_InfoFrameControl
//
//! DESCRIPTION:     This API controls the InfoFrame values.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]     displayId         Monitor Identifier
//! \param [in,out] pInfoframeData    Contains data corresponding to InfoFrame
//!                  
//! \return    This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Disp_InfoFrameControl(__in NvU32 displayId, __inout NV_INFOFRAME_DATA *pInfoframeData);






//! \ingroup dispcontrol
//! @{
///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_Disp_ColorControl
//
//! \fn NvAPI_Disp_ColorControl(NvU32 displayId, NV_COLOR_DATA *pColorData)
//! DESCRIPTION:    This API controls the Color values.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]     displayId         Monitor Identifier
//! \param [in,out] pColorData        Contains data corresponding to color information
//!                  
//! \return  RETURN STATUS:
//! ::NVAPI_OK,  
//! ::NVAPI_ERROR, 
//! ::NVAPI_INVALID_ARGUMENT
//
///////////////////////////////////////////////////////////////////////////////

typedef enum
{
    NV_COLOR_CMD_GET                 = 1,
    NV_COLOR_CMD_SET,
    NV_COLOR_CMD_IS_SUPPORTED_COLOR,
    NV_COLOR_CMD_GET_DEFAULT
} NV_COLOR_CMD;

//!  See Table 14 of CEA-861E.  Not all of this is supported by the GPU.
typedef enum
{
    NV_COLOR_FORMAT_RGB             = 0,
    NV_COLOR_FORMAT_YUV422,
    NV_COLOR_FORMAT_YUV444,

    NV_COLOR_FORMAT_DEFAULT         = 0xFE,
    NV_COLOR_FORMAT_AUTO            = 0xFF
} NV_COLOR_FORMAT;



typedef enum
{
    NV_COLOR_COLORIMETRY_RGB             = 0,
    NV_COLOR_COLORIMETRY_YCC601,
    NV_COLOR_COLORIMETRY_YCC709,
    NV_COLOR_COLORIMETRY_XVYCC601,
    NV_COLOR_COLORIMETRY_XVYCC709,
    NV_COLOR_COLORIMETRY_SYCC601,
    NV_COLOR_COLORIMETRY_ADOBEYCC601,
    NV_COLOR_COLORIMETRY_ADOBERGB,
    NV_COLOR_COLORIMETRY_BT2020RGB,
    NV_COLOR_COLORIMETRY_BT2020YCC,
    NV_COLOR_COLORIMETRY_BT2020cYCC,

    NV_COLOR_COLORIMETRY_DEFAULT         = 0xFE,
    NV_COLOR_COLORIMETRY_AUTO            = 0xFF
} NV_COLOR_COLORIMETRY;

typedef enum _NV_DYNAMIC_RANGE
{
    NV_DYNAMIC_RANGE_VESA     = 0x0,
    NV_DYNAMIC_RANGE_CEA      = 0x1,

    NV_DYNAMIC_RANGE_AUTO     = 0xFF
} NV_DYNAMIC_RANGE;

typedef enum _NV_BPC
{
    NV_BPC_DEFAULT         = 0,
    NV_BPC_6               = 1,
    NV_BPC_8               = 2,
    NV_BPC_10              = 3,
    NV_BPC_12              = 4,
    NV_BPC_16              = 5,
} NV_BPC;

typedef struct _NV_COLOR_DATA_V1
{
    NvU32 version; //!< Version of this structure
    NvU16 size;    //!< Size of this structure
    NvU8  cmd;
    struct
    {
        NvU8  colorFormat;    //!< One of NV_COLOR_FORMAT enum values.
        NvU8  colorimetry;    //!< One of NV_COLOR_COLORIMETRY enum values.
    } data;
} NV_COLOR_DATA_V1;

typedef struct _NV_COLOR_DATA_V2
{
    NvU32 version; //!< Version of this structure
    NvU16 size;    //!< Size of this structure
    NvU8  cmd;
    struct
    {
        NvU8  colorFormat;    //!< One of NV_COLOR_FORMAT enum values.
        NvU8  colorimetry;    //!< One of NV_COLOR_COLORIMETRY enum values.
        NvU8  dynamicRange;   //!< One of NV_DYNAMIC_RANGE enum values.
    } data;
} NV_COLOR_DATA_V2;

typedef struct _NV_COLOR_DATA_V3
{
    NvU32 version; //!< Version of this structure
    NvU16 size;    //!< Size of this structure
    NvU8  cmd;
    struct
    {
        NvU8     colorFormat;    //!< One of NV_COLOR_FORMAT enum values.
        NvU8     colorimetry;    //!< One of NV_COLOR_COLORIMETRY enum values.
        NvU8     dynamicRange;   //!< One of NV_DYNAMIC_RANGE enum values.
        NV_BPC   bpc;            //!< One of NV_BPC enum values.
    } data;
} NV_COLOR_DATA_V3;

typedef NV_COLOR_DATA_V3    NV_COLOR_DATA;

#define NV_COLOR_DATA_VER1  MAKE_NVAPI_VERSION(NV_COLOR_DATA_V1, 1)
#define NV_COLOR_DATA_VER2  MAKE_NVAPI_VERSION(NV_COLOR_DATA_V2, 2)
#define NV_COLOR_DATA_VER3  MAKE_NVAPI_VERSION(NV_COLOR_DATA_V3, 3)
#define NV_COLOR_DATA_VER   NV_COLOR_DATA_VER3

NVAPI_INTERFACE NvAPI_Disp_ColorControl(NvU32 displayId, NV_COLOR_DATA *pColorData);

//! @}


//! \ingroup dispcontrol
//! @{
 
///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DISP_GetVirtualModeData
//
//! \fn NvAPI_DISP_GetVirtualModeData(NvU32 displayId, NV_VIRTUALMODE_DATA *virtualModeData)
//! DESCRIPTION:     This API lets the caller get state information related to
//!                  virtual mode.  See NvAPI_DISP_OverrideDisplayModeList().
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      displayId        Display ID of display to override the
//!                                            mode list. Retrieved from 
//!                                            NvAPI_SYS_GetDisplayIdFromGpuAndOutputId().
//! \param [in,out]  virtualModeData  The type of information to retrieve
//!
//! \return 
//! ::NVAPI_OK,  
//! ::NVAPI_API_NOT_INTIALIZED,  
//! ::NVAPI_ERROR,  
//! ::NVAPI_INVALID_ARGUMENT
//
///////////////////////////////////////////////////////////////////////////////
typedef enum
{
    NV_VIRTUALMODE_CMD_GET_INFO = 1,
} NV_VIRTUALMODE_CMD;

typedef struct
{
    NvU32 isCapableOfVirtualMode : 1;  //!< Set to 1 if system is capable of supporting virtual mode
    NvU32 isInVirtualMode        : 1;  //!< Set to 1 if system is currently in virtual mode; 0, otherwise
    NvU32 reserved               : 30;
} NV_VIRTUALMODE_INFO;

typedef struct
{
    NvU32               version;
    NV_VIRTUALMODE_CMD  cmd;
    union
    {
        NV_VIRTUALMODE_INFO virtualModeInfo;
    } data;
} NV_VIRTUALMODE_DATA;

//! Macro for constructing the version field of ::NV_VIRTUALMODE_DATA
#define NV_VIRTUALMODE_DATA_VER   MAKE_NVAPI_VERSION(NV_VIRTUALMODE_DATA,1)

NVAPI_INTERFACE NvAPI_DISP_GetVirtualModeData(NvU32 displayId, NV_VIRTUALMODE_DATA *virtualModeData);

//! @}




//! \ingroup dispcontrol
//! @{
///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DISP_OverrideDisplayModeList
//
//! \fn NvAPI_DISP_OverrideDisplayModeList(NvU32 displayId, NvU32 modeCount, NV_DISPLAY_MODE_INFO* modeList, NvU32 enableOutput)
//! DESCRIPTION:     This API lets the caller override the Display Mode List.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]       displayId     Display ID of display to override the
//!                                 mode list. Retrieved from 
//!                                 NvAPI_SYS_GetDisplayIdFromGpuAndOutputId().
//! \param [in]       modeCount     Number of supplied elements in modeList - 
//!                                 passing in 0 will disable mode list override.
//! \param [in]       modeList      Array of NV_DISPLAY_MODE_INFO elements. Pass
//!                                 in NULL with modeCount is 0.
//! \param [in]       enableOutput  when set allows monitor output; must be 0
//!                                 if modeCount is 0.
//!
//! \return 
//! ::NVAPI_OK,  
//! ::NVAPI_API_NOT_INTIALIZED,  
//! ::NVAPI_ERROR,  
//! ::NVAPI_INVALID_ARGUMENT 
//
///////////////////////////////////////////////////////////////////////////////


typedef struct _NV_DISPLAY_MODE_INFO
{
    NvU32    version;
    NvU32    width;
    NvU32    height;
    NvU32    depth;
    NvU32    refreshRate1K;         //!< Refresh rate * 1000
    NvU32    preferred      :  1;   //!< Set to true if a preferred mode, false for non-preferred
    NvU32    reserved       : 31;
} NV_DISPLAY_MODE_INFO;

//! Macro for contructing the version field of ::NV_DISPLAY_MODE_INFO
#define NV_DISPLAY_MODE_INFO_VER   MAKE_NVAPI_VERSION(NV_DISPLAY_MODE_INFO,1)

NVAPI_INTERFACE NvAPI_DISP_OverrideDisplayModeList(NvU32 displayId, NvU32 modeCount, NV_DISPLAY_MODE_INFO* modeList, NvU32 enableOutput);

//! @}



//! \ingroup dispcontrol
//! Used in NvAPI_GetDVCInfo()
typedef struct
{
    NvU32   version;            //!< [IN] Version info  
    NvU32   currentLevel;       //!< [OUT] The current DVC level
    NvU32   minLevel;           //!< [OUT] Minimim range level
    NvU32   maxLevel;           //!< [OUT] Maximum range level
} NV_DISPLAY_DVC_INFO;

//! \ingroup dispcontrol
#define NV_DISPLAY_DVC_INFO_VER  MAKE_NVAPI_VERSION(NV_DISPLAY_DVC_INFO,1)


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetDVCInfo
//
//! This function retrieves the Digital Vibrance Control (DVC) information of the selected display.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 95
//!
//! \param [in]  hNvDisplay  NVIDIA Display selection. It can be #NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//! \param [in]  outputId    One of the selected outputId retrieved from NvAPI_GPU_GetActiveOutputs() or NvAPI_GetView(), to identify the target 
//!                          output in case multiple targets are associated with the selected hNvDisplay. 
//!                          Can be NULL to pick the display output ID associated with hNvDisplay. See \ref handles.
//! \param [out] pDVCInfo    The returned DVC information.
//!
//! \retval  NVAPI_OK                           Call successful.
//! \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND      No NVIDIA GPU driving a display was found.
//! \retval  NVAPI_EXPECTED_DISPLAY_HANDLE      hNvDisplay is not a valid display handle.
//! \retval  NVAPI_INVALID_ARGUMENT             pDVCInfo is NULL.
//! \retval  NVAPI_INCOMPATIBLE_STRUCT_VERSION  The version of the NV_DISPLAY_DVC_INFO struct is not supported
//! \retval  NVAPI_NOT_SUPPORTED                DVC feature is not supported on the selected GPU
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetDVCInfo(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_DISPLAY_DVC_INFO *pDVCInfo);





///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SetDVCLevel
//
//!  This function sets the DVC level for the selected display.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 95
//!
//! \param [in]  hNvDisplay      NVIDIA Display selection. It can be #NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//! \param [in]  outputId        One of the selected outputId retrieved from NvAPI_GPU_GetActiveOutputs() or NvAPI_GetView(), to identify the target 
//!                              output in case multiple targets are associated with the selected hNvDisplay.
//!                              Can be NULL to pick the display output id associated with hNvDisplay. See \ref handles.
//! \param [out] level           The new level to apply. Value should be within the range of min and max.
//!
//! \retval  NVAPI_OK                       Call successful.
//! \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found.
//! \retval  NVAPI_EXPECTED_DISPLAY_HANDLE  hNvDisplay is not a valid display handle.
//! \retval  NVAPI_NOT_SUPPORTED            DVC is not supported on the selected GPU
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetDVCLevel(NvDisplayHandle hNvDisplay, NvU32 outputId, NvU32 level);



//! \ingroup dispcontrol
//! Used in NvAPI_GetDVCInfoEx() and NvAPI_SetDVCLevelEx()
typedef struct
{
    NvU32   version;            //!< IN version info  
    NvS32   currentLevel;       //!< OUT current DVC level
    NvS32   minLevel;           //!< OUT min range level
    NvS32   maxLevel;           //!< OUT max range level
    NvS32   defaultLevel;       //!< OUT default DVC level
} NV_DISPLAY_DVC_INFO_EX;

//! \ingroup dispcontrol
//! Macro for constucting the version field of NV_DISPLAY_DVC_INFO_EX
#define NV_DISPLAY_DVC_INFO_EX_VER  MAKE_NVAPI_VERSION(NV_DISPLAY_DVC_INFO_EX,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetDVCInfoEx
//
//!   DESCRIPTION: This API retrieves the Digital Vibrance Control(DVC) information of the selected display.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]  hNvDisplay   NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//! \param [in]  outputId     One of the selected outputId retrieved from NvAPI_GPU_GetActiveOutputs() or NvAPI_GetView(), to identify the target
//!                           output in case multiple targets are associated with the selected hNvDisplay.
//!                           Can be NULL to pick the display output ID associated with hNvDisplay.
//! \param [out] pDVCInfo     The returned DVC information.
//!
//! \retval ::NVAPI_OK: call successful.
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found.
//! \retval ::NVAPI_EXPECTED_DISPLAY_HANDLE: hNvDisplay is not a valid display handle.
//! \retval ::NVAPI_INVALID_ARGUMENT: pDVCInfo is NULL.
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the NV_DISPLAY_DVC_INFO struct is not supported
//! \retval ::NVAPI_NOT_SUPPORTED - DVC feature is not supported on the selected GPU
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetDVCInfoEx(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_DISPLAY_DVC_INFO_EX *pDVCInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SetDVCLevelEx
//
//!   DESCRIPTION: This API sets the DVC level for the selected display.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [in] hNvDisplay  NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//! \param [in] outputId    One of the selected outputId retrieved from NvAPI_GPU_GetActiveOutputs() or NvAPI_GetView(), to identify the target
//!                         output in case multiple targets are associated with the selected hNvDisplay.
//!                         Can be NULL to pick the display output ID associated with hNvDisplay.
//! \param [in] dvcInfo     The new DVC to apply. This structure can be accessed by GetDVCInfo() API.
//!
//! \retval ::NVAPI_OK                       Call successful.
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found.
//! \retval ::NVAPI_EXPECTED_DISPLAY_HANDLE  hNvDisplay is not a valid display handle.
//! \retval ::NVAPI_NOT_SUPPORTED            DVC is not supported on the selected GPU
//!
//! \ingroup dispcontrol 
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetDVCLevelEx(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_DISPLAY_DVC_INFO_EX *pDVCInfo);


//! \ingroup dispcontrol
//! Used in NvAPI_GetHUEInfo()
typedef struct
{
    NvU32   version;            //!< IN Version info
    NvU32   currentHueAngle;    //!< OUT Current HUE Angle. Typically between 0 - 360 degrees
    NvU32   defaultHueAngle;    //!< OUT Default HUE Angle
} NV_DISPLAY_HUE_INFO;

//! \ingroup dispcontrol
//! Macro for constructing the version field of NV_DISPLAY_HUE_INFO 
#define NV_DISPLAY_HUE_INFO_VER  MAKE_NVAPI_VERSION(NV_DISPLAY_HUE_INFO,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetHUEInfo
//
//!   DESCRIPTION: This API retrieves the HUE information of the selected display.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [in] hNvDisplay   NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//! \param [in] outputId     One of the selected outputId retrieved from NvAPI_GPU_GetActiveOutputs() or NvAPI_GetView(), to identify the target 
//!                          output in case multiple targets are associated with the selected hNvDisplay.
//!                          Can be NULL to pick the display output id associated with hNvDisplay.
//! \param [out] pHUEInfo    The returned HUE information.
//!
//! \retval ::NVAPI_OK                        Call successful.
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND   No NVidia GPU driving a display was found.
//! \retval ::NVAPI_EXPECTED_DISPLAY_HANDLE   hNvDisplay is not a valid display handle.
//! \retval ::NVAPI_INVALID_ARGUMENT          pHUEInfo is NULL.
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION  The version of the NV_DISPLAY_HUE_INFO struct is not supported
//! \retval ::NVAPI_NOT_SUPPORTED             HUE feature is not supported on the selected GPU
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetHUEInfo(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_DISPLAY_HUE_INFO *pHUEInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SetHUEAngle
//
//!  DESCRIPTION: This API sets the HUE level for the selected display.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]  hNvDisplay  NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//! \param [in]  outputId    One of the selected outputId retrieved from NvAPI_GPU_GetActiveOutputs() or NvAPI_GetView(), to identify the target 
//!                          output in case multiple targets are associated with the selected hNvDisplay.
//!                          Can be NULL to pick the display output ID associated with hNvDisplay.
//! \param [in]  level       The new level to apply. Value should be within the range of minimum and maximum.
//!
//! \retval ::NVAPI_OK                        Call successful.
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND   No NVidia GPU driving a display was found.
//! \retval ::NVAPI_EXPECTED_DISPLAY_HANDLE   hNvDisplay is not a valid display handle.
//! \retval ::NVAPI_NOT_SUPPORTED             HUE feature is not supported on the selected GPU.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetHUEAngle(NvDisplayHandle hNvDisplay, NvU32 outputId, NvU32 hueAngle);





//! \ingroup dispcontrol
//! Used in NvAPI_GetImageSharpeningInfo()
typedef struct
{
    NvU32   version;            //!< IN version info
    NvU32   currentLevel;       //!< OUT current Image Sharpening level
    NvU32   minLevel;           //!< OUT min range level
    NvU32   maxLevel;           //!< OUT max range level
} NV_DISPLAY_IMAGE_SHARPENING_INFO;

//! \ingroup dispcontrol
#define NV_DISPLAY_IMAGE_SHARPENING_INFO_VER  MAKE_NVAPI_VERSION(NV_DISPLAY_IMAGE_SHARPENING_INFO,1)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetImageSharpeningInfo
//
//!  This function retrieves the Image Sharpening information of the selected display.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 95
//!
//! \param [in]  hNvDisplay            NVIDIA Display selection. It can be #NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//! \param [in]  outputId              One of the selected outputId retrieved from NvAPI_GPU_GetActiveOutputs() or NvAPI_GetView(), to identify the target 
//!                                    output in case multiple targets are associated with the selected hNvDisplay.
//!                                    Can be NULL to pick the display output id associated with hNvDisplay. See \ref handles.
//! \param [out] pImageSharpeningInfo  The returned Image Sharpening information.
//!
//! \retval  NVAPI_OK: call successful.
//! \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND      No NVIDIA GPU driving a display was found.
//! \retval  NVAPI_EXPECTED_DISPLAY_HANDLE      hNvDisplay is not a valid display handle.
//! \retval  NVAPI_INVALID_ARGUMENT             pImageSharpeningInfo is NULL.
//! \retval  NVAPI_INCOMPATIBLE_STRUCT_VERSION  The version of the NV_DISPLAY_IMAGE_SHARPENING_INFO struct is not supported
//! \retval  NVAPI_NOT_SUPPORTED                Image Sharpening is not supported on the selected GPU
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetImageSharpeningInfo(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_DISPLAY_IMAGE_SHARPENING_INFO *pImageSharpeningInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SetImageSharpeningLevel
//
//!  This function sets the Image Sharpening level for the selected display.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 95
//!
//! \param [in]   hNvDisplay  NVIDIA Display selection. It can be #NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//! \param [in]   outputId    One of the selected outputId retrieved from NvAPI_GPU_GetActiveOutputs() or NvAPI_GetView(), to identify the target 
//!                           output in case multiple targets are associated with the selected hNvDisplay. 
//!                           Can be NULL to pick the display output id associated with hNvDisplay. See \ref handles.
//! \param [in]   level       The new level to apply. Value should be within the range of min and max.
//!
//! \retval  NVAPI_OK                       Call successful.
//! \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found.
//! \retval  NVAPI_EXPECTED_DISPLAY_HANDLE  hNvDisplay is not a valid display handle.
//! \retval  NVAPI_NOT_SUPPORTED            Image Sharpening is not supported on the selected GPU
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetImageSharpeningLevel(NvDisplayHandle hNvDisplay, NvU32 outputId, NvU32 level);







//! \ingroup tvapi
//! Use in NvAPI_SetTVEncoderControls() and NvAPI_GetTVEncoderControls().
typedef struct
{
    NvU32   version;                //!< [IN] Version info  

    struct
    {
        NvU32   defaultLevel;       //!< [OUT] Default level
        NvU32   currentLevel;       //!< [IN/OUT] Current level
        NvU32   minLevel;           //!< [OUT] Minimum range level
        NvU32   maxLevel;           //!< [OUT] Maximum range level
    }   flicker, saturation;

} NV_TV_ENCODER_CONTROLS;

//! \ingroup tvapi
#define NV_TV_ENCODER_CONTROLS_VER  MAKE_NVAPI_VERSION(NV_TV_ENCODER_CONTROLS,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetTVEncoderControls
//
//!   DESCRIPTION: This function retrieves the flicker and saturation levels for the selected TV.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 165
//!
//!  \param [in]   hNvDisplay      NVIDIA Display selection. It can be #NVAPI_DEFAULT_HANDLE or 
//!                                a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//!  \param [in]   outputId        One of the selected outputId retrieved from NvAPI_GPU_GetActiveOutputs() or 
//!                                NvAPI_GetView(), to identify the target output in case multiple targets are 
//!                                associated with the selected hNvDisplay. 
//!                                Can be NULL to pick the display output ID associated with hNvDisplay. See \ref handles.
//!  \param [out]  pTvEncoderInfo  The returned TV encoder controls and its levels. See \ref NV_TV_ENCODER_CONTROLS.
//! 
//!  \note If maxLevel and minLevel are both zero then that control is not supported on this GPU and should not be used.
//!
//!  \retval  NVAPI_OK                            Call successful.
//!  \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found.
//!  \retval  NVAPI_EXPECTED_DISPLAY_HANDLE       hNvDisplay is not a valid display handle.
//!  \retval  NVAPI_INVALID_ARGUMENT              pTvEncoderInfo is NULL.
//!  \retval  NVAPI_INCOMPATIBLE_STRUCT_VERSION   The version of the NV_TV_ENCODER_CONTROLS struct is not supported.
//!  \retval  NVAPI_NOT_SUPPORTED                 TV or this API is not supported on the selected GPU.
//!
//!  \ingroup tvapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetTVEncoderControls(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_TV_ENCODER_CONTROLS *pTvEncoderInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SetTVEncoderControls
//
//!   DESCRIPTION: This function sets the flicker and saturation levels for the selected TV.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 165
//!
//!  \param [in]   hNvDisplay      NVIDIA Display selection. It can be #NVAPI_DEFAULT_HANDLE or 
//!                                a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//!  \param [in]   outputId        One of the selected outputId retrieved from NvAPI_GPU_GetActiveOutputs() or 
//!                                NvAPI_GetView(), to identify the target output in case multiple targets are 
//!                                associated with the selected hNvDisplay. See \ref handles.
//!                                Can be NULL to pick the display output ID associated with hNvDisplay.
//!  \param [in]   pTvEncoderInfo  The selected TV encoder controls and its levels that are applied. See \ref NV_TV_ENCODER_CONTROLS.
//!
//!  \retval  NVAPI_OK                            Call successful.
//!  \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND       No NVIDIA GPU driving a display was found.
//!  \retval  NVAPI_EXPECTED_DISPLAY_HANDLE       hNvDisplay is not a valid display handle.
//!  \retval  NVAPI_INCOMPATIBLE_STRUCT_VERSION   The version of the NV_TV_ENCODER_CONTROLS struct is not supported.
//!  \retval  NVAPI_NOT_SUPPORTED                 TV or this API is not supported on the selected GPU.
//!
//!  \ingroup tvapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetTVEncoderControls(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_TV_ENCODER_CONTROLS *pTvEncoderInfo);

//! \ingroup tvapi
//! Used in NvAPI_SetTVOutputBorderColor() and NvAPI_GetTVOutputBorderColor().
typedef enum
{ 
    NV_TV_BORDER_COLOR_BLACK    = 0,
    NV_TV_BORDER_COLOR_GREY     = 1,
} NV_TV_BORDER_COLOR;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetTVOutputBorderColor
//
//!   DESCRIPTION: This function retrieves the color of the TV border.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 165
//!
//!   \param [in]  hNvDisplay     NVIDIA Display selection. It can be #NVAPI_DEFAULT_HANDLE or 
//!                               a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//!   \param [in]  outputId       One of the selected outputId retrieved from NvAPI_GPU_GetActiveOutputs() or 
//!                               NvAPI_GetView(), to identify the target output in case multiple targets are 
//!                               associated with the selected hNvDisplay.
//!                               Can be NULL to pick the display output ID associated with hNvDisplay. See \ref handles.
//!   \param [out] pBorderColor   The returned TV border color.
//!
//!   \retval   NVAPI_OK                       Call successful.
//!   \retval   NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found.
//!   \retval   NVAPI_EXPECTED_DISPLAY_HANDLE  hNvDisplay is not a valid display handle.
//!   \retval   NVAPI_INVALID_ARGUMENT         pBorderColor is NULL.
//!   \retval   NVAPI_NOT_SUPPORTED            TV or this API is not supported on the selected GPU.
//!
//!   \ingroup tvapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetTVOutputBorderColor(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_TV_BORDER_COLOR *pBorderColor);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SetTVOutputBorderColor
//
//!   DESCRIPTION: This function sets the color of the TV border.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 165
//!
//!   \param [in]  hNvDisplay     NVIDIA Display selection. It can be #NVAPI_DEFAULT_HANDLE or 
//!                               a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//!   \param [in]  outputId       One of the selected outputId retrieved from NvAPI_GPU_GetActiveOutputs or 
//!                               NvAPI_GetView, to identify the target output in case multiple targets are 
//!                               associated with the selected hNvDisplay. See \ref handles.
//!                               Can be NULL to pick the display output ID associated with hNvDisplay.
//!   \param [in]  pBorderColor   The TV border color to set.
//!
//!   \retval   NVAPI_OK                       Call successful.
//!   \retval   NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found.
//!   \retval   NVAPI_EXPECTED_DISPLAY_HANDLE  hNvDisplay is not a valid display handle.
//!   \retval   NVAPI_NOT_SUPPORTED            TV or this API is not supported on the selected GPU.
//!
//!   \ingroup tvapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetTVOutputBorderColor(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_TV_BORDER_COLOR borderColor);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetDisplayPosition
//
//!   DESCRIPTION: This function retrieves the display position of the associated analog display.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 165
//!
//!   \param [in]  hNvDisplay     NVIDIA Display selection. It can be #NVAPI_DEFAULT_HANDLE or 
//!                               a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//!   \param [in]  outputId       One of the selected outputId retrieved from NvAPI_GPU_GetActiveOutputs or 
//!                               NvAPI_GetView, to identify the target output in case multiple targets are 
//!                               associated with the selected hNvDisplay. See \ref handles.
//!                               Can be NULL to pick the display output ID associated with hNvDisplay.
//!   \param [out] pXOffset       The returned display position x-offset.  
//!   \param [out] pYOffset       The returned display position y-offset.
//!
//!   \retval   NVAPI_OK                       Call successful.
//!   \retval   NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found.
//!   \retval   NVAPI_EXPECTED_DISPLAY_HANDLE  hNvDisplay is not a valid display handle.
//!   \retval   NVAPI_INVALID_ARGUMENT         pXOffset or pYOffset is NULL.
//!   \retval   NVAPI_NOT_SUPPORTED            This API is not supported.
//!   \retval   NVAPI_EXPECTED_ANALOG_DISPLAY  The selected display is not an analog display.
//!
//!   \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetDisplayPosition(NvDisplayHandle hNvDisplay, NvU32 outputId, NvU32 *pXOffset, NvU32 *pYOffset);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SetDisplayPosition
//
//!   DESCRIPTION: This function sets the display position of the associated analog display.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 165
//!
//!   \param [in]  hNvDisplay     NVIDIA Display selection. It can be #NVAPI_DEFAULT_HANDLE or 
//!                               a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//!   \param [in]  outputId       One of the selected outputId retrieved from NvAPI_GPU_GetActiveOutputs or 
//!                               NvAPI_GetView, to identify the target output in case multiple targets are 
//!                               associated with the selected hNvDisplay. See \ref handles.
//!                               Can be NULL to pick the display output ID associated with hNvDisplay.
//!   \param [in]  XOffset        The set display position x-offset.  
//!   \param [in]  YOffset        The set display position y-offset.
//!
//!   \retval   NVAPI_OK                       Call successful.
//!   \retval   NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found.
//!   \retval   NVAPI_EXPECTED_DISPLAY_HANDLE  hNvDisplay is not a valid display handle.
//!   \retval   NVAPI_NOT_SUPPORTED            This API is not supported.
//!   \retval   NVAPI_EXPECTED_ANALOG_DISPLAY  The selected display is not an analog display.
//!
//!   \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetDisplayPosition(NvDisplayHandle hNvDisplay, NvU32 outputId, NvU32 xOffset, NvU32 yOffset);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_RmConfigGet
//
//!    This is a TEMPORARY implementation of the resource manager configGet for LDDM.
//!    This escape is meant for use by swak only.  Please contact 
//!    sw-nvapi if you wish to use this interface.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! Earliest supported ForceWare version: 82.61
//!
//! \return  NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_RmConfigGet(NvDisplayHandle hNvDisplay,NvU32 opcode,NvU32 *pValue);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetGFAHandle()
//
//!   DESCRIPTION: Used by driver security tools.  Not for export outside NVIDIA.
//!                Contact Andrei Osnovich regarding this API.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \return NVAPI_ERROR or NVAPI_OK
//!
//! 
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetGFAHandle(void **GFAHandle);





///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetDisplaySettings
//
//!  This function retrieves the target display arrangement for a selected display source.
//!  \note Display PATH with this API is limited to a single GPU. DUALVIEW across GPUs will be returned as STANDARD VIEW. 
//!        Use NvAPI_SYS_GetDisplayTopologies() to query views across GPUs.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 100
//!
//! \param [in]   hNvDisplay      NVIDIA Display selection \n
//!                               #NVAPI_DEFAULT_HANDLE is not allowed, it must be a handle enumerated with NvAPI_EnumNVidiaDisplayHandle().
//! \param [out]  pPaths          Detailed target display arrangement for clone, span, and edge blending display modes.
//! \param [out]  pathCount       Count of targets for the selected display source.
//!
//! \return    This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//!
//! \retval    NVAPI_DEVICE_BUSY       -   ModeSet has not yet completed. Please wait and call it again.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetDisplaySettings(NvDisplayHandle hNvDisplay, NV_DISP_PATH *pPaths, NvU32 *pPathCount);

//! \ingroup dispcontrol
//! Used in NvAPI_DISP_GetTiming().
typedef struct
{
    NvU32                   isInterlaced   : 4;  //!< To retrieve interlaced/progressive timing
    NvU32                   reserved0      : 12;
    union
    {
        NvU32               tvFormat       : 8;  //!< The actual analog HD/SDTV format. Used when the timing type is 
                                                 //!  NV_TIMING_OVERRIDE_ANALOG_TV and width==height==rr==0.
        NvU32               ceaId          : 8;  //!< The EIA/CEA 861B/D predefined short timing descriptor ID. 
                                                 //!  Used when the timing type is NV_TIMING_OVERRIDE_EIA861
                                                 //!  and width==height==rr==0.
        NvU32               nvPsfId        : 8;  //!< The NV predefined PsF format Id. 
                                                 //!  Used when the timing type is NV_TIMING_OVERRIDE_NV_PREDEFINED.
    };
    NvU32                   scaling        : 8;  //!< Define preferred scaling
}NV_TIMING_FLAG;

//! \ingroup dispcontrol
//! Used in NvAPI_DISP_GetTiming().
typedef struct _NV_TIMING_INPUT
{
    NvU32 version;                      //!< (IN)     structure version
    
    NvU32 width;						//!< Visible horizontal size
    NvU32 height;						//!< Visible vertical size 
    float rr;							//!< Timing refresh rate
        
    NV_TIMING_FLAG flag;				//!< Flag containing additional info for timing calculation.
    
    NV_TIMING_OVERRIDE type;			//!< Timing type(formula) to use for calculating the timing
}NV_TIMING_INPUT;

#define NV_TIMING_INPUT_VER   MAKE_NVAPI_VERSION(NV_TIMING_INPUT,1)

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetTiming
//
//! \fn NvAPI_GetTiming(NvDisplayHandle hNvDisplay, NvU32 width, NvU32 height, float rr, NV_TIMING_FLAG flag, NvU32 outputId,
//! DESCRIPTION:  This function calculates the timing from the visible width/height/refresh-rate and timing type info.
//!
//! \deprecated  Do not use this function - it is deprecated in release 313. Instead, use NvAPI_DISP_GetTiming.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//!
//! \param [in]   hNvDisplay  NVIDIA Display selection \n
//!                           #NVAPI_DEFAULT_HANDLE is not allowed, it has to be a handle enumerated with NvAPI_EnumNVidiaDisplayHandle().
//! \param [in]   width       Visible horizontal size
//! \param [in]   height      Visible vertical size 
//! \param [in]   rr          Timing refresh rate 
//! \param [in]   flag        Flag containing additional info for timing calculation.
//! \param [in]   outputId    The monitor Id(mask) - only used to get the EDID timing or custom timing or NV policy related timing. See \ref handles.
//!                           (NV_TIMING_OVERRIDE_AUTO).
//! \param [in]   type        Timing type(formula) to use for calculating the timing
//! \param [out]  pT          Pointer to the NV_TIMING structure 
//!
//! \retval                 NVAPI_OK                Completed request
//! \retval                 NVAPI_ERROR             Miscellaneous error occurred
//! \retval                 NVAPI_INVALID_ARGUMENT  Invalid input parameter.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////

//! \addtogroup dispcontrol
//! @{

//! Get CEA format (digital TV format) from NV_TIMING(::etc.status)
#define NV_GET_CEA_FORMAT(n) (((n)&0x3F800000)>>23)     

//! Get the analog TV format from NV_TIMING(::etc.status)
#define NV_GET_ANALOG_TV_FORMAT(n) ((((n)&0x0FF00)==0x1100||((n)&0x0FF00)==0x1200)?((n)&0x0FF):0)   

//! Check if the timing(NV_TIMING::etc.status) is an analog TV format
#define NV_IS_ANALOG_TV_FORMAT(n)  ((((n)&0x0FF00)==0x1100||((n)&0x0FF00)==0x1200)?1:0)    

//! @}

//! \ingroup dispcontrol 
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 313. Instead, use NvAPI_DISP_GetTiming.")
NVAPI_INTERFACE NvAPI_GetTiming(NvDisplayHandle hNvDisplay, NvU32 width, NvU32 height, float rr, NV_TIMING_FLAG flag, NvU32 outputId, NV_TIMING_OVERRIDE type, NV_TIMING *pT); 

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DISP_GetTiming
//
//! DESCRIPTION:  This function calculates the timing from the visible width/height/refresh-rate and timing type info.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 313  
//!
//!
//! \param [in]   displayId		Display ID of the display.
//! \param [in]   timingInput   Inputs used for calculating the timing.
//! \param [out]  pTiming       Pointer to the NV_TIMING structure. 
//!
//! \return        This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_GetTiming( __in NvU32 displayId,__in NV_TIMING_INPUT *timingInput, __out NV_TIMING *pTiming); 



///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DISP_GetMonitorCapabilities
//
//! \fn NvAPI_DISP_GetMonitorCapabilities(NvU32 displayId, NV_MONITOR_CAPABILITIES *pMonitorCapabilities)
//! DESCRIPTION:     This API returns the Monitor capabilities 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      displayId                Monitor Identifier
//! \param [out]     pMonitorCapabilities     The monitor support info
//!
//! \return ::NVAPI_OK, 
//!         ::NVAPI_ERROR, 
//!         ::NVAPI_INVALID_ARGUMENT
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup dispcontrol
//! @{


//! HDMI-related and extended CAPs
typedef enum
{
    // hdmi related caps
    NV_MONITOR_CAPS_TYPE_HDMI_VSDB = 0x1000,
    NV_MONITOR_CAPS_TYPE_HDMI_VCDB = 0x1001,
    // backend caps
    NV_MONITOR_CAPS_TYPE_GENERIC   = 0x1002,
} NV_MONITOR_CAPS_TYPE;



typedef struct _NV_MONITOR_CAPS_VCDB
{
    NvU8    quantizationRangeYcc         : 1;
    NvU8    quantizationRangeRgb         : 1;
    NvU8    scanInfoPreferredVideoFormat : 2;
    NvU8    scanInfoITVideoFormats       : 2;
    NvU8    scanInfoCEVideoFormats       : 2;
} NV_MONITOR_CAPS_VCDB;


//! See NvAPI_DISP_GetMonitorCapabilities().
typedef struct _NV_MONITOR_CAPS_VSDB
{
    // byte 1
    NvU8    sourcePhysicalAddressB         : 4; //!< Byte 1
    NvU8    sourcePhysicalAddressA         : 4; //!< Byte 1
    // byte 2
    NvU8    sourcePhysicalAddressD         : 4; //!< Byte 2
    NvU8    sourcePhysicalAddressC         : 4; //!< Byte 2
    // byte 3
    NvU8    supportDualDviOperation        : 1; //!< Byte 3
    NvU8    reserved6                      : 2; //!< Byte 3
    NvU8    supportDeepColorYCbCr444       : 1; //!< Byte 3
    NvU8    supportDeepColor30bits         : 1; //!< Byte 3
    NvU8    supportDeepColor36bits         : 1; //!< Byte 3
    NvU8    supportDeepColor48bits         : 1; //!< Byte 3
    NvU8    supportAI                      : 1; //!< Byte 3 
    // byte 4
    NvU8    maxTmdsClock;  //!< Bye 4
    // byte 5
    NvU8    cnc0SupportGraphicsTextContent : 1; //!< Byte 5
    NvU8    cnc1SupportPhotoContent        : 1; //!< Byte 5
    NvU8    cnc2SupportCinemaContent       : 1; //!< Byte 5
    NvU8    cnc3SupportGameContent         : 1; //!< Byte 5
    NvU8    reserved8                      : 1; //!< Byte 5
    NvU8    hasVicEntries                  : 1; //!< Byte 5
    NvU8    hasInterlacedLatencyField      : 1; //!< Byte 5
    NvU8    hasLatencyField                : 1; //!< Byte 5    
    // byte 6
    NvU8    videoLatency; //!< Byte 6
    // byte 7
    NvU8    audioLatency; //!< Byte 7
    // byte 8
    NvU8    interlacedVideoLatency; //!< Byte 8
    // byte 9
    NvU8    interlacedAudioLatency; //!< Byte 9
    // byte 10
    NvU8    reserved13                     : 7; //!< Byte 10
    NvU8    has3dEntries                   : 1; //!< Byte 10   
    // byte 11
    NvU8    hdmi3dLength                   : 5; //!< Byte 11
    NvU8    hdmiVicLength                  : 3; //!< Byte 11
    // Remaining bytes
    NvU8    hdmi_vic[7];  //!< Keeping maximum length for 3 bits
    NvU8    hdmi_3d[31];  //!< Keeping maximum length for 5 bits 
} NV_MONITOR_CAPS_VSDB;

typedef struct _NV_MONITOR_CAPS_GENERIC
{
    NvU8    supportVRR         : 1;  //!< monitor supports variable refresh rate. Valid for NV_MONITOR_CAPS_TYPE_GENERIC only. 
    NvU8    supportULMB        : 1;  //!< monitor supports ULMB with variable refresh rate. Valid for NV_MONITOR_CAPS_TYPE_GENERIC only.
    NvU8    reserved           : 6;
} NV_MONITOR_CAPS_GENERIC;


//! See NvAPI_DISP_GetMonitorCapabilities().
typedef struct _NV_MONITOR_CAPABILITIES_V1
{
    NvU32    version;
    NvU16    size;
    NvU32    infoType;
    NvU32    connectorType;        //!< Out: VGA, TV, DVI, HDMI, DP
    NvU8     bIsValidInfo : 1;     //!< Boolean : Returns invalid if requested info is not present such as VCDB not present
    union {
        NV_MONITOR_CAPS_VSDB  vsdb;
        NV_MONITOR_CAPS_VCDB  vcdb;
        NV_MONITOR_CAPS_GENERIC caps;
    } data;
} NV_MONITOR_CAPABILITIES_V1;

typedef NV_MONITOR_CAPABILITIES_V1 NV_MONITOR_CAPABILITIES;

//! Macro for constructing the version field of ::NV_MONITOR_CAPABILITIES_V1
#define NV_MONITOR_CAPABILITIES_VER1   MAKE_NVAPI_VERSION(NV_MONITOR_CAPABILITIES_V1,1)
#define NV_MONITOR_CAPABILITIES_VER    NV_MONITOR_CAPABILITIES_VER1

//! @}

//! SUPPORTED OS:  Windows Vista and higher
//!
//! \ingroup dispcontrol
NVAPI_INTERFACE NvAPI_DISP_GetMonitorCapabilities(__in NvU32 displayId, __inout NV_MONITOR_CAPABILITIES *pMonitorCapabilities);

//! \ingroup dispcontrol
typedef struct _NV_MONITOR_COLOR_DATA
{
    NvU32                   version;            
// We are only supporting DP monitors for now. We need to extend this to HDMI panels as well
    NV_DP_COLOR_FORMAT      colorFormat;        //!< One of the supported color formats
    NV_DP_BPC               backendBitDepths;   //!< One of the supported bit depths
} NV_MONITOR_COLOR_CAPS_V1;

typedef NV_MONITOR_COLOR_CAPS_V1 NV_MONITOR_COLOR_CAPS;

//! \ingroup dispcontrol
#define NV_MONITOR_COLOR_CAPS_VER1   MAKE_NVAPI_VERSION(NV_MONITOR_COLOR_CAPS_V1,1)
#define NV_MONITOR_COLOR_CAPS_VER    NV_MONITOR_COLOR_CAPS_VER1

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DISP_GetMonitorColorCapabilities
//
//! DESCRIPTION:    This API returns all the color formats and bit depth values supported by a given DP monitor. 
//!
//! USAGE:         Sequence of calls which caller should make to get the information.
//!                1. First call NvAPI_DISP_GetMonitorColorCapabilities() with pMonitorColorCapabilities as NULL to get the count.
//!                2. Allocate memory for color caps(NV_MONITOR_COLOR_CAPS) array.
//!                3. Call NvAPI_DISP_GetMonitorColorCapabilities() again with the pointer to the memory allocated to get all the 
//!                   color capabilities.
//!                   
//!                Note : 
//!                1. pColorCapsCount should never be NULL, else the API will fail with NVAPI_INVALID_ARGUMENT.
//!                2. *pColorCapsCount returned from the API will always be the actual count in any/every call.
//!                3. Memory size to be allocated should be (*pColorCapsCount * sizeof(NV_MONITOR_COLOR_CAPS)).
//!                4. If the memory allocated is less than what is required to return all the timings, this API will return the
//!                   amount of information which can fit in user provided buffer and API will return NVAPI_INSUFFICIENT_BUFFER.
//!                5. If the caller specifies a greater value for *pColorCapsCount in second call to NvAPI_DISP_GetMonitorColorCapabilities()
//!                   than what was returned from first call, the API will return only the actual number of elements in the color
//!                   capabilities array and the extra buffer will remain unused.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      displayId                  Monitor Identifier
//! \param [in, out] pMonitorColorCapabilities  The monitor color capabilities information
//! \param [in, out] pColorCapsCount            - During input, the number of elements allocated for the pMonitorColorCapabilities pointer
//!                                             - During output, the actual number of color data elements the monitor supports
//!
//! \return    This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//!
//! \retval         NVAPI_INSUFFICIENT_BUFFER   The input buffer size is not sufficient to hold the total contents. In this case
//!                                             *pColorCapsCount will hold the required amount of elements.
//! \retval         NVAPI_INVALID_DISPLAY_ID    The input monitor is either not connected or is not a DP panel.
//!
//! \ingroup dispcontrol
//!
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_GetMonitorColorCapabilities(__in NvU32 displayId, __inout_ecount_part_opt(*pColorCapsCount, *pColorCapsCount) NV_MONITOR_COLOR_CAPS *pMonitorColorCapabilities, __inout NvU32 *pColorCapsCount);

//! \ingroup dispcontrol
//! Used in NvAPI_DISP_EnumCustomDisplay() and NvAPI_DISP_TryCustomDisplay().
typedef struct
{
    NvU32                   version;
    
    // the source mode information
    NvU32                   width;             //!< Source surface(source mode) width
    NvU32                   height;            //!< Source surface(source mode) height
    NvU32                   depth;             //!< Source surface color depth."0" means all 8/16/32bpp
    NV_FORMAT               colorFormat;       //!< Color format (optional)
  
    NV_VIEWPORTF            srcPartition;      //!< For multimon support, should be set to (0,0,1.0,1.0) for now.
  
    float                   xRatio;            //!< Horizontal scaling ratio
    float                   yRatio;            //!< Vertical scaling ratio
                                                             
    NV_TIMING               timing;            //!< Timing used to program TMDS/DAC/LVDS/HDMI/TVEncoder, etc.
    NvU32                   hwModeSetOnly : 1; //!< If set, it means a hardware modeset without OS update
    
}NV_CUSTOM_DISPLAY; 

//! \ingroup dispcontrol
//! Used in NV_CUSTOM_DISPLAY.
#define NV_CUSTOM_DISPLAY_VER  MAKE_NVAPI_VERSION(NV_CUSTOM_DISPLAY,1)

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_EnumCustomDisplay
//
//! \fn NvAPI_EnumCustomDisplay(NvDisplayHandle hNvDisplay, NvU32 index, NvU32 outputId, NV_CUSTOM_DISPLAY *pC)
//! DESCRIPTION:     This function enumerates the custom displays.
//!
//! \deprecated  Do not use this function - it is deprecated in release 313. Instead, use NvAPI_DISP_EnumCustomDisplay.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//!
//! \param [in]      hNvDisplay  NVIDIA Display selection \n 
//!                              #NVAPI_DEFAULT_HANDLE is not allowed. It must be a handle enumerated with NvAPI_EnumNVidiaDisplayHandle().
//! \param [in]      index       Enum index
//! \param [in]      outputId    Monitor Id to which the custom display configuration should be obtained.
//!                              "-1" is to enum all custom display configurations. See \ref handles.
//! \param [out]     pC          Pointer to the NV_CUSTOM_DISPLAY structure 
//!
//! \retval          NVAPI_OK                Completed request
//! \retval          NVAPI_ERROR             Miscellaneous error occurred
//! \retval          NVAPI_INVALID_ARGUMENT  Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup dispcontrol 
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 313. Instead, use NvAPI_DISP_EnumCustomDisplay.")
NVAPI_INTERFACE NvAPI_EnumCustomDisplay(NvDisplayHandle hNvDisplay, NvU32 index, NvU32 outputId, NV_CUSTOM_DISPLAY *pC); 








///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_TryCustomDisplay
//
//! DESCRIPTION:    This API is a wrapper function of NvAPI_SetDisplaySettings() to set up a custom display without saving the configuration.
//!
//! \note
//!  All the members of srcPartition, present in NV_CUSTOM_DISPLAY structure, should have their range in (0.0,1.0).
//!  In clone mode the timings can applied to both the target monitors but only one target at a time. \n
//!  For the secondary target the applied timings works under the following conditions:
//!  - If the secondary monitor EDID supports the selected timing, OR
//!  - If the selected custom timings can be scaled by the secondary monitor for the selected source resolution on the primary, OR
//!  - If the selected custom timings matches the existing source resolution on the primary.
//!
//! \deprecated  Do not use this function - it is deprecated in release 313. Instead, use NvAPI_DISP_TryCustomDisplay.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//!
//! \param [in]    hNvDisplay     NVIDIA Display selection \n
//!                               #NVAPI_DEFAULT_HANDLE is not allowed, it must be a handle enumerated with NvAPI_EnumNVidiaDisplayHandle().
//! \param [in]    pDispOutId     Array of the target monitor output IDs - See \ref handles.
//! \param [in]    pCustDisp      Pointer to the NV_CUSTOM_DISPLAY structure
//! \param [in]    count          Total number of the incoming NV_CUSTOM_DISPLAY structure. This is for the multi-head support.
//! \param [in]    hwModeSetOnly  Option to let the user flush the timing without OS update
//!
//! \retval        NVAPI_OK                           Completed request
//! \retval        NVAPI_ERROR                        Miscellaneous error occurred
//! \retval        NVAPI_INVALID_ARGUMENT             Invalid input parameter.
//! \retval        NVAPI_NO_IMPLEMENTATION            Not implemented.
//! \retval        NVAPI_INCOMPATIBLE_STRUCT_VERSION  The version of NV_CUSTOM_DISPLAY is not supported.
//! 
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 313. Instead, use NvAPI_DISP_TryCustomDisplay.")
NVAPI_INTERFACE NvAPI_TryCustomDisplay(NvDisplayHandle hNvDisplay, NvU32 *pDispOutputId, NV_CUSTOM_DISPLAY *pCustDisp, NvU32 count, NvU32 hwModeSetOnly);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_RevertCustomDisplayTrial
//
//! DESCRIPTION:    This API is used to restore the old display configuration before NvAPI_TryCustomDisplay() was called. This function
//!                 must be called only after a custom display configuration is tested on the hardware, using NvAPI_TryCustomDisplay(),  
//!                 otherwise no action is taken.
//!                 This API is not supported under Windows XP, in which case it returns NVAPI_NO_IMPLEMENTATION.
//!
//! \deprecated  Do not use this function - it is deprecated in release 313. Instead, use NvAPI_DISP_RevertCustomDisplayTrial.
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 170
//!
//! \param [in]    hNvDisplay   NVIDIA Display selection
//!                             #NVAPI_DEFAULT_HANDLE is not allowed, it must be a handle enumerated with NvAPI_EnumNVidiaDisplayHandle().
//!
//! \retval        NVAPI_OK                Completed request
//! \retval        NVAPI_ERROR             Miscellaneous error occurred
//! \retval        NVAPI_INVALID_ARGUMENT  Invalid input parameter.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 313. Instead, use NvAPI_DISP_RevertCustomDisplayTrial.")
NVAPI_INTERFACE NvAPI_RevertCustomDisplayTrial(NvDisplayHandle hNvDisplay);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DeleteCustomDisplay
//
//! DESCRIPTION:    This function deletes the index-specified custom display configuration from the registry.
//!
//! \deprecated  Do not use this function - it is deprecated in release 313. Instead, use NvAPI_DISP_DeleteCustomDisplay.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//!
//! \param [in]     hNvDisplay       NVIDIA Display selection \n
//!                                  #NVAPI_DEFAULT_HANDLE is not allowed. It must be a handle enumerated with NvAPI_EnumNVidiaDisplayHandle().
//! \param [in]     displayOutputId  Display ID on which the underscan configuration is to be applied. It must be a legal display Id (one bit set)
//!                                  -"0" is allowed, and indicates the default display used by the hNvDisplay handle.
//!                                  -"-1" is allowed, and indicates that the "index" is the absolute index and not a displayOutputId-related
//!                                   index - the index of the custom display
//!
//! \retval                   NVAPI_OK - completed request
//! \retval                   NVAPI_ERROR - miscellaneous error occurred
//! \retval                   NVAPI_INVALID_ARGUMENT: Invalid input parameter.
//!
//! \ingroup dispcontrol 
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 313. Instead, use NvAPI_DISP_DeleteCustomDisplay.")
NVAPI_INTERFACE NvAPI_DeleteCustomDisplay(NvDisplayHandle hNvDisplay, NvU32 displayOutputId, NvU32 index); 

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SaveCustomDisplay
//
//! DESCRIPTION:    This function saves the current hardware display configuration on the specified output ID as a custom display configuration.
//!                 This function should be called right after NvAPI_TryCustomDisplay() to save the custom display from the current
//!                 hardware context. This function will not do anything if the custom display configuration is not tested on the hardware.
//!
//! \deprecated  Do not use this function - it is deprecated in release 313. Instead, use NvAPI_DISP_SaveCustomDisplay.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//!
//! \param [in]     hNvDisplay          NVIDIA Display selection \n
//!                                     NVAPI_DEFAULT_HANDLE not allowed, it has to be a handle enumerated with NvAPI_EnumNVidiaDisplayHandle().
//! \param [in]     isThisOutputIdOnly  If set, the saved custom display will only be applied on the monitor with the same outputId (see \ref handles).
//! \param [in]     isThisMonitorIdOnly If set, the saved custom display will only be applied on the monitor with the same EDID ID or 
//!                                     the same TV connector in case of analog TV.
//!
//! \retval         NVAPI_OK                Completed request
//! \retval         NVAPI_ERROR             Miscellaneous error occurred
//! \retval         NVAPI_INVALID_ARGUMENT  Invalid input parameter.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 313. Instead, use NvAPI_DISP_SaveCustomDisplay.")
NVAPI_INTERFACE NvAPI_SaveCustomDisplay(NvDisplayHandle hNvDisplay, NvU32 isThisOutputIdOnly, NvU32 isThisMonitorIdOnly);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DISP_EnumCustomDisplay
//
//! DESCRIPTION:   This API enumerates the custom timing specified by the enum index. 
//!				   The client should keep enumerating until it returns NVAPI_END_ENUMERATION.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 313 
//!
//! \param [in]     displayId   Dispaly ID of the display.
//! \param [in]     index       Enum index
//! \param [inout]  pCustDisp   Pointer to the NV_CUSTOM_DISPLAY structure 
//!
//! \return        This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
//! \retval        NVAPI_INVALID_DISPLAY_ID:   Custom Timing is not supported on the Display, whose display id is passed
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_EnumCustomDisplay( __in NvU32 displayId, __in NvU32 index, __inout NV_CUSTOM_DISPLAY *pCustDisp);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DISP_TryCustomDisplay
//
//! DESCRIPTION:    This API is used to set up a custom display without saving the configuration on multiple displays.
//!
//! \note
//!  All the members of srcPartition, present in NV_CUSTOM_DISPLAY structure, should have their range in (0.0,1.0).
//!  In clone mode the timings can applied to both the target monitors but only one target at a time. \n
//!  For the secondary target the applied timings works under the following conditions:
//!  - If the secondary monitor EDID supports the selected timing, OR
//!  - If the selected custom timings can be scaled by the secondary monitor for the selected source resolution on the primary, OR
//!  - If the selected custom timings matches the existing source resolution on the primary.
//!  Setting up a custom display on non-active but connected monitors is supported only for Win7 and above.
//!
//! SUPPORTED OS:  Windows XP,  Windows 7 and higher
//!
//!
//! \since Release: 313   
//!
//!                               
//! \param [in]    pDisplayIds    Array of the target display Dispaly IDs - See \ref handles.
//! \param [in]    count          Total number of the incoming Display IDs and corresponding NV_CUSTOM_DISPLAY structure. This is for the multi-head support.
//! \param [in]    pCustDisp      Pointer to the NV_CUSTOM_DISPLAY structure array.
//!
//! \return        This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
//! \retval        NVAPI_INVALID_DISPLAY_ID:   Custom Timing is not supported on the Display, whose display id is passed
//! 
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_TryCustomDisplay( __in_ecount(count) NvU32 *pDisplayIds, __in NvU32 count, __in_ecount(count) NV_CUSTOM_DISPLAY *pCustDisp);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DISP_DeleteCustomDisplay
//
//! DESCRIPTION:    This function deletes the custom display configuration, specified from the registry for  all the displays whose display IDs are passed.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 313 
//!
//!
//! \param [in]     pDisplayIds    Array of Dispaly IDs on which custom display configuration is to be saved.
//! \param [in]     count          Total number of the incoming Dispaly IDs. This is for the multi-head support.
//!	\param [in]     pCustDisp	   Pointer to the NV_CUSTOM_DISPLAY structure
//!
//! \return        This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
//! \retval        NVAPI_INVALID_DISPLAY_ID:   Custom Timing is not supported on the Display, whose display id is passed
//!
//! \ingroup dispcontrol 
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_DeleteCustomDisplay( __in_ecount(count) NvU32 *pDisplayIds, __in NvU32 count, __in NV_CUSTOM_DISPLAY *pCustDisp);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DISP_SaveCustomDisplay
//
//! DESCRIPTION:    This function saves the current hardware display configuration on the specified Display IDs as a custom display configuration.
//!                 This function should be called right after NvAPI_DISP_TryCustomDisplay() to save the custom display from the current
//!                 hardware context. This function will not do anything if the custom display configuration is not tested on the hardware.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 313 
//!
//!
//! \param [in]     pDisplayIds         Array of Dispaly IDs on which custom display configuration is to be saved.
//! \param [in]     count               Total number of the incoming Dispaly IDs. This is for the multi-head support.
//! \param [in]     isThisOutputIdOnly  If set, the saved custom display will only be applied on the monitor with the same outputId (see \ref handles).
//! \param [in]     isThisMonitorIdOnly If set, the saved custom display will only be applied on the monitor with the same EDID ID or 
//!                                     the same TV connector in case of analog TV.
//!
//! \return        This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
//! \retval 	   NVAPI_INVALID_DISPLAY_ID:   Custom Timing is not supported on the Display, whose display id is passed
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_SaveCustomDisplay( __in_ecount(count) NvU32 *pDisplayIds, __in NvU32 count, __in NvU32 isThisOutputIdOnly, __in NvU32 isThisMonitorIdOnly);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DISP_RevertCustomDisplayTrial
//
//! DESCRIPTION:    This API is used to restore the display configuration, that was changed by calling NvAPI_DISP_TryCustomDisplay(). This function
//!                 must be called only after a custom display configuration is tested on the hardware, using NvAPI_DISP_TryCustomDisplay(),  
//!                 otherwise no action is taken. On Vista, NvAPI_DISP_RevertCustomDisplayTrial should be called with an active display that  
//!                 was affected during the NvAPI_DISP_TryCustomDisplay() call, per GPU. 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 313  
//!
//!
//! \param [in]    pDisplayIds   Pointer to display Id, of an active display. 
//! \param [in]    count         Total number of incoming Display IDs. For future use only. Currently it is expected to be passed as 1.
//!
//! \return        This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_RevertCustomDisplayTrial( __in_ecount(count) NvU32* pDisplayIds, __in NvU32 count);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_QueryUnderscanCap
//
//! \fn NvAPI_QueryUnderscanCap(NvDisplayHandle hNvDisplay, NvU32 displayOutputId, NV_UNDERSCAN_CAP* cap)
//!  DESCRIPTION:  This function gets the maximum underscan/overscan ratio and the supported underscan type(s).
//! 
//! <b> Supported Underscan Options for GPU and Display Outputs</b>
//! <table cellspacing="2" cellpadding="2" border="1">
//! <tr>
//!     <th>GPU</th>
//!     <th>Display Output</th>
//!     <th>Available Underscan Options</th>
//! </tr>
//! <tr>
//!     <td>GeForce8/post-GeForce8 </td>
//!     <td>CRT/TV/DFP/HDMI </td>
//!     <td>Source and scaler underscan</td>
//! </tr>
//! <tr>
//!     <td>GeForce7/pre-GeForce7</td>
//!     <td>TV/DFP/HDMI </td>
//!     <td>Source underscan only</td>
//! </tr>
//! <tr>
//!     <td>GeForce7/pre-GeForce7</td>
//!     <td>CRT  </td>
//!     <td>No underscan option yet</td>
//! </tr>
//! </table>
//!
//! <b> EDID Checking Behavior</b>
//! <table cellspacing="2" cellpadding="2" border="1">
//! <tr>
//!     <th>supportMonitorIdMatch</th>
//!     <th>supportDisplayOutputIdMatch</th>
//!     <th>Behavior</th>
//! </tr>
//! <tr>
//!     <td>0</td>
//!    <td>0</td>
//!     <td>No EDID check, apply to all devices (not recommended).</td>
//! </tr>
//! <tr>
//!     <td>0</td>
//!     <td>1</td>
//!     <td>No EDID check, apply to a specified device only (the old WinXP style).</td>
//! </tr>
//! <tr>
//!     <td>1</td>
//!     <td>0</td>
//!     <td>Apply to the specified EDID regardless of the device mask.</td>
//! </tr>
//! <tr>
//!     <td>1</td>
//!     <td>1</td>
//!     <td>Apply to the specified EDID on a specified device.</td>
//! </tr>
//! </table>
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 165
//!
//! \param [in]    hNvDisplay       NVIDIA Display selection \n
//!                                 #NVAPI_DEFAULT_HANDLE is not allowed. It must be a handle enumerated with NvAPI_EnumNVidiaDisplayHandle().
//! \param [in]    displayOutputId  The display ID on which to apply the underscan configuration. 
//!                                 It must be a legal display ID (one bit set). \n
//!                                 "0" is allowed, indicating the default display used by the hNvDisplay handle. See \ref handles.
//! \param [out]   cap              The pointer to the NV_UNDERSCAN_CAP structure
//!
//! \retval  NVAPI_OK                Completed request
//! \retval  NVAPI_ERROR             Miscellaneous error occurred
//! \retval  NVAPI_INVALID_ARGUMENT  Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup dispcontrol
//! Used in NvAPI_QueryUnderscanCap().
typedef struct
{
    NvU32 version;                           //!< Structure version
    
    float xRatioMin;                         //!< The supported min horizontal underscan ratio (e.g. 0.75 ~ 1.25 etc)
    float xRatioMax;                         //!< The supported max horizontal underscan ratio
    float yRatioMin;                         //!< The supported min vertical underscan ratio (e.g. 0.75 ~ 1.25)
    float yRatioMax;                         //!< The supported max vertical underscan ratio
    
    NvU32 supportSourceUnderscan       : 1;  //!< Indicate if source underscan is supported.
    NvU32 supportScalerUnderscan       : 1;  //!< Indicate if the scaler-based underscan is supported.
    NvU32 supportMonitorIdMatch        : 1;  //!< Indicate if the underscan configuration can be set for the monitors with the same EDID.
    NvU32 supportDisplayOutputIdMatch  : 1;  //!< Indicate if the underscan configuration can be set for monitors connected to the same display output ID.
    NvU32 supportXYIndependentCtrl     : 1;  //!< Indicate if we can independently control in the X and Y direction.
//! \code
//! Note 1: 
//!------------------------+--------------------+------------------------------------------------
//!          GPU           |    DisplayOutput   |  Available Underscan option
//!------------------------+--------------------+------------------------------------------------
//! GeForce8/post-GeForce8 |   CRT/TV/DFP/HDMI  |  source and scaler underscan
//! GeForce7/pre-GeForce7  |      TV/DFP/HDMI   |  source under only, the API will automatically
//!                        |                    |  fall back if scaler underscan is specified
//! GeForce7/pre-GeForce7  |         CRT        |  no underscan option yet, the API will return  
//!                        |                    |  failure
//!------------------------+--------------------+-------------------------------------------------
//!
//! Note 2:
//!-------------------+-----------------------------+-------------------------------------------
//! supportEdidMatch  | supportDisplayOutputIdMatch |                        behavior
//!-------------------+-----------------------------+---------------------------------------------
//!       0           |        0                    |  no EDID check, apply to all devices 
//!                   |                             | (not recommended)
//!       0           |        1                    |  no EDID check, apply to a specified device 
//!                   |                             |  only (the old XP style)
//!       1           |        0                    |  apply to the specified Edid regardless of   
//!                   |                             |  the device mask (new)
//!       1           |        1                    |  apply to the specified Edid on a specified
//!                   |                             |  device (new)
//!-------------------+-----------------------------+---------------------------------------------
//! \endcode
    NvU32 isSourceUnderscanRecommended : 1;  //!< Indicate if source underscan is recommended under the current display context.
    NvU32 isScalerUnderscanRecommended : 1;  //!< Indicate if the scaler based underscan is recommended under the current display context.
} NV_UNDERSCAN_CAP;


//! \ingroup dispcontrol
//! Macro for constructing the version field of NV_UNDERSCAN_CAP
#define NV_UNDERSCAN_CAP_VER  MAKE_NVAPI_VERSION(NV_UNDERSCAN_CAP,1)


//! \ingroup dispcontrol
NVAPI_INTERFACE NvAPI_QueryUnderscanCap(NvDisplayHandle hNvDisplay, NvU32 displayOutputId, NV_UNDERSCAN_CAP* cap);


//! \ingroup dispcontrol
//! @{

typedef enum NV_CURSOR_SIZE
{
    NV_CURSOR_SIZE_64  = 64,
    NV_CURSOR_SIZE_128 = 128,
    NV_CURSOR_SIZE_256 = 256
} NV_CURSOR_SIZE;

typedef struct
{
    NvU32           version;                           //!< Structure version

    NvU32           targetId;                          //!< Target Id of the display
    NV_CURSOR_SIZE  cursorSize;                        //!< Size in pixels of the cursor to be set
    NvU32           hwCursorEnable : 1;                //!< Flag to enable or disable the cursor
    NvU32           reserved : 31;                     //!< Reserved. Should be initialized to 0
} NV_CURSOR_STATE_V1;

typedef NV_CURSOR_STATE_V1 NV_CURSOR_STATE;

#define NV_CURSOR_STATE_VER_1 MAKE_NVAPI_VERSION(NV_CURSOR_STATE_V1,1)

#define NV_CURSOR_STATE_VER   NV_CURSOR_STATE_VER_1


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_DISP_SetCursorState
//
//! DESCRIPTION:    This function sets the hardware cursor size and enables/disables the cursor.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      cursorState                   - The pointer for the input structure containing the cursor state info.
//!                                                   
//! \param [in]      hNvDisplay                    - NVIDIA Display selection 
//!
//! \return      This API can return any of the error codes enumerated in #NvAPI_Status. 
//!              Error codes specific to this API are described below.
//!              (None)
//!
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_SetCursorState(__in NvDisplayHandle hNvDisplay, __in NV_CURSOR_STATE* cursorState);





///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_DISP_GetCursorState
//
//! DESCRIPTION:    This function gets the information regarding the hardware cursor size and whether the cursor is enabled/disabled.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in,out]      cursorState                - The pointer for the input structure containing the cursor state info.
//!                                 
//! \param [in]          hNvDisplay                 - NVIDIA Display selection 
//!
//!
//! \return      This API can return any of the error codes enumerated in #NvAPI_Status. 
//!              Error codes specific to this API are described below.
//!              (None)
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_GetCursorState(__in NvDisplayHandle hNvDisplay, __inout NV_CURSOR_STATE* cursorState);

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_EnumUnderscanConfig
//
//! \fn NvAPI_EnumUnderscanConfig(NvDisplayHandle hNvDisplay, NvU32 displayOutputId, NvU32 index, NV_UNDERSCAN_CONFIG* config)
//! DESCRIPTION:    This function enumerates the user-customized underscan configurations on the given device.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 165
//!
//!  \param [in]    hNvDisplay         NVIDIA Display selection \n 
//!                                    #NVAPI_DEFAULT_HANDLE is not allowed - it must be a handle enumerated with
//!                                    NvAPI_EnumNVidiaDisplayHandle().
//!
//!  \param [in]    displayOutputId  The display ID to which the underscan configuration applies. See \ref handles.
//!                                  It must be a legal display ID (one bit set). 
//!                                  - Use "0" to specify the default display used by the hNvDisplay handle.
//!                                  - Use "-1" to enumerate all saved underscan configurations regardless of
//!                                    the target display
//!
//!   \param [in]   index            The regular the enum index. 
//!                                  - Use "-1"(0xFFFFFFFF) to enumerate the current active underscan config on 
//!                                    the display uniquely indicated by displayOutId
//!
//!   \param [out]  config             The output pointer for the API to populate the underscan config info.
//!                                    See \ref NV_UNDERSCAN_CONFIG.
//!
//!   \retval       NVAPI_OK                Completed request
//!   \retval       NVAPI_ERROR             Miscellaneous error occurred
//!   \retval       NVAPI_INVALID_ARGUMENT  Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup dispcontrol
//! @{
//! Used in NvAPI_EnumUnderscanConfig().
typedef struct
{
    NvU32 version;                           //!< Structure version
    
    float xRatio;                            //!< Horizontal underscan ratio
    float yRatio;                            //!< Vertical undercan ratio \n
                                             //! The API may modify the client passed in config due to the
                                             //! hardware restrictions. For example, the xRatio/yRatio may be
                                             //! fine tuned so that they're aligned on a certain number
                                             //! because of the tiled memory restriction. Also "isSrcUnderscan" 
                                             //! may also be changed if the hardware can't do backend underscan.

    NvU32 nativeWidth;                       //!< Width of the native mode
    NvU32 nativeHeight;                      //!< Height of the native mode
    NvU32 nativeRR;                          //!< Refresh rate of the native mode
    NvU32 isInterlaced                 : 1;  //!< Whether native timing is interlaced or not
    
    NvU32 isScalerUnderscan            : 1;  //!< Scaler-based underscan or sourcedbased underscan
    NvU32 isOnThisMonitorOnly          : 1;  //!< Whether this config is applied only to this specific monitor (EDID)
    NvU32 isOnThisDisplayOutputIdOnly  : 1;  //!< Whether this underscan configuration is applied only to this display output ID
    NvU32 isEnabled                    : 1;  //!< whether this underscan config is enabled or not.

    NvU32 reserved                     : 27;
} NV_UNDERSCAN_CONFIG;

#define NV_UNDERSCAN_CONFIG_VER1  MAKE_NVAPI_VERSION(NV_UNDERSCAN_CONFIG,1)
#define NV_UNDERSCAN_CONFIG_VER2  MAKE_NVAPI_VERSION(NV_UNDERSCAN_CONFIG,2)
#define NV_UNDERSCAN_CONFIG_VER   NV_UNDERSCAN_CONFIG_VER2

//! @}


//!   \ingroup      dispcontrol
NVAPI_INTERFACE NvAPI_EnumUnderscanConfig(NvDisplayHandle hNvDisplay, NvU32 displayOutputId, NvU32 index, NV_UNDERSCAN_CONFIG* config);


//!   \ingroup      dispcontrol
#define NVAPI_INDEX_CURRENT_ENTRY  -1

//!   \ingroup      dispcontrol
#define NVAPI_INDEX_ALL_ENTRIES    -2

//!   \ingroup      dispcontrol
#define NVAPI_INDEX_UNINITIALIZED  -3

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DeleteUnderscanConfig
//
//! DESCRIPTION:    This function deletes the specified underscan configuration entry.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 165
//!
//! \param [in]     hNvDisplay       NVIDIA Display selection \n
//!                                  #NVAPI_DEFAULT_HANDLE is not allowed, it must be a handle enumerated with NvAPI_EnumNVidiaDisplayHandle().
//!
//! \param [in]     displayOutputId  The display ID to which the underscan config is applied. See \ref handles.
//!                                  It must be a legal display Id (one bit set)
//!                                  - Use "0" to specify the default display used by the hNvDisplay handle.
//!                                  - Use "-1" to indicate that "index" is the absolute index and not
//!                                    displayOutputId related
//!
//! \param [in]      index           The config index enumerated from NvAPI_EnumUnderScanConfig
//!                                  - Use "-1" for the current active underscan config being applied on
//!                                    the specified display output ID.
//!
//! \retval          NVAPI_OK                        Completed request
//! \retval          NVAPI_ERROR                     Miscellaneous error occurred
//! \retval          NVAPI_INVALID_ARGUMENT          Invalid input parameter.
//! \retval          NVAPI_UNKNOWN_UNDERSCAN_CONFIG  The current active underscan config is from an unknown source 
//!                                                  and can't be deleted.
//!
//! \ingroup         dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DeleteUnderscanConfig(NvDisplayHandle hNvDisplay, NvU32 displayOutputId, NvU32 index);





///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SetUnderscanConfig
//
//! DESCRIPTION:    This function adds and sets a custom underscan configuration on the given device.  
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 165
//!
//! \param [in]      hNvDisplay       NVIDIA Display selection. #NVAPI_DEFAULT_HANDLE is not allowed, 
//!                                   it must be a handle enumerated with NvAPI_EnumNVidiaDisplayHandle().
//!
//! \param [in]      displayOutputId  The display Id on which the underscan config is to apply. See \ref handles.
//!                                   It must be a legal display ID (one bit set).
//!                                   - Use "0" to indicate the default display used by the hNvDisplay handle.
//!                                     NOTE: 0xFFFFFFFF(-1) is not allowed in NvAPI_SetUnderScanConfig()
//!
//! \param [in,out]  config           The underscan config to set. See \ref NV_UNDERSCAN_CONFIG.
//! \param [in]      setDeferred      
//!                                   - "0": Apply the setup immediately.
//!                                   - "1": Apply refresh at the next OS modeset.
//!
//! \retval       NVAPI_OK                 Completed request
//! \retval       NVAPI_ERROR              Miscellaneous error occurred
//! \retval       NVAPI_INVALID_ARGUMENT   Invalid input parameter
//!
//! \ingroup      dispcontrol 
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetUnderscanConfig(NvDisplayHandle hNvDisplay, NvU32 displayOutputId, NV_UNDERSCAN_CONFIG* config, NvU32 setDeferred);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DISP_EnableUnderscanConfig
//
//! DESCRIPTION:     Enables one or all of the already created underscan/overscan configs.
//!                  If one of the underscan/overscan configs being enabled has same timing as currently applied timing,
//!                  this api will switch to that config.
//!                  If a source config is available, it will apply that. Otherwise, scalar config will be applied.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:      displayId(IN) - Display on which the caller wants to enable the underscan config. 
//!                                  Retrieved from NvAPI_SYS_GetDisplayIdFromGpuAndOutputId().
//!
//!                  index(IN)     - This index specifies which underscan config to enable.
//!                                  This config index should be enumerated from NvAPI_EnumUnderScanConfig().
//!                                  If NVAPI_INDEX_ALL_ENTRIES(-2) is passed, it enables all the underscan config's created for the display.
//!
//! RETURN STATUS:
//!                  NVAPI_OK                      - Completed request.
//!                  NVAPI_ERROR                   - Miscellaneous error occurred.
//!                  NVAPI_ID_OUT_OF_RANGE         - Incorrect display ID.
//!                  NVAPI_INVALID_ARGUMENT        - Invalid index.
//!                  NVAPI_NO_IMPLEMENTATION       - NVAPI is not implemented. Only supported on Vista and above.
//!                  NVAPI_API_NOT_INTIALIZED      - NVAPI not initialized.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_EnableUnderscanConfig(NvU32 displayId, NvU32 index);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DISP_DisableUnderscanConfig
//
//! DESCRIPTION:     Disables one or all of the already created underscan/overscan configs.
//!                  If currently applied underscan/overscan is being disabled,
//!                  this api will change the mode to the max width heigth available for the timing, keeping the timing unchanged.        
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:      displayId(IN) - Display on which caller wants to disable the underscan config. 
//!                                  Retrieved from NvAPI_SYS_GetDisplayIdFromGpuAndOutputId().
//!
//!                  index(IN)     - This index specifies which underscan config to disable.
//!                                  This config index should be enumerated from NvAPI_EnumUnderScanConfig().
//!                                  If NVAPI_INDEX_ALL_ENTRIES(-2) is passed, disables all the underscan config's created for the display.
//!
//! RETURN STATUS:
//!                  NVAPI_OK                      - Completed request.
//!                  NVAPI_ERROR                   - Miscellaneous error occurred.
//!                  NVAPI_ID_OUT_OF_RANGE         - Incorrect display ID.
//!                  NVAPI_INVALID_ARGUMENT        - Invalid index.
//!                  NVAPI_NO_IMPLEMENTATION       - NVAPI is not implemented. Only supported on Vista and above.
//!                  NVAPI_API_NOT_INTIALIZED      - NVAPI not initialized.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_DisableUnderscanConfig(NvU32 displayId, NvU32 index);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DISP_GetViewPortInfo
//
//! \fn NvAPI_DISP_GetViewPortInfo(__in NvU32 displayId, __inout NV_VIEW_PORT_INFO *viewPortInfo)
//! DESCRIPTION:    This function gets the view port information of an active display from the display driver.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]  displayId - Display id.
//! \param [out] viewPort  - Pointer to the NV_VIEW_PORT_INFO structure. Should not be NULL in any case.
//!
//! \return        This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
///////////////////////////////////////////////////////////////////////////////

//! \ingroup dispcontrol
//! View Port Information.

typedef struct 
{
    NvU32 x;    //!<  x-coordinate of the viewport top-left point
    NvU32 y;    //!<  y-coordinate of the viewport top-left point
    NvU32 w;    //!<  Width of the viewport
    NvU32 h;    //!<  Height of the viewport
} NVAPI_VIEWPORT;

typedef struct _NV_VIEW_PORT_INFO_V1
{
    NvU32          version;                //!< Structure version

    NVAPI_VIEWPORT viewPort;
    NvU32          viewPortLockState : 1;  //!< 0 means unlock/unlocked and 1 means lock/locked.
    NvU32          reserved          : 31; //!< Reserved. Should be 0.
} NV_VIEW_PORT_INFO_V1;

typedef struct _NV_VIEW_PORT_INFO_V2
{
    NvU32          version;                //!< Structure version

    NVAPI_VIEWPORT viewPort;
    NvU32          viewPortLockState : 1;  //!< 0 means unlock/unlocked and 1 means lock/locked.
    NvU32          reserved          : 31; //!< Reserved. Should be 0.
    NvU32          zoomValue;              //!< Zoom value is the zoom percentage multiplied by 1000 to take care of the decimal percentage values.
} NV_VIEW_PORT_INFO_V2;

typedef NV_VIEW_PORT_INFO_V2    NV_VIEW_PORT_INFO;

#define NV_VIEW_PORT_INFO_VER1  MAKE_NVAPI_VERSION(NV_VIEW_PORT_INFO_V1, 1)
#define NV_VIEW_PORT_INFO_VER2  MAKE_NVAPI_VERSION(NV_VIEW_PORT_INFO_V2, 2)
#define NV_VIEW_PORT_INFO_VER   NV_VIEW_PORT_INFO_VER2

//! \ingroup dispcontrol
NVAPI_INTERFACE NvAPI_DISP_GetViewPortInfo(__in NvU32 displayId, __inout NV_VIEW_PORT_INFO *viewPortInfo);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DISP_SetViewPortInfo
//
//! DESCRIPTION:    This function sends the view port information for an active display to the display driver.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in] displayId - Display id.
//! \param [in] viewPort  - Pointer to the NV_VIEW_PORT_INFO structure. Should not be NULL in any case.
//! \param [in] setFlags  - Set of NV_VIEW_PORT_INFO_SET_* flag values mentioned below.
//!
//! \return        This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
///////////////////////////////////////////////////////////////////////////////

#define NV_VIEW_PORT_INFO_SET_VIEWPORT   0x00000001
#define NV_VIEW_PORT_INFO_SET_LOCK_STATE 0x00000002
#define NV_VIEW_PORT_INFO_SET_ZOOM       0x00000004

//! \ingroup dispcontrol
NVAPI_INTERFACE NvAPI_DISP_SetViewPortInfo(__in NvU32 displayId, __in NV_VIEW_PORT_INFO *viewPortInfo, __in NvU32 setFlags);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DISP_GetFeatureConfig
//
//! \fn NvAPI_DISP_GetFeatureConfig(__in NvU32 displayId, __inout NV_DISPLAY_FEATURE_CONFIG *pDisplayFeatureConfig)
//! DESCRIPTION:     This function returns the current display feature configuration.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in] displayId             - Display id.
//! \param [in] pDisplayFeatureConfig - Pointer to the NV_DISPLAY_FEATURE_CONFIG structure. Should not be NULL in any case.
//!
//! \return        This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
///////////////////////////////////////////////////////////////////////////////

//! \ingroup dispcontrol
//! Information of the features.

typedef struct _NV_DISPLAY_FEATURE_CONFIG
{
    NvU32 version;                                   //!< Structure version
    
    NvU32 isPanAndScanEnabled                  : 1;  //!< Current pan and scan state of the display. Should only be looked in case of NvAPI_DISP_GetFeatureConfig() call.
	NvU32 modulePresentSyncGDIPrimaryTarget    : 1;  //!< Should only be set in case of NvAPI_DISP_SetFeatureConfig() call. Display Id of the GDI primary must be passed in.
    NvU32 reserved                             : 30; //!< Reserved.
} NV_DISPLAY_FEATURE_CONFIG_V1;

#define NV_DISPLAY_FEATURE_CONFIG_VER1  MAKE_NVAPI_VERSION(NV_DISPLAY_FEATURE_CONFIG_V1, 1)
#define NV_DISPLAY_FEATURE_CONFIG_VER   NV_DISPLAY_FEATURE_CONFIG_VER1

typedef NV_DISPLAY_FEATURE_CONFIG_V1    NV_DISPLAY_FEATURE_CONFIG;

//! \ingroup dispcontrol
NVAPI_INTERFACE NvAPI_DISP_GetFeatureConfig(__in NvU32 displayId, __inout NV_DISPLAY_FEATURE_CONFIG *pDisplayFeatureConfig);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DISP_SetFeatureConfig
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in] displayId             - Display id.
//! \param [in] pDisplayFeatureConfig - Pointer to the NV_DISPLAY_FEATURE_CONFIG structure. Should not be NULL in any case.
//!
//! \return        This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_SetFeatureConfig(__in NvU32 displayId, __inout NV_DISPLAY_FEATURE_CONFIG *pDisplayFeatureConfig);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetDisplayFeatureConfig
//
//! \fn NvAPI_GetDisplayFeatureConfig(NvDisplayHandle hNvDisplay, NV_DISPLAY_FEATURE* pFeature)
//! DESCRIPTION:     This function returns the current display feature configuration.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 170
//!
//! \param [in]      hNvDisplay   NVIDIA Display selection \n
//!                                #NVAPI_DEFAULT_HANDLE is not allowed, it must be a handle enumerated with NvAPI_EnumNVidiaDisplayHandle().
//! \param [in,out]   feature      Pointer to NV_DISPLAY_FEATURE structure to retrieve the current feature configuration.
//! 
//! \retval           NVAPI_OK                Completed request
//! \retval           NVAPI_ERROR             Miscellaneous error occurred
//! \retval           NVAPI_INVALID_ARGUMENT  Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup dispcontrol
//! Used in NvAPI_GetDisplayFeatureConfig() and NvAPI_SetDisplayFeatureConfig().
typedef struct _NV_DISPLAY_FEATURE
{
    NvU32      enableScalerUnderscan  : 1;          //!< Enable/disable HDTV scaler-based resizing.
    NvU32      enableCEoverHDMI       : 1;          //!< Enable/disable the feature to force CE timings over HDMI.
                                                    //!< If this feature is enabled, then CE timings will only be used for HDMI displays.
    NvU32      reservedOEM            : 1;          //!< Reserved bit for OEM configuration
    NvU32      isDriverCtrlCEoverHDMI : 1;          //!< if == 1, the feature "Force CE timing over HDMI" is dynamically controlled by the driver so
                                                    //!< it's selectively enabled/disabled based on internal driver policy.
                                                    //!< if == 0, this feature is statically controlled by the application. 
    NvU32      reserved               : 28;

} NV_DISPLAY_FEATURE; 


//! \ingroup dispcontrol
NVAPI_INTERFACE NvAPI_GetDisplayFeatureConfig(NvDisplayHandle hNvDisplay, NV_DISPLAY_FEATURE* pFeature);




///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SetDisplayFeatureConfig
//
//! DESCRIPTION:    This sets the display feature configuration.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 170
//!
//! \param [in]     hNvDisplay  NVIDIA Display selection \n
//!                 #NVAPI_DEFAULT_HANDLE is not allowed, it must be a handle enumerated with NvAPI_EnumNVidiaDisplayHandle().
//! \param [in,out] feature     Copy of NV_DISPLAY_FEATURE structure to set up the new feature configuration
//! 
//! \retval         ::NVAPI_OK                
//! \retval         ::NVAPI_ERROR             
//! \retval         ::NVAPI_INVALID_ARGUMENT  
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetDisplayFeatureConfig(NvDisplayHandle hNvDisplay, NV_DISPLAY_FEATURE feature);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetDisplayFeatureConfigDefaults
//
//! DESCRIPTION:     This function returns the default display feature configuration.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 177
//!
//!  \param [in]     hNvDisplay   NVIDIA display selection.  \n
//!                  #NVAPI_DEFAULT_HANDLE is not allowed, it must be a handle enumerated with NvAPI_EnumNVidiaDisplayHandle().
//!  \param [in,out] feature      A copy of the NV_DISPLAY_FEATURE structure to set up the default feature configuration
//! 
//!  \retval ::NVAPI_OK             
//!  \retval ::NVAPI_ERROR           
//!  \retval ::NVAPI_INVALID_ARGUMENT 
//!
//!  \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetDisplayFeatureConfigDefaults(NvDisplayHandle hNvDisplay, NV_DISPLAY_FEATURE* pFeature);







///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetView
//
//! This API lets caller retrieve the target display arrangement for selected source display handle.
//! \note Display PATH with this API is limited to single GPU. DUALVIEW across GPUs will be returned as STANDARD VIEW. 
//!       Use NvAPI_SYS_GetDisplayTopologies() to query views across GPUs.
//!
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_DISP_GetDisplayConfig.
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 85
//!
//!  \param [in]     hNvDisplay             NVIDIA Display selection. It can be #NVAPI_DEFAULT_HANDLE or a handle enumerated from 
//!                                         NvAPI_EnumNVidiaDisplayHandle().
//!  \param [out]    pTargets               User allocated storage to retrieve an array of  NV_VIEW_TARGET_INFO. Can be NULL to retrieve 
//!                                         the targetCount.
//!  \param [in,out] targetMaskCount        Count of target device mask specified in pTargetMask.
//!  \param [out]    targetView             Target view selected from NV_TARGET_VIEW_MODE.
//!
//!  \retval         NVAPI_OK               Completed request
//!  \retval         NVAPI_ERROR            Miscellaneous error occurred
//!  \retval         NVAPI_INVALID_ARGUMENT Invalid input parameter.
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use NvAPI_DISP_GetDisplayConfig.")
NVAPI_INTERFACE NvAPI_GetView(NvDisplayHandle hNvDisplay, NV_VIEW_TARGET_INFO *pTargets, NvU32 *pTargetMaskCount, NV_TARGET_VIEW_MODE *pTargetView);







///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetViewEx
//
//! DESCRIPTION:    This API lets caller retrieve the target display arrangement for selected source display handle.
//!                 \note Display PATH with this API is limited to single GPU. DUALVIEW across GPUs will be returned as STANDARD VIEW. 
//!                       Use NvAPI_SYS_GetDisplayTopologies() to query views across GPUs.
//!
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_DISP_GetDisplayConfig.
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 165
//!
//! \param [in]     hNvDisplay       NVIDIA Display selection. #NVAPI_DEFAULT_HANDLE is not allowed, it has to be a handle enumerated with
//!                                  NvAPI_EnumNVidiaDisplayHandle().
//! \param [in,out] pPathInfo        Count field should be set to NVAPI_MAX_DISPLAY_PATH. Can be NULL to retrieve just the pathCount.
//! \param [in,out] pPathCount       Number of elements in array pPathInfo->path.
//! \param [out]    pTargetViewMode  Display view selected from NV_TARGET_VIEW_MODE.
//!
//! \retval         NVAPI_OK                      Completed request
//! \retval         NVAPI_API_NOT_INTIALIZED      NVAPI not initialized
//! \retval         NVAPI_ERROR                   Miscellaneous error occurred
//! \retval         NVAPI_INVALID_ARGUMENT        Invalid input parameter.
//! \retval         NVAPI_EXPECTED_DISPLAY_HANDLE hNvDisplay is not a valid display handle.
//! 
//! \ingroup dispcontrol   
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use NvAPI_DISP_GetDisplayConfig.")
NVAPI_INTERFACE NvAPI_GetViewEx(NvDisplayHandle hNvDisplay, NV_DISPLAY_PATH_INFO *pPathInfo, NvU32 *pPathCount, NV_TARGET_VIEW_MODE *pTargetViewMode);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetSupportedViews
//
//!  This API lets caller enumerate all the supported NVIDIA display views - nView and Dualview modes.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 85
//!
//!  \param [in]     hNvDisplay             NVIDIA Display selection. It can be #NVAPI_DEFAULT_HANDLE or a handle enumerated from
//!                                         NvAPI_EnumNVidiaDisplayHandle().
//!  \param [out]    pTargetViews           Array of supported views. Can be NULL to retrieve the pViewCount first.
//!  \param [in,out] pViewCount             Count of supported views.
//!
//!  \retval         NVAPI_OK               Completed request
//!  \retval         NVAPI_ERROR            Miscellaneous error occurred
//!  \retval         NVAPI_INVALID_ARGUMENT Invalid input parameter.
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetSupportedViews(NvDisplayHandle hNvDisplay, NV_TARGET_VIEW_MODE *pTargetViews, NvU32 *pViewCount);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetSupportedViewsEx
//
//! DESCRIPTION:     This API lets caller enumerate all the supported NVIDIA display views - nView and DualView modes.
//!                  Same as NvAPI_GetSupportedViews() except it takes a flag to return cached or uncached connections.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      hNvDisplay      NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//! \param [out]     pTargetViews    Array of supported views. Can be NULL to retrieve the pViewCount first.
//! \param [in,out]  pViewCount      Count of supported views.
//! \param [in]      flag            Uncached (re-scanned) connected devices or cached connected devices
//!
//! \retval ::NVAPI_OK                completed request
//! \retval ::NVAPI_ERROR             miscellaneous error occurred
//! \retval ::NVAPI_INVALID_ARGUMENT  Invalid input parameter.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetSupportedViewsEx(NvDisplayHandle hNvDisplay, NV_TARGET_VIEW_MODE *pTargetViews, NvU32 *pViewCount, NvU32 flag);




///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SetViewExInternal
//
//! The description and usage is the same as NvAPI_SetViewEx(). Used only in Sedona. This API does not check for the inhibit state.
//! \note Display PATH with this API is limited to single GPU. DUALVIEW across GPUs cannot be enabled with this API. 
//!
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_DISP_SetDisplayConfig.
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use NvAPI_DISP_SetDisplayConfig.")
NVAPI_INTERFACE NvAPI_SetViewExInternal(NvDisplayHandle hNvDisplay, NV_DISPLAY_PATH_INFO *pPathInfo, NV_TARGET_VIEW_MODE displayView);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_DISP_IsFullscreenAppRunning
//
//!   DESCRIPTION:  This API queries whether the application is running in full-screen mode or not.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 185
//!
//! \param [in] hNvDisplay      NVIDIA Display selection. NVAPI_DEFAULT_HANDLE is not allowed, it has to be a handle enumerated with NvAPI_EnumNVidiaDisplayHandle().
//! \param [in] pFullScreenApp  Pointer to pFullScreenApp.
//!                                 
//! \retval ::NVAPI_OK 
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND 
//! \retval ::NVAPI_EXPECTED_DISPLAY_HANDLE    hNvDisplay is not a valid display handle.
//! \retval ::NVAPI_INVALID_ARGUMENT           pFullScreenApp is NULL.
//! \retval ::NVAPI_NO_IMPLEMENTATION  
//! \retval ::NVAPI_ERROR  
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_IsFullscreenAppRunning(NvDisplayHandle hNvDisplay, NvU32 *pFullScreenApp);











///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_SetHDMIAudioStreamMute
//
//! \fn NvAPI_SetHDMIAudioStreamMute(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_HDMI_AUDIO_INFO* pNvHdmiAudioInfo)
//! DESCRIPTION:   This API signals the driver to turn mute ON or OFF on the HDMI audio stream.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 100
//!
//! \param [in]    hNvDisplay        NVIDIA Display selection. It can be #NVAPI_DEFAULT_HANDLE or a handle enumerated 
//!                                  from NvAPI_EnumNVidiaDisplayHandle().
//! \param [in]    outputId          The display output ID for the HDMI display. If it's "0", then the default 
//!                                  outputId from NvAPI_GetAssociatedDisplayOutputId() will be used. See \ref handles.
//! \param [in]    pNvHdmiAudioInfo  Pointer to NV_HDMI_AUDIO_INFO which contains the audio stream mute value for the HDMI display. 
//!
//! \retval        NVAPI_OK                Completed request
//! \retval        NVAPI_NOT_SUPPORTED     Display output ID is for non-active HDMI display.
//! \retval        NVAPI_ERROR             Miscellaneous error occurred.
//! \retval        NVAPI_INVALID_ARGUMENT  Invalid input parameter.
///////////////////////////////////////////////////////////////////////////////


//! \ingroup dispcontrol
//! HDMI Audio Stream Mute \n
//! Used in NV_HDMI_AUDIO_INFO
typedef enum _NV_HDMI_AUDIO_STREAM_MUTE_STATUS
{
    NV_SET_HDMI_AUDIO_STREAM_MUTE_OFF  = 0x00, //!< Set mute Off
    NV_SET_HDMI_AUDIO_STREAM_MUTE_ON   = 0x01, //!< Set mute On
} NV_HDMI_AUDIO_STREAM_MUTE_STATUS;



//!  \ingroup dispcontrol
//!  Used in NvAPI_SetHDMIAudioStreamMute()
typedef struct 
{
    NvU32 version;
    NV_HDMI_AUDIO_STREAM_MUTE_STATUS nvHdmiAudioMute; //!< See NV_HDMI_AUDIO_STREAM_MUTE_STATUS documentation.  
} NV_HDMI_AUDIO_INFO;
 

//! \ingroup dispcontrol
#define NV_HDMI_AUDIO_INFO_VER  MAKE_NVAPI_VERSION(NV_HDMI_AUDIO_INFO,1)


//! \ingroup       dispcontrol        
NVAPI_INTERFACE NvAPI_SetHDMIAudioStreamMute(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_HDMI_AUDIO_INFO* pNvHdmiAudioInfo);








//! \ingroup dispcontrol
//! See _NV_DPCD_PARAMS.
#define NVAPI_DPCD_MAX_DATA_SIZE 16

//! \ingroup dispcontrol 
//! Used in _NV_DPCD_PARAMS.
typedef enum _NV_DPCD_CMD
{
    NV_DP_AUXCH_CMD_REQ_TYPE_WRITE = 0,             //!< DisplayPort Aux Channel write
    NV_DP_AUXCH_CMD_REQ_TYPE_READ,                  //!< DisplayPort Aux Channel read    
    NV_DP_AUXCH_CMD_REQ_TYPE_I2C_WRITE,             //!< I2C write request
    NV_DP_AUXCH_CMD_REQ_TYPE_I2C_READ,              //!< I2C read request
    NV_DP_AUXCH_CMD_REQ_TYPE_I2C_WRITE_STATUS,      //!< I2C write status request
    NV_DP_AUXCH_CMD_REQ_TYPE_MOT_I2C_WRITE,         //!< I2C write request in the middle of the transaction     
    NV_DP_AUXCH_CMD_REQ_TYPE_MOT_I2C_READ           //!< I2C read request in the middle of the transaction 

} NV_DPCD_CMD;

//! \ingroup dispcontrol
//! Used in _NV_DPCD_PARAMS.
typedef enum _NV_DPCD_REPLY_TYPE
{
    NV_DP_AUXCH_REPLYTYPE_ACK = 0,                  //!< For write: transaction completed and all data bytes are written.
                                                    //!< For read: ACK indicates it is ready for another read request.
    NV_DP_AUXCH_REPLYTYPE_NACK,                     //!< For write: the first return size bytes have been written.
                                                    //!< For read: there is no requested data for the read request transaction.
    NV_DP_AUXCH_REPLYTYPE_DEFER,                    //!< Not ready for the write/read request and client should retry later.    
    NV_DP_AUXCH_REPLYTYPE_TIMEOUT = 0xFF,           //!< The receiver did not respond within the time-out period defined in the DisplayPort 1.1a specification.
	NV_DP_AUXCH_REPLYTYPE_INVALID_ARGUMENT = 0xFFFFFFFF  //!<.Invalid size and type is passed for aux transaction.
} NV_DPCD_REPLY_TYPE;

//! \ingroup discontrol
//! Used in NvAPI_Disp_DpAuxChannelControl().
typedef struct _NV_DPCD_PARAMS_V1
{
    NvU32                version;                        //!< Structure version
    NvU32                displayId;                      //!< NvAPI displayId of the DisplayPort 
    NV_DPCD_CMD          cmd;                            //!< See ::_NV_DPCD_CMD
    NvU32                addr;                           //!< The address of the I2C slave. The address should be shifted left by one.  For
                                                         //!< example, the I2C address 0x50, often used for reading EDIDs, would be stored
                                                         //!< here as 0xA0.  This matches the position within the byte sent by the master, as
                                                         //!< the last bit is reserved to specify the read or write direction.
    NvU8                 data[NVAPI_DPCD_MAX_DATA_SIZE]; //!< Data for the read/write command
    NvU32                size;                           //!< Number of bytes to read/write. The input size value should be indexed from 0. Returns
                                                         //!  the total number of data bytes successfully read/written, indexed from 1.
    NV_DPCD_REPLY_TYPE   replyType;                      //!< See ::_NV_DPCD_REPLY_TYPE
} NV_DPCD_PARAMS_V1;

//! \ingroup discontrol
//! Used in NvAPI_Disp_DpAuxChannelControl().
typedef struct _NV_DPCD_PARAMS_V2
{
    NvU32                version;                        //!< Structure version
    NvU32                displayId;                      //!< IN - NvAPI displayId of the DisplayPort
    NV_DPCD_CMD          cmd;                            //!< IN - See ::_NV_DPCD_CMD
    NvU32                addr;                           //!< The address of the I2C slave. The address should be shifted left by one.  For
                                                         //!< example, the I2C address 0x50, often used for reading EDIDs, would be stored
                                                         //!< here as 0xA0.  This matches the position within the byte sent by the master, as
                                                         //!< the last bit is reserved to specify the read or write direction.
    NvU8                 data[NVAPI_DPCD_MAX_DATA_SIZE]; //!< IN/OUT - Data for the read/write command
    NvU32                size;                           //!< IN/OUT - Number of bytes to read/write. The input size value should be indexed from 0. Returns
                                                         //!  the total number of data bytes successfully read/written, indexed from 1.
    NV_DPCD_REPLY_TYPE   replyType;                      //!< OUT - See ::_NV_DPCD_REPLY_TYPE
    NV_DP_ADDRESS        auxAddress;                     //!< IN - The AUX address that is associated with the device in a multi stream topology
                                                         //!< When this is set, the above displayId should be set to the root connector on which 
                                                         //!< the multi stream topology is hosted. When the displayId of a sink device is set in 
                                                         //!< the above field, this auxAddress input will be ignored
} NV_DPCD_PARAMS_V2;

//! \ingroup discontrol
//! Macro for constructing the version field of _NV_DPCD_PARAMS
#define NV_DPCD_PARAMS_VER1  MAKE_NVAPI_VERSION(NV_DPCD_PARAMS_V1, 1)
#define NV_DPCD_PARAMS_VER2  MAKE_NVAPI_VERSION(NV_DPCD_PARAMS_V2, 2)
#define NV_DPCD_PARAMS_VER  NV_DPCD_PARAMS_VER2

typedef NV_DPCD_PARAMS_V2   NV_DPCD_PARAMS;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Disp_DpAuxChannelControl
//
//! DESCRIPTION:  This API read/writes to the DisplayPort Aux Channel 
//!               The DisplayPort display needs to be active for this NvAPI call.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]     hNvDisplay   Display handle associated with the attached DisplayPort monitor
//! \param [in,out] pDpcdParams  Pointer to _NV_DPCD_PARAMS structure for input/output parameters
//! \param [in]     reserved     Reserved for future use.
//!
//! \return        This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Disp_DpAuxChannelControl(__in NvDisplayHandle hNvDisplay, __inout NV_DPCD_PARAMS *pDpcdParams, __in NvU32 reserved);



//! \ingroup dispcontrol
typedef enum _NV_DP_TESTPATTERN_DATA
{
    NV_DP_TESTPATTERN_DATA_NONE,
    NV_DP_TESTPATTERN_DATA_D10_2,
    NV_DP_TESTPATTERN_DATA_SERMP,
    NV_DP_TESTPATTERN_DATA_PRBS_7,
    NV_DP_TESTPATTERN_DATA_CSTM,
    NV_DP_TESTPATTERN_DATA_HBR2COMPLIANCE
} NV_DP_TESTPATTERN_DATA;

//! This structure specifies the 80 bit DP CSTM Test Pattern data
//! \ingroup dispcontrol
typedef struct _NV_DP_TESTPATTERN_CSTM
{
    NvU32 lower;            //!< specifies bits 31:0
    NvU32 middle;           //!< specifies bits 63:32
    NvU32 upper;            //!< specifies bits 79:64
} NV_DP_TESTPATTERN_CSTM;

//! \ingroup dispcontrol
typedef struct _NV_DP_TESTPATTERN
{
    NvU32                                   version;            //!< structure version

    NvU32                                   rootDisplayId;      //!< NvAPI displayID of the root DP connector (IN)
    NV_DP_TESTPATTERN_DATA                  testPattern;        //!< Testpattern on the displayport (IN/OUT depending on the get/set)
    NV_DP_TESTPATTERN_CSTM                  cstmTestPattern;    //!< If the test pattern is of type CSTM, then this holds the data (IN/OUT depending on the get/set)
    NvU32                                   isHBR2  : 1;        //!< Specifies if this is for HBR2 compliance test (IN)
    NvU32                                   laneMask: 8;        //!< Each bit corresponds to a lane i.e. bit 0 => lane 0, bit 1 => lane 1 etc (IN)
    NvU32                                   reserved: 23;       //!< Should be set to ZERO

} NV_DP_TESTPATTERN_V1;

#define NV_DP_TESTPATTERN_VER1  MAKE_NVAPI_VERSION(NV_DP_TESTPATTERN_V1,1)
#define NV_DP_TESTPATTERN_VER   NV_DP_TESTPATTERN_VER1

typedef NV_DP_TESTPATTERN_V1    NV_DP_TESTPATTERN;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Disp_DP_SetTestPattern
//
//!   DESCRIPTION: This API sets the Physical Test Pattern on the DisplayPort.
//!                Test patterns that can currently be set are defined by NV_DP_TESTPATTERN_DATA 
//!                To stop the test pattern, a test pattern of NV_DP_TESTPATTERN_DATA_NONE needs to be set.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in] pDpTestPattern  Pointer to NV_DP_TESTPATTERN structure
//!
//! \return     This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!             specific meaning for this API, they are listed below.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Disp_DP_SetTestPattern(__in NV_DP_TESTPATTERN *pDpTestPattern);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Disp_DP_GetTestPattern
//
//!   DESCRIPTION: This API gets the Physical Test Pattern on the DisplayPort.
//!                Test patterns that are currently supported are defined by NV_DP_TESTPATTERN_DATA 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in,out] pDpTestPattern  Pointer to NV_DP_TESTPATTERN structure
//!
//! \return        This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Disp_DP_GetTestPattern(__inout NV_DP_TESTPATTERN *pDpTestPattern);


//! \ingroup dispcontrol
#define NV_DP_MAX_LANES 4
typedef enum 
{
    NV_DP_PREEMPHASIS_LEVEL_NONE,        //!< No-preemphais for this lane.
    NV_DP_PREEMPHASIS_LEVEL_1,           //!< Preemphasis set to 3.5 dB.
    NV_DP_PREEMPHASIS_LEVEL_2,           //!< Preemphasis set to 6.0 dB.
    NV_DP_PREEMPHASIS_LEVEL_3            //!< Preemphasis set to 9.5 dB.
} NV_DP_PREEMPHASIS_LEVEL;

//! \ingroup dispcontrol
typedef enum 
{
    NV_DP_DRIVE_CURRENT_LEVEL_0,        //!< Drive current level set to 8 mA
    NV_DP_DRIVE_CURRENT_LEVEL_1,        //!< Drive current level set to 12 mA
    NV_DP_DRIVE_CURRENT_LEVEL_2,        //!< Drive current level set to 16 mA
    NV_DP_DRIVE_CURRENT_LEVEL_3         //!< Drive current level set to 24 mA
} NV_DP_DRIVE_CURRENT_LEVEL;

//! \ingroup dispcontrol
typedef struct _NV_DP_LANE_DATA
{
    NV_DP_PREEMPHASIS_LEVEL     preEmphasisLevel;
    NV_DP_DRIVE_CURRENT_LEVEL   driveCurrent;
} NV_DP_LANE_DATA;

//! \ingroup dispcontrol
typedef struct _NV_DP_LANE_CONFIG
{
    NvU32                   version;                   //!< structure version

    NvU32                   rootDisplayId;             //!< displayID of the root DP connector (IN)
    NvU32                   numLanes;                  //!< Number of DP lanes    (IN/OUT depending on the get/set)
    NV_DP_LANE_DATA         data[NV_DP_MAX_LANES];     //!< Lane data i.e. preemphasis & drive current (IN/OUT depending on the get/set)
} NV_DP_LANE_CONFIG_V1;

#define NV_DP_LANE_CONFIG_VER1  MAKE_NVAPI_VERSION(NV_DP_LANE_CONFIG_V1,1)
#define NV_DP_LANE_CONFIG_VER   NV_DP_LANE_CONFIG_VER1

typedef NV_DP_LANE_CONFIG_V1    NV_DP_LANE_CONFIG;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Disp_DP_SetLaneConfig
//
//!   DESCRIPTION: This API sets the Pre-Emphasis/DriveCurrent Level for 
//!                each lane on the DisplayPort.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in] pDpLaneConfig  Pointer to NV_DP_LANE_CONFIG structure
//!
//! \return     This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!             specific meaning for this API, they are listed below.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Disp_DP_SetLaneConfig(__in NV_DP_LANE_CONFIG *pDpLaneConfig);







///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Disp_DP_GetLaneConfig
//
//!   DESCRIPTION: This API gets the Pre-Emphasis/DriveCurrent Level for 
//!                each lane on the DisplayPort.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in] pDpLaneConfig  Pointer to NV_DP_LANE_CONFIG structure
//!
//! \return     This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!             specific meaning for this API, they are listed below.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Disp_DP_GetLaneConfig(__inout NV_DP_LANE_CONFIG *pDpLaneConfig);



//! \ingroup dispcontrol
//! Used in NV_DP_LINK_CONFIG
typedef enum _NV_DP_LINK_CONFIG_CMD
{
    NV_DP_LINK_CONFIG_CMD_GET = 0,         //!< get the current link configuration
    NV_DP_LINK_CONFIG_CMD_SET              //!< set the Link Configuration

}NV_DP_LINK_CONFIG_CMD;

//! \ingroup dispcontrol
//! Used in NvAPI_DISP_DP_LinkConfiguration().
typedef struct _NV_DP_LINK_CONFIG_V1
{
    NvU32                   version;                   //!< (IN)     structure version
    NvU32                   rootDisplayId;             //!< (IN)     displayID of the root DP connector
    NV_DP_LINK_CONFIG_CMD   cmd;                       //!< (IN)     see :: _NV_DP_LINK_CONFIG_CMD
    NvU8                    useDefaults;               //!< (IN)     Valid for _CMD_SET only.
                                                       //!<          1: Let the driver pick the default link config based on current resolution/bpc settings.
                                                       //!<             The fields below are ignored if this is set to true.
                                                       //!<          0: Use the input settings specified below.
    NV_DP_LINK_RATE         linkRate;                  //!< (IN/OUT) _CMD_GET : current link rate;  _CMD_SET : the new link rate
    NvU32                   laneCount;                 //!< (IN/OUT) _CMD_GET : current lane count; _CMD_SET : the new lane count 
    NvU32                   forceLinkConfig:1;         //!< (IN)     Force the change even if it cannot support the bandwidth requirements of current display modes.
                                                       //!<          Valid for _CMD_SET only.
    NvU32                   forceRGDivMode: 1;         //!< (IN)     Force the hardware into RG Div mode - used for testing only. Valid for _CMD_SET only.
    NvU32                   reserved:       30;        //!<          should be set to zero
}NV_DP_LINK_CONFIG_V1;

#define NV_DP_LINK_CONFIG_VER1  MAKE_NVAPI_VERSION(NV_DP_LINK_CONFIG_V1,1)
#define NV_DP_LINK_CONFIG_VER   NV_DP_LINK_CONFIG_VER1

typedef NV_DP_LINK_CONFIG_V1    NV_DP_LINK_CONFIG;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DISP_DP_LinkConfiguration
//
//!  DESCRIPTION: This API gets or sets the Link Configuration for the link
//!               associated with the connector specified by the rootDisplayId.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in,out] pNvDpLinkConfig  Pointer to the NV_DP_LINK_CONFIG structure.
//!
//! \return     This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!             specific meaning for this API, they are listed below.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_DP_LinkConfiguration(__inout NV_DP_LINK_CONFIG *pNvDpLinkConfig);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Diag_DPCD
//
//!  DESCRIPTION: This function makes a control call to the resource manager to set/get DPCD.
//!
//! \deprecated  Do not use this function - it is deprecated in release 295. Instead, use NvAPI_Disp_DpAuxChannelControl.
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 170
//!
//! \retval ::NVAPI_ERROR 
//! \retval ::NVAPI_OK
//! \retval ::NVAPI_NOT_SUPPORTED
//! \retval ::NVAPI_INVALID_ARGUMENT
//! \retval ::NVAPI_API_NOT_INTIALIZED
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 295. Instead, use NvAPI_Disp_DpAuxChannelControl.")
NVAPI_INTERFACE NvAPI_Diag_DPCD(NvPhysicalGpuHandle nvGPUHandle, void *pDpcdParams, NvU32 size);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Diag_DP_TestPattern
//
//!   DESCRIPTION: This function makes a control call to resource manager to set/get(set if BOOL variable 
//!                set is 1, get otherwise) Physical Test Pattern on the DisplayPort. \n
//!                Test patterns that can currently be set include PRBS, D10.2, and 
//!                Symbol Error Rate Measurement(SERM). To stop the test pattern,
//!                a test pattern of "None" needs to be set.
//!
//! \deprecated  Do not use this function - it is deprecated in release 295. Instead, use following functions: NvAPI_Disp_DP_SetTestPattern, NvAPI_Disp_DP_GetTestPattern.
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 170
//!
//! \retval ::NVAPI_ERROR 
//! \retval ::NVAPI_OK
//! \retval ::NVAPI_NOT_SUPPORTED
//! \retval ::NVAPI_INVALID_ARGUMENT
//! \retval ::NVAPI_API_NOT_INTIALIZED
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 295. Instead, use following functions: NvAPI_Disp_DP_SetTestPattern, NvAPI_Disp_DP_GetTestPattern.")
NVAPI_INTERFACE NvAPI_Diag_DP_TestPattern(NvPhysicalGpuHandle nvGPUHandle, NvU32 set, void *pTestPatternParams, NvU32 size);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Diag_DP_VideoInfo
//
//!   DESCRIPTION: This function makes a control call to RM to set/get(set if BOOL variable set
//!                is 1, get otherwise) the color format on the DisplayPort. \n
//!                Color format includes the bits per component value(6, 8, 10, 12, 16), 
//!                the color space being used (RGB, YCbCr4:2:2, YCbCr4:4:4), 
//!                the dynamic range (VESA, CEA), and the  colorimetry (ITU 601/709).
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 170
//!
//! \retval ::NVAPI_ERROR 
//! \retval ::NVAPI_OK
//! \retval ::NVAPI_NOT_SUPPORTED
//! \retval ::NVAPI_INVALID_ARGUMENT
//! \retval ::NVAPI_API_NOT_INTIALIZED
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Diag_DP_VideoInfo(NvPhysicalGpuHandle nvGPUHandle, NvU32 set, void *pVideoInfoParams, NvU32 size);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Diag_DP_LaneData
//
//!   DESCRIPTION: This function makes an RM control call to set/get(set if BOOL variable set
//!                is 1, get otherwise) the Pre-Emphasis/DriveCurrent Level for 
//!                each lane on the DisplayPort.
//!
//! \deprecated  Do not use this function - it is deprecated in release 295. Instead, use following functions: NvAPI_Disp_DP_SetLaneConfig, NvAPI_Disp_DP_GetLaneConfig.
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 170
//!
//! \retval ::NVAPI_ERROR 
//! \retval ::NVAPI_OK
//! \retval ::NVAPI_NOT_SUPPORTED
//! \retval ::NVAPI_INVALID_ARGUMENT
//! \retval ::NVAPI_API_NOT_INTIALIZED
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 295. Instead, use following functions: NvAPI_Disp_DP_SetLaneConfig, NvAPI_Disp_DP_GetLaneConfig.")
NVAPI_INTERFACE NvAPI_Diag_DP_LaneData(NvPhysicalGpuHandle nvGPUHandle, NvU32 set, void *pLaneDataParams, NvU32 size);






//! \ingroup hybridapi
//! Used in NV_HYBRID_OUTPUTS_INFO.
typedef struct
{
    NvU32               GPUId;          //!< dGPU ID
    NvU32               Devicemask;     //!< Display mask
} NV_HYBRID_GPU_INFO;


//! \ingroup hybridapi
//! Used in NvAPI_GetHybridConnectedOutputs().
typedef struct
{
    NvU32               version;           //!< Structure version
    NvU32               GPUCount;          //!< Number of GPU Info structures
    NV_HYBRID_GPU_INFO  GPUs[NVAPI_MAX_PHYSICAL_GPUS];
}NV_HYBRID_OUTPUTS_INFO;


//! \ingroup hybridapi
//! Macro for constructing the version field of NV_HYBRID_OUTPUTS_INFO
#define NV_HYBRID_OUTPUTS_INFO_VER  MAKE_NVAPI_VERSION(NV_HYBRID_OUTPUTS_INFO,1)


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_GetHybridConnectedOutputs
//
//! DESCRIPTION:    This API returns information about the Hybrid GPUs - dGPU ID and connected device mask array.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \retval   ::NVAPI_OK 
//! \retval   ::NVAPI_ERROR 
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE     NvAPI_GetHybridConnectedOutputs(NV_HYBRID_OUTPUTS_INFO *dGPUInfo);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_GetHybridEDID
//
//! DESCRIPTION:    This API returns the EDID for the specified dGPU and display output on a hybrid system.
//
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \retval   ::NVAPI_OK 
//! \retval   ::NVAPI_ERROR 
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE     NvAPI_GetHybridEDID(NvU32 GPUId, NvU32 displayOutputId, NV_EDID *pEDID);




///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SendHybridMessage
//
//! \fn NvAPI_SendHybridMessage(NV_HYBRID_MESSAGE msgType, NvU32 param)
//! DESCRIPTION:    This API sends a Hybrid message to nvsvc.
//!
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 173
//!
//! \param [in]     msgType    message type
//! \param [in]     param      message param
//! 
//! \retval         NVAPI_OK                 Completed request
//! \retval         NVAPI_ERROR              Miscellaneous error occurred
//! \retval         NVAPI_INVALID_ARGUMENT   Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////


//! \ingroup hybridapi
//! Used in NvAPI_SendHybridMessage().
typedef enum _NV_HYBRID_MESSAGE
{
    NV_HYBRID_MESSAGE_D3D_ATTACH           = 0x00,
    NV_HYBRID_MESSAGE_OGL_ATTACH           = 0x01,
    NV_HYBRID_MESSAGE_PROCESS_ATTACH       = 0x02,
    NV_HYBRID_MESSAGE_PROCESS_DETACH       = 0x03,
    NV_HYBRID_MESSAGE_POWER_SETTING        = 0x04,
    NV_HYBRID_MESSAGE_POWER_SOURCE         = 0x05,
    NV_HYBRID_MESSAGE_DISPLAY_SETTING      = 0x06,
    NV_HYBRID_MESSAGE_DOCKING              = 0x07,
    NV_HYBRID_MESSAGE_THERMAL              = 0x08,
    NV_HYBRID_MESSAGE_SETHYBRIDMODE        = 0x09,
} NV_HYBRID_MESSAGE;



//! \ingroup hybridapi
NVAPI_INTERFACE NvAPI_SendHybridMessage(NV_HYBRID_MESSAGE msgType, NvU32 param);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SetHybridMode
//
//! \fn NvAPI_SetHybridMode(NV_HYBRID_MODE mode)
//! DESCRIPTION: This API sets Hybrid mode. Supported on Vista and higher.
//!              Applications calling this API are required to run in elevated mode. 
//!              This API can be called from a system service to derive the elevated context of the System service. 
//!              \note Non-migratable applications that are running can prevent a successful transition.
//!              To query non-migratable applications use NvAPI_QueryNonMigratableApps().
//!
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 173
//!
//! \param [in]     mode     hybrid mode; see ::NV_HYBRID_MODE
//!
//! \retval         NVAPI_OK                 Completed request
//! \retval         NVAPI_ERROR              Miscellaneous error occurred
//! \retval         NVAPI_INVALID_ARGUMENT   Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup hybridapi
//! Used in NvAPI_SetHybridMode(), NvAPI_GetHybridMode(), and NvAPI_SetHybridModeEx().
typedef enum _NV_HYBRID_MODE
{
    NV_HYBRID_MODE_IGPU                 = 0x00,  //!< Integrated GPU
    NV_HYBRID_MODE_DGPU                 = 0x01,  //!< Discrete GPU
    NV_HYBRID_MODE_MULTI_ADAPTER        = 0x02,  //!< Multiple adapters
    NV_HYBRID_MODE_INVALID              = 0x03,  //!< Invalid mode
    NV_HYBRID_MODE_DGPU_WARMUP          = 0x04,
    NV_HYBRID_MODE_DGPU_DEEP_IDLE       = 0x05,
    NV_HYBRID_MODE_INSTALL              = 0x06,
    NV_HYBRID_MODE_ADAPTIVE             = 0x07, //!< This mode is only applicable for GetSwitchSettings.
} NV_HYBRID_MODE;



//! \ingroup hybridapi
NVAPI_INTERFACE NvAPI_SetHybridMode(NV_HYBRID_MODE mode);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetHybridMode
//
//! DESCRIPTION:    This function gets the current Hybrid mode. Supported on Vista and higher.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 173
//!
//! \param [out]    pMode     hybrid mode; see ::NV_HYBRID_MODE
//!
//! \retval         NVAPI_OK                 Completed request
//! \retval         NVAPI_ERROR              Miscellaneous error occurred
//! \retval         NVAPI_INVALID_ARGUMENT   Invalid input parameter
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetHybridMode(NV_HYBRID_MODE *pMode);







//! \ingroup hybridapi
//! Reference: Hybrid Spec 3.0 DSM Function HYBRIDCAPS bit 28:27
typedef enum _NV_HYBRID_SWITCH_METHOD
{
    NV_HYBRID_SWITCH_METHOD_NONE                = 0x00, //!< None of physical selector available 
                                    //!< (no hotkey, no physical button/switch, etc.)
    NV_HYBRID_SWITCH_METHOD_UNKNOWN                = 0x01, //!< Uses unspecified means to pass required state via 
                                    //!< POLICYSELECT, or other API
    NV_HYBRID_SWITCH_METHOD_HOTKEY                = 0x02,  
    NV_HYBRID_SWITCH_METHOD_PHYSICAL_SWITCH            = 0x03,
} NV_HYBRID_SWITCH_METHOD;


//! \ingroup hybridapi
typedef struct
{
    NV_HYBRID_SWITCH_METHOD method;
    NvU32                    numberOfWays;    
} NV_HYBRID_TRANSITION_METHOD;







///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetHybridSwitchStatus
//
//! DESCRIPTION:     This API gets the current Hybrid Switch Status (Hybrid mode).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \param [out]   pMode      Hybrid mode
//!
//! \retval  ::NVAPI_OK 
//! \retval  ::NVAPI_ERROR 
//! \retval  ::NVAPI_INVALID_ARGUMENT 
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetHybridSwitchStatus(NV_HYBRID_MODE *pMode);




///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetHybridInfo
//
//! \fn NvAPI_GetHybridInfo(NV_HYBRID_INFO *pHybridInfo)
//! DESCRIPTION:     This API queries the valid hybrid modes and the hybrid status. Supported on Vista and higher.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 173
//!
//! \param [in]    pHybridInfo             The hybrid information structure
//!
//! \retval        NVAPI_OK                Completed request
//! \retval        NVAPI_ERROR             Miscellaneous error occurred
//! \retval        NVAPI_INVALID_ARGUMENT  Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////


//! \ingroup hybridapi
//! Used in NvAPI_GetHybridInfo().
typedef struct
{
    NvU32 version;                          //!< The structure version
    NvU32 validHybridModes;                 //!< ::NV_HYBRID_VALID_MODES mask
    NvU32 hybridStatus;                     //!< ::NV_HYBRID_STATUS mask
} NV_HYBRID_INFO_v1;



//! \ingroup hybridapi
//! Used in NvAPI_GetHybridInfo().
typedef struct
{
    NvU32 version;                          //!< The structure version
    NvU32 validHybridModes;                 //!< ::NV_HYBRID_VALID_MODES mask
    NvU32 hybridStatus;                     //!< ::NV_HYBRID_STATUS mask
    NvU32 hybridDefaultGPU;                 //!< ::NV_GPU_TYPE: default GPU in the current mode
    NvU32 hybridUIState;                    //!< ::NV_HYBRID_STATE : what is the UI icon showing
    NvU32 hybridDriverState;                //!< ::NV_HYBRID_STATE : what state is the driver in
    NvU32 bIsHybridPerfSliSupported:1;      //!< Boolean: 0 = not supported, 1 = supported;
    NvU32 bIsHybridMCP:1;                   //!< Boolean: true if this is an MCP board.
    NvU32 bIsHybridMobileSystem:1;          //!< Boolean: true if a mobile hybrid system
    NvU32 transferNodeType;                 //!< ::NV_HYBRID_TRANSFER_NODE
} NV_HYBRID_INFO_v2;



//! \ingroup hybridapi
//! Used in NvAPI_GetHybridInfo().
typedef struct
{
    NvU32 version;                          //!< The structure version
    NvU32 validHybridModes;                 //!< ::NV_HYBRID_VALID_MODES mask
    NvU32 hybridStatus;                     //!< ::NV_HYBRID_STATUS mask
    NvU32 hybridDefaultGPU;                 //!< ::NV_GPU_TYPE: default GPU in the current mode
    NvU32 hybridUIState;                    //!< ::NV_HYBRID_STATE : what is the UI icon showing
    NvU32 hybridDriverState;                //!< ::NV_HYBRID_STATE : what state is the driver in
    NvU32 bIsHybridPerfSliSupported:1;      //!< Boolean: 0 = not supported, 1 = supported;
    NvU32 bIsHybridMCP:1;                   //!< Boolean: TRUE if this is an MCP board.
    NvU32 bIsHybridMobileSystem:1;          //!< Boolean: TRUE if this is a notebook hybrid system
    NvU32 transferNodeType;                 //!< ::NV_HYBRID_TRANSFER_NODE
    NvU8  showHybridUI;                     //!< (boolean) show the hybrid UI
} NV_HYBRID_INFO_v3;


//! \ingroup hybridapi
//! Used in NvAPI_GetHybridInfo().
typedef struct
{
    NvU32 version;                          //!< The structure version
    NvU32 validHybridModes;                 //!< ::NV_HYBRID_VALID_MODES mask
    NvU32 hybridStatus;                     //!< ::NV_HYBRID_STATUS mask
    NvU32 hybridDefaultGPU;                 //!< ::NV_GPU_TYPE: default GPU in the current mode
    NvU32 hybridUIState;                    //!< ::NV_HYBRID_STATE : what is the UI icon showing
    NvU32 hybridDriverState;                //!< ::NV_HYBRID_STATE : what state is the driver in
    NvU32 bIsHybridPerfSliSupported:1;      //!< Boolean: 0 = not supported, 1 = supported;
    NvU32 bIsHybridMCP:1;                   //!< Boolean: TRUE if this is an MCP board.
    NvU32 bIsHybridMobileSystem:1;          //!< Boolean: TRUE if a notebook hybrid system
    NvU32 transferNodeType;                 //!< ::NV_HYBRID_TRANSFER_NODE
    NvU8  showHybridUI;                     //!< (boolean) show the hybrid UI
    NV_HYBRID_TRANSITION_METHOD transMethod; //!< Method each system uses to transition  
} NV_HYBRID_INFO;





//! \addtogroup hybridapi
//! @{

//! Macro for determining the version field of NV_HYBRID_INFO_v1
#define NV_HYBRID_INFO_VER_1        MAKE_NVAPI_VERSION(NV_HYBRID_INFO_v1, 1)

//! Macro for determining the version field of NV_HYBRID_INFO_v2
#define NV_HYBRID_INFO_VER_2        MAKE_NVAPI_VERSION(NV_HYBRID_INFO_v2, 2)

//! Macro for determining the version field of NV_HYBRID_INFO_v3
#define NV_HYBRID_INFO_VER_3        MAKE_NVAPI_VERSION(NV_HYBRID_INFO_v3, 3)

//! Macro for determining the version field of NV_HYBRID_INFO
#define NV_HYBRID_INFO_VER          MAKE_NVAPI_VERSION(NV_HYBRID_INFO   , 4)

//! @}


//! \ingroup hybridapi
//! Used in NV_HYBRID_INFO, NV_HYBRID_INFO_V1, and NV_HYBRID_INFO_V2.
typedef enum 
{
    NV_HYBRID_STATUS_OK                     = 0x00000000,
    NV_HYBRID_STATUS_CHIPSET_NOT_SUPPORTED  = 0x00000001,
    NV_HYBRID_STATUS_MGPU_NOT_SUPPORTED     = 0x00000002,
    NV_HYBRID_STATUS_DGPU_NOT_SUPPORTED     = 0x00000004,
    NV_HYBRID_STATUS_NO_ASYNC_DMA_ENGINE    = 0x00000008,
    NV_HYBRID_STATUS_SBIOS_NOT_CONFIGURED   = 0x00000010,
    NV_HYBRID_STATUS_DGPUS_NOT_IDENTICAL    = 0x00000020,
    NV_HYBRID_STATUS_INVALID_GPU_COUNT      = 0x00000040,
    NV_HYBRID_STATUS_DGPU_DEEP_IDLE_NOT_SUPPORTED = 0x00000080
} NV_HYBRID_STATUS;


//! \ingroup hybridapi
//! Used in NV_HYBRID_INFO, NV_HYBRID_INFO_V1, and NV_HYBRID_INFO_V2.
typedef enum 
{
    NV_HYBRID_VALID_MODE_NONE               = 0x00000000,
    NV_HYBRID_VALID_MODE_POWER              = 0x00000001,
    NV_HYBRID_VALID_MODE_PERF               = 0x00000002,
    NV_HYBRID_VALID_MODE_PERFSLI            = 0x00000004,
    NV_HYBRID_VALID_MODE_MULTI_ADAPTER      = 0x00000008,
    NV_HYBRID_VALID_MODE_POWER_DEEP_IDLE    = 0x00000010
} NV_HYBRID_VALID_MODES;


//! \ingroup hybridapi
//! Used in NV_HYBRID_INFO and NV_HYBRID_INFO_v2.
typedef enum _NV_HYBRID_TRANSFER_NODE
{
    NV_HYBRID_TRANSFER_NODE_3D            = 0x00000000,
    NV_HYBRID_TRANSFER_NODE_CIPHER        = 0x00000001,
    NV_HYBRID_TRANSFER_NODE_VP            = 0x00000002,
    NV_HYBRID_TRANSFER_NODE_DMACOPY0      = 0x00000003,
    NV_HYBRID_TRANSFER_NODE_DMACOPY1      = 0x00000004,
    NV_HYBRID_TRANSFER_NODE_UNKNOWN       = 0xFFFFFFFF
} NV_HYBRID_TRANSFER_NODE;


//! \ingroup hybridapi
//! Used in NV_HYBRID_INFO, NV_HYBRID_INFO_V1, and NV_HYBRID_INFO_V2.
typedef enum _NV_HYBRID_STATE
{
    NV_HYBRID_STATE_POWER              = 0x00000000,
    NV_HYBRID_STATE_PERF               = 0x00000001,
    NV_HYBRID_STATE_MULTI_ADAPTER      = 0x00000002,
    NV_HYBRID_STATE_INVALID            = 0xFFFFFFFF,
} NV_HYBRID_STATE;



//! \ingroup hybridapi
NVAPI_INTERFACE NvAPI_GetHybridInfo(NV_HYBRID_INFO *pHybridInfo);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_Coproc_GetCoprocStatus
//
//! \fn NvAPI_Coproc_GetCoprocStatus(NvU32 *pCoprocStatus, NV_COPROC_STATE* pCoprocState)
//! DESCRIPTION:     This API queries the the coproc status and state. 
//!                  Supported on Vista and higher.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in,out]      pCoprocStatus  The coproc status
//! \param [in,out]      pCoprocState   The coproc state
//!
//! \retval ::NVAPI_OK              Completed request
//! \retval ::NVAPI_NOT_SUPPORTED   This feature is not supported on Windows XP
//! \retval ::NVAPI_API_NOT_INTIALIZED  You must call NvAPI_Initialize first
//! \retval ::NVAPI_ERROR               Miscellaneous error occurred
//! \retval ::NVAPI_INVALID_ARGUMENT    Invalid input parameter
///////////////////////////////////////////////////////////////////////////////

//! \ingroup coprocapi
//! Used in NvAPI_Coproc_GetCoprocStatus().
typedef enum _NV_COPROC_STATUS
{
    NV_COPROC_STATUS_OK                                       = 0x00000000,
    NV_COPROC_STATUS_CHIPSET_NOT_SUPPORTED                    = 0x00000001,
    NV_COPROC_STATUS_MGPU_NOT_SUPPORTED                       = 0x00000002,
    NV_COPROC_STATUS_DGPU_NOT_SUPPORTED                       = 0x00000004,
    NV_COPROC_STATUS_INVALID_GPU_COUNT                        = 0x00000008,
    NV_COPROC_STATUS_DISABLED_BY_REG_KEY                      = 0x00000010,
    NV_COPROC_STATUS_DGPU_POSTING_DEVICE                      = 0x00000020,
    NV_COPROC_STATUS_DISABLED_BY_HYBRID                       = 0x00000040,
    NV_COPROC_STATUS_OS_NOT_SUPPORTED                         = 0x00000080,
    NV_COPROC_STATUS_SBIOS_NOT_CONFIGURED                     = 0x00000100,
    NV_COPROC_STATUS_DGPU_NOT_SUPPORTED_BY_MSHYBRID           = 0x00000200,
    NV_COPROC_STATUS_TRANSCODE_ONLY_NOT_SUPPORTED             = 0x00000400,
    NV_COPROC_STATUS_XGPU_NOT_SUPPORTED                       = 0x00000800,
    NV_COPROC_STATUS_DISABLED_NOT_SUPPORTED_IGPU_DRIVER_MODEL = 0x00001000,

    NV_COPROC_STATUS_UNKNOWN                                  = 0xFFFFFFFF,
} NV_COPROC_STATUS;

typedef enum _NV_COPROC_PROBLEM_TYPE
{
    NV_COPROC_PROBLEM_MISC               =  0x00000001, 
    NV_COPROC_PROBLEM_DISABLED           =  0x00000002, 
    NV_COPROC_PROBLEM_DDI_ACQUIRE        =  0x00000004, 
    NV_COPROC_PROBLEM_BUS_SCAN           =  0x00000008, 
    NV_COPROC_PROBLEM_POWER_EVENT        =  0x00000010, 
    NV_COPROC_PROBLEM_PS_RULE            =  0x00000020, 
    NV_COPROC_PROBLEM_ACPI               =  0x00000040, 
    NV_COPROC_PROBLEM_DEVICE             =  0x00000080, 
    NV_COPROC_PROBLEM_OUTSTANDING_LOCK   =  0x00000100, 
    NV_COPROC_PROBLEM_CPUVISIBLE_SURFACE =  0x00000200, 
    NV_COPROC_PROBLEM_SRLESS_MONITOR     =  0x00000400, 
    NV_COPROC_PROBLEM_AUDIO_MONITOR      =  0x00000800, 
    NV_COPROC_PROBLEM_FLIP               =  0x00001000, 
    NV_COPROC_PROBLEM_CMD_BUF            =  0x00002000,
    NV_COPROC_PROBLEM_DEFERRED_WORK      =  0x00004000,
    NV_COPROC_PROBLEM_SR_INACTIVE        =  0x00008000,
    NV_COPROC_PROBLEM_REF_RM             =  0x00010000,
    NV_COPROC_PROBLEM_REF_MSHYBRID       =  0x00020000,
} NV_COPROC_PROBLEM_TYPE;

//! \ingroup coprocapi
//! Used in NvAPI_Coproc_GetCoprocStatus().
typedef enum _NV_COPROC_STATE
{
    NV_COPROC_STATE_DGPU_GOLD              = 0x00000000,
    NV_COPROC_STATE_DGPU_ON                = 0x00000001,
    NV_COPROC_STATE_DGPU_GC6               = 0x00000002,
} NV_COPROC_STATE;

//! \ingroup coprocapi
//! Used in NvAPI_Coproc_GetCoprocInfo().

//! JT flags represent the JT GPU capabilities.
typedef enum _NV_JT_FLAGS
{
    NV_JT_FLAGS_NONE                        = 0x00000000,
    NV_JT_FLAGS_GC6_ENABLED                 = 0x00000001,
    NV_JT_FLAGS_SUPPORTS_GC6_TDR	    = 0x00000002,
} NV_JT_FLAGS;

//! \ingroup coprocapi
NVAPI_INTERFACE NvAPI_Coproc_GetCoprocStatus(NvU32 *pCoprocStatus, NV_COPROC_STATE* pCoprocState);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_Coproc_GetCoprocInfo
//
//! \fn NvAPI_Coproc_GetCoprocInfo(NV_COPROC_INFO *pCoprocInfo)
//!
//! DESCRIPTION:     This API queries the the copoc status. Supported on Vista and higher.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:      pCoprocInfo (IN)     - the coproc info structure
//!
//! RETURN STATUS:
//!                  NVAPI_OK - completed request
//!                  NVAPI_ERROR - miscellaneous error occurred
//!                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//!
///////////////////////////////////////////////////////////////////////////////

//! \ingroup coprocapi
typedef struct
{
    NvU32 version;                      //!< the structure version
    NvU32 coprocStatusMask;             //!< NV_COPROC_STATUS mask
    NvU32 coprocFlags;                  //!< NV_COPROC_FLAGS mask
    NvU32 totalReferenceCount;          //!< Sum of references keeping the GPU powered up.
    NvU32 deviceCount;                  //!< Devices created on GPU
    NvU32 allocationCount;              //!< Allocations created on GPU
    NvU32 activeEntryPointCount;        //!< Active calls into the KMD.
    NvU32 timeInCurrentStateMs;         //!< in ms
    NvU32 timeInLastStateMs;            //!< in ms
    NvU8  currentState;                 //!< State NV_COPROC_STATE
    NvU8  lastState;                    //!< State NV_COPROC_STATE
} NV_COPROC_INFO_V1;

typedef struct
{
    NvU32 version;                      //!< the structure version
    NvU32 coprocStatusMask;             //!< NV_COPROC_STATUS mask
    NvU32 coprocFlags;                  //!< NV_COPROC_FLAGS mask
    NvU32 totalReferenceCount;          //!< Sum of references keeping the GPU powered up.
    NvU32 deviceCount;                  //!< Devices created on GPU
    NvU32 allocationCount;              //!< Allocations created on GPU
    NvU32 activeEntryPointCount;        //!< Active calls into the KMD.
    NvU32 timeInCurrentStateMs;         //!< in ms
    NvU32 timeInLastStateMs;            //!< in ms
    NvU8  currentState;                 //!< State NV_COPROC_STATE
    NvU8  lastState;                    //!< State NV_COPROC_STATE
    NvU32 goldMask;                     //!< bitfield of the reasons Gold is not active from NV_COPROC_REF_TYPE
    NvU32 GC6Mask;                      //!< bitfield of the reasons GC6 is not active from NV_COPROC_REF_TYPE
    NvU32 JTFlags;                      //!< JT State NV_JT_FLAGS_

} NV_COPROC_INFO_V2;



//! \ingroup coprocapi
//! Macro for constructingthe version field of ::NV_COPROC_INFO

typedef NV_COPROC_INFO_V2 NV_COPROC_INFO;

#define NV_COPROC_INFO_VER_1  MAKE_NVAPI_VERSION(NV_COPROC_INFO_V1,1)
#define NV_COPROC_INFO_VER_2  MAKE_NVAPI_VERSION(NV_COPROC_INFO_V2,2)
#define NV_COPROC_INFO_VER    NV_COPROC_INFO_VER_2

//! \ingroup coprocapi
typedef enum _NV_COPROC_FLAGS
{
    NV_COPROC_FLAGS_NONE                          = 0x00000000,
    NV_COPROC_FLAGS_MONITOR_FOUND                 = 0x00000001,
    NV_COPROC_FLAGS_TIMER_SCHEDULED               = 0x00000002,
    NV_COPROC_FLAGS_GOLD_ON_HYBRID                = 0x00000004, 
    NV_COPROC_FLAGS_CHECK_SBIOS_COOKIE            = 0x00000008,
    NV_COPROC_FLAGS_SBIOS_NOT_CONFIGURED          = 0x00000010,
    NV_COPROC_FLAGS_IGPU_MODE_ONLY                = 0x00000020,   //!< Indicates whether IGPU is forced
    NV_COPROC_FLAGS_HDMI_AUDIO_DYNAMIC            = 0x00000040,
    NV_COPROC_FLAGS_FORCE_GPU_SWITCH_AVAILABLE    = 0x00000080,   //!< Indicates whether we are providing the Force GPU switch feature
    NV_COPROC_FLAGS_FORCE_OPTIMUS                 = 0x00000100,   //!< Indicates that we have to set Optimus mode and override FORCE_IGPU \ FORCE_DGPU if set.
    NV_COPROC_FLAGS_REQUIRED_SBIOS_COOKIE         = 0x00000200,   //!< Indicates whether SBIOS cookie is required
    NV_COPROC_FLAGS_DGPU_MODE_ONLY                = 0x00000400,   //!< Indicates whether DGPU is forced
    NV_COPROC_FLAGS_ENABLE_FRAMERATE_LIMITER      = 0x00000800,   //!< Indicates if FRL is permitted
    NV_COPROC_FLAGS_FWD_OPTIMUS                   = 0x00001000,   //!< Indicates if we should support forward (normal) optimus
    NV_COPROC_FLAGS_TRANSCODE                     = 0x00002000,   //!< Indicates if we should support limited reverse optimus for transcode
    NV_COPROC_FLAGS_GPU_SOLDERED_ON_MB            = 0x00004000,   //!< Indicates whether DGPU motherboard soldered or not. 
    NV_COPROC_FLAGS_MS_HYBRID                     = 0x00008000,   //!< Indicates whether it is MS-Hybrid. 
    NV_COPROC_FLAGS_CHECK_XGPU_CONFIG             = 0x00010000,   //!< Indicates the presence of XGPU and need to confirmed with valud dGPU device IDs.
    NV_COPROC_FLAGS_QUADRO                        = 0x00020000,   //!< Indicates if it is Quadro system.
    NV_COPROC_FLAGS_LIMITTOWDDM12                 = 0x00040000,
    NV_COPROC_FLAGS_DGPU_PASSTHROUGH              = 0x00080000,
    NV_COPROC_FLAGS_DGPU_VIDEOLESS                = 0x00100000,
    NV_COPROC_FLAGS_TRANSITION_LIMITED            = 0x00200000,
    NV_COPROC_FLAGS_HW_NOT_SUPPORT_MSHYBRID_WIN10_PLUS = 0x00400000,   //!< MsHybrid support (will be catered on Win10 and above for detecting).
                                                                       //!< This is to identify the older system architecture (HuronRiver and below) which are not supporting MsHybrid.
                                                                       //!< Systems Ivybridge (Chief River) and above is capable of MsHybrid support.
    NV_COPROC_FLAGS_OPTIMUS_STYLE_POWER_MANAGEMENT    = 0x00800000,    //!< Optimus (GOLD) style of power management.
    NV_COPROC_FLAGS_STOPWHITELISTING_APP_FOR_DGPU     = 0x01000000,    //!< Not to whitelist any application to use dGPU.
} NV_COPROC_FLAGS;

//! \ingroup coprocapi
NVAPI_INTERFACE NvAPI_Coproc_GetCoprocInfo(__inout NV_COPROC_INFO *pCoprocInfo);



///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_Coproc_SetCoprocInfoFlags
//
//! DESCRIPTION:     This API sets values in the coproc info flags.
//!                  The mask that can be changed is NV_COPROC_FLAGS_IGPU_MODE_ONLY
//!                  Passing in 0 unsets NV_COPROC_FLAGS_IGPU_MODE_ONLY in NV_COPROC_INFO.coprocFlags
//!                  Passing NV_COPROC_FLAGS_IGPU_MODE_ONLY sets NV_COPROC_FLAGS_IGPU_MODE_ONLY 
//!                  in NV_COPROC_INFO.coprocFlags
//!                  All other masks are left untouched.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:      NvU32 (IN)     - the mask to be set
//!
//! RETURN STATUS:
//!                  NVAPI_OK - completed request
//!                  NVAPI_ERROR - miscellaneous error occurred
//!                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//!
//! \ingroup coprocapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Coproc_SetCoprocInfoFlags(NvU32 coprocInfoFlags);



//! \ingroup coprocapi
typedef struct 
{
    NvU32  version;
    NvU32  is_IGPU_MODE_ONLY : 1;   //!< Indicates if the IGPU_MODE_ONLY flag is set or needs to be set
    NvU32  is_DGPU_MODE_ONLY : 1;   //!< Indicates if the DGPU_MODE_ONLY flag is set or needs to be set
    NvU32  reserved          : 30;  //!< Should be set to ZERO
} NV_COPROC_FLAGS_EX;

//! \ingroup coprocapi
#define NV_COPROC_FLAGS_EX_VER          MAKE_NVAPI_VERSION(NV_COPROC_FLAGS_EX, 1)

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_Coproc_SetCoprocInfoFlagsEx
//
//! DESCRIPTION:     This API sets the coproc info flags.
//!
//! \param [in]      coprocInfoExFlags  pointer to the NV_COPROC_FLAGS_EX indicating the mask to be set
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \retval ::NVAPI_OK                  completed request
//! \retval ::NVAPI_ERROR               miscellaneous error occurred
//! \retval ::NVAPI_INVALID_POINTER     null input parameter
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION
//!
//! \ingroup coprocapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Coproc_SetCoprocInfoFlagsEx(NV_COPROC_FLAGS_EX* coprocInfoExFlags);




///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_Coproc_GetCoprocInfoFlagsEx
//
//! DESCRIPTION:     This API gets the coproc info flags.
//!
//! \param [out]     coprocInfoExFlags   pointer to the NV_COPROC_FLAGS_EX indicating the mask to get
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \retval ::NVAPI_OK                  completed request
//! \retval ::NVAPI_ERROR               miscellaneous error occurred
//! \retval ::NVAPI_INVALID_POINTER     null input parameter
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION
//!
//! \ingroup coprocapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Coproc_GetCoprocInfoFlagsEx(NV_COPROC_FLAGS_EX* coprocInfoExFlags);



//! \ingroup coprocapi
typedef enum _NVAPI_COPROC_OVERRIDE_OPTION
{
    NVAPI_COPROC_OVERRIDE_OPTION_SET    = 0,
    NVAPI_COPROC_OVERRIDE_OPTION_RESET  = 1
} NVAPI_COPROC_OVERRIDE_OPTION;

//! \ingroup coprocapi
typedef struct _NV_COPROC_OVERRIDE_INFO_FLAGS
{
    NvU32  version;
    NVAPI_COPROC_OVERRIDE_OPTION    coprocOverrideOption;                    //!< Indicates option to set or reset the required flag
    NvU32                           is_STOP_WHITELISTING_APP_FOR_DGPU : 1;   //!< Indicates if the Stop Whitelisting coproc flag is to be overridden
    NvU32                           reserved : 31;                           //!< Should be set to ZERO
} NV_COPROC_OVERRIDE_INFO_FLAGS_V1;

//! \ingroup coprocapi
typedef NV_COPROC_OVERRIDE_INFO_FLAGS_V1    NV_COPROC_OVERRIDE_INFO_FLAGS;

#define NV_COPROC_OVERRIDE_INFO_FLAGS_VER1  MAKE_NVAPI_VERSION(NV_COPROC_OVERRIDE_INFO_FLAGS_V1, 1)

#define NV_COPROC_OVERRIDE_INFO_FLAGS_VER   NV_COPROC_OVERRIDE_INFO_FLAGS_VER1

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_Coproc_OverrideCoprocInfoFlags
//
//! DESCRIPTION:     This API sets or resets the coproc info flag. And these 
//!                  flags will not be changed by internal hardware settings.
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]      coprocOverrideInfoFlags  pointer to the NV_COPROC_OVERRIDE_INFO_FLAGS \n
//!                  indicating the flags to be set or reset
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \ingroup coprocapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Coproc_OverrideCoprocInfoFlags(NV_COPROC_OVERRIDE_INFO_FLAGS* coprocOverrideInfoFlags);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_Coproc_NotifyCoprocPowerState
//
//! \fn NvAPI_Coproc_NotifyCoprocPowerState(NvU32 IsSafetoPowerOff, NvU64 SequenceNumber, NvU32 *pStatus)
//!
//! DESCRIPTION:     This API tells driver that now it is safe to power off dGPU since No running Application is using the coproc.
//!                  
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:      IsSafetoPowerOff (IN)     - decides if it is safe to power off the dGPU. TRUE to turn off dGPU.
//!                    SequenceNumber (IN)       - In response to event with matching sequence number
//!                  pStatus(OUT)              - returns the status if powering off dGPU has started.
//!
//! RETURN STATUS:
//!                  NVAPI_OK - completed request
//!                  NVAPI_ERROR - miscellaneous error occurred
//!                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup coprocapi
typedef enum
{
    NV_COPROC_POWER_OFF_MODE_UNSAFE = 0,
    NV_COPROC_POWER_OFF_MODE_GPU_OFF = 1,
    NV_COPROC_POWER_OFF_MODE_HDA_REMOVE = 0xff10,
} NV_COPROC_POWER_OFF_MODE;


//! \ingroup coprocapi
NVAPI_INTERFACE NvAPI_Coproc_NotifyCoprocPowerState(NvU32 IsSafetoPowerOff, NvU64 SequenceNumber, NvU32 *pStatus);




///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_Coproc_GetApplicationCoprocInfo
//
//! \fn NvAPI_Coproc_GetApplicationCoprocInfo(NV_COPROC_APP_INFO *pCoprocAppInfo)
//! DESCRIPTION:     This API queries the the coproc status for the application
//!                  running in the current process.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]   pCoprocAppInfo   The coproc application info structure
//!
//! \retval ::NVAPI_OK - completed request
//! \retval ::NVAPI_ERROR - miscellaneous error occurred
//! \retval ::NVAPI_INVALID_ARGUMENT - Invalid input parameter
//! \retval ::NVAPI_NOT_SUPPORTED - function is not supported in this platform
//! \retval ::NVAPI_API_NOT_INTIALIZED 
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION 
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup coprocapi
//! Used in NvAPI_Coproc_GetApplicationCoprocInfo().
typedef struct
{
    NvU32 version;                      //!< the structure version
    NvU32 appStatus;            //!< the application status  
} NV_COPROC_APP_INFO;

//! \ingroup coprocapi
//! Macro for onstructing the version field of NV_COPROC_APP_INFO
#define NV_COPROC_APP_INFO_VER          MAKE_NVAPI_VERSION(NV_COPROC_APP_INFO, 1)

//! \ingroup coprocapi
//! See .NV_COPROC_APP_INFO
typedef enum
{
    NV_COPROC_APP_STATUS_ENABLED           = 0x00000000, //!< coproc mode has been enabled
    NV_COPROC_APP_STATUS_DISABLED          = 0x00000001, //!< copro mode has been disabled.
} NV_COPROC_APP_STATUS;

//! \ingroup coprocapi
NVAPI_INTERFACE NvAPI_Coproc_GetApplicationCoprocInfo(NV_COPROC_APP_INFO *pCoprocAppInfo);




//! \ingroup coprocapi
//! @{

#define NV_COPROC_STATE_CHANGE_LOG_COUNT       32

typedef enum _NV_COPROC_POWER_STATE 
{
    NV_COPROC_POWER_STATE_ERROR = 0,
    NV_COPROC_POWER_STATE_ON,
    NV_COPROC_POWER_STATE_GOLD,
    NV_COPROC_POWER_STATE_EXITING_GOLD,
    NV_COPROC_POWER_STATE_ENTERING_GOLD,
    NV_COPROC_POWER_STATE_WAITING_FOR_SVC,
    NV_COPROC_POWER_STATE_GC6,
    NV_COPROC_POWER_STATE_EXITING_GC6,
    NV_COPROC_POWER_STATE_ENTERING_GC6,
} NV_COPROC_POWER_STATE;

typedef struct _NV_COPROC_STATE_CHANGE_ENTRY 
{
    NvU64                      timeStampMicroseconds;
    NV_COPROC_POWER_STATE      coprocPowerState;
    NvU32                      coprocReason;       //!<This variable is not implemented as yet in the driver.
                                                   //!< As of now , we shall always return 0 for this variable.

} NV_COPROC_STATE_CHANGE_ENTRY;


typedef struct _NV_COPROC_GET_GOLD_STATISTICS 
{
    NvU32 version;  //!<NV_COPROC_GOLD_STATISTICS struct version
    
    NvU32 dwGoldTimeoutValue;   
    NvU32 dwGoldTransitionCount;
    NvU32 dwMinTimeInGoldMs;
    NvU32 dwMaxTimeInGoldMs;
    NvU32 dwAvgTimeInGoldMs;
    NvU32 dwMinTimeEnteringGoldMs;
    NvU32 dwMaxTimeEnteringGoldMs;
    NvU32 dwAvgTimeEnteringGoldMs;
    NvU32 dwMinTimeExitingGoldMs;
    NvU32 dwMaxTimeExitingGoldMs;
    NvU32 dwAvgTimeExitingGoldMs;
    
    // Entry 0 is most recent
    NV_COPROC_STATE_CHANGE_ENTRY stateChangeLog[NV_COPROC_STATE_CHANGE_LOG_COUNT];

}NV_COPROC_GOLD_STATISTICS;
    
//! Macro for constructing the version field of ::NV_COPROC_GOLD_STATISTICS     
#define NV_COPROC_GOLD_STATISTICS_VER  MAKE_NVAPI_VERSION(NV_COPROC_GOLD_STATISTICS,1)



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Coproc_GetGoldStatistics
//
//! PARAMETERS:        bClearStatistics (IN) - if set, clears all the statistics.
//!                  pCoprocGoldStats (OUT) - Pointer to the NV_COPROC_GOLD_STATISTICS data. 
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! DESCRIPTION:     This API call is used to get the GOLD Stats from the Driver.
//!                  If call succeeds,  "pCoprocGoldStats" points to the Gold Statistics.
//!
//!
//! RETURN STATUS:
//!    NVAPI_OK - completed request
//!    NVAPI_INCOMPATIBLE_STRUCT_VERSION - NV_COPROC_GOLD_STATISTICS structure version mismatch.
//!    NVAPI_ERROR - miscellaneous error occurred.
//!    NVAPI_INVALID_POINTER - NULL argument passed.
//!    NVAPI_NOT_SUPPORTED - call is not supported.
//!    NVAPI_API_NOT_INTIALIZED - NvAPI not initialized.
//!      NVAPI_INVALID_ARGUMENT - Invalid Argument.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Coproc_GetGoldStatistics(NvU32 bClearStatistics, NV_COPROC_GOLD_STATISTICS *pCoprocGoldStats);

//! @}


//! \ingroup coprocapi
typedef enum _NV_COPROC_HYSTERESIS_TYPE
{
    NV_COPROC_HYSTERESIS_GOLD,
    NV_COPROC_HYSTERESIS_GC6,
    NV_COPROC_HYSTERESIS_ALL,
    NV_COPROC_HYSTERESIS_NONE,
    
} NV_COPROC_HYSTERESIS_TYPE;

//! \ingroup coprocapi
typedef struct _NV_COPROC_HYSTERESIS
{
    NvU32 version;
    
    NV_COPROC_HYSTERESIS_TYPE type; 
    NvU32 goldIdleTimeoutMs;
    NvU32 GC6IdleTimeoutMs;
    
} NV_COPROC_HYSTERESIS_V1;

typedef NV_COPROC_HYSTERESIS_V1     NV_COPROC_HYSTERESIS;

#define NV_COPROC_HYSTERESIS_VER1   MAKE_NVAPI_VERSION(NV_COPROC_HYSTERESIS_V1,1)

#define NV_COPROC_HYSTERESIS_VER    NV_COPROC_HYSTERESIS_VER1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Coproc_SetHysteresis
//
//! DESCRIPTION:    This API allows setting hysteresis values for Gold and GC6
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in,out]     pCoprocSetHysteresis  - Pointer to NV_COPROC_HYSTERESIS structure. 
//!                                            The input value in NV_COPROC_TYPE indicates which threshold to set.
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \ingroup coprocapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Coproc_SetHysteresis(__inout NV_COPROC_HYSTERESIS *pCoprocSetHysteresis);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Coproc_GetHysteresis
//
//! DESCRIPTION:    This API gets hysteresis values for Gold and GC6
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in,out]     pCoprocGetHystersis  - Pointer to NV_COPROC_HYSTERESIS structure. 
//!                                            The input value in NV_COPROC_TYPE indicates which of the threshold returned value is valid.
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \ingroup coprocapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Coproc_GetHysteresis(__inout NV_COPROC_HYSTERESIS *pCoprocGetHysteresis);



//! \ingroup coprocapi
typedef struct _NV_COPROC_GC6_WAKE_BEHAVIOR
{
    NvU32 version;
    
    NvU32 bUseHwTimer;
    NvU32 timeToWakeUs;
    
} NV_COPROC_GC6_WAKE_BEHAVIOR_V1;

typedef NV_COPROC_GC6_WAKE_BEHAVIOR_V1     NV_COPROC_GC6_WAKE_BEHAVIOR;

#define NV_COPROC_GC6_WAKE_BEHAVIOR_VER1   MAKE_NVAPI_VERSION(NV_COPROC_GC6_WAKE_BEHAVIOR_V1,1)

#define NV_COPROC_GC6_WAKE_BEHAVIOR_VER    NV_COPROC_GC6_WAKE_BEHAVIOR_VER1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Coproc_SetGC6WakeBehavior
//
//! DESCRIPTION:    
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in,out]     pCoprocSetGC6WakeBehavior  - Pointer to NV_COPROC_GC6_WAKE_BEHAVIOR structure. 
//!                                            The input value in 
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \ingroup coprocapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Coproc_SetGC6WakeBehavior(__inout NV_COPROC_GC6_WAKE_BEHAVIOR *pCoprocSetGC6WakeBehavior);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Hybrid_ControlDriverHDABus
//
//!   DESCRIPTION: Disable/Enable the Driver of HDMI Audio Bus
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:     stateChange (IN) - TRUE to enable the HDMI AudioBus driver, FALSE to disable it 
//! RETURN STATUS:  NVAPI_OK - completed request
//!                 NVAPI_ERROR - miscellaneous error occurred
//!                 NVAPI_INVALID_ARGUMENT - Invalid input parameter
//!            NVAPI_NOT_SUPPORTED - function is not supported in this platform
//!            NVAPI_API_NOT_INTIALIZED - You must call NvAPI_Initialize first
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Hybrid_ControlDriverHDABus(NvU32 stateChange);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Hybrid_ControlDriverHDA
//
//!   DESCRIPTION: Disable/Enable the Driver of HDMI Audio
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:     stateChange (IN) - TRUE to enable the HDMI Audio-driver, FALSE to disable it 
//! RETURN STATUS:  NVAPI_OK - completed request
//!                 NVAPI_ERROR - miscellaneous error occurred
//!                 NVAPI_INVALID_ARGUMENT - Invalid input parameter
//!            NVAPI_NOT_SUPPORTED - function is not supported in this platform
//!            NVAPI_API_NOT_INTIALIZED - You must call NvAPI_Initialize first
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Hybrid_ControlDriverHDA(NvU32 stateChange);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetHybridStatusString
//
//!   DESCRIPTION: This function converts a Hybrid status into a null terminated string.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 173
//!
//! \return  A null terminated string (always, never NULL)
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetHybridStatusString(NvU32 nr,NvAPI_String szDesc);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetHybridModesString
//
//!   DESCRIPTION: This function converts a Hybrid mode into a null terminated string.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 173
//!
//! \return  A null terminated string (always, never NULL)
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetHybridModesString(NvU32 nr,NvAPI_String szDesc);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Coproc_GetCoprocStatusString
//
//!   DESCRIPTION: converts an Coproc status into a null terminated string
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \return null terminated string (always, never NULL)
//!
//! \ingroup coprocapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Coproc_GetCoprocStatusString(NvU32 nr,NvAPI_String szDesc);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Coproc_GetCoprocFlagsString
//
//!   DESCRIPTION: converts an Coproc status into a null terminated string
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \return null terminated string (always, never NULL)
//!
//! \ingroup coprocapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Coproc_GetCoprocFlagsString(NvU32 nr,NvAPI_String szDesc);






///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_LightWeightDGPU
//
//!   DESCRIPTION: This API wakes up the dGPU and loads the NVIDIA driver for Intel Hybrid systems.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \retval ::NVAPI_OK    
//! \retval ::NVAPI_ERROR  
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_LightWeightDGPU(NvU32 flags);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_HybridIGPUHeadsControl
//
//!   DESCRIPTION: This API requests the Hybrid Interposer to hide or unhide iGPU heads.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \retval ::NVAPI_OK    
//! \retval ::NVAPI_ERROR  
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_HybridIGPUHeadsControl(NvU8 bHide);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_QueryHybridIGPUHeadsControl
//
//!   DESCRIPTION: This API queries the Hybrid Interposer iGPU hide-heads state.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \retval ::NVAPI_OK    
//! \retval ::NVAPI_ERROR  
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_QueryHybridIGPUHeadsControl(NvU8 *pbHide);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_IsIntelHybrid
//
//! PARAMETERS:      IsIntel(IN/OUT)          - boolean: zero=Not a Intel Hybrid System, one=Intel Hybrid System
//! DESCRIPTION:     This API determines whether running system is Intel Hybrid or not
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! RETURN STATUS: 
//!                  NVAPI_OK - completed request
//!                  NVAPI_ERROR - miscellaneous error occurred
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_IsIntelHybrid(NvU8 *IsIntel);



///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_Hybrid_SetDGPUPowerState
//
//! \fn NvAPI_Hybrid_SetDGPUPowerState(NV_HYBRID_POWERSTATE powerState)
//!
//! DESCRIPTION: This API sets the dGPU Power State on a hybrid system. 
//!         Supported on Vista and higher.
//!              App calling this API is required to run in elevated mode. 
//!              When called, this will change the power state of all dGPUs in
//!              the system.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:      powerState(IN)     - Requested power state for dGPUs
//!
//! RETURN STATUS: 
//!                  NVAPI_OK - completed request
//!                  NVAPI_ERROR - miscellaneous error occurred
//!                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup hybridapi
typedef enum _NV_HYBRID_POWERSTATE
{
    NV_HYBRID_POWERSTATE_OFF       = 0x00,
    NV_HYBRID_POWERSTATE_ON        = 0x01,
    NV_HYBRID_POWERSTATE_DEEPIDLE  = 0x02, 
} NV_HYBRID_POWERSTATE;

//! \ingroup hybridapi
NVAPI_INTERFACE NvAPI_Hybrid_SetDGPUPowerState(NV_HYBRID_POWERSTATE powerState);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_Hybrid_GetDGPUPowerState
//
//! DESCRIPTION:     This API gets current dGPU Power State. 
//!                  Supported on Vista and higher.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:      pPowerState(OUT)     - Power State
//!
//! RETURN STATUS: 
//!                  NVAPI_OK - completed request
//!                  NVAPI_ERROR - miscellaneous error occurred
//!                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Hybrid_GetDGPUPowerState(NV_HYBRID_POWERSTATE *pPowerState);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_Hybrid_StartTransition
//
//! DESCRIPTION: This API notifies the driver to start a hybrid transition
//!         Supported on Vista and higher.
//!              App calling this API is required to run in elevated mode. 
//!              This call is called after the dGPUs are powered up, but before
//!              the DGPU drivers are enabled.
//!              If this call succeeds, an NvAPI_Hybrid_StopTransition() must
//!              be called, regardless of success or failure.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:      mode(IN)     - Requested mode for transition
//!                  phTransition(OUT) - Handle used to address this transition
//!
//! RETURN STATUS: 
//!                  NVAPI_OK - completed request
//!                  NVAPI_ERROR - miscellaneous error occurred
//!                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Hybrid_StartTransition(NV_HYBRID_MODE mode, NvTransitionHandle* phTransition);



///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_Hybrid_StopTransition
//
//! DESCRIPTION: This API notifies the driver to stop a hybrid transition
//!         Supported on Vista and higher.
//!              App calling this API is required to run in elevated mode. 
//!              This call is called after the drivers are stable, but
//!              not necessarily powered off.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:      hTransition(IN) - Handle returned from NvAPI_Hybrid_StartTransition
//!                  mode(IN)     - Final mode which was accepted
//!                                 This might be different than the 
//!                                 StartTransition mode, since a failure
//!                                 could result in falling back
//!
//! RETURN STATUS: 
//!                  NVAPI_OK - completed request
//!                  NVAPI_ERROR - miscellaneous error occurred
//!                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Hybrid_StopTransition(NvTransitionHandle hTransition, NV_HYBRID_MODE mode);



///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_Hybrid_SetDGPUDriverState
//
//! \fn NvAPI_Hybrid_SetDGPUDriverState(NvTransitionHandle hTransition, NV_HYBRID_DRIVERSTATE driverState)
//!
//! DESCRIPTION:     This API sets the current dGPU Driver State
//!                  Supported on Vista and higher.
//!                  NOTE: If the driver is currently yellow-banged, and the
//!                  request is to start the driver, a stop will be called 
//!                  first to clear the driver failure.
//!                  This call is made after a successful StartTransition
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:      hTransition(IN) - Handle returned from NvAPI_Hybrid_StartTransition
//!                  driverState(IN) - Requested driver state
//!
//! RETURN STATUS: 
//!                  NVAPI_OK - completed request
//!                  NVAPI_ERROR - miscellaneous error occurred
//!                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup hybridapi
typedef enum _NV_HYBRID_DRIVERSTATE
{
    NV_HYBRID_DRIVERSTATE_UNKNOWN   = 0x00,
    NV_HYBRID_DRIVERSTATE_DISABLED  = 0x01,
    NV_HYBRID_DRIVERSTATE_ENABLED   = 0x02,
    NV_HYBRID_DRIVERSTATE_PROBLEM   = 0x03,
    NV_HYBRID_DRIVERSTATE_STARTING  = 0x04,
} NV_HYBRID_DRIVERSTATE;

//! \ingroup hybridapi
NVAPI_INTERFACE NvAPI_Hybrid_SetDGPUDriverState(NvTransitionHandle hTransition, NV_HYBRID_DRIVERSTATE driverState);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_Hybrid_GetDGPUDriverState
//
//! DESCRIPTION:     This API gets the current dGPU Driver State
//!                  Supported on Vista and higher.
//!                  NOTE: If the driver is currently yellow-banged, and the
//!                  request is to start the driver, a stop will be called 
//!                  first to clear the driver failure.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:      hTransition(IN) - Handle returned from NvAPI_Hybrid_StartTransition
//!                  pDriverState(OUT) - Current driver state
//!
//! RETURN STATUS: 
//!                  NVAPI_OK - completed request
//!                  NVAPI_ERROR - miscellaneous error occurred
//!                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Hybrid_GetDGPUDriverState(NvTransitionHandle hTransition, NV_HYBRID_DRIVERSTATE* pDriverState);







///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_Hybrid_StartDisplaySwitch
//
//! DESCRIPTION: This API notifies the driver to prepare to switch the display
//!         Supported on Vista and higher.
//!              App calling this API is required to run in elevated mode. 
//!              This call is called after the dGPUs drivers are enabled, but
//!              before calls to ChangeDisplaySettingsEx
//!              If this call succeeds, an NvAPI_Hybrid_StopDisplaySwitch() 
//!              must be called, regardless of success or failure.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:      hTransition(IN) - Handle returned from NvAPI_Hybrid_StartTransition
//!                  mode(IN)     - Requested mode for transition
//!
//! RETURN STATUS: 
//!                  NVAPI_OK - completed request
//!                  NVAPI_ERROR - miscellaneous error occurred
//!                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Hybrid_StartDisplaySwitch(NvTransitionHandle hTransition, NV_HYBRID_MODE mode);



///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_Hybrid_StopDisplaySwitch
//
//! DESCRIPTION: This API notifies the driver that display switching is done
//!         Supported on Vista and higher.
//!              App calling this API is required to run in elevated mode. 
//!              This call is called after an attempt to move the active display
//!              to the new hybrid display. The requested mode may differ if
//!              a failure was encountered during the switching of displays.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:      hTransition(IN) - Handle returned from NvAPI_Hybrid_StartTransition
//!                  mode(IN)     - Final mode which was accepted
//!                                 This might be different than the 
//!                                 StartTransition mode, since a failure
//!                                 could result in falling back
//!
//! RETURN STATUS: 
//!                  NVAPI_OK - completed request
//!                  NVAPI_ERROR - miscellaneous error occurred
//!                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Hybrid_StopDisplaySwitch(NvTransitionHandle hTransition, NV_HYBRID_MODE mode);



///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_Hybrid_GetMirroredDisplays
//
//! DESCRIPTION:     This API gets the display mirrors for power and perf.
//!                  Supported on Vista and higher.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:      hTransition(IN) - Handle returned from NvAPI_Hybrid_StartTransition
//!                  pMirroredHeadIDs(OUT) - Array of NVAPI_MAX_HEADS_PER_GPU
//!                                          elements which holds the mirror
//!                                          IDs for a configuration
//!
//! RETURN STATUS: 
//!                  NVAPI_OK - completed request
//!                  NVAPI_ERROR - miscellaneous error occurred
//!                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Hybrid_GetMirroredDisplays(NvTransitionHandle hTransition, 

                                                 NvU32* pMirroredHeadIDs);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_Hybrid_SwapDisplays
//
//! DESCRIPTION:     This API swaps the current active displays from one adapter
//!                  to the other. This should not be used with multi-adapter.
//!                  Supported on Vista and higher.
//!                  Mode is used to verify the proper display direction
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:      hTransition(IN) - Handle returned from NvAPI_Hybrid_StartTransition
//!                  mode(IN)     - Requested mode for transition
//!
//! RETURN STATUS: 
//!                  NVAPI_OK - completed request
//!                  NVAPI_ERROR - miscellaneous error occurred
//!                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Hybrid_SwapDisplays(NvTransitionHandle hTransition, NV_HYBRID_MODE mode);





// FUNCTION NAME:   NvAPI_Hybrid_SetDisplayMUX
//
//! DESCRIPTION:     This API sets the active display MUX, used on systems with
//!                  either Intel Hybrid, or MCP controlled by a MUX.
//!                  Supported on Vista and higher.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:      hTransition(IN) - Handle returned from NvAPI_Hybrid_StartTransition
//!                  mode(IN) - Must be either NV_HYBRID_MODE_IGPU or 
//!                             NV_HYBRID_MODE_DGPU
//!
//! RETURN STATUS: 
//!                  NVAPI_OK - completed request
//!                  NVAPI_ERROR - miscellaneous error occurred
//!                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Hybrid_SetDisplayMUX(NvTransitionHandle hTransition, NV_HYBRID_MODE mode);

//! \addtogroup hybridapi
//! @{

//! Basic Flow Diagram of SetHybridMode(NV_HYBRID_MODE_DGPU)
//! \code
//!  NvAPI_Hybrid_SetDGPUPowerState(NV_HYBRID_POWERSTATE_ON);
//!  NvAPI_Hybrid_StartTransition(NV_HYBRID_MODE_DGPU);
//!  NvAPI_Hybrid_SetDGPUDriverState(NV_HYBRID_DRIVERSTATE_ENABLED);
//!  NvAPI_Hybrid_StartDisplaySwitch(NV_HYBRID_MODE_DGPU);
//!  NvAPI_Hybrid_SwapDisplays(NV_HYBRID_MODE_DGPU);
//!  NvAPI_Hybrid_StopDisplaySwitch(NV_HYBRID_MODE_DGPU);
//!  NvAPI_Hybrid_StopTransition(NV_HYBRID_MODE_DGPU);
//! \endcode

//! Basic Flow Diagram of SetHybridMode(NV_HYBRID_MODE_IGPU)
//! \code
//!  NvAPI_Hybrid_StartTransition(NV_HYBRID_MODE_IGPU);
//!  NvAPI_Hybrid_StartDisplaySwitch(NV_HYBRID_MODE_IGPU);
//!  NvAPI_Hybrid_SwapDisplays(NV_HYBRID_MODE_IGPU);
//!  NvAPI_Hybrid_StopDisplaySwitch(NV_HYBRID_MODE_IGPU);
//!  NvAPI_Hybrid_SetDGPUDriverState(NV_HYBRID_DRIVERSTATE_DISABLED);
//!  NvAPI_Hybrid_StopTransition(NV_HYBRID_MODE_IGPU);
//!  NvAPI_Hybrid_SetDGPUPowerState(NV_HYBRID_POWERSTATE_OFF);
//! \endcode

//! Basic Flow Diagram of SetHybridMode(NV_HYBRID_MODE_MULTI_ADAPTER)
//! \code
//!  NvAPI_Hybrid_SetDGPUPowerState(NV_HYBRID_POWERSTATE_ON);
//!  NvAPI_Hybrid_StartTransition(NV_HYBRID_MODE_MULTI_ADAPTER);
//!  NvAPI_Hybrid_SetDGPUDriverState(NV_HYBRID_DRIVERSTATE_ENABLED);
//!  NvAPI_Hybrid_StopTransition(NV_HYBRID_MODE_MULTI_ADAPTER);
//! \endcode

//! @}




//! \ingroup hybridiapi
#define NV_MAX_HYBRID_ACPI_IDS      16      //!< Based on NV_MAX_DOD_ACPI_IDS as per spec limit

//! \ingroup hybridiapi
typedef struct
{
    NvU32                   acpiId;
    NvU32                   intelId;
    NvU32                   displayId;          //!< Not yet supported
    NvPhysicalGpuHandle     physicalGpu;        //!< Not yet supported
    NvU32                   outputId;
} NV_HYBRID_INTEL_DEVICE_MAP_ENTRY;

//! \ingroup hybridiapi
typedef struct
{
    NvU32 version;
    NvU32 count;
    NV_HYBRID_INTEL_DEVICE_MAP_ENTRY maps[NV_MAX_HYBRID_ACPI_IDS];
} NV_HYBRID_INTEL_DEVICE_MAP;

//! \ingroup hybridiapi
//! Macro for constructingthe version field of NV_HYBRID_INTEL_DEVICE_MAP
#define NV_HYBRID_INTEL_DEVICE_MAP_VER          MAKE_NVAPI_VERSION(NV_HYBRID_INTEL_DEVICE_MAP, 1)

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_Hybrid_GetIntelDeviceMap
//
//! DESCRIPTION:     This API gets the mapping table for all the IDs for an
//!                  Intel Hybrid system. The system must have booted to 
//!                  NV_HYBRID_MODE_DGPU at least once before this call will
//!                  succeed.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:      pMap(IN/OUT) - Pointer to the NV_HYBRID_INTEL_DEVICE_MAP
//!                                 structure, which will be filled with the
//!                                 proper data.
//!
//! RETURN STATUS: 
//!                  NVAPI_OK - completed request
//!                  NVAPI_ERROR - miscellaneous error occurred
//!                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//!                  NVAPI_DATA_NOT_FOUND - System must have been to DGPU mode
//!                                         before calling this API
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Hybrid_GetIntelDeviceMap(NV_HYBRID_INTEL_DEVICE_MAP* pMap);






//! \ingroup hybridapi
typedef struct
{
  NvU32 version;    //!< Structure version
  NvAPI_LongString   appName;
  NvAPI_LongString   friendlyName;
}NV_HYBRID_APP_INFO;

//! \ingroup hybridapi
//! Macro for constructing the version field of NV_HYBRID_APP_INFO 
#define NV_HYBRID_APP_INFO_VER  MAKE_NVAPI_VERSION(NV_HYBRID_APP_INFO,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Hybrid_QueryUnblockedNonMigratableApps
//
//! DESCRIPTION:     This API queries the user white-list applications for Hybrid transition.
//!
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in,out]     apps     Empty structure passed as an input and upon successfull exit, it contains list of Unblocked(user white-list) applications.
//! \param [in,out]     total    Total number of applications returned from the white list.
//!
//! \retval ::NVAPI_OK                 completed request.
//! \retval ::NVAPI_ERROR              miscellaneous error occurred.
//! \retval ::NVAPI_INVALID_ARGUMENT   invalid input parameter.
//! \retval ::NVAPI_NO_IMPLEMENTATION  not implemented.
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Hybrid_QueryUnblockedNonMigratableApps(NV_HYBRID_APP_INFO apps[NVAPI_MAX_3D_Apps] , NvU32 *total);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Hybrid_QueryBlockedMigratableApps
//
//! DESCRIPTION:     This API queries the user black-list applications for Hybrid transition.
//!
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in,out]     apps     Empty structure passed as an input and upon successfull exit, it contains list of Unblocked(user black-list) applications..
//! \param [in,out]     total    Total number of applications returned from the black list.
//!
//! \retval ::NVAPI_OK                 completed request.
//! \retval ::NVAPI_ERROR              miscellaneous error occurred.
//! \retval ::NVAPI_INVALID_ARGUMENT   invalid input parameter.
//! \retval ::NVAPI_NO_IMPLEMENTATION  not implemented.
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Hybrid_QueryBlockedMigratableApps(NV_HYBRID_APP_INFO apps[NVAPI_MAX_3D_Apps] , NvU32 *total);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Hybrid_SetAppMigrationState
//
//! DESCRIPTION:     This API overrides the pre-determined application migration state.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]     app  Application executable name that is to be blocked, unblocked, reset or removed
//! \param [in]     flag Decides on the block, unblock, reset or remove operation. \n
//!                      block =0, unblock =1, reset =2, remove =3
//!
//! \retval ::NVAPI_OK  completed request.
//! \retval ::NVAPI_ERROR  miscellaneous error occurred.
//! \retval ::NVAPI_INVALID_ARGUMENT  invalid input parameter.
//! \retval ::NVAPI_SET_NOT_ALLOWED  the application list override is not allowed.  
//! \retval ::NVAPI_NO_IMPLEMENTATION  not implemented.
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Hybrid_SetAppMigrationState(NV_HYBRID_APP_INFO app , NvU32 flag);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Hybrid_IsAppMigrationStateChangeable
//
//! DESCRIPTION:     This API queries if an application's migration state can be changed by the user.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      app      Application executable name which user is querying about
//! \param [out]     allowed  Change in migration state of app is allowed or not. \n
//!                           not_allowed =0, allowed =1
//!
//! \retval ::NVAPI_OK  completed request.
//! \retval ::NVAPI_ERROR  miscellaneous error occurred.
//! \retval ::NVAPI_INVALID_ARGUMENT  invalid input parameter.
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Hybrid_IsAppMigrationStateChangeable(NV_HYBRID_APP_INFO app , NvU32 *allowed);



//! \ingroup hybridapi
//! Declaration for the possible use of NVAPI flags
//! @{
#define NV_SET_HYBRID_MODE_DEFER_NON_MIGRATABLE_APP_SHUTDOWN    0x00000001 //!< Calling application will control the shutdown of non-migratable applications holding hw resources
#define NVAPI_ADAPTIVE_POLICY_ON                 0x00000002 //!< Set the hybrid mode to turn on adaptive mode
//! @}


 
///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SetHybridModeEx
//
//! DESCRIPTION:     This API will support elevated transition if the application does not run in elevated mode.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 173
//!
//!  \param [in]    mode      The hybrid mode - see NV_HYBRID_MODE.
//!  \param [in]    flags     Flags that indicate additional control - see ::NV_SET_HYBRID_MODE_FLAGS.
//!
//!  \retval        NVAPI_OK                Completed request
//!  \retval        NVAPI_ERROR             Miscellaneous error occurred
//!  \retval        NVAPI_INVALID_ARGUMENT  Invalid input parameter
//!
//!  \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetHybridModeEx(NV_HYBRID_MODE mode, NvU32 flags);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_InitHybridMicroController
//
//!   DESCRIPTION: This API initializes the hybrid micro-controller
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 175
//! 
//! \retval    NVAPI_OK      Completed request
//! \retval    NVAPI_ERROR   Miscellaneous error occurred
//!
//! \ingroup   hybridapi 
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_InitHybridMicroController();







///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_CreateUnAttachedDisplayFromDisplay
//
//! DESCRIPTION:     This API unattaches an active display if it is not the GDI primary display.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//! 
//! \param [in]       hNvDisplay                   Active display handle
//! \param [out]      pNvUnAttachedDisp            Pointer to the unattached display handle
//!
//! \retval ::NVAPI_OK 
//! \retval ::NVAPI_ERROR 
//! \retval ::NVAPI_INVALID_ARGUMENT 
//! \retval ::NVAPI_EXPECTED_DISPLAY_HANDLE 
//! \retval ::NVAPI_EXPECTED_NON_PRIMARY_DISPLAY_HANDLE  The GDI primary handle passed
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_CreateUnAttachedDisplayFromDisplay(NvDisplayHandle hNvDisplay, NvUnAttachedDisplayHandle *pNvUnAttachedDisp);






//
// NV_GET_SCALING_CAPS
//
// Interface structure used in NvAPI_GetScalingCaps call.
//
// This NvAPI_GetScalingCaps returns scaling capability info for the specified display device
//




//! \ingroup dispcontrol
//! Used in NvAPI_GetScalingCaps(), which returns scaling capability information for the specified display device. 
typedef struct 
{
    NvU32   version;                                      //!< Structure version
    NvU32   isGPUScalingAvailable                   : 1;  //!< If the GPU scaling mode available
    NvU32   isGPUFixedAspectRatioScalingAvailable   : 1;  //!< If the GPU Fixed-Aspect ratio scaling mode available
    NvU32   isMonitorScalingAvailable               : 1;  //!< If the monitor scaling mode available
    NvU32   isCenterScalingAvailable                : 1;  //!< If center scaling mode available
} NV_GET_SCALING_CAPS_V1;

//! \ingroup dispcontrol
typedef struct 
{
    NvU32      version;
    union // if Force GPU - Full Screen scaling available.
    {
        NvU32  isGPUScalingAvailable                  : 1;
        NvU32  isGPUScalingToNative                   : 1;
    };
    union // if Force GPU - Aspect Ratio scaling available.
    {
        NvU32  isGPUFixedAspectRatioScalingAvailable  : 1;
        NvU32  isGPUScalingToAspectScanoutToNative    : 1;
    };
    union // if Balanced - Full Screen scaling available.
    {
        NvU32  isMonitorScalingAvailable              : 1;
        NvU32  isGPUScalingToClosest                  : 1;
    };
    union // if Force GPU - Centered scaling available.
    {
        NvU32  isCenterScalingAvailable               : 1;
        NvU32  isGPUScanoutToNative                   : 1;
    };
    NvU32      isGPUScalingToAspectScanoutToClosest   : 1;  //!< if Balanced - Aspect Ratio scaling available.
    NvU32      isGPUScanoutToClosest                  : 1;  //!< if Balanced - Centered scaling available.
    NvU32      reserved                               : 30;
     
    NV_SCALING defaultScaling; //!< Default scaling setting for the display.
    NV_SCALING currentScaling; //!< Currently applied scaling setting for the display.
} NV_GET_SCALING_CAPS_V2;

//! \ingroup dispcontrol
typedef NV_GET_SCALING_CAPS_V2     NV_GET_SCALING_CAPS;



//! \ingroup dispcontrol
//! @{
#define NV_GET_SCALING_CAPS_VER1   MAKE_NVAPI_VERSION(NV_GET_SCALING_CAPS_V1,1)
#define NV_GET_SCALING_CAPS_VER2   MAKE_NVAPI_VERSION(NV_GET_SCALING_CAPS_V2,2)
#define NV_GET_SCALING_CAPS_VER    NV_GET_SCALING_CAPS_VER2
//! @}





///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetScalingCaps
//
//! DESCRIPTION:   This API returns all the scaling Caps for the specified display. Each member is used to disable the corresponding scaling feature. 
//!                - If the value of the member is true, the caller does not care. 
//!                - If the value of the member is false, the caller has to set the corresponding scaling option disabled. 
//!
//!                Note: NvAPI_GetScalingCaps() at present only supports "Monitor Scaling caps".
//!                Other scaling caps are not implemented by the display driver.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]   hNvDisplay    NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//! \param [in]   outputId      The active display output ID associated with the selected display handle hNvDisplay.
//!                             The outputid will have only one bit set. In case of Clone or Span modes, this will indicate the display
//!                             outputId of the primary display that the GPU is driving.
//! \param [out]  pScalingCaps  Pointer to structure NV_GET_SCALING_CAPS. Returns various scaling caps for a given displayId. 
//!
//! \retval ::NVAPI_OK 
//! \retval ::NVAPI_API_NOT_INTIALIZED 
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND      No NVIDIA GPU driving a display was found.
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION  Structure version is not supported, initialize to NV_GET_SCALING_CAPS_VER.
//! \retval ::NVAPI_EXPECTED_DISPLAY_HANDLE      hNvDisplay is not a valid display handle.
//! \retval ::NVAPI_INVALID_ARGUMENT             outputId is zero.
//! \retval ::NVAPI_INVALID_HANDLE               Invalid Display handle.
//! \retval ::NVAPI_ERROR 
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetScalingCaps(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_GET_SCALING_CAPS *pScalingCaps);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DISP_GetScalingCaps
//
//! PARAMETERS:    displayId(IN)     - NVIDIA Display ID. It is the value returned from NvAPI_SYS_GetDisplayIdFromGpuAndOutputId()
//!                pScalingCaps(OUT) - Pointer to struct NV_GET_SCALING_CAPS. Returns various scaling caps for a given displayId.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION:   Returns all the scaling Caps of given display. 
//!                This API can also be used to get the scaling caps for an inactive connected display.
//!
//! RETURN STATUS: NVAPI_OK                          - Call successful.
//!                NVAPI_ERROR                       - Miscellenous errors.
//!                NVAPI_INVALID_POINTER             - Invalid pointer pScalingCaps.
//!                NVAPI_INVALID_ARGUMENT            - If display Id passed is invalid.
//!                NVAPI_API_NOT_INTIALIZED          - NVAPI not initialized.
//!                NVAPI_NVIDIA_DEVICE_NOT_FOUND     - No NVIDIA GPU driving a display was found.
//!                NVAPI_INCOMPATIBLE_STRUCT_VERSION - Structure version is not supported, initialize to NV_GET_SCALING_CAPS_VER.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_GetScalingCaps(NvU32 displayId, NV_GET_SCALING_CAPS *pScalingCaps);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetHybridControllerInfo
//
//! \fn NvAPI_GPU_GetHybridControllerInfo(NvPhysicalGpuHandle hPhysicalGpu, 
//!                                                  NV_GPU_HYBRID_CONTROLLER_INFO *pHybridControllerInfo)
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! DESCRIPTION:     Returns the hybrid controller information
//!                      present - true if the hybrid controller is present
//!                      fwVersion - firmware version of the hybrid controller. 
//!                                  Firmware version is zero if the hybrid controller is not present.
//!
//!
//! RETURN STATUS: 
//!    NVAPI_OK - completed request, *pTable contains the thermal table entries
//!    NVAPI_ERROR - miscellaneous error occurred
//!    NVAPI_INVALID_ARGUMENT - pHybridCOntrollerInfo is NULL
//!    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//!    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup hybridapi
typedef struct
{
    NvU32   version;            //! Structure version
    NvU32   present;
    NvU32   fwVersion;
} NV_GPU_HYBRID_CONTROLLER_INFO;


//! \ingroup hybridapi
//! Macro for constructingthe version field of ::NV_GPU_HYBRID_CONTROLLER_INFO
#define NV_GPU_HYBRID_CONTROLLER_INFO_VER MAKE_NVAPI_VERSION(NV_GPU_HYBRID_CONTROLLER_INFO,1)

//! \ingroup hybridapi
NVAPI_INTERFACE NvAPI_GPU_GetHybridControllerInfo(NvPhysicalGpuHandle hPhysicalGpu, 
                                                  NV_GPU_HYBRID_CONTROLLER_INFO *pHybridControllerInfo);




//! \ingroup dispcontrol
typedef struct
{
    NvU32   version;

    NvU32   width;
    NvU32   height;
    NvU32   depth;
    NvU32   refresh;
    NvU32   format;
    NvU32   interlaced;
} NVAPI_DISPLAY_MODE;

//! SUPPORTED OS:  Windows XP and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME : NvAPI_Disp_EnumerateDisplayModes
//
//! PARAMETERS    : hNvDisplay (IN)          - NVIDIA display handle
//!                 modeIndex  (IN)          - index for desired mode
//!                 mode       (OUT)         - display mode at modeIndex of driver table
//!
//! DESCRIPTION   : Enumerate the entire mode table in the driver.
//!
//! HOW TO USE    : Call repeatedly with increasing modeIndex until NVAPI_END_ENUMERATION returns
//!                 
//! RETURN STATUS:
//!                 NVAPI_OK                      - completed request
//!                 NVAPI_ERROR                   - miscellaneous error occurred
//!                 NVAPI_API_NOT_INTIALIZED      - must initialize first
//!                 NVAPI_EXPECTED_DISPLAY_HANDLE - invalid hNvDisplay
//!                 NVAPI_END_ENUMERATION         - modeIndex is greater than the number of modes in the driver table
//!
//! \ingroup dispcontrol 
///////////////////////////////////////////////////////////////////////////////    
NVAPI_INTERFACE NvAPI_Disp_EnumerateDisplayModes(NvDisplayHandle hNvDisplay, NvU32 modeIndex, NVAPI_DISPLAY_MODE *mode);



#define NV_MAX_PROTECTED_VIDEO_SESSIONS 8

typedef enum _NV_PROTECTED_VIDEO_SESSION_TYPE
{
    NV_VIDEO_SESSION_COPP = 0,
    NV_VIDEO_SESSION_OPM  = 1
}NV_PROTECTED_VIDEO_SESSION_TYPE;

typedef struct _NVAPI_PROTECTED_VIDEO_SESSION_INFO
{
    NvU32                              version;                                       //!< (IN) version info
    NvU32                              dwNumProtSessions;                             //!< number of protected sessions
    NV_PROTECTED_VIDEO_SESSION_TYPE    sessionType[NV_MAX_PROTECTED_VIDEO_SESSIONS];  //!< SessionType COPP/OPM associated with each session
} NVAPI_PROTECTED_VIDEO_SESSION_INFO;

//! Macro for constructing the version field of ::_NVAPI_PROTECTED_VIDEO_SESSION_INFO
#define NVAPI_PROTECTED_VIDEO_SESSION_INFO_VER  MAKE_NVAPI_VERSION(NVAPI_PROTECTED_VIDEO_SESSION_INFO,1)


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Video_GetProtectedVideoSessionInfo
//
//! DESCRIPTION: Returns information on the number of protected Video sessions and their semantics COPP/OPM so far
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! RETURN STATUS:
//!                NVAPI_OK    - completed request
//!                NVAPI_ERROR - miscellaneous error occurred
//
//////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Video_GetProtectedVideoSessionInfo(NVAPI_PROTECTED_VIDEO_SESSION_INFO *pProtVideoSessionInfo); 

//! @}



//! SUPPORTED OS:  Windows XP and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_DISP_GetDisplayIdByDisplayName
//
//! DESCRIPTION:     This API retrieves the Display Id of a given display by
//!                  display name. The display must be active to retrieve the
//!                  displayId. In the case of clone mode or Surround gaming,
//!                  the primary or top-left display will be returned.
//!
//! \param [in]     displayName  Name of display (Eg: "\\DISPLAY1" to
//!                              retrieve the displayId for.
//! \param [out]    displayId    Display ID of the requested display.
//!
//! retval ::NVAPI_OK:                          Capabilties have been returned.
//! retval ::NVAPI_INVALID_ARGUMENT:            One or more args passed in are invalid.
//! retval ::NVAPI_API_NOT_INTIALIZED:          The NvAPI API needs to be initialized first
//! retval ::NVAPI_NO_IMPLEMENTATION:           This entrypoint not available
//! retval ::NVAPI_ERROR:                       Miscellaneous error occurred
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_GetDisplayIdByDisplayName(const char *displayName, NvU32* displayId);



//! SUPPORTED OS:  Windows XP and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_DISP_GetGDIPrimaryDisplayId
//
//! DESCRIPTION:     This API returns the Display ID of the GDI Primary.
//!
//! \param [out]     displayId   Display ID of the GDI Primary display.
//!
//! \retval ::NVAPI_OK:                          Capabilties have been returned.
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND:     GDI Primary not on an NVIDIA GPU.
//! \retval ::NVAPI_INVALID_ARGUMENT:            One or more args passed in are invalid.
//! \retval ::NVAPI_API_NOT_INTIALIZED:          The NvAPI API needs to be initialized first
//! \retval ::NVAPI_NO_IMPLEMENTATION:           This entrypoint not available
//! \retval ::NVAPI_ERROR:                       Miscellaneous error occurred
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_GetGDIPrimaryDisplayId(NvU32* displayId);


//! \ingroup dispcontrol
typedef enum {
    NV_SR_ENTRY_METHOD_UNSUPPORTED = 0, 
    NV_SR_ENTRY_METHOD_INBAND,              //!< SR Entry request is sent by reverting hsync polarity (LVDS) or sending infoframe (eDP)
    NV_SR_ENTRY_METHOD_SIDEBAND,            //!< SR Entry request is sent by writing to I2C slave (LVDS)/Aux (eDP) address.
} NV_SR_ENTRY_METHOD_ENUM;

//! \ingroup dispcontrol
typedef struct _NV_SR_ENTRY_PARAM_V1
{
    NvU32                      version;                                               //!< (IN)version info
    NvU32                      displayId;
    NV_SR_ENTRY_METHOD_ENUM    entryMethod;                                           //!< The entry method used for entering SR mode
}NV_SR_ENTRY_PARAM_V1;

//! \ingroup dispcontrol
typedef NV_SR_ENTRY_PARAM_V1      NV_SR_ENTRY_PARAM;
//! \ingroup dispcontrol 
#define NV_SR_ENTRY_PARAM_VER_1   MAKE_NVAPI_VERSION(NV_SR_ENTRY_PARAM_V1,1)
//! \ingroup dispcontrol
#define NV_SR_ENTRY_PARAM_VER     NV_SR_ENTRY_PARAM_VER_1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_DISP_EnterSparseSelfRefreshPanel
//
//! DESCRIPTION:     This API causes the panel to enter self refresh mode. Self Refresh
//!                  mode means the panel caches the frame GPU sends into its local frame buffer
//!                  and scans out from its buffer instead of from GPU. 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pSrEntryParams    - Pointer to the NV_SR_ENTRY data
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval ::NVAPI_OK:                          Completed request
//! \retval ::NVAPI_INVALID_DISPLAY_ID:          Incorrect display ID
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_EnterSparseSelfRefreshPanel(__in NV_SR_ENTRY_PARAM* pSrEntryParams);


//! \ingroup dispcontrol
typedef enum {
    NV_SR_EXIT_METHOD_UNSUPPORTED = 0, 
    NV_SR_EXIT_METHOD_INBAND,           //!< Self refresh panel (SRP) exit request is sent by reverting hsync polarity (LVDS) 
                                        //!< or sending infoframe (eDP)
    NV_SR_EXIT_METHOD_SIDEBAND,         //!< SRP exit request is sent by writing to I2C slave (LVDS)/Aux (eDP) address.
} NV_SR_EXIT_METHOD_ENUM;

//! \ingroup dispcontrol
typedef enum {
    NV_SR_RESYNC_METHOD_UNSUPPORTED = 0, 
    NV_SR_RESYNC_METHOD_SLIDING_SYNC,            //!< GPU and SRP both slide its timing such that its vblank overlap.
    NV_SR_RESYNC_METHOD_FRAMELOCK,               //!< SRP sends framelock to GPU so that it resets its scanout to 0,0
    NV_SR_RESYNC_METHOD_BLANK_STRETCH,           //!< SRP stretch the vblank to resync
} NV_SR_RESYNC_METHOD_ENUM;

//! \ingroup dispcontrol
typedef struct _NV_SR_EXIT_PARAM_V1
{
    NvU32                     version;            //!< (IN)version info
    NvU32                     displayId;
    NV_SR_EXIT_METHOD_ENUM    exitMethod;         //!< The exit method used for exiting SR mode
    NV_SR_RESYNC_METHOD_ENUM  resyncMethod;       //!< The resync method between GPU and panel
    NvU32                     resyncDelay : 2;    //!< The resync delay between GPU and panel. Unit is # of frames
    NvU32                     reserved    : 30;
}NV_SR_EXIT_PARAM_V1;

//! \ingroup dispcontrol
typedef NV_SR_EXIT_PARAM_V1      NV_SR_EXIT_PARAM;
//! \ingroup dispcontrol 
#define NV_SR_EXIT_PARAM_VER_1   MAKE_NVAPI_VERSION(NV_SR_EXIT_PARAM_V1,1)
//! \ingroup dispcontrol
#define NV_SR_EXIT_PARAM_VER     NV_SR_EXIT_PARAM_VER_1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_DISP_ExitSparseSelfRefreshPanel
//
//! DESCRIPTION:     This API causes the panel to exit self refresh mode. Self Refresh
//!                  mode means the panel caches the frame GPU sends into its local frame buffers
//!                  and scans out from its buffer instead of from GPU. When GPU exits from
//!                  self refresh mode, GPU gets back the control for scanout from panel.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! \param [in]     pSrExitParams    - In Pointer to the NV_SR_EXIT data
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval ::NVAPI_OK:                          Completed request
//! \retval ::NVAPI_INVALID_DISPLAY_ID:          Incorrect display ID
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_ExitSparseSelfRefreshPanel(__in NV_SR_EXIT_PARAM* pSrExitParams);


//! \ingroup dispcontrol
typedef struct _NV_SR_STATE_PARAM_V1
{
    NvU32   version;     //!< (IN)version info
    NvU32   displayId;
    NvU32   status;      //!< The SRC controller status

}NV_SR_STATE_PARAM_V1;

//! \ingroup dispcontrol
typedef NV_SR_STATE_PARAM_V1      NV_SR_STATE_PARAM;
//! \ingroup dispcontrol 
#define NV_SR_STATE_PARAM_VER_1   MAKE_NVAPI_VERSION(NV_SR_STATE_PARAM_V1,1)
//! \ingroup dispcontrol
#define NV_SR_STATE_PARAM_VER     NV_SR_STATE_PARAM_VER_1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_DISP_GetSelfRefreshPanelStatus
//
//! DESCRIPTION:     This API gets the self refresh panel status register value.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! \param [inout]   pSrStatus       - Out Pointer to the NV_SR_STATE data
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval ::NVAPI_OK:                          Completed request
//! \retval ::NVAPI_INVALID_DISPLAY_ID:          Incorrect display ID
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_GetSelfRefreshPanelStatus(__inout NV_SR_STATE_PARAM* pSrStatus);


//! \ingroup dispcontrol
typedef struct _NV_BURST_SR_ENTRY_PARAM_V1
{
    NvU32                       version;               //!< version info
    NvU32                       displayId;
    NV_SR_ENTRY_METHOD_ENUM     entryMethod;
    NvU32                       extraVFPExtension;	   //!< For burst mode, the timing is recalculated based on max pclk (min of max pclk of panel, GPU, and SRC).
                                                       //!< Therefore, current clk (max pclk) >= pclk used previously. To maintain the same refresh rate, we 
                                                       //!< make the vblank, especially vertical front porch longer. But, sometimes we want to experiment with more
                                                       //!< VFP extension, such as the case of resuming from GPU sleep. 
                                                       //!< Extra vertical front porch timing extension on top of VFP extension resulted from max pclk calculation.
                                                       //!< Unit is percentage.
    NvU32                       resyncDelay : 2;       //!< The resync delay between GPU and panel. Unit is # of frames
    NvU32                       reserved    : 30;    
}NV_BURST_SR_ENTRY_PARAM_V1;

//! \ingroup dispcontrol
typedef NV_BURST_SR_ENTRY_PARAM_V1      NV_BURST_SR_ENTRY_PARAM;
//! \ingroup dispcontrol 
#define NV_BURST_SR_ENTRY_PARAM_VER_1   MAKE_NVAPI_VERSION(NV_BURST_SR_ENTRY_PARAM_V1,1)
//! \ingroup dispcontrol
#define NV_BURST_SR_ENTRY_PARAM_VER     NV_BURST_SR_ENTRY_PARAM_VER_1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_DISP_EnterBurstSelfRefresh
//
//! DESCRIPTION:      This API gets into burst self refresh. Once entered into burst SR, panel 
//!                   stays in self refresh. Scanout is controlled by panel once it enters burst self refresh until
//!                   burst exit is called or panel is reset.
//!                      Another re-entry will cause the panel to recache the frame.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! \param [in]       pBurstSREntry   - In Pointer to the NV_BURST_SR_ENTRY data
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval ::NVAPI_OK:                          Completed request
//! \retval ::NVAPI_INVALID_DISPLAY_ID:          Incorrect display ID
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_EnterBurstSelfRefresh(__in NV_BURST_SR_ENTRY_PARAM* pBurstSREntry);


//! \ingroup dispcontrol
typedef struct _NV_BURST_SR_EXIT_PARAM_V1
{
    NvU32                     version;            //!< (IN)version info
    NvU32                     displayId;
    NV_SR_EXIT_METHOD_ENUM    exitMethod;
    NvU32                     resyncDelay : 2;    //!< The resync delay between GPU and panel. Unit is # of frames
    NvU32                     reserved    : 30;
}NV_BURST_SR_EXIT_PARAM_V1;

//! \ingroup dispcontrol
typedef NV_BURST_SR_EXIT_PARAM_V1      NV_BURST_SR_EXIT_PARAM;
//! \ingroup dispcontrol 
#define NV_BURST_SR_EXIT_PARAM_VER_1   MAKE_NVAPI_VERSION(NV_BURST_SR_EXIT_PARAM_V1,1)
//! \ingroup dispcontrol
#define NV_BURST_SR_EXIT_PARAM_VER     NV_BURST_SR_EXIT_PARAM_VER_1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_DISP_ExitBurstSelfRefresh
//
//! DESCRIPTION:    This API causes the panel to exit burst self refresh. 
//!                 The scanout control is handed back to GPU from panel.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! \param [in]     pBurstSRExit    - In Pointer to the NV_BURST_SR_EXIT data
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval ::NVAPI_OK:                          Completed request
//! \retval ::NVAPI_INVALID_DISPLAY_ID:          Incorrect display ID
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_ExitBurstSelfRefresh(__in NV_BURST_SR_EXIT_PARAM* pBurstSRExit);


//! \ingroup dispcontrol
typedef struct _NV_BUFFERED_SR_ENTRY_PARAM_V1
{
    NvU32                      version;              //!< (IN)version info
    NvU32                      displayId;
    NV_SR_ENTRY_METHOD_ENUM    entryMethod;
    NvU32                      GPUFramePeriodScale;	 //!< Buffered mode means GPU pclk is running faster than 
                                                     //!< the panel pclk by GPUFramePeriodScale times. 
                                                     //!< Note: Because we want to make sure GPU and panel frame time is 
                                                     //!< exactly lining up, this means GPU vertical front porch is longer 
                                                     //!< by GPUFramePeriodScale times than panel vertical front porch. 
    NvU32                      resyncDelay : 2;      //!< The resync delay between GPU and panel. Unit is # of frames
    NvU32                      reserved    : 30;
}NV_BUFFERED_SR_ENTRY_PARAM_V1;

//! \ingroup dispcontrol
typedef NV_BUFFERED_SR_ENTRY_PARAM_V1      NV_BUFFERED_SR_ENTRY_PARAM;
//! \ingroup dispcontrol 
#define NV_BUFFERED_SR_ENTRY_PARAM_VER_1   MAKE_NVAPI_VERSION(NV_BUFFERED_SR_ENTRY_PARAM_V1,1)
//! \ingroup dispcontrol
#define NV_BUFFERED_SR_ENTRY_PARAM_VER     NV_BUFFERED_SR_ENTRY_PARAM_VER_1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_DISP_EnterBufferedSelfRefresh
//
//! DESCRIPTION:    This API causes the panel to enter buffered SR
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! \param [in]        pBufferedSREntry - In Pointer to the NV_BUFFERED_SR_ENTRY data
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval ::NVAPI_OK:                          Completed request
//! \retval ::NVAPI_INVALID_DISPLAY_ID:          Incorrect display ID
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_EnterBufferedSelfRefresh(__in NV_BUFFERED_SR_ENTRY_PARAM* pBufferedSREntry);


//! \ingroup dispcontrol
typedef struct _NV_BUFFERED_SR_EXIT_PARAM_V1
{
    NvU32                     version;             //!< version info
    NvU32                     displayId;
    NV_SR_EXIT_METHOD_ENUM    exitMethod;
    NV_SR_RESYNC_METHOD_ENUM  resyncMethod;
    NvU32                     resyncDelay : 2;    //!< The resync delay between GPU and panel. Unit is # of frames
    NvU32                     reserved    : 30;
}NV_BUFFERED_SR_EXIT_PARAM_V1;

//! \ingroup dispcontrol
typedef NV_BUFFERED_SR_EXIT_PARAM_V1      NV_BUFFERED_SR_EXIT_PARAM;
//! \ingroup dispcontrol 
#define NV_BUFFERED_SR_EXIT_PARAM_VER_1   MAKE_NVAPI_VERSION(NV_BUFFERED_SR_EXIT_PARAM_V1,1)
//! \ingroup dispcontrol
#define NV_BUFFERED_SR_EXIT_PARAM_VER     NV_BUFFERED_SR_EXIT_PARAM_VER_1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_DISP_ExitBufferedSelfRefresh
//
//! DESCRIPTION:      This API causes the panel to exit buffered self refresh. 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! \param [in]        pBufferedSRExit    - In Pointer to the NV_BUFFERED_SR_EXIT data
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval ::NVAPI_OK:                          Completed request
//! \retval ::NVAPI_INVALID_DISPLAY_ID:          Incorrect display ID
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_ExitBufferedSelfRefresh(__in NV_BUFFERED_SR_EXIT_PARAM* pBufferedSRExit);



//! \ingroup dispcontrol
typedef struct _NV_LATENCY_STATS
{
    NvU32           min;					     
    NvU32           max;						 
    NvU32           average;					 
}NV_RANGE_STATS;

typedef struct _NV_DISPLAY_SELFREFRESH_STATS
{
    NvU32                   version;             //!< [IN]  Structure version.
    NvU32                   displayId;           //!< [In]  DisplayId of the display.
    NvU32		            totalTime;           //!< [OUT] Total time in milisec for PSR.
    NvU32		            numberOfCycles;		 //!< [OUT] Number of PSR cycles (enter + exit).
    NV_RANGE_STATS          resyncLatency;       //!< [OUT] PSR exit triggered to framelock arrival (min/max/average).
    NV_RANGE_STATS          enterLatency;        //!< [OUT] PSR enter triggered to enter done IRQ (min/max/average).
    NV_RANGE_STATS          exitLatency;         //!< [OUT] PSR exit triggered to exit done IRQ (min/max/average).
} NV_DISPLAY_SELFREFRESH_STATS_V1; 

//! \ingroup dispcontrol
typedef NV_DISPLAY_SELFREFRESH_STATS_V1   NV_DISPLAY_SELFREFRESH_STATS;
//! \ingroup dispcontrol 
#define NV_DISPLAY_SELFREFRESH_STATS_VER_1   MAKE_NVAPI_VERSION(NV_DISPLAY_SELFREFRESH_STATS_V1,1)
//! \ingroup dispcontrol
#define NV_DISPLAY_SELFREFRESH_STATS_VER     NV_DISPLAY_SELFREFRESH_STATS_VER_1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_DISP_GetSelfRefreshStats
//
//! DESCRIPTION:      This API retrieve panel self refresh (PSR) stats.
//!                   NOTE: All times are in miliseconds
//! SUPPORTED OS:  Windows Vista and higher
//!
//! \param [in]        pSRStats    - In Pointer to the NV_DISPLAY_PANEL_SR_STATUS data
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval ::NVAPI_OK:                          Completed request
//! \retval ::NVAPI_INVALID_DISPLAY_ID:          Incorrect display ID
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_GetSelfRefreshStats(__inout NV_DISPLAY_SELFREFRESH_STATS* pSRStats);


///////////////////////////////////////////////////////////////////////////////
// Clustering APIs
///////////////////////////////////////////////////////////////////////////////

// This category is intentionally added before the #ifdef. The #endif should also be in the same scope
#ifndef NV_CLUSTER_STRUCTS_DEFINED
#define NV_CLUSTER_STRUCTS_DEFINED

//! \addtogroup clusterapi
//! @{
typedef struct _NV_TILE_INFO_V1
{
     NvU32                              version;                //!< Only element 0 must be properly set
     NvU32                              displayId;              //!< this is a unique identifier for display
     NvU32                              locationX;              //!< Physical row position of display in tiles. starts from 0.
     NvU32                              locationY;              //!< Physical column position of display in tiles. starts from 0.
} NV_TILE_INFO_V1;


typedef NV_TILE_INFO_V1       NV_TILE_INFO;

#define NV_TILE_INFO_VER1     MAKE_NVAPI_VERSION(NV_TILE_INFO_V1,1)
#define NV_TILE_INFO_VER      NV_TILE_INFO_VER1

//! PIVOT structure that stores the configuration information of a cluster
typedef struct _NV_PIVOT_V1
{
    NvU32               version;
  
    NV_TIMING           timing;             //!<  The backend timing
    NV_DP_COLOR_FORMAT  colorFormat;        //!<  The color format enum specifier: (RGB/YCbCr422/YCbCr444)
    NV_DP_BPC           backendBitDepth;    //!<  The backend bit-per-component enum specifier: (6,8,10,12, or 16 bits per component)
} NV_PIVOT_V1;

typedef NV_PIVOT_V1       NV_PIVOT;

#define NV_PIVOT_VER1     MAKE_NVAPI_VERSION(NV_PIVOT_V1,1)
#define NV_PIVOT_VER      NV_PIVOT_VER1

//! Enum values for representing the types of the cluster
typedef enum _NV_CLUSTER_TYPE
{
    NV_CLUSTER_TYPE_UNKNOWN         = 0,  //!<  Unknown cluster type 
    NV_CLUSTER_TYPE_DP_STREAM_CLONE = 1,      //!<  DisplayPort 1.2 stream cloning cluster
    NV_CLUSTER_TYPE_MOSAIC_SPAN = 2,			  //!<  Mosaic Display Cluster
    NV_CLUSTER_TYPE_TILE	    = 3,		      //!<  Tile Display Cluster
    
} NV_CLUSTER_TYPE;

//! Enum values for representing the states of the cluster
typedef enum _NV_CLUSTER_STATE
{
    NV_CLUSTER_STATE_UNKNOWN   = 0,//!< Unknown state
    NV_CLUSTER_STATE_DISABLED,     //!< A cluster has not been defined yet or is disabled by the user
    NV_CLUSTER_STATE_ENABLED,      //!< Enabled. The cluster may or may not be empty. If the node count is ZERO, the cluster is in DORMANT state, else in ACTIVE state
    NV_CLUSTER_STATE_DELETE,       //!< This flag should be used in NvAPI_GPU_SetupClusterTopology() to delete an existing cluster.
} NV_CLUSTER_STATE;

//! Enum values for representing the discovery mode of the cluster
typedef enum _NV_CLUSTER_DISCOVERY_MODE
{
    NV_CLUSTER_DISCOVERY_MODE_UNKNOWN  = 0,  //!<  Unknown mode type
    NV_CLUSTER_DISCOVERY_MODE_MANUAL,        //!<  The client is responsible for adding/deleting nodes from the cluster. This mode is currently not supported yet.
    NV_CLUSTER_DISCOVERY_MODE_AUTO           //!<  The driver is responsible for adding/deleting nodes from the cluster based on its internal policy
    
} NV_CLUSTER_DISCOVERY_MODE;

#define NV_DEFAULT_CLUSTER_PRIORITY   0       //!<  The driver will assign priority to a given cluster 

typedef struct _NV_CLUSTER_V1
{
    NvU32                       version;
    NvU32                       id;                 //!<  ID that uniquely identifies a cluster. This is a read-only value and is generated by the display driver while setting up the cluster.
    NvU32                       displayId;          //!<  Read only value. This field will be populated while enumerating existing clusters or during creating a new cluster.
    NvU32                       priority;           //!<  Priority of the cluster, 1 being the highest possible priority. The driver will assign a default priority during  
                                                    //!<  setting up the cluster and during creation, this needs to be initialized to NV_DEFAULT_CLUSTER_PRIORITY. 
  
    NV_PIVOT                    pivot;              //!<  The pivot configuration of this cluster
    NV_CLUSTER_TYPE             type;               //!<  The type of cluster (DP1.2 Stream cloning cluster, etc)
    NV_CLUSTER_DISCOVERY_MODE   discoveryMode;      //!<  The nodes' discovery policy
    NV_CLUSTER_STATE            state;              //!<  The current state of the cluster
    NvU32                       numOfNodeEntries;   //!<  The number of nodes in the cluster
    union // The possible types of NODES will be part of this union. The type of nodes will be based on the value of type (NV_CLUSTER_TYPE_ENUM)
    {
      NV_DP_NODE_INFO*          pDPNodeEntries;     //!<  The list of DP1.2 nodes in the cluster
      NV_TILE_INFO*        pTileEntries;       //!<  The list of tile displays in the cluster for NV_CLUSTER_TYPE_TILE
      // When new cluster types are defined, corresponding node types will be added to this union
    };

    NvU32                       isCEDevice      : 1; //!< If at least one of the device in the cluster is CE device, then the cluster will be marked as CE device
                                                     //!< This is a read-only value and is set by DD while setting up the cluster.
    NvU32                       isAudioCapable  : 1; //!< If there exists at least one audio capable device in the cluster  
                                                     //!< This is a read-only value and is set by DD while setting up the cluster.
    NvU32                       reserved        : 30;//!< Should be zero
  
} NV_CLUSTER_V1;

typedef NV_CLUSTER_V1   NV_CLUSTER;

#define NV_CLUSTER_VER1    MAKE_NVAPI_VERSION(NV_CLUSTER_V1,1)
#define NV_CLUSTER_VER     NV_CLUSTER_VER1


//! @}

// This category is intentionally added before the #endif. The #ifdef should also be in the same scope
#endif NV_CLUSTER_STRUCTS_DEFINED

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GPU_EnumClusterTopologies
//
//! DESCRIPTION: This API enumerates the clusters associated with a physical connector. Use this API to either enumerate all the 
//!              possible cluster topologies on the physical connector for a given Pivot configuration or 
//!              to enumerate all the clusters that were created/defined on the physical connector. The client 
//!              should keep enumerating until NVAPI_END_ENUMERATION is returned.
//!
//!  - To enumerate the possible clusters for a given configuration, set pPivot to the configuration needed.
//!  - To enumerate the current clusters that are defined on the connector, set pPivot to NULL.
//!                
//!  To enumerate the possible clusters for a given configuration:
//!    # Set the pPivot value to the desired configuration.
//!    # Set the following fields of the NV_CLUSTER structure :
//!      1. discoveryMode to NV_CLUSTER_DISCOVERY_MODE_AUTO.
//!      2. type to one of the NV_CLUSTER_TYPE enum values.
//!    # Starting with ZERO for thisENUM, repeatedly call NvAPI_GPU_EnumClusterTopologies in a loop, while incrementing thisENUM 
//!       for each iteration until NVAPI_END_ENUMERATION is returned.
//!    # For each iteration, call NvAPI_GPU_EnumClusterTopologies twice (see the note below), first to get the cluster details including the number
//!       of nodes in the cluster, and then to retrieve the complete node list.
//!    # During the first call, set the corresponding node's pointer to NULL. If the call succeeds, 
//!       the numOfNodeEntries value will have the node count for the cluster.
//!    # Allocate memory based on numOfNodeEntries and set the pointer for the nodes list and call NvAPI_GPU_EnumClusterTopologies
//!       again to fetch the complete node topology.
//!
//!  To enumerate the clusters defined on a given connector:
//!    # Follow the same steps as above, except set pPivot to NULL.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]     rootDisplayId     For NV_CLUSTER_TYPE_DP_STREAM_CLONE, this is the displayId of the connector to which the topology is rooted.
//!                                   For NV_CLUSTER_TYPE_TILE, by passing any displayId of GPU, all Tile cluster of that GPU can be enumerated.
//! \param [in]     pPivot            This is the pivot that defines the cluster parameters. If this is NULL, then this call translates into
//!                                   enumerating the existing clusters.
//! \param [in]     thisEnum          Index of cluster whose topology is requested 
//! \param [in,out] pClusterTopology  Pointer to a NV_CLUSTER structure
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. 
//!          If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval ::NVAPI_END_ENUMERATION     - no more clusters to enumerate.
//! \retval ::NVAPI_INSUFFICIENT_BUFFER - the number of nodes allocated for pClusterTopology->pDPNodeEntries is insufficient. 
//!                                       The actual nodes' count is returned in pClusterTopology->numOfNodeEntries.
//!
//! \ingroup clusterapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_EnumClusterTopologies(__in NvU32 rootDisplayId, __in_opt NV_PIVOT* pPivot, __in NvU32 thisEnum, __inout NV_CLUSTER* pClusterTopology);


//! SUPPORTED OS:  Windows Vista and higher
//!
///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GPU_SetupClusterTopology
//
//! DESCRIPTION:  This API sets up - or re-configures - a cluster on the physical connector identified by the passed in rootDisplayId.
//!               The pivot within the NV_CLUSTER structure holds the configuration information of the target cluster. 
//!               A node cannot belong to more than 1 cluster at any given point of time. The pivot configuration, combined 
//!               with the list of nodes in the cluster, uniquely describes a cluster.
//!
//!
//!  This API can be used to set up a completely new cluster and also to re-configure any existing cluster. The clusterId parameter is 
//!  used to distinguish between both the scenarios. When this parameter is set to NULL, this API reconfigures an existing cluster, otherwise
//!  it sets up a new cluster.  Note that, if a cluster has been created on a connector with the discovery mode set to 
//!  NV_CLUSTER_DISCOVERY_MODE_AUTO, then no more clusters can be set up on the same connector until the auto mode cluster is torn down.  
//!  
//! ============================================================================================================
//!
//!  <b> Setting up a new cluster </b>
//!
//!  
//!  \param [in] rootDisplayId   This is the displayId of the physical connector on which the cluster is to be defined.
//!
//!  The client should fill the following member variables in the NV_CLUSTER structure
//!  \param [in] pClusterTopology::pivot  The configuration of the cluster to be set up. 
//!                                       This is only used when discoveryMode = NV_CLUSTER_DISCOVERY_MODE_AUTO.
//!                                       When discoveryMode = NV_CLUSTER_DISCOVERY_MODE_MANUAL, 
//!                                       the driver will decide the best pivot configuration possible
//!                                       for the given list of monitors. 
//!                                       In this mode, if there is no common configuration possible, this API will fail
//!                                       with NVAPI_CLUSTER_NODES_MISMATCH error.
//!                 
//!  NOTE: Currently interlaced timing is not supported and when pivot.timing.interlaced is set to '1', this API will fail with NVAPI_SET_NOT_ALLOWED.
//!
//!
//!  \param [in]  pClusterTopology::type  The type of cluster
//!  \param [in]  pClusterTopology::discoveryMode     The nodes' inclusion and exclusion policy. Currently only NV_CLUSTER_DISCOVERY_MODE_AUTO is supported.
//!                                       When discoveryMode = NV_CLUSTER_DISCOVERY_MODE_AUTO, the numOfNodeEntries 
//!                                       should be 0 and pDPNodeEntries should be NULL.
//!                                       When discoveryMode = NV_CLUSTER_DISCOVERY_MODE_MANUAL, 
//!                                       - if the numOfNodeEntries > 0, then pDPNodeEntries cannot be NULL.
//!                                       - if the numOfNodeEntries == 0, then pDPNodeEntries should be NULL. In this 
//!                                         case a empty cluster will be set up and the cluster state will be set to 
//!                                         NV_CLUSTER_STATE_DORMANT.
//!  \param [in/out]  pClusterTopology::numOfNodeEntries  The number of nodes in the cluster
//!                                       ([in] Valid only when discoveryMode = NV_CLUSTER_DISCOVERY_MODE_MANUAL)
//!                                       ([out] Valid only when discoveryMode = NV_CLUSTER_DISCOVERY_MODE_AUTO)        
//!  \param [in]  pClusterTopology::pDPNodeEntries    The list of nodes in the cluster 
//!                                       (Valid only when discoveryMode = NV_CLUSTER_DISCOVERY_MODE_MANUAL)
//!
//!  All other variables of the NV_CLUSTER struct are ignored and should be set to ZERO.
//!
//!  \param [out] clusterId                The id of the cluster that gets created if the call is successful. 
//!               
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. 
//!          If there are return error codes with specific meaning for this API, they are listed below.
//!
//!  \retval ::NVAPI_CLUSTER_ALREADY_EXISTS - Another cluster with the same configuration or whose discovery mode is 
//!                                           NV_CLUSTER_DISCOVERY_MODE_AUTO is already created on this connector.
//!  \retval ::NVAPI_SET_NOT_ALLOWED        - The combination of the input is not allowed or is not currently supported.
//!
//! ======================================================================================================================  
//!             
//!  <b> Configuring an existing cluster </b>
//!
//!  \param [in] rootDisplayId    This is the displayId of the physical connector on which the cluster is already defined.
//!
//!  The client should fill the following variables in the NV_CLUSTER structure:
//!  \param [in]  NV_CLUSTER::id           The id of the cluster that was generated during creation.  
//!  \param [in]  NV_CLUSTER::priority     To keep the priority unchanged, set this to NV_DEFAULT_CLUSTER_PRIORITY. 
//!                                        To alter the existing priority, set this to the desired value (non-zero) and if the priority
//!                                        already exists, it slides the priority down of every item = or >. 
//!                                        So if you insert priority 1, it becomes the highest, and everyone else slides down the line.
//!  \param [in] NV_CLUSTER::discoveryMode  The discovery mode of an existing cluster cannot be changed. 
//!                                        The value set here will be used in tandem with the nodes' list to alter the nodes in the existing cluster. 
//!                                        The only valid values in this scenario are NV_CLUSTER_DISCOVERY_MODE_UNKNOWN and NV_CLUSTER_DISCOVERY_MODE_MANUAL.
//!                       Use NV_CLUSTER_DISCOVERY_MODE_UNKNOWN when no change is required in the nodes' list. 
//!                       Use NV_CLUSTER_DISCOVERY_MODE_MANUAL, when altering the nodes in the cluster. Note that modifying the nodes 
//!                       list is only possible when the cluster itself was created with NV_CLUSTER_DISCOVERY_MODE_MANUAL
//!                       in the first place. 
//!  \param [in] NV_CLUSTER::numOfNodeEntries  The number of nodes in the cluster 
//!                                        (Valid only when discoveryMode = NV_CLUSTER_DISCOVERY_MODE_MANUAL)
//!  \param [in] NV_CLUSTER::pDPNodeEntries    The list of nodes in the cluster 
//!                                        (Valid only when discoveryMode = NV_CLUSTER_DISCOVERY_MODE_MANUAL)
//!  \param [in] NV_CLUSTER::state         - NV_CLUSTER_STATE_DISABLED : to disable an exisiting cluster.
//!                                        - NV_CLUSTER_STATE_ENABLED  : to enable an exisiting disabled cluster.
//!                                        - NV_CLUSTER_STATE_DELETE   : to delete an exisiting cluster.
//!       
//!    All other variables of the NV_CLUSTER struct are ignored and should be set to ZERO.
//!
//!  \param [out]clusterId                Not set by the callee. Clients should not use this and should be passing NULL. 
//!               
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. 
//!          If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup clusterapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetupClusterTopology(__in NvU32 rootDisplayId, __inout NV_CLUSTER* pClusterTopology, __out_opt NvU32* clusterId);


//! \ingroup gpu
//! @{

typedef enum _NV_IMP_MODE_STRUCTURE
{
    NV_IMP_MODE_INTERLACED = 0,
    NV_IMP_MODE_PROGRESSIVE,               
} NV_IMP_MODE_TYPE;

typedef enum _NV_IMP_VERTICAL_TAPS
{
    NV_IMP_MODE_VERTICAL_TAPS1 = 0,
    NV_IMP_MODE_VERTICAL_TAPS2,
    NV_IMP_MODE_VERTICAL_TAPS3,
    NV_IMP_MODE_VERTICAL_TAPS3_ADAPTIVE,
    NV_IMP_MODE_VERTICAL_TAPS5,                   
} NV_IMP_VERTICAL_TAPS;

typedef enum _NV_IMP_HORIZONTAL_TAPS
{
    NV_IMP_MODE_HORIZONTAL_TAPS1 = 0,
    NV_IMP_MODE_HORIZONTAL_TAPS2,
    NV_IMP_MODE_HORIZONTAL_TAPS8,      
} NV_IMP_HORIZONTAL_TAPS;

typedef enum _NV_IMP_FORMAT
{
    NV_IMP_MODE_FORMAT_I8 = 0,
    NV_IMP_MODE_FORMAT_VOID16,
    NV_IMP_MODE_FORMAT_VOID32,
    NV_IMP_MODE_FORMAT_RF16_GF16_BF16_AF16,
    NV_IMP_MODE_FORMAT_A8R8G8B8,
    NV_IMP_MODE_FORMAT_A2B10G10R10,
    NV_IMP_MODE_FORMAT_A8B8G8R8,
    NV_IMP_MODE_FORMAT_R5G6B5,
    NV_IMP_MODE_FORMAT_A1R5G5B5
} NV_IMP_FORMAT;

typedef enum _NV_IMP_SUPERSAMPLE
{
    NV_IMP_MODE_SS_X1AA = 0,
    NV_IMP_MODE_SS_X4AA,               
} NV_IMP_SUPERSAMPLE;

typedef enum _NV_IMP_BASE_USAGE_BOUNDS_USABLE
{
    NV_IMP_MODE_BASE_USAGE_BOUNDS_USABLE_CURRENT = 0,
    NV_IMP_MODE_BASE_USAGE_BOUNDS_USABLE_NO,
    NV_IMP_MODE_BASE_USAGE_BOUNDS_USABLE_YES,
} NV_IMP_BASE_USAGE_BOUNDS_USABLE;

typedef enum _NV_IMP_BASE_USAGE_BOUNDS_DEPTH
{
    NV_IMP_MODE_BASE_USAGE_BOUNDS_DEPTH_CURRENT = 0,
    NV_IMP_MODE_BASE_USAGE_BOUNDS_DEPTH_8,
    NV_IMP_MODE_BASE_USAGE_BOUNDS_DEPTH_16,
    NV_IMP_MODE_BASE_USAGE_BOUNDS_DEPTH_32,
    NV_IMP_MODE_BASE_USAGE_BOUNDS_DEPTH_64,
} NV_IMP_BASE_USAGE_BOUNDS_DEPTH;

typedef enum _NV_IMP_BASE_USAGE_BOUNDS_SS
{
    NV_IMP_MODE_BASE_USAGE_BOUNDS_SS_CURRENT = 0,
    NV_IMP_MODE_BASE_USAGE_BOUNDS_SS_X1AA,
    NV_IMP_MODE_BASE_USAGE_BOUNDS_SS_X4AA,
} NV_IMP_BASE_USAGE_BOUNDS_SS;

typedef enum _NV_IMP_BASE_USAGE_BOUNDS_LUT
{
    NV_IMP_MODE_BASE_USAGE_BOUNDS_BASE_LUT_USAGE_NONE = 0,
    NV_IMP_MODE_BASE_USAGE_BOUNDS_BASE_LUT_USAGE_257,             
    NV_IMP_MODE_BASE_USAGE_BOUNDS_BASE_LUT_USAGE_1025,
} NV_IMP_BASE_USAGE_BOUNDS_BASE_LUT;

typedef enum _NV_IMP_BASE_USAGE_BOUNDS_OUTPUT_LUT
{
    NV_IMP_MODE_BASE_USAGE_BOUNDS_OUTPUT_LUT_USAGE_NONE = 0,
    NV_IMP_MODE_BASE_USAGE_BOUNDS_OUTPUT_LUT_USAGE_257,             
    NV_IMP_MODE_BASE_USAGE_BOUNDS_OUTPUT_LUT_USAGE_1025,
} NV_IMP_BASE_USAGE_BOUNDS_OUTPUT_LUT;

typedef enum _NV_IMP_OVERLAY_USAGE_BOUNDS_USABLE
{
    NV_IMP_MODE_OVERLAY_USAGE_BOUNDS_USABLE_USE_CURRENT = 0,
    NV_IMP_MODE_OVERLAY_USAGE_BOUNDS_USABLE_NO,
    NV_IMP_MODE_OVERLAY_USAGE_BOUNDS_USABLE_YES,
} NV_IMP_OVERLAY_USAGE_BOUNDS_USABLE;

typedef enum _NV_IMP_OVERLAY_USAGE_BOUNDS_DEPTH
{
    NV_IMP_MODE_OVERLAY_USAGE_BOUNDS_PIXEL_DEPTH_USE_CURRENT = 0,
    NV_IMP_MODE_OVERLAY_USAGE_BOUNDS_PIXEL_DEPTH_16,
    NV_IMP_MODE_OVERLAY_USAGE_BOUNDS_PIXEL_DEPTH_32,
    NV_IMP_MODE_OVERLAY_USAGE_BOUNDS_PIXEL_DEPTH_64,
} NV_IMP_OVERLAY_USAGE_BOUNDS_DEPTH;

typedef enum _NV_IMP_OVERLAY_USAGE_BOUNDS_OUTPUT_LUT
{
    NV_IMP_MODE_OVERLAY_USAGE_BOUNDS_OVERLAY_LUT_USAGE_NONE = 0,
    NV_IMP_MODE_OVERLAY_USAGE_BOUNDS_OVERLAY_LUT_USAGE_257,             
    NV_IMP_MODE_OVERLAY_USAGE_BOUNDS_OVERLAY_LUT_USAGE_1025,
} NV_IMP_OVERLAY_USAGE_BOUNDS_OUTPUT_LUT;

typedef enum _NV_IMP_BASE_LUT_LO_MODE
{
    NV_IMP_MODE_BASE_LUT_LO_MODE_LORES = 0,
    NV_IMP_MODE_BASE_LUT_LO_MODE_HIRES,
    NV_IMP_MODE_BASE_LUT_LO_MODE_INDEX_1025_UNITY_RANGE,
    NV_IMP_MODE_BASE_LUT_LO_MODE_INTERPOLATE_1025_UNITY_RANGE,
    NV_IMP_MODE_BASE_LUT_LO_MODE_INTERPOLATE_1025_XRBIAS_RANGE,
    NV_IMP_MODE_BASE_LUT_LO_MODE_INTERPOLATE_1025_XVYCC_RANGE,
    NV_IMP_MODE_BASE_LUT_LO_MODE_INTERPOLATE_257_UNITY_RANGE,
    NV_IMP_MODE_BASE_LUT_LO_MODE_INTERPOLATE_257_LEGACY_RANGE,
} NV_IMP_BASE_LUT_LO_MODE;

typedef enum _NV_IMP_OUTPUT_LUT_LO_MODE
{
    NV_IMP_MODE_OUTPUT_LUT_LO_MODE_LORES = 0,
    NV_IMP_MODE_OUTPUT_LUT_LO_MODE_HIRES,
    NV_IMP_MODE_OUTPUT_LUT_LO_MODE_INDEX_1025_UNITY_RANGE,
    NV_IMP_MODE_OUTPUT_LUT_LO_MODE_INTERPOLATE_1025_UNITY_RANGE,
    NV_IMP_MODE_OUTPUT_LUT_LO_MODE_INTERPOLATE_1025_XRBIAS_RANGE,
    NV_IMP_MODE_OUTPUT_LUT_LO_MODE_INTERPOLATE_1025_XVYCC_RANGE,
    NV_IMP_MODE_OUTPUT_LUT_LO_MODE_INTERPOLATE_257_UNITY_RANGE,
    NV_IMP_MODE_OUTPUT_LUT_LO_MODE_INTERPOLATE_257_LEGACY_RANGE,
} NV_IMP_OUTPUT_LUT_LO_MODE;

typedef enum _NV_IMP_OUTPUT_RESOURCE_PIXEL_DEPTH
{
    NV_IMP_MODE_OUTPUT_RESOURCE_PIXEL_DEPTH_DEFAULT = 0,
    NV_IMP_MODE_OUTPUT_RESOURCE_PIXEL_DEPTH_BPP_16_422,           
    NV_IMP_MODE_OUTPUT_RESOURCE_PIXEL_DEPTH_BPP_18_444,           
    NV_IMP_MODE_OUTPUT_RESOURCE_PIXEL_DEPTH_BPP_20_422,           
    NV_IMP_MODE_OUTPUT_RESOURCE_PIXEL_DEPTH_BPP_24_422,          
    NV_IMP_MODE_OUTPUT_RESOURCE_PIXEL_DEPTH_BPP_24_444,           
    NV_IMP_MODE_OUTPUT_RESOURCE_PIXEL_DEPTH_BPP_30_444,           
    NV_IMP_MODE_OUTPUT_RESOURCE_PIXEL_DEPTH_BPP_32_422,          
    NV_IMP_MODE_OUTPUT_RESOURCE_PIXEL_DEPTH_BPP_36_444,         
    NV_IMP_MODE_OUTPUT_RESOURCE_PIXEL_DEPTH_BPP_48_444,          
} NV_IMP_OUTPUT_RESOURCE_PIXEL_DEPTH;

typedef enum _NV_IMP_PIXEL_REPLICATE_MODE
{
    NV_IMP_MODE_PIXEL_REPLICATE_MODE_OFF = 0,
    NV_IMP_MODE_PIXEL_REPLICATE_MODE_X2,
    NV_IMP_MODE_PIXEL_REPLICATE_MODE_X4,
}NV_IMP_PIXEL_REPLICATE_MODE;

typedef enum _NV_IMP_REQUESTED_OPERATION
{
    NV_IMP_MODE_REQUESTED_OPERATION_QUERY = 0,
    NV_IMP_MODE_REQUESTED_OPERATION_PRE_MODESET,
    NV_IMP_MODE_REQUESTED_OPERATION_POST_MODESET,
    NV_IMP_MODE_REQUESTED_OPERATION_QUERY_USE_SC,
    NV_IMP_MODE_REQUESTED_OPERATION_PRE_MODESET_USE_SC,
    NV_IMP_MODE_REQUESTED_OPERATION_POST_MODESET_USE_SC,
    NV_IMP_MODE_REQUESTED_OPERATION_COMPUTE_DMI_DURATION,
// This argument is for VERIF and INTERNAL use only
    NV_IMP_MODE_REQUESTED_OPERATION_SUPERVISOR,
}NV_IMP_REQUESTED_OPERATION;

typedef enum _NV_IMP_POSSIBLE_PSTATES
{
    NV_IMP_MODE_POSSIBLE_PSTATES_UNDEFINED = 0,
    NV_IMP_MODE_POSSIBLE_PSTATES_P0,
    NV_IMP_MODE_POSSIBLE_PSTATES_P1,
    NV_IMP_MODE_POSSIBLE_PSTATES_P2,
    NV_IMP_MODE_POSSIBLE_PSTATES_P3,
    NV_IMP_MODE_POSSIBLE_PSTATES_P8,
    NV_IMP_MODE_POSSIBLE_PSTATES_P10,
    NV_IMP_MODE_POSSIBLE_PSTATES_P12,
    NV_IMP_MODE_POSSIBLE_PSTATES_P15,
    NV_IMP_MODE_POSSIBLE_PSTATES_MAX = 8,
}NV_IMP_POSSIBLE_PSTATES;

typedef struct _NV_IMP_MODE_EX_V1
{
    NvU32 version;
    NvU32 displayId; 
    NvU32 isHeadActive :1;
    NvU32 isPossible :1;
    NvU32 reserved :30;

    struct
    {
         NvU32 frequency;
         NvU32 adj1000Div1001;
    } PixelClock;

    struct
    {    
         NvU32 width;
         NvU32 height;
    } RasterSize;

    struct
    {
         NvU32 x;
         NvU32 y;
    } RasterBlankStart;

    struct
    {   
         NvU32 x;
         NvU32 y;
    } RasterBlankEnd;

    struct
    {    
         NvU32 yStart;
         NvU32 yEnd;
    } RasterVertBlank2;
    
    struct
    {
         NvU32 width;
         NvU32 height;
    } ViewportSizeOut;

    struct
    {
         NvU32 width;
         NvU32 height;
    } ViewportSizeOutMin;

    struct
    {
         NvU32 width;
         NvU32 height;
    } ViewportSizeOutMax;

    struct
    { 
         NvU32 width;
         NvU32 height;
    } ViewportSizeIn;
        
    struct
    {
         NV_IMP_MODE_TYPE structure;
    } Control;
   
    struct
    {
         NV_IMP_VERTICAL_TAPS verticalTaps;
         NV_IMP_HORIZONTAL_TAPS horizontalTaps;
         NvU32 force422 :1;
         NvU32 reserved :31;
    } OutputScaler;
    
    struct
    {
         NV_IMP_FORMAT format;
         NV_IMP_SUPERSAMPLE superSample;
    } ChannelParams;

    struct
    {    
         NV_IMP_BASE_USAGE_BOUNDS_USABLE usable;
         NV_IMP_BASE_USAGE_BOUNDS_DEPTH pixelDepth;
         NV_IMP_BASE_USAGE_BOUNDS_SS superSample;
         NV_IMP_BASE_USAGE_BOUNDS_BASE_LUT baseLutUsage;
         NV_IMP_BASE_USAGE_BOUNDS_OUTPUT_LUT outputLutUsage;
    } BaseUsageBounds;
      
    struct
    {
         NV_IMP_OVERLAY_USAGE_BOUNDS_USABLE usable;
         NV_IMP_OVERLAY_USAGE_BOUNDS_DEPTH pixelDepth;
         NV_IMP_OVERLAY_USAGE_BOUNDS_OUTPUT_LUT overlayLutUsage;
    } OverlayUsageBounds;

    struct
    {
         NvU32 enable :1;
         NvU32 reserved :31;
         NV_IMP_BASE_LUT_LO_MODE       mode;
    } BaseLutLo;
       
    struct
    {
         NvU32 enable :1;
         NvU32 reserved :31;
         NV_IMP_OUTPUT_LUT_LO_MODE       mode;
    } OutputLutLo;

    NV_IMP_OUTPUT_RESOURCE_PIXEL_DEPTH outputResourcePixelDepthBPP;
     
    struct
    {
        NvU32 owner;
        NvU32 protocol;
    } Dac;

    struct
    {
        NvU32 owner;
        NvU32 protocol;
        NV_IMP_PIXEL_REPLICATE_MODE pixelReplicateMode;
    } Sor;

    struct
    {
        NvU32 owner;
        NvU32 protocol;
    } Pior;

    NV_IMP_REQUESTED_OPERATION requestedOperation;

    NvU32 duration;

    NV_IMP_POSSIBLE_PSTATES minPState;
        
} NV_IMP_MODE_EX_V1;
 
typedef NV_IMP_MODE_EX_V1 NV_IMP_MODE_EX;

#define NV_IMP_MODE_EX_VER_1 MAKE_NVAPI_VERSION(NV_IMP_MODE_EX_V1,1)

#define NV_IMP_MODE_EX_VER   NV_IMP_MODE_EX_VER_1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Disp_ConstructIMPModeEx
//
//! DESCRIPTION:   This function will convert the mode data from the
//!                pPathInfo input to the display driver version of the
//!                IMP structure used for IsModePossible calls.
//!
//! PARAMETERS:    pPathInfo    (IN)  - Pointer to a display path Info
//!                pathCount    (IN)  - Count of displayConfig paths
//!                pIMPMode     (OUT) - IMP version of display path
//!                modeCount    (IN/OUT)  - Count of IMPmode paths
//!
//!    FOR INTERNAL TOOL USE ONLY
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!  USAGE:     The caller might have to call this two times to fetch all the required configuration details as follows: \n 
//!             First  Pass: Caller should Call NvAPI_Disp_ConstructIMPModeEx() with pIMPMode set to NULL to fetch correct modeCount depending on the pPathInfo and pathCount passed. 
//!             Second Pass: Allocate memory for pIMPMode with respect to the number of modeCount(from First Pass) to fetch the correct Mode information.
//!
//! RETURN STATUS:
//!              This API can return any of the error codes enumerated in #NvAPI_Status. 
//!              Error codes specific to this API are described below.
//!              (None)
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Disp_ConstructIMPModeEx(__in_ecount(pathCount) NV_DISPLAYCONFIG_PATH_INFO* pPathInfo, __in NvU32 pathCount, __inout_ecount(*modeCount) NV_IMP_MODE_EX* pIMPMode, __inout NvU32* modeCount);

//! @}


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DISP_GetDisplayConfig
//
//! DESCRIPTION:     This API lets caller retrieve the current global display
//!                  configuration.
//!       USAGE:     The caller might have to call this three times to fetch all the required configuration details as follows:
//!                  First  Pass: Caller should Call NvAPI_DISP_GetDisplayConfig() with pathInfo set to NULL to fetch pathInfoCount.
//!                  Second Pass: Allocate memory for pathInfo with respect to the number of pathInfoCount(from First Pass) to fetch 
//!                               targetInfoCount. If sourceModeInfo is needed allocate memory or it can be initialized to NULL.
//!             Third  Pass(Optional, only required if target information is required): Allocate memory for targetInfo with respect 
//!                               to number of targetInfoCount(from Second Pass).               
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in,out]  pathInfoCount    Number of elements in pathInfo array, returns number of valid topologies, this cannot be null.
//! \param [in,out]  pathInfo         Array of path information
//!
//! \return    This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//!
//! \retval    NVAPI_INVALID_ARGUMENT  -   Invalid input parameter. Following can be the reason for this return value:
//!                                        -# pathInfoCount is NULL.
//!                                        -# *pathInfoCount is 0 and pathInfo is not NULL.
//!                                        -# *pathInfoCount is not 0 and pathInfo is NULL.
//! \retval    NVAPI_DEVICE_BUSY       -   ModeSet has not yet completed. Please wait and call it again.
//!                                       
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_GetDisplayConfig(__inout NvU32 *pathInfoCount, __out_ecount_full_opt(*pathInfoCount) NV_DISPLAYCONFIG_PATH_INFO *pathInfo);




///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DISP_SetDisplayConfig
//
//
//! DESCRIPTION:     This API lets caller apply a global display configuration
//!                  across multiple GPUs.
//!
//!                  If all sourceIds are zero, then NvAPI will pick up sourceId's based on the following criteria :
//!                  - If user provides sourceModeInfo then we are trying to assign 0th sourceId always to GDIPrimary. 
//!                     This is needed since active windows always moves along with 0th sourceId.
//!                  - For rest of the paths, we are incrementally assigning the sourceId per adapter basis.
//!                  - If user doesn't provide sourceModeInfo then NVAPI just picks up some default sourceId's in incremental order.
//!                  Note : NVAPI will not intelligently choose the sourceIDs for any configs that does not need a modeset.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pathInfoCount   Number of supplied elements in pathInfo
//! \param [in]      pathInfo        Array of path information
//! \param [in]      flags           Flags for applying settings
//! 
//! \retval ::NVAPI_OK - completed request
//! \retval ::NVAPI_API_NOT_INTIALIZED - NVAPI not initialized
//! \retval ::NVAPI_ERROR - miscellaneous error occurred
//! \retval ::NVAPI_INVALID_ARGUMENT - Invalid input parameter.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_SetDisplayConfig(__in NvU32 pathInfoCount, __in_ecount(pathInfoCount) NV_DISPLAYCONFIG_PATH_INFO* pathInfo, __in NvU32 flags);



///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_Hybrid_SetHybridModeAndDisplayConfig
//
//! DESCRIPTION:     This request will set the hybrid mode, and attempt to 
//!                  apply the display settings after the transition. If the 
//!                  requested settings cannot be applied, a default path will 
//!                  be applied, and status will return NVAPI_PATH_IGNORED.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:      mode(IN)     - hybrid mode
//!                  pathInfoCount(IN) - Number of supplied elements in pathInfo
//!                  pathInfo(IN) - Array of path information
//!                  flags(IN) - Flags for applying settings
//!
//! RETURN STATUS:
//!                  NVAPI_OK - completed request
//!                  NVAPI_API_NOT_INTIALIZED - NVAPI not initialized
//!                  NVAPI_ERROR - miscellaneous error occurred
//!                  NVAPI_INVALID_ARGUMENT - Invalid input parameter.
//!                  NVAPI_PATH_IGNORED - The transition was successful, but
//!                                           the requested path could not
//!                                           be applied.
//!
//! \ingroup hybridapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Hybrid_SetHybridModeAndDisplayConfig(NV_HYBRID_MODE mode, NvU32 pathInfoCount, NV_DISPLAYCONFIG_PATH_INFO* pathInfo, NvU32 flags);








//! \ingroup dispcontrol
//! @{


typedef struct _NV_TV_CLASSIFICATION_TYPE
{
    NvU32 isPC      : 1;    //!< supports at least one PC timing, as defined by the VESA specification
    NvU32 isSDTV    : 1;    //!< supports at least one SDTV timing (720x480i or 720x576i)   
    NvU32 isEDTV    : 1;    //!< supports at least one EDTV timing (720x480p or 720x576p)
    NvU32 isHDTV    : 1;    //!< supports at least one HDTV timing (1920x1080i or 1280x720p or above)
    NvU32 reserved  : 28;
} NV_TV_CLASSIFICATION_TYPE;

typedef struct _NV_TV_CLASSIFICATION
{
    NvU32 version;
    // the TV classification based on the combination of the display's EDID (if it 
    // has a valid one)connector, and bandwidth of the display link as determined 
    // by the display driver
    NV_TV_CLASSIFICATION_TYPE identifiedAs;       
    
    // the TV classification based on the modes supported by the entire hardware &
    // software stack, including modes added by an operating system or end user 
    // which are not present in the EDID
    NV_TV_CLASSIFICATION_TYPE treatedAs;    
} NV_TV_CLASSIFICATION;

//! Macro for constructing the version field of ::_NV_TV_CLASSIFICATION
#define NV_TV_CLASSIFICATION_VER  MAKE_NVAPI_VERSION(NV_TV_CLASSIFICATION,1)

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DISP_GetTvClassification
//
//! DESCRIPTION:     Given a display Id, this API returns the monitor's TV 
//!                  classifications based on the monitor's EDID or connector 
//!                  type and customer's usage.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:      displayId(IN) - NVIDIA Display ID. It is the value 
//!                                  returned from 
//!                                  NvAPI_SYS_GetDisplayIdFromGpuAndOutputId()
//!                  pTvClass(OUT) - Pointer to struct NV_TV_CLASSIFICATION. 
//!                                  Returns various TV Classification for a 
//!                                  given displayId.
//!
//! RETURN STATUS:
//!                  NVAPI_OK - *pTvClass has a NV_TV_CLASSIFICATION value
//!                  NVAPI_API_NOT_INTIALIZED - NVAPI not initialized
//!                  NVAPI_INVALID_ARGUMENT - Invalid input parameter.
//!                  NVAPI_INCOMPATIBLE_STRUCT_VERSION - Incompatible structure version
//!                  NVAPI_NVIDIA_DEVICE_NOT_FOUND - The display specified by displayId is not connected
//!                  NVAPI_ID_OUT_OF_RANGE - The DisplayId corresponds to a 
//!                                          display which is not within the
//!                                          normal outputId range.
//!                  NVAPI_ERROR - miscellaneous error occurred
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_GetTvClassification(NvU32 displayId, NV_TV_CLASSIFICATION *pTvClass);

//! @}







//! \ingroup dispcontrol
//! @{

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DISP_GetSourceModeSet
//
//! \fn NvAPI_DISP_GetSourceModeSet(__in NV_DISPLAY_TOPOLOGY        *pTopology,                                     
//!
//! DESCRIPTION:     This API lets caller retrieve the source mode set corresponding to a particular path on a given VidPn topology.
//!                  Pass NULL for pSourceModeSet to obtain the number of source mode that will be returned.
//! 
//!                  NOTE: For performance consideration, each call to query size of the source mode set should immediately be followed by
//!                        a call to retrieve the source mode set. That is, avoid calling this API with alternating pathIndex.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:      pTopolgy(IN)                - Representing the required VidPN topology for which source mode set is to be enumerated.
//!                                                Pinning a source mode on any path is being ignored at the present, in the future, 
//!                                                they may be used to evaluate the IMP condition of the source mode set returned.
//!                  pathIndex(IN)               - Index to pTopology for the required VidPN path containing the source id
//!                  pSourceModeSet(IN/OUT)      - The array of source mode that will be returned
//!                                                Set version to current NV_DISPLAY_SOURCE_MODE struct for least the first element
//!                  pSourceModeCount(IN/OUT)    - IN: The number of source mode allocated in pSourceModeSet
//!                                              - OUT: The number of source mode returned
//!                  bIsFilteringInvalidMode(IN) - Defaulting to false. TRUE if and only if caller wants only valid source mode in the output
//!
//! RETURN STATUS:
//!                  NVAPI_OK                    - completed request
//!                  NVAPI_NO_IMPLEMENTATION     - This interface is only supported by Windows Vista and above
//!                  NVAPI_ERROR                 - miscellaneous error occurred
//!                  NVAPI_INVALID_ARGUMENT      - Invalid input parameter.
//!                  NVAPI_OUT_OF_MEMORY         - Not enough memory to allocate internal cached source mode table
//
///////////////////////////////////////////////////////////////////////////////

typedef enum
{  
    NV_DISPLAY_SOURCE_FILTER_NONE                               = 0,
    NV_DISPLAY_SOURCE_FILTER_DUPLICATE                          = 1,
    NV_DISPLAY_SOURCE_FILTER_1400x1050                          = 2,
    NV_DISPLAY_SOURCE_FILTER_INVALID                            = 3,
    NV_DISPLAY_SOURCE_FILTER_CRT_NO_EDID_MATCH                  = 4,
    NV_DISPLAY_SOURCE_FILTER_DFPTV_TOO_LARGE_PRIMARY            = 5,
    NV_DISPLAY_SOURCE_FILTER_DFPTV_TOO_LARGE_CLONE              = 6,
    NV_DISPLAY_SOURCE_FILTER_DFPTV_UNDERSCAN                    = 7,
    NV_DISPLAY_SOURCE_FILTER_DFPTV_TOO_LARGE_NO_EDID            = 8,
    NV_DISPLAY_SOURCE_FILTER_HDTV_TOO_LARGE                     = 9,
    NV_DISPLAY_SOURCE_FILTER_SDTV_TOO_LARGE                     = 10,
    NV_DISPLAY_SOURCE_FILTER_DFP_CLONE_UNDERSCAN                = 11,
    NV_DISPLAY_SOURCE_FILTER_DFP_CLONE_TOO_LARGE                = 12,
    NV_DISPLAY_SOURCE_FILTER_LOGIC_SCALING                      = 13,
    NV_DISPLAY_SOURCE_FILTER_UNRECOGNIZED                       = 14,
    NV_DISPLAY_SOURCE_FILTER_ES_GPU                             = 15,
    NV_DISPLAY_SOURCE_FILTER_DFPTV_NOT_CE_FOR_HDMI              = 16,
    NV_DISPLAY_SOURCE_FILTER_HYBRID_EXCEEDED_MAX_LIMIT          = 17,
    NV_DISPLAY_SOURCE_FILTER_HYBRID_INTERPOSER                  = 18,
    NV_DISPLAY_SOURCE_FILTER_MCP7X_IMP_WAR                      = 19,
    NV_DISPLAY_SOURCE_FILTER_R_AND_T                            = 20,
    NV_DISPLAY_SOURCE_FILTER_VIDPN_TARGET_COMBINATION           = 21,   //!< invalid when specified in the source/target context of VidPn
    NV_DISPLAY_SOURCE_FILTER_COPROC_RESOLUTION_LIMITER          = 22,
    NV_DISPLAY_SOURCE_FILTER_MOSAIC_COMPAT_MISMATCH             = 23,
    NV_DISPLAY_SOURCE_FILTER_HCLONE_SOURCE_MISMATCH             = 24,
    NV_DISPLAY_SOURCE_FILTER_IMP_CHECK_WITH_CVT                 = 25,
    NV_DISPLAY_SOURCE_FILTER_IMP_CHECK_WITH_CVT_RB              = 26,
    NV_DISPLAY_SOURCE_FILTER_GRAYSCALE_INVALID                  = 27,
    NV_DISPLAY_SOURCE_FILTER_SIZE_LIMIT_EXCEEDED                = 28,
    NV_DISPLAY_SOURCE_FILTER_MOSAIC_OS_ADDED_MODE               = 29,
    NV_DISPLAY_SOURCE_FILTER_BAR1_SIZE_LIMIT_EXCEEDED           = 30,
    NV_DISPLAY_SOURCE_FILTER_DP_INSUFFICIENT_LINK_BW            = 31,
    NV_DISPLAY_SOURCE_FILTER_IMP_MULTIHEAD                      = 32,
    NV_DISPLAY_SOURCE_FILTER_TEGRA_LIMITED_SCALING_CLONE        = 33,
    NV_DISPLAY_SOURCE_FILTER_MIRACAST                           = 34,
    NV_DISPLAY_SOURCE_FILTER_STITCHED_DISPLAY_SCALING_CLONE     = 35,
} NV_DISPLAY_SOURCE_FILTER;


typedef struct
{    
    NvU32 hybridList            :1; 
    NvU32 nbsi                  :1; 
    NvU32 infStandard           :1; //!< from registry key NV_Modes
    NvU32 infCustom             :1; //!< from registry key NV_CustModes
    NvU32 hdtv                  :1; //!< from registry key NV_HDTVModes
    NvU32 fallbackNvmode        :1; //!< from hardcoded nvmode string
    NvU32 fallbackHdtv          :1; //!< from hardcoded hdtv mode string
    NvU32 underscan             :1; //!< from custom underscan
    NvU32 custom                :1; //!< from custom timing
    NvU32 osAdditionalMode      :1; //!< additional mode added by OS in win7
    NvU32 nativeRotation        :1; 
    NvU32 hSpan                 :1;
    NvU32 vSpan                 :1;
    NvU32 edid                  :1; //!< Mode was added from EDID, but detailed origins information could not be obtained
    NvU32 edidNativeRefreshRate :1; //!< Mode added because EDID indciates a native RR different than the INF mode
    NvU32 edidDTD               :1; //!< EDID detailed timing from base block
    NvU32 edidSTD               :1; //!< EDID standard timing from base block
    NvU32 edidEST               :1; //!< EDID established timing from base block
    NvU32 edidCVT               :1; //!< EDID defined CVT timing (EDID 1.4)
    NvU32 edid861ST             :1; //!< EDID CEA861 extension block
    NvU32 edidExtDTD            :1; //!< EDID detailed timing from extension block
    NvU32 edidExtVTB            :1; //!< EDID defined VTB extension timing
    NvU32 defaultUnderscan      :1; //!< from default underscan
    NvU32 hyperSampling         :1; //!< from hyper sampling 
    NvU32 reserved              :8;

} NV_DISPLAY_SOURCE_ORIGIN;

typedef struct 
{
    NvU32 identity          : 1;  //!< Capability for displaying content with no rotation.
    NvU32 rotation90        : 1;  //!< Capability for displaying content that is rotated 90 degrees.
    NvU32 rotation180       : 1;  //!< Capability for displaying content that is rotated 180 degrees.
    NvU32 rotation270       : 1;  //!< Capability for displaying content that is rotated 270 degrees.
    NvU32 reserved          : 28;
  
} NV_DISPLAY_ROTATE_CAPABILITY;

typedef struct _NV_DISPLAY_SOURCE_MODE_V1
{
    NvU32                                           version;       //!< Structure version
    NV_RESOLUTION                                   resolution;    //!< Source mode resolution in Width * Height, including information on color depth
    NV_FORMAT                                       colorFormat;   //!< Color format information
    NV_DISPLAY_ROTATE_CAPABILITY                    rotation;      //!< Rotation capability of source mode
    NV_DISPLAY_SOURCE_FILTER                        filteredOutBy; //!< whether this source mode has been filtered out and for what reason
    NV_DISPLAY_SOURCE_ORIGIN                        origin;        //!< Using NV_DISPLAY_SOURCE_ORIGIN_MASK
  
} NV_DISPLAY_SOURCE_MODE_V1;

typedef NV_DISPLAY_SOURCE_MODE_V1           NV_DISPLAY_SOURCE_MODE;

//! Macro for constructing the version field of ::NV_DISPLAY_SOURCE_MODE
#define NV_DISPLAY_SOURCE_MODE_VER1         MAKE_NVAPI_VERSION(NV_DISPLAY_SOURCE_MODE_V1,1)
#define NV_DISPLAY_SOURCE_MODE_VER          NV_DISPLAY_SOURCE_MODE_VER1


#define NVAPI_MAX_PATH_PER_TOPOLOGY             8

typedef struct
{   
    NvU32               version;       //!< Structure version
    
    // Set of VidPn path making up the topology.
    // The displays specified on these path must all belong to the same logical GPU
    struct
    {
        NvU32                   srcID;                  //!< ID of the VidPn source surface
        NvU32                   displayID;              //!< display id of the VidPn target
        NvU32                   importanceOrdinal;      //!< importance ordinal (lower value = higher importance) of the VidPn target in case of clone mode
        NV_DISPLAY_SOURCE_MODE  pinnedSourceMode;       //!< A pinned source mode on the current path. Note that GetSourceModeSet will ignore this as of now.
        
    } path [NVAPI_MAX_PATH_PER_TOPOLOGY];
    
    NvU32               pathCount;              //!< number of valid path
    
} NV_DISPLAY_TOPOLOGY_V1;

typedef struct
{
    NvU32               version;       // Structure version

    //! Set of VidPn path making up the topology.
    //! The displays specified on these path must all belong to the same logical GPU
    //! The paths must be sorted such that lowest srcID is first.
    //! For HCLONE topologies, the logical GPU contains both the NonNVIDIA GPU and the NVIDIA GPU. 
    //! This allows for (valid GPU heads * 2[number of GPUs in logical GPU]) paths.
    //! For now, we support a single NonNVIDIA GPU and a single NVIDIA dGPU for HCLONE topologies.So normally this will be 4 paths
    //! The path count is not to exceed NVAPI_MAX_PATH_PER_TOPOLOGY.
    struct
    {
        NvU32                   srcID;                  //!< ID of the VidPn source surface
        union 
        {
            NvU32       targetId; //!< same as in SDC() and QDC() for non NVIDIA display. This will be used when isNonNVIDIA is 1.
            NvU32       displayID; //!< NVIDIA display ID only for NVIDIA displays. This will be used when isNonNVIDIA is 0.
        };
        NvU32                   importanceOrdinal;      //!< importance ordinal (lower value = higher importance) of the VidPn target in case of clone mode
        NV_DISPLAY_SOURCE_MODE  pinnedSourceMode;       //!< A pinned source mode on the current path. Note that GetSourceModeSet will ignore this as of now.
        NvU32                   isNonNVIDIA :1; //!< True for non-NVIDIA GPU and False for NVIDIA GPU. We assume there is only one non-NVIDIA iGPU in the system.
                                                //!< Currently applies to Hclone config only
        NvU32                   isAttachedToDesktop :1;//!<True for path attached to desktop (currently path index 0 and until primary path is different from attached one).
                                                       //!< Currently applies to Hclone config only
        NvU32                   isPanAndScanTarget  :1;//!< Whether this target will have Pan and Scan enabled. Valid only when the target is 
                                                       //!< secondary display in clone topology.
        NvU32                   reserved :29;   //!< reserved
    } path [NVAPI_MAX_PATH_PER_TOPOLOGY];

    NvU32               pathCount;              //!< number of valid path

} NV_DISPLAY_TOPOLOGY_V2;

typedef NV_DISPLAY_TOPOLOGY_V2       NV_DISPLAY_TOPOLOGY;
#define NV_DISPLAY_TOPOLOGY_VER1     MAKE_NVAPI_VERSION(NV_DISPLAY_TOPOLOGY_V1,1)
#define NV_DISPLAY_TOPOLOGY_VER2     MAKE_NVAPI_VERSION(NV_DISPLAY_TOPOLOGY_V2,2)
#define NV_DISPLAY_TOPOLOGY_VER      NV_DISPLAY_TOPOLOGY_VER2


NVAPI_INTERFACE NvAPI_DISP_GetSourceModeSet(__in NV_DISPLAY_TOPOLOGY        *pTopology,
                                            __in NvU32                     pathIndex,
                                            __inout_ecount_part_opt(*pSourceModeCount, *pSourceModeCount) NV_DISPLAY_SOURCE_MODE   *pSourceModeSet,
                                            __inout NvU32                   *pSourceModeCount,
                                            __in NvU8                       bIsFilteringInvalidMode);
                                             
//! @}


//! \ingroup dispcontrol
typedef struct
{
    //! numerator / denominator gives the refresh rate in Hz
    NvU32   numerator;
    NvU32   denominator;

} NV_DISPLAY_REFRESH_RATE;




//! \ingroup dispcontrol
//! @{


typedef struct
{   
    NvU32 gvo                   : 1;
    NvU32 sdtv                  : 1; 
    NvU32 lenovoSlowRefreshRate : 1;  
    NvU32 virtualMode           : 1;  
    NvU32 hybridList            : 1; 
    NvU32 nbsi                  : 1; 
    NvU32 infStandard           : 1; //!< from registry key NV_Modes
    NvU32 infCustom             : 1; //!< from registry key NV_CustModes
    NvU32 hdtv                  : 1; //!< from registry key NV_HDTVModes
    NvU32 fallbackNvmode        : 1; //!< from hardcoded nvmode string
    NvU32 fallbackHdtv          : 1; //!< from hardcoded hdtv mode string
    NvU32 underscan             : 1;
    NvU32 custom                : 1; //!< from custom timing
    NvU32 osAdditionalMode      : 1; //!< additional mode added by OS in win7
    NvU32 nativeRotation        : 1; 
    NvU32 hSpan                 : 1;
    NvU32 vSpan                 : 1;
    NvU32 edid                  : 1; //!< Mode was added from EDID, but detailed origins information could not be obtained
    NvU32 edidNativeRefreshRate : 1; //!< Mode added because EDID indciates a native RR different than the INF mode
    NvU32 edidDTD               : 1; //!< EDID detailed timing from base block
    NvU32 edidSTD               : 1; //!< EDID standard timing from base block
    NvU32 edidEST               : 1; //!< EDID established timing from base block
    NvU32 edidCVT               : 1; //!< EDID defined CVT timing (EDID 1.4)
    NvU32 edid861ST             : 1; //!< EDID CEA861 extension block
    NvU32 edidExtDTD            : 1; //!< EDID detailed timing from extension block
    NvU32 edidExtVTB            : 1; //!< EDID defined VTB extension timing
    NvU32 edidHdmiExt           : 1; //!< EDID HDMI 4kx2k extended resolutions
    
    NvU32 reserved              : 5;

} NV_DISPLAY_TARGET_ORIGIN;



typedef struct
{
    NvU32                         version;        //!< Structure version
    NvU32                         visibleWidth;   //!< Number of visible horizontal pixels
    NvU32                         visibleHeight;  //!< Number of visible vertical pixels
    NvU32                         totalWidth;     //!< Number of total horizontal pixels including blanking
    NvU32                         totalHeight;    //!< Number of total vertical pixels including blanking
    NV_DISPLAY_REFRESH_RATE       refreshRate;    //!< Non-interlaced Refresh Rate of the mode
    NvU32                         pclk;           //!< Pixel clock in Hz    
    NvU32                         aspectRatio;    //!< Currently not being used    
    NV_DISPLAY_TARGET_ORIGIN      origin;
    NvU32                         isInterlaced  : 1;   //!< True if and only if interlace scan mode
    NvU32                         reserved      : 31;
  
} NV_DISPLAY_TARGET_MODE_V1;

typedef struct
{
    NvU32                         version;        //!< Structure version
    NvU32                         visibleWidth;   //!< Number of visible horizontal pixels
    NvU32                         visibleHeight;  //!< Number of visible vertical pixels
    NvU32                         totalWidth;     //!< Number of total horizontal pixels including blanking
    NvU32                         totalHeight;    //!< Number of total vertical pixels including blanking
    NV_DISPLAY_REFRESH_RATE       refreshRate;    //!< Non-interlaced Refresh Rate of the mode
    NvU32                         pclk;           //!< Pixel clock in Hz    
    NvU32                         aspectRatio;    //!< Currently not being used    
    NV_DISPLAY_TARGET_ORIGIN      origin;
    NvU32                         isInterlaced  : 1;   //!< True if and only if interlace scan mode
    NvU32                         isPreferred   : 1;   //!< True if the target mode is the preferred mode.
    NvU32                         reserved      : 30;
    NV_DISPLAY_TV_FORMAT          tvFormat;
  
} NV_DISPLAY_TARGET_MODE_V2;


typedef struct
{
    NvU32                         version;        //!< Structure version
    NvU32                         visibleWidth;   //!< Number of visible horizontal pixels
    NvU32                         visibleHeight;  //!< Number of visible vertical pixels
    NvU32                         totalWidth;     //!< Number of total horizontal pixels including blanking
    NvU32                         totalHeight;    //!< Number of total vertical pixels including blanking
    NV_DISPLAY_REFRESH_RATE       refreshRate;    //!< Non-interlaced Refresh Rate of the mode
    NvU32                         pclk;           //!< Pixel clock in Hz    
    NvU32                         aspectRatio;    //!< Currently not being used    
    NV_DISPLAY_TARGET_ORIGIN      origin;
    NvU32                         isInterlaced  : 1;   //!< True if and only if interlace scan mode
    NvU32                         isPreferred   : 1;   //!< True if the target mode is the preferred mode.
    NvU32                         reserved      : 30;
    NV_DISPLAY_TV_FORMAT          tvFormat;
    NvU32                         hSyncNumerator;      //!< Horizontal sync numerator.
    NvU32                         hSyncDenominator;    //!< Horizontal sync denominator.
    NvU32                         videoStandard;       //!< Video signal standards(ex : D3DKMDT_VSS_VESA_GTF).
} NV_DISPLAY_TARGET_MODE_V3;


#define NV_DISPLAY_TARGET_MODE_VER1   MAKE_NVAPI_VERSION(NV_DISPLAY_TARGET_MODE_V1, 1)
#define NV_DISPLAY_TARGET_MODE_VER2   MAKE_NVAPI_VERSION(NV_DISPLAY_TARGET_MODE_V2, 2)
#define NV_DISPLAY_TARGET_MODE_VER3   MAKE_NVAPI_VERSION(NV_DISPLAY_TARGET_MODE_V3, 3)

#define NV_DISPLAY_TARGET_MODE_VER    NV_DISPLAY_TARGET_MODE_VER3
typedef NV_DISPLAY_TARGET_MODE_V3     NV_DISPLAY_TARGET_MODE; 

#define NV_MAX_TARGET_MODE_NUM              32

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DISP_GetTargetModeSet
//
//!
//! DESCRIPTION:     This API lets caller retrieve the target mode set corresponding to a particular pinned source mode
//!                  given the VidPN topology.
//!
//!                  A pinned source mode MUST be present on the path in pTopology indicated by pathIndex.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:      pTopolgy(IN)            - Representing the required VidPN topology
//!                  pathIndex(IN)           - Index to pTopology for the required VidPN path containing the target device mask
//!                  pTargetModeSet(OUT)     - The array of target mode that will be returned
//!                                            Set version to current NV_DISPLAY_TARGET_MODE struct for least the first element
//!                  pTargetModeCount(OUT)   - The number of target mode returned
//!
//! RETURN STATUS:
//!                  NVAPI_OK - completed request
//!                  NVAPI_NO_IMPLEMENTATION - This interface is only supported by Windows Vista and above
//!                  NVAPI_ERROR - miscellaneous error occurred
//!                  NVAPI_INVALID_ARGUMENT: Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_GetTargetModeSet(
    __in NV_DISPLAY_TOPOLOGY                                                            *pTopology,
    __in NvU32                                                                          pathIndex,
    __out_ecount_part(NV_MAX_TARGET_MODE_NUM, *pTargetModeCount) NV_DISPLAY_TARGET_MODE pTargetModeSet[NV_MAX_TARGET_MODE_NUM],
    __out NvU32                                                                         *pTargetModeCount);
//! @}





//! \ingroup dispcontrol
//! @{

typedef struct
{
    NvU32 version;
    NvU32 useGpuScalerOnly         : 1;
    NvU32 useGpuAndDisplayScaler   : 1;
    NvU32 reserved                 : 30;
} NV_DISPLAY_TARGET_MODE_SETTINGS_V1;

#define NV_DISPLAY_TARGET_MODE_SETTINGS_VER1 MAKE_NVAPI_VERSION(NV_DISPLAY_TARGET_MODE_SETTINGS_V1, 1)

#define NV_DISPLAY_TARGET_MODE_SETTINGS_VER  NV_DISPLAY_TARGET_MODE_SETTINGS_VER1
typedef NV_DISPLAY_TARGET_MODE_SETTINGS_V1   NV_DISPLAY_TARGET_MODE_SETTINGS;

//! @}



///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DISP_GetTargetModeSetEx()
//
//! DESCRIPTION:     This API lets caller retrieve target mode set for the provided VidPN topology.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:      pTopolgy(IN)            - Representing the required VidPN topology.
//!                  pathIndex(IN)           - Index to pTopology for the required VidPN path containing the target device mask.
//!                  pTargetModeSet(IN/OUT)  - The array of target mode that will be returned.
//!                                            Set version to current NV_DISPLAY_TARGET_MODE struct for least the first element.
//!                  pTargetModeCount(OUT)   - The number of target mode returned.
//!                  targetModeSettings(IN)  - Specifies settings to be used to find the target mode set.
//!
//! RETURN STATUS:
//!                  NVAPI_OK                          - Completed Request.
//!                  NVAPI_ERROR                       - Miscellaneous error occurred.
//!                  NVAPI_INVALID_POINTER             - Invalid pointer to NV_DISPLAY_TOPOLOGY or NvU32.
//!                  NVAPI_INVALID_ARGUMENT            - Invalid input parameter.
//!                  NVAPI_NO_IMPLEMENTATION           - This interface is only supported by Windows Vista and above.
//!                  NVAPI_API_NOT_INTIALIZED          - NVAPI not initialized.
//!                  NVAPI_INCOMPATIBLE_STRUCT_VERSION - The structure version passed is invalid.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////                                             
NVAPI_INTERFACE NvAPI_DISP_GetTargetModeSetEx(
    __in NV_DISPLAY_TOPOLOGY                                                            *pTopology,
    __in NvU32                                                                          pathIndex,
    __inout_ecount_part(NV_MAX_TARGET_MODE_NUM, *pTargetModeCount) NV_DISPLAY_TARGET_MODE pTargetModeSet[NV_MAX_TARGET_MODE_NUM],
    __out NvU32                                                                         *pTargetModeCount,
    __in NV_DISPLAY_TARGET_MODE_SETTINGS                                                targetModeSettings);



///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DISP_GetScanoutRasterDimension
//
//! DESCRIPTION:     This API lets caller query the dimensions of the scanout and raster for a particular VidPN topology and pinned target mode.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:      pTopolgy(IN)           - Representing the required VidPN topology.
//!                  pathIndex(IN)          - Index to pTopology for the required VidPN path containing the target device mask.
//!                  pPinnedTargetMode(IN)  - The pinned target mode for which caller needs the scanout and raster dimensions.
//!                  scaling(IN)            - The scaling for which caller needs the scanout and raster dimensions.
//!                  pScanoutRectangle(OUT) - The rectangle where the active image will be displayed.
//!                  pRasterRectangle(OUT)  - The rectangle where the monitor will show image.
//!
//! RETURN STATUS:
//!                  NVAPI_OK                          - Completed Request.
//!                  NVAPI_ERROR                       - Miscellaneous error occurred.
//!                  NVAPI_INVALID_POINTER             - Invalid pointer to NV_DISPLAY_TOPOLOGY or NV_DISPLAY_TARGET_MODE or RECT.
//!                  NVAPI_INVALID_ARGUMENT            - Invalid input parameter.
//!                  NVAPI_NO_IMPLEMENTATION           - This interface is only supported by Windows Vista and above.
//!                  NVAPI_API_NOT_INTIALIZED          - NVAPI not initialized.
//!                  NVAPI_INCOMPATIBLE_STRUCT_VERSION - The structure version passed is invalid.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////                                             
NVAPI_INTERFACE NvAPI_DISP_GetScanoutRasterDimension(__in  NV_DISPLAY_TOPOLOGY     *pTopology,
                                                     __in  NvU32                    pathIndex,
                                                     __in  NV_DISPLAY_TARGET_MODE  *pPinnedTargetMode,
                                                     __in  NV_SCALING               scaling,
                                                     __out NV_RECT                 *pScanoutRectangle,
                                                     __out NV_RECT                 *pRasterRectangle);




///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:  NvAPI_DISP_GetTimingInfo
//
//! \fn NvAPI_DISP_GetTimingInfo(__in NvU32 displayID, __inout NvU32 *timingInfoCount, __out_ecount_part_opt(*timingInfoCount, *timingInfoCount) NV_BACKEND_TIMING_INFO *timingInfo)
//! 
//! DESCRIPTION:   This API lets caller retrieve backend timings supported by the display along with timing origin information.
//!                Currently the API returns only the timings present in EDID.
//!
//! USAGE:         Sequence of calls which caller should make to get the timing information.
//!                1. First call NVAPI_DISP_GetTimingInfo() with timingInfo as NULL to get the count of timings.
//!                2. Allocate memory for timing info array.
//!                3. Call NVAPI_DISP_GetTimingInfo() again with the pointer to the memory allocated to get all the timing info.
//!                   
//!                Note : 
//!                1. timingInfoCount should never be NULL, else the API will fail with NVAPI_INVALID_ARGUMENT.
//!                2. *timingInfoCount returned from the API will always be the actual count in any/every call.
//!                3. Memory size to be allocated should be (*timingInfoCount * sizeof(NV_BACKEND_TIMING_INFO)).
//!                4. If the memory allocated is less than what is required to return all the timings, this API will return the
//!                   amount of timing information which can fit in user provided buffer and API will return NVAPI_INSUFFICIENT_BUFFER.
//!                5. If the caller specifies a greater value for *timingInfoCount in second call to NVAPI_DISP_GetTimingInfo() than
//!                   what was returned from first call, the API will return only the actual number of elements in the timingInfo array 
//!                   and the extra buffer will remain unused.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in,out] timingInfoCount - Always returns the actual number of timings.
//! \param [in,out]    timingInfo   - Array of NV_BACKEND_TIMING_INFO structure which holds the timing info.
//!
//! \return         This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!                 specific meaning for this API, they are listed below.
//! 
///////////////////////////////////////////////////////////////////////////////

//! \ingroup dispcontrol
//! Target timing related information.
typedef struct
{
        NvU32                    version;

    NV_DISPLAY_TARGET_ORIGIN targetOrigin;
        NV_TIMING                timingInfo;
} NV_BACKEND_TIMING_INFO_V1;

typedef NV_BACKEND_TIMING_INFO_V1     NV_BACKEND_TIMING_INFO;

#define NV_BACKEND_TIMING_INFO_VER1   MAKE_NVAPI_VERSION(NV_BACKEND_TIMING_INFO_V1, 1) 
#define NV_BACKEND_TIMING_INFO_VER    NV_BACKEND_TIMING_INFO_VER1 

//! \ingroup dispcontrol
NVAPI_INTERFACE NvAPI_DISP_GetTimingInfo(__in NvU32 displayID, __inout NvU32 *timingInfoCount, __inout_ecount_part_opt(*timingInfoCount, *timingInfoCount) NV_BACKEND_TIMING_INFO *timingInfo);
                                            


//! \ingroup dispcontrol
//! @{

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NVAPI_DISP_GetScalingSupport
//
//! \fn NvAPI_DISP_GetScalingSupport(NV_DISPLAY_TOPOLOGY        *pTopology, 
//!                                             NvU32                       pathIndex,
//!                                             NV_DISPLAY_TARGET_MODE     *pPinnedTargetMode,
//!                                             NV_DISPLAY_SCALING_SUPPORT *pScalingSupport)
//!
//! DESCRIPTION:     This API lets caller retrieve scaling support information given a VidPn topology, a pinned source mode
//!                  and optionally a pinned target mode
//!
//!                  A pinned source mode MUST be present(not NULL) on the path in pTopology indicated by pathIndex.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:      pTopolgy(IN)            - Representing the required VidPN topology
//!                  pathIndex(IN)           - Index to pTopology for the required VidPN path containing the target device mask
//!                  pPinnedTargetMode(IN)   - Optionally a target mode can be pinned for getting scaling support on full source/target mode combination
//!                  pScalingSupport(OUT)    - Scaling support information
//!
//! RETURN STATUS:
//!                  NVAPI_OK - completed request
//!                  NVAPI_NO_IMPLEMENTATION - This interface is only supported by Windows Vista and above
//!                  NVAPI_ERROR - miscellaneous error occurred
//!                  NVAPI_INVALID_ARGUMENT: Invalid input parameter.
//
///////////////////////////////////////////////////////////////////////////////

typedef struct
{
    NvU32   identity                : 1; //!< Capability for displaying content with no transformation.
    NvU32   centered                : 1; //!< Capability for displaying centered content.
    NvU32   stretched               : 1; //!< Capability for displaying scaled content.
    NvU32   aspectRatioCenteredMax  : 1; //!< (Windows 7) Capability for scaling source content to fit the target while preserving the aspect ratio of the source.
    NvU32   custom                  : 1; //!< (Windows 7) Capability for displaying one or more scaling modes that are not described by other members of this structure.
    NvU32   reserved                : 27;

} NV_DISPLAY_SCALING_SUPPORT;

NVAPI_INTERFACE NvAPI_DISP_GetScalingSupport(NV_DISPLAY_TOPOLOGY        *pTopology, 
                                             NvU32                       pathIndex,
                                             NV_DISPLAY_TARGET_MODE     *pPinnedTargetMode,
                                             NV_DISPLAY_SCALING_SUPPORT *pScalingSupport);
                                            
//! @}


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DISP_GetScalingCapsOverride
//
//! DESCRIPTION:     This API lets caller retrieve scaling override information for a particular display.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:      displayId(IN)     - Display ID of display to override the scaling caps. 
//!                                      Retrieved from NvAPI_SYS_GetDisplayIdFromGpuAndOutputId().
//!                  pScalingCaps(OUT) - Scaling settings information which caller has overridden.
//!
//! RETURN STATUS:
//!                  NVAPI_OK                          - Completed request.
//!                  NVAPI_ERROR                       - Miscellaneous error occurred.
//!                  NVAPI_INVALID_POINTER             - Invalid pointer to NV_GET_SCALING_CAPS.
//!                  NVAPI_ID_OUT_OF_RANGE             - Incorrect display ID.
//!                  NVAPI_NO_IMPLEMENTATION           - Only supported on Windows Vista and above.
//!                  NVAPI_API_NOT_INTIALIZED          - NVAPI not initialized.
//!                  NVAPI_INCOMPATIBLE_STRUCT_VERSION - The structure version passed is invalid.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////                                             
NVAPI_INTERFACE NvAPI_DISP_GetScalingCapsOverride(NvU32 displayId, NV_GET_SCALING_CAPS * pScalingCaps);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DISP_SetScalingCapsOverride
//
//! DESCRIPTION:     This API lets caller set scaling override for a particular display.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:      displayId(IN)            - Display ID corresponding to the connected display for which the caller wants to override scaling.
//!                  pScalingCaps(IN)         - The requested scaling capabilities the caller wishes to use instead of the true scaling capabilities.
//!                                             Due to a driver limitation, there can be only one bit set in the scaling cap override structure.  
//!                                             To disable the scaling cap override feature, set pScalingCaps to the true scaling capabilities
//!                                             (from NvAPI_DISP_GetScalingCaps).
//!                  preferredScaling(IN)     - Changes the current display scaling to preferredScaling settings. This parameter is ignored if the display is inactive.
//!
//! RETURN STATUS:
//!                  NVAPI_OK                          - Completed request.
//!                  NVAPI_ERROR                       - Miscellaneous error occurred.
//!                  NVAPI_INVALID_POINTER             - Invalid pointer to NV_GET_SCALING_CAPS.
//!                  NVAPI_ID_OUT_OF_RANGE             - Incorrect display ID.
//!                  NVAPI_INVALID_ARGUMENT            - Invalid value passed for preferredScaling.
//!                  NVAPI_NO_IMPLEMENTATION           - Only supported on Windows Vista and above.
//!                  NVAPI_API_NOT_INTIALIZED          - NVAPI not initialized.
//!                  NVAPI_INVALID_COMBINATION         - Invalid combination of pScalingCaps and preferredScaling.
//!                  NVAPI_INCOMPATIBLE_STRUCT_VERSION - The structure version passed is invalid.
//!
//! \ingroup dispcontrol 
///////////////////////////////////////////////////////////////////////////////                                             
NVAPI_INTERFACE NvAPI_DISP_SetScalingCapsOverride(NvU32 displayId, NV_GET_SCALING_CAPS * pScalingCaps, NV_SCALING preferredScaling);



//! \ingroup dispcontrol
//! @{

typedef struct _NV_DISPLAY_BLANKING_INFO_V1 
{ 
   NvU32 version;
   NvU32 blankingState                      : 1;  //!< 1 - Set    , 0 - Unset.
   NvU32 persistBlankingAcrossHotPlugUnplug : 1;  //!< 1 - Persist, 0 - Do Not persist.
   NvU32 reserved                           : 30;
}NV_DISPLAY_BLANKING_INFO_V1; 

typedef NV_DISPLAY_BLANKING_INFO_V1   NV_DISPLAY_BLANKING_INFO;

#define NV_DISPLAY_BLANKING_INFO_VER1 MAKE_NVAPI_VERSION(NV_DISPLAY_BLANKING_INFO_V1, 1) 
#define NV_DISPLAY_BLANKING_INFO_VER  NV_DISPLAY_BLANKING_INFO_VER1 

//! @}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_DISP_GetDisplayBlankingState 
//
//! DESCRIPTION:    This API returns the information about the display's blanking state. 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]     displayId              - NVIDIA Display selection.
//! \param [out]    pDisplayBlankingState  - Pointer to the structure containing the flags about the display's current blanking state.
//!
//! \retval ::NVAPI_OK                           - Completed request.
//! \retval ::NVAPI_ERROR                        - Miscellaneous error occurred.
//! \retval ::NVAPI_NOT_SUPPORTED                - Feature not supported on GPU. Will work on Quadro's only.
//! \retval ::NVAPI_ID_OUT_OF_RANGE              - Incorrect display ID.
//! \retval ::NVAPI_INVALID_POINTER              - Invalid pointer to NV_DISPLAY_BLANKING_INFO structure.
//! \retval ::NVAPI_NO_IMPLEMENTATION            - API not implemented. Will return this error in case of WinXP.    
//! \retval ::NVAPI_API_NOT_INTIALIZED           - NvAPI_Initialize() has not been called or was not successfull.
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION  - The structure version passed is invalid.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_GetDisplayBlankingState(NvU32 displayId, NV_DISPLAY_BLANKING_INFO *pDisplayBlankingState); 



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_DISP_SetDisplayBlankingState 
//
//! DESCRIPTION:    This API sets the display's blanking state information provided by the user. 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]     displayId               - NVIDIA Display selection.
//! \param [in]     pDisplayBlankingState   - Pointer to the structure containing the blanking flags which the user 
//!                                              wants to set on the display.
//!
//! \retval ::NVAPI_OK                           - Completed request.
//! \retval ::NVAPI_ERROR                        - Miscellaneous error occurred.
//! \retval ::NVAPI_ACCESS_DENIED                - Access denied to the current caller process of this API. 
//!                                                Until the process which has blanked the display doesn't unblank the display
//!                                                or exits, no other process can set the blanking state.
//! \retval ::NVAPI_NOT_SUPPORTED                - Feature not supported on GPU. Will work on Quadro's only.
//! \retval ::NVAPI_ID_OUT_OF_RANGE              - Incorrect display ID.
//! \retval ::NVAPI_INVALID_POINTER              - Invalid pointer to NV_DISPLAY_BLANKING_INFO structure.
//! \retval ::NVAPI_NO_IMPLEMENTATION            - API not implemented. Will return this error in case of WinXP.    
//! \retval ::NVAPI_API_NOT_INTIALIZED           - NvAPI_Initialize() has not been called or was not successfull.
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION  - The structure version passed is invalid.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_SetDisplayBlankingState(NvU32 displayId, NV_DISPLAY_BLANKING_INFO * pDisplayBlankingState); 



//! \ingroup dispcontrol
//! @{
typedef struct _NV_DISPLAY_EDID_MONITOR_RANGE
{
    NvU16    minRefreshRateHz;               // Minimum frame rate in Hz
    NvU16    maxRefreshRateHz;               // Maximum frame rate in Hz
    NvU16    minLineRateKHz;                 // Minimum line rate in kHz
    NvU16    maxLineRateKHz;                 // Maximum line rate in kHz 
    NvU16    maxPclkMHz;                     // Maximum pixel rate in MHz
} NV_DISPLAY_EDID_TIMING_RANGE;

typedef struct _NV_DISPLAY_EDID_DATA_V1 
{ 
   NvU32 version;
   NvAPI_ShortString displayName;             // Display name string.
   NvAPI_ShortString manufacturerName;        // Manufacturer name string.
   NvU32 specificID;                          // 32 bit CRC32, will be the same for all displays with identical EDID data.
   NvU32 commonID;                            // 32 bit CRC calculated after purging 'Week of Manufacture', 'Year of Manufacture', 'Product ID String' & 'Serial Number' from EDID.
   NvU32 isValid                      : 1;    // EDID validity
   NvU32 reserved                     : 31;
}NV_DISPLAY_EDID_DATA_V1; 

typedef struct _NV_DISPLAY_EDID_DATA_V2 
{ 
   NvU32 version;
   NvAPI_ShortString displayName;             // Display name string.
   NvAPI_ShortString manufacturerName;        // Manufacturer name string.
   NvU32 specificID;                          // 32 bit CRC32, will be the same for all displays with identical EDID data.
   NvU32 commonID;                            // 32 bit CRC calculated after purging 'Week of Manufacture', 'Year of Manufacture', 'Product ID String' & 'Serial Number' from EDID.
   NvU32 isValid                      : 1;    // EDID validity
   NvU32 reserved                     : 31;
   NV_DISPLAY_EDID_TIMING_RANGE timingRangeLimit;  // EDID timing range limit    
}NV_DISPLAY_EDID_DATA_V2; 


typedef NV_DISPLAY_EDID_DATA_V2   NV_DISPLAY_EDID_DATA;

#define NV_DISPLAY_EDID_DATA_VER1 MAKE_NVAPI_VERSION(NV_DISPLAY_EDID_DATA_V1, 1) 
#define NV_DISPLAY_EDID_DATA_VER2 MAKE_NVAPI_VERSION(NV_DISPLAY_EDID_DATA_V2, 2) 
#define NV_DISPLAY_EDID_DATA_VER  NV_DISPLAY_EDID_DATA_VER2 

//! @}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_DISP_GetEdidParsed 
//
//! DESCRIPTION:    This API returns the parsed edid data from Driver. 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:     displayId(IN)  - NVIDIA Display selection.
//!                 pEdidData(OUT) - Pointer to the structure to get the parsed edid data.
//!
//! RETURN STATUS: 
//!    NVAPI_OK                           - Completed request.
//!    NVAPI_ERROR                        - Miscellaneous error occurred.
//!    NVAPI_ID_OUT_OF_RANGE              - Incorrect display ID.
//!    NVAPI_INVALID_POINTER              - Invalid pointer to NV_DISPLAY_EDID_DATA structure.
//!    NVAPI_NO_IMPLEMENTATION            - API not implemented. Will return this error in case of WinXP.    
//!    NVAPI_API_NOT_INTIALIZED           - NvAPI_Initialize() has not been called or was not successfull.
//!    NVAPI_INCOMPATIBLE_STRUCT_VERSION  - The structure version passed is invalid.
//!
//! \ingroup dispcontrol 
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_GetEdidParsed(NvU32 displayId, NV_DISPLAY_EDID_DATA *pEdidData); 







///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Coproc_QueryHDAudioState  
//
//! PARAMETERS:      pHDAState (OUT)               Pointer to a NvU32 which receives the status 
//!                                                of HDAudio from driver. 
//!                                                1 : HDAudio is enabled.
//!                                                0 : HDAudio is disabled.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! DESCRIPTION:     This API call is used to query the status of HDAudio from the driver.
//!
//! RETURN STATUS:
//!    NVAPI_OK - completed request
//!    NVAPI_ERROR - miscellaneous error occurred
//!    NVAPI_NOT_SUPPORTED - call is not supported
//!    NVAPI_API_NOT_INTIALIZED - NvAPI not initialized
//!    NVAPI_INVALID_ARGUMENT - Invalid Argument passed.
//!
//! \ingroup coprocapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Coproc_QueryHDAudioState(NvU32 *pHDAState);



///////////////////////////////////////////////////////////////////////////////
// Heterogeneous Clone related APIs.
///////////////////////////////////////////////////////////////////////////////



//! \ingroup hcloneapi
typedef struct
{
    NvU32   width;
    NvU32   height;
    NV_FORMAT colorFormat;
    NV_DISPLAY_REFRESH_RATE   refreshRate;
    NvU32   reserved; //!< Must be initialized to zero.
} NV_DISPLAY_SETTING;

//! \ingroup hcloneapi
typedef struct
{
    NvU32       version;
    NvU32       isNonNVIDIA :1; //!< True for non-NVIDIA GPU and False for NVIDIA GPU. We assume there is only one non-NVIDIA iGPU in the system.
    NvU32       isAttachedToDesktop :1;//!< True for path attached to desktop (currently path index 0 and until primary path is different from attached one).
    NvU32       reserved :30;
    NvU32       sourceId;  //!< For SET call: 
                          //!< IN: For the main adapter which is the primary of this HClone node that is attached and visible to the desktop,
                          //!< pass in the sourceId as seen by the OS.
                          //!< N/A: For the paths not visible to the OS, Driver will internally pick the sourceId. Note that this sourceId can
                          //!< dynamically be changed by Driver at runtime such as when MSPanel extends a monitor on the main adapter.
                          //!< For the GET call:
                          //!< OUT: Driver will return the sourceId for all the paths involved in this Hclone Node. The main adapter's 
                          //!< sourceId, is guaranteed to remain the same as passed in at the SET time but the value might have changed for
                          //!< the other paths
    union {
        NvU32       targetId; //!< same as in SDC() and QDC() for non NVIDIA display. This will be used when isNonNVIDIA is 1.
        NvU32       displayId; //!, NVIDIA display ID only for NVIDIA displays. This will be used when isNonNVIDIA is 0.
    };
    NV_DISPLAY_SETTING   dispSetting;
    NvU32      reserved1; //!< Must be initialized to zero.
} NV_HCLONE_PATH_V1;


//! \ingroup hcloneapi
typedef NV_HCLONE_PATH_V1    NV_HCLONE_PATH;

//! \ingroup hcloneapi
#define NV_HCLONE_PATH_VER1  MAKE_NVAPI_VERSION(NV_HCLONE_PATH_V1,1)

//! \ingroup hcloneapi
#define NV_HCLONE_PATH_VER   NV_HCLONE_PATH_VER1

//! \ingroup hcloneapi
typedef struct 
{
    NvU32 version;
    NvU32 numPaths; //!< Number of paths in this node.
    NV_HCLONE_PATH *pHClonePathArray;//!< index 0 is primary (of highest priority)
    NvU32  reserved1; //!< Must be initialized to zero.
} NV_HCLONE_NODE_V1;

//! \ingroup hcloneapi
typedef NV_HCLONE_NODE_V1    NV_HCLONE_NODE;

//! \ingroup hcloneapi
#define NV_HCLONE_NODE_VER1  MAKE_NVAPI_VERSION(NV_HCLONE_NODE_V1,1)

//! \ingroup hcloneapi
#define NV_HCLONE_NODE_VER   NV_HCLONE_NODE_VER1

//! \ingroup hcloneapi
typedef enum NV_HCLONE_HOTPLUG_BEHAVIOR
{
    NV_HCLONE_HOTPLUG_BEHAVIOR_CCD=0,   //!< Default behavior, using CCD rules for hotplug behavior
    NV_HCLONE_HOTPLUG_BEHAVIOR_EXTENDED,//!< Override Hotplug for the 1st display - will ignore persistence and go to extended mode
    NV_HCLONE_HOTPLUG_BEHAVIOR_UI,      //!< Override Hotplug for the 1st display - will invoke the Hotplug Dialog interraction
                                        //!< (note, also depends on 
                                        //!< the additional setting persisted within the dialog)
} NV_HCLONE_HOTPLUG_BEHAVIOR;

//! \ingroup hcloneapi
typedef struct 
{
    NvU32 version;
    NvU32 numHCloneNodes;
    NV_HCLONE_NODE *pHCloneNodeArray;
    NvU32 isMultiHClonePairsEnabled:1; //!< True: allow more than 1 hclone pairs simultaneously. 
                                       //!< False: Only a single pair is allowed with integrated adapter as primary display.
    NvU32 isNWayHCloneNodesEnabled:1;  //!< True: 3-way and 4-way nodes are enabled. False: Only 2-way hclone nodes are enabled.
    NvU32 reserved1:30;                //!< Must be initialized to zero.
    NV_HCLONE_HOTPLUG_BEHAVIOR HCloneHotPlugBehavior;      //!< Different flavors of behaviors on hotplug.
} NV_HCLONE_TOPOLOGY_V1;



//! \ingroup hcloneapi
typedef NV_HCLONE_TOPOLOGY_V1    NV_HCLONE_TOPOLOGY;

//! \ingroup hcloneapi
#define NV_HCLONE_TOPOLOGY_VER1  MAKE_NVAPI_VERSION(NV_HCLONE_TOPOLOGY_V1,1)

//! \ingroup hcloneapi
#define NV_HCLONE_TOPOLOGY_VER   NV_HCLONE_TOPOLOGY_VER1


/////////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_DISP_SetHCloneTopology   
//!   DESCRIPTION: This API applies the Heterogeneous clone over displays given in pHCloneTopology.  
//!                Caller should first set the topology over all primary display using OS-API and then call this NVAPI.
//!  
//! SUPPORTED OS:  Windows 7
//!
//! \param [in] pHCloneTopology    Heterogeneous clone topology information              
//!
//! \retval ::NVAPI_INVALID_ARGUMENT: invalid arguments.
//! \retval ::NVAPI_OK: Display topology successfully applied.
//! \retval ::NVAPI_NOT_SUPPORTED: This software feature is not supported on the system.
//! \retval ::NVAPI_OUT_OF_MEMORY: Could not allocate sufficient memory to complete the call
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION: NV_HCLONE_TOPOLOGY/NV_HCLONE_NODE structure version mismatch. see pDispTopology->version.
//!
//! \ingroup hcloneapi
//////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_SetHCloneTopology(__in NV_HCLONE_TOPOLOGY *pHCloneTopology);




///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:  NvAPI_DISP_GetHCloneTopology
//
//! DESCRIPTION:   This API retrieves the current HClone topology information.
//!                Use the following steps to retrieve pHCloneTopology completely:
//!                -# Call this function with pHCloneTopology->pHCloneNodeArray set to NULL, to get the total number nodes in the HClone.
//!                -# Allocate memory to pHCloneTopology->pHCloneNodeArray of size sizeof(NV_HCLONE_NODE)*pHCloneTopology->numHCloneNodes.
//!                -# Assign NULL to all pHCloneTopology->pHCloneNodeArray[count].pHClonePathArray in a loop and call this function
//!                   to get all the pHCloneTopology->pHCloneNodeArray[count].numPaths.
//!                -# In loop allocate memory to pHCloneTopology->pHCloneNodeArray[code].pHClonePathArray
//!                   of size sizeof(NV_HCLONE_PATH)*pHCloneTopology->pHCloneNodeArray[count].numPaths.
//!                -# Call this function to get entire topology.
//!
//!                In step 5, if HClone is not completed, return value will be NVAPI_DEVICE_BUSY. \p
//!                In step 1 and step 3, even if HClone is not completed you will get return value as ::NVAPI_OK.
//!                
//! SUPPORTED OS:  Windows 7
//!
//! 
//! \param [out]    pHCloneTopology(gives current Heterogeneous clone topology information.
//!
//! \retval ::NVAPI_INVALID_ARGUMENT invalid arguments.
//! \retval ::NVAPI_OK  successfully returned.
//! \retval ::NVAPI_DEVICE_BUSY It means HClone is not completed yet and pHCloneTopology will contain topology that is being set.
//! \retval ::NVAPI_NOT_SUPPORTED This software feature is not supported on the system.
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION NV_HCLONE_TOPOLOGY/NV_HCLONE_NODE structure version mismatch. See pHCloneTopology->version.
//!
//! \ingroup hcloneapi
//////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_GetHCloneTopology(__inout NV_HCLONE_TOPOLOGY *pHCloneTopology);


typedef struct {
    NvU32 version;                  //!< [IN] Must be set to NV_HCLONE_DISPLAY_CAPS_VER.
    union {
        NvU32 displayID;            //!< [IN] Display ID for NVIDIA monitor. Must be set if isNonNVIDIADisplay is false.
        NvU32 targetID;             //!< [IN] CCD's target ID for non NVIDIA monitor. Must be set if isNonNVIDIADisplay is true.
    };

    NvU32 isNonNVIDIA:1;            //!< [IN] States if monitor is attached to NVIDIA or non-NVIDIA display.
    NvU32 isPrimaryCapable:1;       //!< [OUT] This monitor is capable of being a primary monitor in Heterogeneous clone.
    NvU32 isSecondaryCapable:1;     //!< [OUT] This monitor is capable of being a secondary monitor in Heterogeneous clone.
    NvU32 reserved:29;              //!< [OUT] This will be undefined.
} NV_HCLONE_DISPLAY_CAPS_V1;

//! \ingroup hcloneapi
typedef NV_HCLONE_DISPLAY_CAPS_V1   NV_HCLONE_DISPLAY_CAPS;

//! \ingroup hcloneapi
#define NV_HCLONE_DISPLAY_CAPS_VER1 MAKE_NVAPI_VERSION(NV_HCLONE_DISPLAY_CAPS_V1,1)

//! \ingroup hcloneapi
#define NV_HCLONE_DISPLAY_CAPS_VER  NV_HCLONE_DISPLAY_CAPS_VER1

///////////////////////////////////////////////////////////////////////////////
//
//! DESCRIPTION:    This function gets capabilities of monitors related to HClone.
//!                 The capability includes:
//!                     1. Can a monitor becomes primary monitor in HClone (isPrimaryCapable).
//!                     2. Can a monitor becomes secondary monitor in HClone (isSecondaryCapable).
//!
//! SUPPORTED OS:  Windows 7
//!
//! \param [in,out]     pDisplayCaps    Array of display capabilities. See NV_HCLONE_DISPLAY_CAPS for more details.
//! \param [in]         countDisplay    Number of displays in array pDisplayCaps.
//! 
//! \return      This API can return any of the error codes enumerated in #NvAPI_Status.
//!              If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval ::NVAPI_NOT_SUPPORTED Heterogeneous clone is not supported on your system.
//!
//! \ingroup hcloneapi
//////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_GetHCloneDisplayCaps(__inout_ecount_full(countDisplay) NV_HCLONE_DISPLAY_CAPS *pDisplayCaps, __in NvU32 countDisplay);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:  NvAPI_DISP_ValidateHCloneTopology
//
//! DESCRIPTION:   This API validates the HClone topology if that is supported/valid.It will validate only topology (Not the display setting)
//!                any NV_DISPLAY_SETTING in pHCloneTopology would be ignored
//!
//! SUPPORTED OS:  Windows 7
//!
//!
//! \param [in]   pHCloneTopology    Heterogenous clone topology information.
//! \param [out]  pValid             TRUE if valid/supported otherwise FALSE
//! 
//! \retval ::NVAPI_INVALID_ARGUMENT invalid arguments.
//! \retval ::NVAPI_OK  succesfully returned.
//! \retval ::NVAPI_NOT_SUPPORTED This software feature is not supported on the system.
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION NV_HCLONE_TOPOLOGY/NV_HCLONE_NODE structure version mismatch. see pHCloneTopology->version.
//! \ingroup hcloneapi
//////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_ValidateHCloneTopology(__in NV_HCLONE_TOPOLOGY *pHCloneTopology, __out NvU32 *pValid);



//! SUPPORTED OS:  Windows 7 and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DISP_GetHCloneIGPUDisplayEdid
//
//!   DESCRIPTION: Returns the EDID data for the specified Target Id. Supported on IGPU display only.
//!                User must call this function with pEDID NULL and pSizeofEDID set, to get the size of
//!                buffer for pEDID. Once user get the size, allocate pEDID with buffer of size returned
//!                by pSizeofEDID and call this function again with all parameters.
//!
//! \param [in]     targetId     The same TargetId that is retrieved from CCD-API QueryDisaplyConfig.
//! \param [out]    pEdid        The pointer to the buffer that will have EDID data returned from
//!                              the driver. To get just the size of EDID data, call this function
//!                              with pEdid NULL and pSizeofEDID set.
//! \param [in,out] pSizeofEDID  Pointer to size of buffer pointed by pEDID as input.
//                               Size of actual EDID data as output. When pEDID is
//                               NULL this is output only parameter.
//!
//! \retval ::NVAPI_INVALID_ARGUMENT  This can be returned in any of the following scenarios:
//!                    - targetId is invalid.
//!                    - pSizeofEDID is NULL.
//!                    - pEdid is present and *pSizeofEDID is 0.
//! \retval ::NVAPI_OK              *pEDID contains valid data.
//! \retval ::NVAPI_DATA_NOT_FOUND  requested display does not contain an EDID
//!
//! \ingroup hcloneapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_GetHCloneIGPUDisplayEdid(__in NvU32 targetId, __out_bcount_part_opt(*pSizeofEDID, *pSizeofEDID) NvU8 *pEdid, __inout NvU32 *pSizeofEDID);




//! \ingroup dispcontrol
typedef enum _NV_WIDE_COLOR_RANGE
{
    NV_COLOR_UNKNOWN = 0,
    NV_COLOR_xvYCC, 
    
}NV_WIDE_COLOR_RANGE; 

//! \ingroup dispcontrol
typedef struct _NV_WIDE_COLOR_RANGE_SETTING
{
    NvU32 version;                   //!< structure version
    NV_WIDE_COLOR_RANGE colorRange;  //!< (IN)Color range (NV_WIDE_COLOR_RANGE)
    NvU32 enable    :1;              //!< (IN for NvAPI_DISP_SetWideColorRange, OUT for NvAPI_DISP_GetWideColorRange ) 
                                     //! 1: enable ,0: disable
    NvU32 reserved  :31;             //!< reserved 
}NV_WIDE_COLOR_RANGE_SETTING_V1;

//! \ingroup dispcontrol
typedef NV_WIDE_COLOR_RANGE_SETTING_V1    NV_WIDE_COLOR_RANGE_SETTING;

//! \ingroup dispcontrol
#define NV_WIDE_COLOR_RANGE_SETTING_VER1  MAKE_NVAPI_VERSION(NV_WIDE_COLOR_RANGE_SETTING_V1,1)

//! \ingroup dispcontrol
#define NV_WIDE_COLOR_RANGE_SETTING_VER   NV_WIDE_COLOR_RANGE_SETTING_VER1

//! SUPPORTED OS:  Windows Vista and higher
//!
///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DISP_SetWideColorRange
//
//! DESCRIPTION:     This API is used to enable/disable different color modes.
//!                  Currently only NV_COLOR_xvYCC_Range is supported.
//!
//! \param [in]      displayId          Monitor Identifier.
//! \param [in]      colorRangeSetting  Color range settings.
//!
//! \retval ::NVAPI_OK - completed request
//! \retval ::NVAPI_ERROR - miscellaneous error occurred
//! \retval ::NVAPI_INVALID_ARGUMENT - Invalid input parameter
//! \retval ::NVAPI_NO_IMPLEMENTATION - API is not supported on the system
//! \retval ::NVAPI_API_NOT_INTIALIZED - NVAPI not initialized
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION - Structure version mismatch
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_SetWideColorRange(NvU32 displayId, NV_WIDE_COLOR_RANGE_SETTING *colorRangeSetting);



//! SUPPORTED OS:  Windows Vista and higher
//!
///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DISP_GetWideColorRange
//
//! DESCRIPTION:     This API is used to query the status of different color modes.
//!                  Currently NV_COLOR_xvYCC_Range is supported only.
//!
//! \param [in]      displayId           Monitor Identifier.
//! \param [in,out]  colorRangeSetting   Color range settings.
//!
//! \retval ::NVAPI_OK - completed request
//! \retval ::NVAPI_ERROR - miscellaneous error occurred
//! \retval ::NVAPI_INVALID_ARGUMENT - Invalid input parameter
//! \retval ::NVAPI_NO_IMPLEMENTATION - API is not supported on the system
//! \retval ::NVAPI_API_NOT_INTIALIZED - NVAPI not initialized
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION - Structure version mismatch
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_GetWideColorRange(NvU32 displayId, NV_WIDE_COLOR_RANGE_SETTING *colorRangeSetting);



//! \ingroup vidcontrol
//! @{

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetVideoLinkParams
//
//! \fn NvAPI_GetVideoLinkParams(__in_opt NvDisplayHandle hNvDisplay, __in NvU32 outputId, __ inout NV_VIDEO_LINK_INFO* pVideoLinkInfo)
//!
//! DESCRIPTION:     This API receives content protection information
//!                  during video playback.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:      hNvDisplay(IN)      - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//!                                        This parameter is ignored when the outputId is a NvAPI displayId.
//!                  outputId(IN)        - This can either be the connection bit mask or the NvAPI displayId. When the legacy connection bit mask is passed, 
//!                                        it should have exactly 1 bit set to indicate a single display. If it's "0" then the default outputId from 
//!                                        NvAPI_GetAssociatedDisplayOutputId() will be used.
//!                  pVideoLinkInfo(OUT) - The supplied NV_VIDEO_LINK_INFO packet. 
//!
//! RETURN STATUS: 
//!                  NVAPI_OK - completed request
//!                  NVAPI_ERROR - miscellaneous error occurred
//!                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//
///////////////////////////////////////////////////////////////////////////////

typedef enum _NV_HDCP_STATUS_INFO 
{
    NV_HDCP_STATUS_INFO_AVAILABLE                               = 0x00000000, //!< Link (GPU + display) is HDCP-capable
    NV_HDCP_STATUS_INFO_UNAVAILABLE                             = 0x00000001, //!< Link not HDCP-capable
    NV_HDCP_STATUS_INFO_UNAVAILABLE_INVALID_DISPLAY_ID          = 0x00000002, //!< DisplayId does not match a digital (DVI/HDMI) connector
    NV_HDCP_STATUS_INFO_UNAVAILABLE_INVALID_DISPLAY             = 0x00000004, //!< Display is not HDCP-capable as reported by RM (may be independent of _INVALID_DISPLAY_ID)
    NV_HDCP_STATUS_INFO_UNAVAILABLE_INVALID_DISPLAY_MODE        = 0x00000008, //!< In clone/span mode
    NV_HDCP_STATUS_INFO_UNAVAILABLE_INVALID_GPU                 = 0x00000010, //!< GPU is not HDCP-capable as reported by RM
    NV_HDCP_STATUS_INFO_UNAVAILABLE_INVALID_GPU_MODE            = 0x00000020, //!< *NOT SUPPORTED, please remove option from CPL* 
    NV_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_UNTRUST               = 0x00000040, //!< Status signature did not match
    NV_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_LINK_FAILURES         = 0x00000080, //!< Abort due to repeated link failures
    NV_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_KSV_LENGTH            = 0x00000100, //!< Invalid key parameter passed by app
    NV_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_KSV_SIGNATURE         = 0x00000200, //!< Invalid key signature passed by app
    NV_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_SRM_SIGNATURE         = 0x00000400, //!< The player app looks suspicious
    NV_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_SRM_REVOKED           = 0x00000800, //!< Bad display due to revocation to carry HDCP content
    NV_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_REPEATER_NO_READY     = 0x00001000, //!< Repeater not ready
    NV_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_TOPOLOGY_ERROR        = 0x00002000, //!< Invalid topology for display devices' configuration
    NV_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_BAD_DISPLAY           = 0x00004000, //!< Invalid BKSV from display device
    NV_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_DEVICE_REVOKED        = 0x00008000, //!< Revoked device in multi stream topology
    NV_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_DEVICE_INVALID        = 0x00010000, //!< Invalid device in multi stream topology
    NV_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_HOP_LIMIT_EXCEEDED    = 0x00020000, //!< Number of device hops in multi stream topology exceeds supported limit    
    // additional HDCP-related codes
} NV_HDCP_STATUS_INFO;

typedef struct _NV_HDCP_LINK_STATUS
{
    NV_HDCP_STATUS_INFO     nvHdcpStatusInfo;           //!< One or more HDCP-related status codes         
    NvU64                   bRepeaterPresent    : 1;    //!< Has a repeater
    NvU64                   bDebuggerDetected   : 1;    //!< Debugger is present
    NvU64                   bHDCPOn             : 1;    //!< HDCP encryption is ON
    NvU64                   bReserved1          : 61;
    NvU64                   qwReserved2;
} NV_HDCP_LINK_STATUS;

typedef struct _NV_MACROVISION_STATUS
{
    NvU64   bMacrovisionOn      : 1; //!< Macrovision protection is ON
    NvU64   bReserved1          : 63;
    NvU64   qwReserved2;
} NV_MACROVISION_STATUS;

typedef struct _NV_VIDEO_LINK_INFO
{
    NvU32                   version;
    NV_HDCP_LINK_STATUS     hdcpStatus;         //!< (OUT)
    NV_MACROVISION_STATUS   macrovisionStatus;  //!< (OUT)
} NV_VIDEO_LINK_INFO;

//! macro for constructing the version field of ::NV_VIDEO_LINK_INFO
#define NV_VIDEO_LINK_INFO_VER  MAKE_NVAPI_VERSION(NV_VIDEO_LINK_INFO,1)

NVAPI_INTERFACE NvAPI_GetVideoLinkParams(__in_opt NvDisplayHandle hNvDisplay, __in NvU32 outputId, __inout NV_VIDEO_LINK_INFO* pVideoLinkInfo);





#define NV_WFD_MAC_LEN 6
#define NV_WFD_SSID_LEN 32

///// BEGIN WFD Spec version 1.43 /////

typedef enum _NV_RESOLUTION_SPEC
{
    NV_RESOLUTION_SPEC_UNKNOWN         = 0,
    NV_RESOLUTION_SPEC_VESA            = 1,
    NV_RESOLUTION_SPEC_CEA             = 2,
    NV_RESOLUTION_SPEC_HANDHELD        = 3,
} NV_RESOLUTION_SPEC;

typedef struct _NV_RESOLUTION_EX_V1
{
    NvU32   version;
    NvU32   width;
    NvU32   height;
    NvU32   colorDepth;
    NvU32   refreshRate;
    NvU16   isInterlaced:1;
    NvU16   isNative    :1;
    NvU16   is3D        :1;
    NvU16   reserved    :13;
    NV_RESOLUTION_SPEC originSpec;
} NV_RESOLUTION_EX_V1;

typedef NV_RESOLUTION_EX_V1   NV_RESOLUTION_EX;
#define NV_RESOLUTION_EX_VER1 MAKE_NVAPI_VERSION(NV_RESOLUTION_EX_V1,1)
#define NV_RESOLUTION_EX_VER  NV_RESOLUTION_EX_VER1

// WFD spec, section 5.1.5.5, Table 5-14: Profiles Bitmap
typedef struct _NV_WFD_PROFILE_BITMAP
{
    NvU8    CBPbit          :  1;   //!< when 1, constrained baseline profile is supported
    NvU8    CHPbit          :  1;   //!< when 1, constrained high profile is supported
    NvU8    reserved        :  6;   //!< must be zero
} NV_WFD_PROFILE_BITMAP;


// WFD spec, section 5.1.5.6, Table 5-15: Levels bitmap
typedef struct _NV_WFD_LEVELS_BITMAP
{
    NvU16    supportH264Level3_1    :  1;   //!< when 1, H.264 Level 3.1 supported
    NvU16    supportH264Level3_2    :  1;   //!< when 1, H.264 Level 3.2 supported
    NvU16    supportH264Level4      :  1;   //!< when 1, H.264 Level 4 supported
    NvU16    supportH264Level4_1    :  1;   //!< when 1, H.264 Level 4.1 supported
    NvU16    supportH264Level4_2    :  1;   //!< when 1, H.264 Level 4.2 supported
    NvU16    reserved               :  11;  //!< must be zero
} NV_WFD_LEVELS_BITMAP;

// WFD spec, section 5.1.5.7, Table 5-16: Slice Encoding parameters bitmap
typedef struct _NV_WFD_SLICE_ENCODING_INFO
{
    NvU32   maxSliceNumBits     : 10;   
    NvU32   maxSliceSizeRatio   :  3;
    NvU32   reserved            : 19;   //!< must be zero
} NV_WFD_SLICE_ENCODING_INFO;


// WFD spec, section 5.1.5.8, Table 5-17: Video Frame Rate Control Support Bitmap
typedef struct _NV_WFD_FRAME_RATE_CONTROL_INFO
{
    NvU16    supportVideoFrameSkipping   :  1;   // lsb
    NvU16    maxSkipInterval             :  3;
    NvU16    supportVideoFrameRateChange :  1;
    NvU16    reserved                    :  11;   // msb, must be zero
} NV_WFD_FRAME_RATE_CONTROL_INFO;


typedef struct _NV_WFD_VIDEO_FORMATS
{  
    NV_WFD_PROFILE_BITMAP          profileBitmap;
    NV_WFD_LEVELS_BITMAP           levelsBitmap;
    NvU32                          resolutionCount;
    NV_RESOLUTION_EX*              resolutions;
    NvU8                           latencyField;                   //!< WFD spec 5.1.5, retrieve via WFD Video Format subelement
    NvU16                          minSliceSize;                   //!< WFD spec 5.1.5, retrieve via WFD Video Format subelement
    NV_WFD_SLICE_ENCODING_INFO     sliceEncoding;
    NV_WFD_FRAME_RATE_CONTROL_INFO frameRateControl;
    NvU8                           supportPreferredDisplayMode  :1; //!< WFD spec, wfd-preferred-display-mode (6.1.14) and Preferred Display Mode (Chapter 8)
    NvU8                           reserved                     :7; //!< Reserved. Should be ZERO.
    NvU16                          maxWidth;                        //!< WFD spec 6.1.3, supportedPreferredDisplayMode is true
    NvU16                          maxHeight;                       //!< WFD spec 6.1.3, supportedPreferredDisplayMode is true
} NV_WFD_VIDEO_FORMATS;


// Nvidia WFD definition based on WFD spec section 6.1.5
typedef struct _NV_WFD_CONTENT_PROTECTION
{
    NvU32   hdcp2_0     :  1;   //!< WFD transition period only
    NvU32   hdcp2_1     :  1; 
    NvU32   reserved    : 30;   //!< must be zero
    NvU16   tcpPort;
} NV_WFD_CONTENT_PROTECTION;


// Nvidia WFD definition
typedef struct _NV_WFD_PROTOCOL_PARAM_V1
{
    NvU32   version;   
    NvU32   isVideoFormatsValid       :  1;
    NvU32   iscontentProtectionValid  :  1;
    NvU32   reserved                  : 30;
    NV_WFD_VIDEO_FORMATS           videoFormats;
    NV_WFD_CONTENT_PROTECTION      contentProtection;
} NV_WFD_PROTOCOL_PARAM_V1;

typedef NV_WFD_PROTOCOL_PARAM_V1   NV_WFD_PROTOCOL_PARAM;
#define NV_WFD_PROTOCOL_PARAM_VER1 MAKE_NVAPI_VERSION(NV_WFD_PROTOCOL_PARAM_V1,1)
#define NV_WFD_PROTOCOL_PARAM_VER  NV_WFD_PROTOCOL_PARAM_VER1

typedef struct _NV_WFD_DISPLAY_V1
{
    NvU32 version;                     

    union
    {
        NvU32   displayId;                      //!< Display Identifier of display. Used for NvAPI_DISP_ReportDisplayEvent during NV_DISPLAY_REQUEST_UNPLUG
        NvPhysicalGpuHandle   hPhysicalGPU;     //!< GPU Identifier. Used for NvAPI_DISP_ReportDisplayEvent during NV_DISPLAY_REQUEST_HOTPLUG
    };
    NvU8    MAC[NV_WFD_MAC_LEN];                //!< Unique identity of the WFD sink 
    NvU8    SSID[NV_WFD_SSID_LEN];              //!< Current SSID associated to the WiFi Group
    NvU32   sizeOfEdid;                         //!< size of edid
    NvU8*   edid;                               //!< Edid of the monitor. Only used for NvAPI_DISP_ReportDisplayEvent during NV_DISPLAY_REQUEST_HOTPLUG
    NV_WFD_PROTOCOL_PARAM protocolParams;       //!< WFD protocol params. Only used for NvAPI_DISP_ReportDisplayEvent during NV_DISPLAY_REQUEST_HOTPLUG

    NvU32   wfdFormatsProvided          : 1;    //!< if formats provided via 6.1.3 wfd-video-formats, 6.1.4 wfd-3d-formats 
    NvU32   reconstructEdid             : 1;    //!< if edid is missing (6.1.6 wfd-display-edid not supported) reconstruct edid via wfd-video-formats 
    NvU32   blockSingleView             : 1;    //!< disallow topology in singleview for this monitor 
    NvU32   blockCloneView              : 1;    //!< disallow topology in clonview for this monitor  
    NvU32   blockMultiView              : 1;    //!< disallow topology in multiview for this monitor 
    NvU32   blockMixedView              : 1;    //!< disallow topology with combination of clone and extended for this monitor 
    NvU32   checkOwnerProcessId         : 1;    //!< disallow unplug operations on monitors not owned by the process 
    NvU32   unplugConnectionOnOwnerExit : 1;    //!< unplug monitor when owner process exits 
    NvU32   refreshConnectionOnBoot     : 1;    //!< if true, remember the last hotplug state prior to reboot
    NvU32   refreshConnectionOnResume   : 1;    //!< if true, remember the last hotplug state prior to hibernate
    NvU32   reserved                    : 22;   //!< must be zero
} NV_WFD_DISPLAY_V1;

typedef NV_WFD_DISPLAY_V1   NV_WFD_DISPLAY;
#define NV_WFD_DISPLAY_VER1 MAKE_NVAPI_VERSION(NV_WFD_DISPLAY_V1,1)
#define NV_WFD_DISPLAY_VER  NV_WFD_DISPLAY_VER1

typedef struct _NV_WFD_DISP_INFO_V1
{
    NvU32   version;                  
    NvU32   maxOsVisibleWFDDisplays;  //!< [out]max number of WFD sinks that are visible to the OS; not necessarily active
    NvU32   maxOsActiveWFDDisplays;   //!< [out]max number of WFD sink that can be simultaneously active
    NvU32   wfdDisplaysCount;         //!< [in]number of wireless displays for which information is being asked
    NV_WFD_DISPLAY* wfdDisplays;      //!< [in-out]displayIds as input
} NV_WFD_DISP_INFO_V1;


typedef NV_WFD_DISP_INFO_V1   NV_WFD_DISP_INFO;
#define NV_WFD_DISP_INFO_VER1 MAKE_NVAPI_VERSION(NV_WFD_DISP_INFO_V1,1)
#define NV_WFD_DISP_INFO_VER  NV_WFD_DISP_INFO_VER1

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DISP_GetWFDDisplaysInfo
//
//! \fn NvAPI_DISP_GetWFDDisplaysInfo(__inout NV_WFD_DISP_INFO *wfdDisplaysInfo);
//! \code
//! DESCRIPTION:    This API gets information about wireless displays. To get display specific information, Caller is supposed to pass wfdDisplaysCount and 
//!                 displayIds of NV_WFD_DISPLAY. It will return information of all WFD displays whose displayId is passed.
//!                 DisplayId for WFD displays can be retrieved by NvAPI_GPU_GetConnectedDisplayIds.
//!                 
//!
//! SUPPORTED OS:  Windows 7
//!
//! \param [in,out]     wfdDisplaysInfo      pointer to NV_WFD_DISP_INFO
//! 
//! \return      This API can return any of the error codes enumerated in #NvAPI_Status.
//!              If there are return error codes with specific meaning for this API, they are listed below.
//!
//!
//! \ingroup dispcontrol 
//////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_GetWFDDisplaysInfo(__inout NV_WFD_DISP_INFO *wfdDisplaysInfo);




typedef enum _NV_DISP_REQUEST_TYPE
{
    NV_DISPLAY_REQUEST_UNKNOWN = 0,
    NV_DISPLAY_REQUEST_HOTPLUG,           //!< Hot-Plug Request
    NV_DISPLAY_REQUEST_UNPLUG,            //!< Unplug Request
}NV_DISP_REQUEST_TYPE;

typedef struct _NV_DISP_REQ_INFO_V1
{
    NvU32 version;                  
    NV_DISP_REQUEST_TYPE reqType;
    NvU32 isWFD    : 1;                 //!< if WFD display
    NvU32 reserved : 31;
    NV_WFD_DISPLAY wfdDisplay;          //!< if request is related to WFD display, this must be filled. Otherwise ignored.
} NV_DISP_REQ_INFO_V1;

typedef NV_DISP_REQ_INFO_V1   NV_DISP_REQ_INFO;
#define NV_DISP_REQ_INFO_VER1 MAKE_NVAPI_VERSION(NV_DISP_REQ_INFO_V1,1)
#define NV_DISP_REQ_INFO_VER  NV_DISP_REQ_INFO_VER1

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DISP_ReportDisplayEvent
//
//! \fn NvAPI_DISP_ReportDisplayEvent(__in NV_DISP_REQ_INFO *dispReqInfo);
//! \code
//! DESCRIPTION:    This API reports hot-plug, unplug event of display to driver with detailed info of display.To unplug, Caller needs to just
//!                 pass displayId of NV_WFD_DISPLAY. To hot-plug, caller needs to pass maciD, SSID, protocol etc except displayId.
//!
//! SUPPORTED OS:  Windows 7
//!
//! \param [in]  dispReqInfo      Properties of WFD displays with request type.
//! 
//! \return      This API can return any of the error codes enumerated in #NvAPI_Status.
//!              If there are return error codes with specific meaning for this API, they are listed below.
//!
//!
//! \ingroup dispcontrol 
//////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_ReportDisplayEvent(__in NV_DISP_REQ_INFO *dispReqInfo);




//! @}


//! \ingroup dispcontrol
//! Used in _NV_BPC_CONFIG
typedef enum _NV_BPC_CONFIG_CMD
{
    NV_BPC_CONFIG_CMD_GET = 0,        //!< get the current BPC configuration
    NV_BPC_CONFIG_CMD_SET             //!< set the new BPC configuration

}NV_BPC_CONFIG_CMD;

//! \ingroup dispcontrol
//! Used in NvAPI_DISP_BpcConfiguration().
typedef struct _NV_BPC_CONFIG_V1
{
    NvU32                   version;                   //!< (IN)     structure version
    NvU32                   displayId;                 //!< (IN)     the displayId of the monitor whose BPC config is being get or set
    NV_BPC_CONFIG_CMD       cmd;                       //!< (IN)     see :: _NV_BPC_CONFIG_CMD
    NvU32                   bpc;                       //!< (IN/OUT) the new/current scan out bits per component
    NvU32                   ditherOff :            1;  //!< (IN)     Force to turn the dither off. Valid for _CMD_SET only.
    NvU32                   forceAtCurLinkConfig : 1;  //!< (IN)     Force the depth change even if it is not supported at current link config - used for testing.
                                                       //!<          Valid for _CMD_SET only.
    NvU32                   forceRGDivMode :       1;  //!< (IN)     Force the hardware into RG Div mode - used for testing. Valid for _CMD_SET only.
}NV_BPC_CONFIG_V1;

#define NV_BPC_CONFIG_VER1  MAKE_NVAPI_VERSION(NV_BPC_CONFIG_V1,1)
#define NV_BPC_CONFIG_VER   NV_BPC_CONFIG_VER1

typedef NV_BPC_CONFIG_V1    NV_BPC_CONFIG;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DISP_BpcConfiguration
//
//!  DESCRIPTION: This API gets or set the BPC (Bits per Component) configuration
//!               for the display specified by the displayId input.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in,out] pNvBpcConfig  Pointer to the NV_BPC_CONFIG structure.
//!
//! \return     This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!             specific meaning for this API, they are listed below.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_DISP_BpcConfiguration(__inout NV_BPC_CONFIG *pNvBpcConfig);



//! \ingroup disphandle

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:	NvAPI_DISP_GetDisplayHandleFromDisplayId
//
//! DESCRIPTION:	This API maps a Display ID to the Display Handle of a display.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:     displayId(IN)		- Display ID assigned to a display selection.
//!					phNvDisplay(OUT)    - Pointer to display handle associated with the input displayId.
//!					
//!                  
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//! \endcode
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_DISP_GetDisplayHandleFromDisplayId(__in NvU32 displayId, __out NvDisplayHandle *phNvDisplay);


//! \ingroup disphandle

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:	NvAPI_DISP_GetDisplayIdFromDisplayHandle
//
//! DESCRIPTION:	This API maps a Display Handle to the Display ID of a display.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:     hNvDisplay(IN)	   - Display handle assigned to a display selection.
//!					pdisplayId(OUT)    - Pointer to display ID associated with the input hNvDisplay.
//!					
//!                  
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//! \endcode
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_DISP_GetDisplayIdFromDisplayHandle(__in NvDisplayHandle hNvDisplay, __out NvU32 *pDisplayId);

//! SUPPORTED OS:  Windows Vista and higher
//!

//! This enum could be extended in the future to support more request type.
typedef enum _NV_DP_REQUEST
{
    NV_DP_REQUEST_QSES
} NV_DP_REQUEST;

typedef enum _NV_DP_REQUEST_STATUS
{
    NV_DP_REQUEST_STATUS_PENDING = 0,
    NV_DP_REQUEST_STATUS_DONE = 1,
    NV_DP_REQUEST_STATUS_ERROR = 2,
    NV_DP_REQUEST_STATUS_NEWREQUEST = 3,
} NV_DP_REQUEST_STATUS;

typedef enum _NV_DP_STREAM_STATE
{
    NV_DP_STREAM_STATE_NOT_EXIST = 0,
    NV_DP_STREAM_STATE_INACTICE = 1,
    NV_DP_STREAM_STATE_ACTIVE = 2,
} NV_DP_STREAM_STATE;

typedef enum _NV_OUTPUT_SINK_TYPE
{
    NV_OUTPUT_SINK_TYPE_UNCONNECTED = 0,
    NV_OUTPUT_SINK_TYPE_NONEAUTH_LEGACY_DEVICE = 1,    //!< TV or CRT
    NV_OUTPUT_SINK_TYPE_NONE12CP_OR_NONQSE = 2,        //!< DVI/HDMI or DP 1.1 sink/repeater
    NV_OUTPUT_SINK_TYPE_DP_MST = 4
} NV_OUTPUT_SINK_TYPE;

typedef enum _NV_OUTPUT_CPTYPE
{
    NV_OUTPUT_CPTYPE_HDCP1x = 1,
    NV_OUTPUT_CPTYPE_HDCP2x = 2
} NV_OUTPUT_CPTYPE;

//! more info for this struct, refer to VESA DisplayPort Standard
typedef struct _NV_DP_REPLY_QSES
{
    NV_DP_STREAM_STATE      streamState;            //!< active or inactive
    NvU8                    repeaterFuncPresent;    //!< true, if The stream is directed to one or more outputs of the Branch device
    NvU8                    encryption;             //!< true, if encryting on
    NvU8                    authentication;         //!< true if stream completed all parts of authentication
    NV_OUTPUT_SINK_TYPE     sinkType;               //!< receiver type
    NV_OUTPUT_CPTYPE        cpType;                 //!< output type
    NvU8                    signedLPrime;           //!< true if signature L' is provided
    NvU8                    streamId;               //!< stream ID
    NvU8                    LPrime[20];             //!< L' signature
} NV_DP_REPLY_QSES;

typedef struct _NV_DP_REQUEST_HEADER
{
    NvU32                   requestSize;            //!< size of real requeset structure pointed by pRequest
    void                    *pRequest;              //!< request pointer
} NV_DP_REQUEST_HEADER;

//! Macro for constructing the version field of NV_DP_REQUEST_HEADER.
#define NV_DP_REQUEST_HEADER_VER1  MAKE_NVAPI_VERSION(NV_DP_REQUEST_HEADER,1)

typedef struct _NV_DP_STATUS_REQUEST_QSES
{
    NV_DP_REQUEST                   requestType;    //!< indicated what status to get, for DP    
    NvU32                           streamID;
    NV_DP_REPLY_QSES                reply;
} NV_DP_STATUS_REQUEST_QSES;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DISP_DP_QueryStatus
//
//! DESCRIPTION: This API is used to get display device status. The type of status to get is based on the arguments.
//!
//!              pRequest in a NV_DP_REQUEST_HEADER pointed by pRequestHeader should point to a NV_DP_STATUS_REQUEST_xxx
//!              structure. The requestSize in the NV_DP_REQUEST_HEADER structure should be sizeof(NV_DP_STATUS_REQUEST_xxx)
//!              
//! \param [in]         displayId             Display ID
//! \param [in,out]     pRequestHeader        pointer to request header structure
//!
//! \return    This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//!                              
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_DP_QueryStatus(__in NvU32 displayId, __inout NV_DP_REQUEST_HEADER *pRequestHeader);

//! SUPPORTED OS:  Windows Vista and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DISP_DP_GetStreamIDs
//
//! DESCRIPTION: This is API used to get DP device stream IDs. 
//!              
//!              The API should be called twice,
//!              first time with NULL for pStreamIds to get the total stream number pointed by pCount,
//!              and second time pass in the buffer pointer of minimum size sizeof(*pCount * sizeof(NvU32)).
//!
//!              For the second time call, the pCount should point to the number that indicates the maximum
//!              number of streams the buffer can hold. After API returns, the number pointed by pCount will
//!              indicated how many streamID has been put in the buffer, if the function succeeds. The return
//!              value should always be checked. If the function fails for NVAPI_INSUFFICIENT_BUFFER, the value
//!              pointed by pCount indicates the number of entry the buffer should hold.
//!
//! \param [in]             displayId           Display ID
//! \param [in,out,opt]     pStreamIds          pointer to streamID buffer
//! \param [in,out]         pCount              pointer to counter of entries
//!
//! \return    This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_DP_GetStreamIDs(__in NvU32 displayId, __inout_opt NvU32 *pStreamIds, __inout NvU32 *pCount);

//! SUPPORTED OS:  Windows 7 and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DISP_ApplyAndSaveCustomResolution
//
//! DESCRIPTION: This API is used to apply the given resolution directly on the specified display.
//!              
//!                 Currently this API is only supported on a virtualized platform.
//!                 The originSpec field in the NV_RESOLUTION_EX structure is ignored.
//!                 Minimum RefreshRate supported is 20Hz. If lower than 20Hz RefreshRate 
//!                 is specified, this API will override refreshRate to 20Hz
//!
//! \param [in]     displayId           Display ID
//! \param [in]     pResolution         pointer to NV_RESOLUTION_EX structure.
//!
//! \return    This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_ApplyAndSaveCustomResolution(__in NvU32 displayId, __in NV_RESOLUTION_EX *pResolution);

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_DISP_GetDisplayIdsInCluster
//
//! DESCRIPTION:    This API returns the set of Display Ids which comprise the cluster, whose representative display ID is passed as input.
//!
//! HOW TO USE: 1. The first call should be made to get the physical display ID count. To get the display ID count, send in 
//!                  a) clusterDisplayId     - a valid cluster representative's display Id as input.
//!					 b) clusterType          - a valid pointer to NV_CLUSTER_TYPE, whose value is set to ZERO.      
//!                  c) displayIdCount       - a valid pointer to NvU32, whose value is set to ZERO.                            
//!                  d) displayIds           - NULL, as we just want to get the display ID count.                 
//!                If all parameters are correct and this call is successful, this call will return the display ID's count and the cluster type. 
//!             2. To get the display ID array, make the second call to NvAPI_DISP_GetDisplayIdsInCluster() with   
//!                  a) clusterDisplayId     - a valid cluster representative's display Id as input.
//!                  b) clusterType          - a valid pointer to NV_CLUSTER_TYPE.                                  
//!                  c) displayIdCount       - a valid pointer to NvU32. This indicates for how many display IDs            
//!                                            the memory is allocated(displayIds) by the caller. 
//!                  d) displayIds           - pointer to the display ID array allocated by caller based on display ID count,   
//!                                            eg. malloc(sizeof(NvU32) * displayIdCount).                                             
//!                If all parameters are correct and this call is successful, this call will return the cluster type, display ID array 
//!                and actual display ID count (which was obtained in the first call to NvAPI_DISP_GetDisplayIdsInCluster).
//!                If the input display ID count is  less than the actual display ID count, it will overwrite the input and give the
//!                displayIdCount as actual count and the API will return NVAPI_INSUFFICIENT_BUFFER.
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]     clusterDisplayId  The representative display ID for which the underlying display IDs are requested.
//! \paran [out]    clusterType       This parameter will return the type of cluster the displays form.
//! \param [in,out] displayIdCount    As input, this parameter indicates the number of display's id's for which caller has 
//!                                   allocated the memory. As output, it will return the actual number of display IDs.
//! \param [out]    displayIds        Pointer to an array of NvU32 structure, each entry represents one displayID.
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \retval  NVAPI_INSUFFICIENT_BUFFER  When the input buffer(displayIds) is less than the actual number of display IDs, this API 
//!                                     will return NVAPI_INSUFFICIENT_BUFFER. 
//!
//! \ingroup dispcontrol
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_GetDisplayIdsInCluster(__in NvU32 clusterDisplayId, __out NV_CLUSTER_TYPE* clusterType, __inout NvU32* displayIdCount,  __out_ecount_part_opt(*displayIdCount, *displayIdCount) NvU32* displayIds);




#define NV_HYPER_SAMPLING_FLAG_CREATE_DESKTOP_RESOLUTION  0x00000001
typedef enum _NV_HYPER_SAMPLING_CMD
{
    NV_HYPER_SAMPLING_CREATE  = 1,
    NV_HYPER_SAMPLING_APPLY_SHARPNESS_ONLY  = 2, 
} NV_HYPER_SAMPLING_CMD;

typedef struct _NV_HYPER_SAMPLING_V1
{
    NvU32                           version;
    NvU32                           samplingFactorsCount;  //!< number of entries in samplingFactors
    NvU32                           *samplingFactors;     //!< Array of factor in multipleS of 10K to which native resolution of monitor is multiplied
    NvU32                           sharpness;           //!< sharpness in percentage. It will be same for all smooth sampling factors.
                                                     
} NV_HYPER_SAMPLING_V1;

typedef struct _NV_HYPER_SAMPLING_V2
{
    NvU32                           version;
    NvU32                           samplingFactorsCount;  //!< number of entries in samplingFactors and hyperSampledRes
    NvU32                           *samplingFactors;     //!< Array of factor in multipleS of 10K to which native resolution of monitor is multiplied
    NvU32                           sharpness;           //!< sharpness in percentage. It will be same for all smooth sampling factors.
    NV_RESOLUTION                   *hyperSampledRes;    //!< Array of width, height multipled by samplingFactor.
                                                         //!< bloated height/ width of samplingFcators[i] is at hyperSampledRes[i]. colordepth is 32 bit.
                                                         //!< only used in NvAPI_DISP_GetHyperSamplingSettings
} NV_HYPER_SAMPLING_V2;

#define NV_HYPER_SAMPLING_VER1  MAKE_NVAPI_VERSION(NV_HYPER_SAMPLING_V1,1)
#define NV_HYPER_SAMPLING_VER2  MAKE_NVAPI_VERSION(NV_HYPER_SAMPLING_V2,2)
#define NV_HYPER_SAMPLING_VER   NV_HYPER_SAMPLING_VER2

typedef NV_HYPER_SAMPLING_V2    NV_HYPER_SAMPLING;


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DISP_SetHyperSamplingSettings
//
//! DESCRIPTION: This API is used to enable smooth sampling. After successful return of API, native(max) resolution*sampling factor
//!              will be enabled on the display. 
//!              In case of cmd NV_HYPER_SAMPLING_APPLY_SHARPNESS, sharpness would be applied on all Hyper Sampling factors.
//!
//! \deprecated  Do not use this function - it is deprecated in release 346. Instead, use NvAPI_DISP_SetHyperSamplingSettingsEx.
//! SUPPORTED OS:  Windows Vista and higher
//!
//! \param [in]         displayId             display identifier. Ignored in case of cmd NV_HYPER_SAMPLING_APPLY_SHARPNESS.
//! \param [in]         cmd                   one of command of NV_HYPER_SAMPLING_CMD.
//! \param [in,out]     smoothSampling        NV_HYPER_SAMPLING
//! \param [in]         flag                  reserved for future use
//!
//! \return    This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//!  \retval ::NVAPI_SET_NOT_ALLOWED        - Either custom resolution is active or active sampling factor is getting removed.
//!                              
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 346. Instead, use NvAPI_DISP_SetHyperSamplingSettingsEx.")
NVAPI_INTERFACE NvAPI_DISP_SetHyperSamplingSettings(__in_opt NvU32 displayId, __in NV_HYPER_SAMPLING_CMD cmd, __inout NV_HYPER_SAMPLING hyperSampling, __in NvU32 *flag);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DISP_GetHyperSamplingSettings
//
//! DESCRIPTION: This API is used to get all Hyper sampling setting applied on the display. 
//!              
//! HOW TO USE: 1.make a call to NvAPI_DISP_GetHyperSamplingSettings to get the hyperSampling->hyperSamplingcount by passing the hyperSampling->samplingFactors as NULL. 
//!              On call success:
//!             2.Allocate memory (samplingFactorsCount * sizeof(NvU32)) then make a call NvAPI_DISP_GetHyperSamplingSettings to get hyperSampling info.
//!               Allocate memory (samplingFactorsCount * sizeof(NV_RESOLUTION)) to get multiplied hyperSampled resolutions
//!
//! \deprecated  Do not use this function - it is deprecated in release 346. Instead, use NvAPI_DISP_GetHyperSamplingSettingsEx.
//! SUPPORTED OS:  Windows Vista and higher
//!
//! \param [in]         displayId             display identifier. Ignored in case of cmd NV_HYPER_SAMPLING_APPLY_SHARPNESS_ONLY.
//! \param [in,out]     hyperSampling         pointer to NV_HYPER_SAMPLING
//! \param [in]         flag                  if flag  = NULL or  *flag = 0, API will return already created factors.
//!                                           if *flag = 1, API will return supported factors and recommended sharpness.   
//! \return    This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//!                              
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 346. Instead, use NvAPI_DISP_GetHyperSamplingSettingsEx.")
NVAPI_INTERFACE NvAPI_DISP_GetHyperSamplingSettings(__in_opt NvU32 displayId, __in_opt NV_HYPER_SAMPLING *hyperSampling, __in NvU32 *flag);


typedef struct _NV_HYPER_SAMPLING_EX_V3
{
    NvU32                           version;
    NvU32                           samplingFactorsCount;  //!< number of entries in pSamplingFactors and pHyperSampledRes
    NvU32                           *pSamplingFactors;     //!< Array of factor in multipleS of 10K to which native resolution of monitor is multiplied
    NvU32                           sharpness;             //!< sharpness in percentage. It will be same for all sampling factors.
    NV_RESOLUTION                   *pHyperSampledRes;     //!< Array of width, height multipled by samplingFactor.
                                                           //!< bloated height/ width of pSamplingFactors[i] is at pHyperSampledRes[i]. colordepth is 32 bit.
                                                           //!< only used in NvAPI_DISP_GetHyperSamplingSettingsEx
    NvU32                           flag;                  //!< one or more of NV_HYPER_SAMPLING_FLAG_XXXX. Currently used in NvAPI_DISP_GetHyperSamplingSettingsEx only
} NV_HYPER_SAMPLING_EX_V3;

typedef NV_HYPER_SAMPLING_V1    NV_HYPER_SAMPLING_EX_V1;
typedef NV_HYPER_SAMPLING_V2    NV_HYPER_SAMPLING_EX_V2;

#define NV_HYPER_SAMPLING_EX_VER1  NV_HYPER_SAMPLING_VER1
#define NV_HYPER_SAMPLING_EX_VER2  NV_HYPER_SAMPLING_VER2
#define NV_HYPER_SAMPLING_EX_VER3  MAKE_NVAPI_VERSION(NV_HYPER_SAMPLING_EX_V3,3)
#define NV_HYPER_SAMPLING_EX_VER   NV_HYPER_SAMPLING_EX_VER3

typedef NV_HYPER_SAMPLING_EX_V3    NV_HYPER_SAMPLING_EX;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DISP_SetHyperSamplingSettingsEx
//
//! DESCRIPTION: This API is used to enable hyper sampling. After successful return of API, native(max) resolution*sampling factor
//!              will be enabled on the display. 
//!              In case of cmd NV_HYPER_SAMPLING_APPLY_SHARPNESS, sharpness would be applied on all Hyper Sampling factors.
//! SUPPORTED OS:  Windows Vista and higher
//!
//! \param [in]         displayId             display identifier. Ignored in case of cmd NV_HYPER_SAMPLING_APPLY_SHARPNESS.
//! \param [in]         cmd                   one of command of NV_HYPER_SAMPLING_CMD.
//! \param [in,out]     pHyperSampling        pointer to NV_HYPER_SAMPLING_EX
//!
//! \return    This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//!  \retval ::NVAPI_SET_NOT_ALLOWED        - Either custom resolution is active or active sampling factor is getting removed.
//!                              
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_SetHyperSamplingSettingsEx(__in_opt NvU32 displayId, __in NV_HYPER_SAMPLING_CMD cmd, __inout NV_HYPER_SAMPLING_EX *pHyperSampling);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DISP_GetHyperSamplingSettingsEx
//
//! DESCRIPTION: This API is used to get all Hyper sampling setting applied on the display. 
//!              
//! HOW TO USE: 1.make a call to NvAPI_DISP_GetHyperSamplingSettingsEx to get the hyperSampling->hyperSamplingcount by passing the hyperSampling->pSamplingFactors as NULL. 
//!              On call success:
//!             2.Allocate memory (samplingFactorsCount * sizeof(NvU32)) then make a call NvAPI_DISP_GetHyperSamplingSettingsEx to get hyperSampling info.
//!               Allocate memory (samplingFactorsCount * sizeof(NV_RESOLUTION)) to get multiplied hyperSampled resolutions
//! SUPPORTED OS:  Windows Vista and higher
//!
//! \param [in]         displayId             display identifier. Ignored in case of cmd NV_HYPER_SAMPLING_APPLY_SHARPNESS_ONLY.
//! \param [in,out]     pHyperSampling        pointer to NV_HYPER_SAMPLING_EX
//! \param [in]         flag                  if flag = 0, API will return already created factors.
//!                                           if flag = 1, API will return supported factors and recommended sharpness.   
//! \return    This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//!                              
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_GetHyperSamplingSettingsEx(__in_opt NvU32 displayId, __in_opt NV_HYPER_SAMPLING_EX *pHyperSampling, __in NvU32 flag);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DISP_SetOculusZoomFactor
//
//! DESCRIPTION: This API is used to set the Oculus zoom factor used in source warping so the cursor position can be adjusted accordingly. 
//!              
//! SUPPORTED OS:  Windows 7 and higher
//!
//! \param [in]         displayId             display identifier of the active Oculus device.
//! \param [in]         fZoom                 the zoom factor
//!
//! \return    This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//!                              
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_SetOculusZoomFactor(__in NvU32 displayId, __in float fZoom);


typedef struct
{
    NvU64 timeStamp;   //!< timestamp based on ptimer at each dmi interrupt
    NvU32 ctxDmaAddr0; //!< base ctxdma pointer to analyse stutter
    NvU32 ctxDmaAddr1; //!< base ctxdma1 pointer to analyse stereo case stutter
} SCANOUTLOGGING;

typedef enum
{
    NV_SCANOUT_LOGGING_DISABLE = 0, //!< Request to disable logging and de-allocate RM buffer
    NV_SCANOUT_LOGGING_ENABLE  = 1, //!< Request to allocate RM buffer of size and start logging
    NV_SCANOUT_LOGGING_GET     = 2  //!< Pass the pointer of type SCANOUTLOGGING to copy logged data
} NV_SCANOUT_LOGGING_CMD;

typedef struct _NV_SCANOUT_LOGGING
{
    NvU32                   version;            //!< structure version
    NvU32                   displayId;          //!< (IN)Monitor Identifier
    void                    *pLoggingAddr;      //!< (IN/OUT)address at which logged data will be copied
    NvU32                   size;               //!< (IN)number of data to be logged
    NvU32                   verticalScanline;   //!< (IN)vertical scanline to configure DMI intr
    NV_SCANOUT_LOGGING_CMD  cmd;                //!< (IN)command to enable/disable/get/reset logging
    NvU8                    bFreeBuffer;        //!< (IN)flag to free allocated buffer during disable cmd
    NvU8                    bUseRasterLineIntr; //!< (IN )1 to use RG line and 0 to use DMI line intr
    NvU8                    bCaptureCRC;        //!< (IN)1 to log CRC and 0 to log ctxdma1
} NV_SCANOUT_LOGGING_V1;

#define NV_SCANOUT_LOGGING_VER1  MAKE_NVAPI_VERSION(NV_SCANOUT_LOGGING_V1,1)
#define NV_SCANOUT_LOGGING_VER   NV_SCANOUT_LOGGING_VER1

typedef NV_SCANOUT_LOGGING_V1 NV_SCANOUT_LOGGING;
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DISP_ScanoutLogging
//
//! DESCRIPTION: This API is used for Stutter analysis using scanout data
//! User has to allocate buffer of type SCANOUTLOGGING structure and pass count
//! of number of logged data need to be caputred by RM in "size" field of 
//! structure NV_SCANOUT_LOGGING
//! valid command seq : ENABLE, DISABLE (flag not to free buffer), GET
//!                     ENABLE, GET, DISABLE (flag to free buffer)
//! Note: After GET command, if relogging is required then must send ENABLE command
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//! \param [inout]         pScanoutLogging             Pointer to NV_SCANOUT_LOGGING
//!
//! \return    This API can return any of the error codes enumerated in #NvAPI_Status. 
//!                              
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_ScanoutLogging(__inout NV_SCANOUT_LOGGING *pScanoutLogging);


typedef enum
{
    NV_DP_FULL_LT_STATS = 0,
    NV_DP_FAST_LT_STATS = 1,
    NV_DP_NO_LT_STATS   = 2
}NV_DP_LT_TYPE_FLAG;

typedef enum
{
    NV_DP_RESET_LT_STATS = 0,
    NV_DP_GET_LT_STATS   = 1
}NV_DP_LT_STATS_CMD;

typedef struct _NV_DP_LT_STATS
{
    NvU32              version;
    NvU32              displayId;
    NV_DP_LT_TYPE_FLAG flag;
    NV_DP_LT_STATS_CMD cmd;
    NvU32              dpLTSuccess;
    NvU32              dpLTFailure;
    NvU64              dpMinTimeMicroSec;
    NvU64              dpMaxTimeMicroSec;
    NvU64              dpAvgTimeMicroSec;
} NV_DP_LT_STATS_V1;

#define NV_DP_LT_STATS_VER1  MAKE_NVAPI_VERSION(NV_DP_LT_STATS_V1,1)
#define NV_DP_LT_STATS_VER   NV_DP_LT_STATS_VER1

typedef NV_DP_LT_STATS_V1 NV_DP_LT_STATS;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DISP_LTStats
//
//! DESCRIPTION: This API is used to get/reset Link training stats
//! (NLT, Fast LT, Full LT). 
//!              
//! SUPPORTED OS:  Windows 7 and higher
//!
//! \param [in]         pDpLaneConfig  Pointer to NV_DP_LT_STATS structure.
//!
//! \return    This API can return any of the error codes enumerated in #NvAPI_Status. 
//! If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//!                              
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_LTStats(__inout NV_DP_LT_STATS *pDpLTStats);


typedef enum _NV_SR_ENTER_EXIT_STATS_MODE
{
    NV_SR_STATS_SPARSE_MODE   = 0,    //!< stats for sparse mode
    NV_SR_STATS_BURST_MODE    = 1     //!< stats for burst mode
} NV_SR_ENTER_EXIT_STATS_MODE;

typedef struct _SR_STATS
{
    NvU64   minTimeMicroSec;  //!< (OUT) min time for SR entry/exit
    NvU64   maxTimeMicroSec;  //!< (OUT) max time of SR entry/exit
    NvU64   avgTimeMicroSec;  //!< (OUT) average time SR entry/exit
}SR_STATS;

typedef struct _NV_SR_GET_STATS
{
    NvU32                         version;          //!< (IN) structure version
    NvU32                         displayId;        //!< (IN) the displayId of the monitor
    NV_SR_ENTER_EXIT_STATS_MODE   mode;             //!< (IN) see :: _NV_SR_ENTER_EXIT_STATS_MODE
    SR_STATS                      SREnterStats;     //!< (OUT) see :: _SR_STATS
    SR_STATS                      SRExitStats;      //!< (OUT) see :: _SR_STATS
} NV_SR_GET_STATS_V1;

#define NV_SR_GET_STATS_VER1  MAKE_NVAPI_VERSION(NV_SR_GET_STATS_V1,1)
#define NV_SR_GET_STATS_VER   NV_SR_GET_STATS_VER1

typedef NV_SR_GET_STATS_V1 NV_SR_GET_STATS;
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DISP_SR_GET_LATENCY_STATS
//
//! DESCRIPTION: This API is used to get SR entry/exit stats
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//! \param [inout]         pSRGetStats             Pointer to NV_SR_GET_STATS
//!
//! \return    This API can return any of the error codes enumerated in #NvAPI_Status. 
//!                              
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_SR_GET_LATENCY_STATS(__inout NV_SR_GET_STATS *pSRGetStats);


typedef struct _NV_SR_RESET_STATS
{
    NvU32                         version;    //!< (IN) structure version
    NvU32                         displayId;  //!< (IN) the displayId of the monitor
    NV_SR_ENTER_EXIT_STATS_MODE   mode;       //!< (IN) see :: _NV_SR_ENTER_EXIT_STATS_MODE
} NV_SR_RESET_STATS_V1;

#define NV_SR_RESET_STATS_VER1  MAKE_NVAPI_VERSION(NV_SR_RESET_STATS_V1,1)
#define NV_SR_RESET_STATS_VER   NV_SR_RESET_STATS_VER1

typedef NV_SR_RESET_STATS_V1 NV_SR_RESET_STATS;
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DISP_SR_RESET_LATENCY_STATS
//
//! DESCRIPTION: This API is used to reset SR entry/exit stats
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//! \param [inout]         pSRResetStats             Pointer to NV_SR_RESET_STATS
//!
//! \return    This API can return any of the error codes enumerated in #NvAPI_Status. 
//!                              
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_SR_RESET_LATENCY_STATS(__inout NV_SR_RESET_STATS *pSRResetStats);

#define NV_DP_MAX_MSG_SIZE     16

typedef struct
{
    NvU32    auxEvents;                                 //!< Indicates the kind of events(native/hotplug/irq)
    NvU32    auxRequestTimeStamp;                       //!< Request timestamp in nanoseconds
    NvU32    auxMessageReqSize;                         //!< Expected aux reply size
    NvU32    auxMessageReplySize;                       //!< Actual aux reply size 
    NvU32    auxOutPort;                                //!< DP port number 
    NvU32    auxPortAddress;                            //!< Aux transaction address
    NvU32    auxReplyTimeStamp;                         //!< Reply time stamp in nanoseconds
    NvU32    auxSerialNo;                               //!< Serial no of the transaction
    NvU8     auxPacket[NV_DP_MAX_MSG_SIZE];             //!< Array holds aux transaction packet
}NV_DP_AUX_PACKET;

typedef struct
{
    NvU32                 version;                      //!< Structure version 
    NV_DP_AUX_PACKET      auxPacket;                    //!< aux packet buffer to hold aux packet data
}NV_DP_AUX_DATA_V1;

#define NV_DP_AUX_DATA_VER1   MAKE_NVAPI_VERSION(NV_DP_AUX_DATA_V1,1)
#define NV_DP_AUX_DATA_VER    NV_DP_AUX_DATA_VER1

typedef NV_DP_AUX_DATA_V1     NV_DP_AUX_DATA;

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DP_ReadAuxLogger
//
//!   DESCRIPTION:  This API retrieves the number of logs requested from auxlogger in RM.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! 
//! \param [in]     hPhysicalGpu
//! \param [in]     auxloggerReadSize           Number of logs to be retrieved from auxlogger(Max 150)
//! \param [out]    numLogsRetrieved            Number of logs actually retrieved from auxlogger
//! \param [out]    auxloggerAppBuffer          Target buffer pointer passed from the Auxlogger app
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval  NVAPI_OK         Completed request
//!
//! \ingroup dp_auxlogger
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DP_ReadAuxLogger(__in NvU32 hPhysicalGpu, __in NvU32 auxloggerReadSize, __out NvU32 *numLogsRetrieved, __out NV_DP_AUX_PACKET *auxloggerAppBuffer);   


#define NV_VRR_GPU_NO_SUPPORT                                  NV_BIT(0)
#define NV_VRR_DISPLAY_NO_SUPPORT                              NV_BIT(1)
#define NV_VRR_CURRENT_DISPLAY_SETTINGS_NO_SUPPORT             NV_BIT(2)
#define NV_VRR_MODE_DISABLED                                   NV_BIT(3)

typedef enum _NV_VRR_MODE
{
    NV_VRR_MODE_NOT_SUPPORTED               = 0,        //!< VRR not supported
    NV_VRR_MODE_FULLSCREEN_ONLY             = 1,        //!< VRR supported only in fullscreen
    NV_VRR_MODE_FULLSCREEN_AND_WINDOWED     = 2,        //!< VRR supported in fullscreen and windowed mode
} NV_VRR_MODE;

typedef struct _NV_VRR_SETTINGS
{
    NvU32                 version;                      //!< Structure version 

    NV_VRR_MODE           currentSupportedMode;         //!< The current VRR mode supported
    NvU32                 problemFlags;                 //!< The problem flags when currentSupportedMode is NV_VRR_MODE_NOT_SUPPORTED
}NV_VRR_SETTINGS_V1;

#define NV_VRR_SETTINGS_VER1   MAKE_NVAPI_VERSION(NV_VRR_SETTINGS_V1,1)
#define NV_VRR_SETTINGS_VER    NV_VRR_SETTINGS_VER1

typedef NV_VRR_SETTINGS_V1     NV_VRR_SETTINGS;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DISP_GetCurrentVRRSettings
//
//! DESCRIPTION: This API is used to get the current VRR capabilities and settings.
//!              
//! SUPPORTED OS:  Windows 7 and higher
//!
//! \param [in]         displayId             display identifier of the display device.
//! \param [in]         pVRRSettings          pointer to structure which will contain current VRR settings after the call
//!
//! \return    This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//!                              
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_GetCurrentVRRSettings(__in NvU32 displayId, __inout NV_VRR_SETTINGS *pVRRSettings);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DISP_EnableDirectMode
//
//!   DESCRIPTION:  This API enables the Direct mode on the specified display
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! 
//! \param [in]     vendorId         Vendor Id of the target VR solution                
//! \param [in]     reserved         Reserved for future use
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_EnableDirectMode(__in NvU32  vendorId, __in NvU32 reserved);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DISP_DisableDirectMode
//
//!   DESCRIPTION:  This API disables the Direct mode on the specified display
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! 
//! \param [in]     vendorId         Vendor Id of the target VR solution
//! \param [in]     reserved         Reserved for future use
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_DisableDirectMode(__in NvU32  vendorId, __in NvU32 reserved);

typedef struct _NV_DIRECT_MODE_DISPLAY_HANDLE
{
    NvU32   displayId;              //!< DisplayId of the VR Headset
    void*   pDisplayContext;        //!< IHV's VR display context
} NV_DIRECT_MODE_DISPLAY_HANDLE;

typedef enum _NV_ENUM_DIRECTMODE_DISPLAY_FLAG
{
    NV_ENUM_DIRECTMODE_DISPLAY_CAPABLE = 0,     //!< Used to enumerate all VR capable displays for a given vendorId
    NV_ENUM_DIRECTMODE_DISPLAY_ENABLED          //!< Used to enumerate all VR displays in DirectMode for a given vendorId
} NV_ENUM_DIRECTMODE_DISPLAY_FLAG;

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DISP_EnumerateDirectModeDisplays
//
//!   DESCRIPTION:  This API disables the Direct mode on the specified display
//!
//! HOW TO USE: 1) For a given vendor Id, make a call to get the number of DirectMode display handles
//!                using NvAPI_DISP_EnumerateDirectModeDisplays by passing the phDisplay as NULL
//!                On call success:
//!             2) Allocate memory based on pNumDisplays then make a call NvAPI_GPU_GetConnectedDisplayIds to populate DirectMode display handles
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! 
//! \param [in]     vendorId     - Vendor Id of the target VR solution
//! \param [in,out] pNumDisplays - IN -> Number of entries in the phDisplay array.
//!                              - OUT -> Number of actual displayHandles in the system
//! \param [in,out] phDisplay    - Pointer to an NV_DIRECT_MODE_DISPLAY_HANDLE struct, each entry represents a one display handle
//! \param [in]     flags        - A value from NV_ENUM_DIRECTMODE_DISPLAY_FLAG. 
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval  NVAPI_INSUFFICIENT_BUFFER  When the input buffer(phDisplay)'s size(*pNumDisplays) is less than the available displays. 
//!                                     The *pNumDisplays will return the actual available displays count.
//!
//! \retval  NVAPI_INVALID_ARGUMENT     When phDisplay is NULL and *pNumDisplays > 0, then this error is returned.
//!
//! \ingroup disphandle
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_EnumerateDirectModeDisplays(__in NvU32 vendorId, __inout NvU32 *pNumDisplays, __inout_opt NV_DIRECT_MODE_DISPLAY_HANDLE *phDisplay, __in NV_ENUM_DIRECTMODE_DISPLAY_FLAG flag);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:	NvAPI_DISP_GetDisplayHandleFromDisplayId
//
//! DESCRIPTION:	This API maps a Display ID to the Display Handle of a display.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]     displayId	- Display Id assigned to a display selection.
//!	\param [out]    phNvDisplay - Pointer to display handle associated with the input displayId.
//!					
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \ingroup disphandle
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_GetDirectModeDisplayHandleFromDisplayId(__in NvU32 displayId, __out NV_DIRECT_MODE_DISPLAY_HANDLE *phNvDisplay);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:	NvAPI_DISP_GetDisplayIdFromDisplayHandle
//
//! DESCRIPTION:	This API maps a Display Handle to the Display ID of a display.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]    phNvDisplay	 - Display handle assigned to a display selection.
//!	\param [out]   pDisplayId    - Pointer to display ID associated with the input hNvDisplay.
//!					
//!                  
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \ingroup disphandle
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_GetDisplayIdFromDirectModeDisplayHandle(__in NV_DIRECT_MODE_DISPLAY_HANDLE* phNvDisplay, __out NvU32 *pDisplayId);


typedef enum _NV_DIRECTMODE_DISPLAY_CONTROL
{
    NV_DM_DISPLAY_CONTROL_POWER_ON,
    NV_DM_DISPLAY_CONTROL_POWER_OFF,
    NV_DM_DISPLAY_CONTROL_VISIBILITY_ON,
    NV_DM_DISPLAY_CONTROL_VISIBILITY_OFF

} NV_DIRECTMODE_DISPLAY_CONTROL;

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:	NvAPI_DISP_DirectModeDisplayControl
//
//! DESCRIPTION:	This API can be used to control the defined features of a Direct Mode Display.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]   phNvDisplay	 - Display handle assigned to a display selection.
//!	\param [in]   dispControl    - One of the NV_DIRECTMODE_DISPLAY_CONTROL values.
//!					
//!                  
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \ingroup disphandle
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_DirectModeDisplayControl(__in NV_DIRECT_MODE_DISPLAY_HANDLE* phNvDisplay, __in NV_DIRECTMODE_DISPLAY_CONTROL dispControl);


NV_DECLARE_HANDLE(NvNotifyHandle);      //!< A handle to a waitable object

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DISP_DirectModeGetVSyncWaitableObject
//
//! DESCRIPTION:   This API returns a waitable object that gets signalled on every VSync. Typically on Windows,  
//!                this is a HANDLE to an auto reset event.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]  phNvDisplay  - Display handle assigned to a display selection whose VSync events are of interest.
//! \param [out] phEvent      - Handle to a waitable event object. On Windows, clients can use this in a WaitForSingleObject() function
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//!  NVAPI_INVALID_CONFIGURATION : NvAPI_D3D_AcquireDirectModeDisplay has not been called on the input display  
//!
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_DirectModeGetVSyncWaitableObject(__in NV_DIRECT_MODE_DISPLAY_HANDLE* phNvDisplay, __out NvNotifyHandle* phEvent);

//! \ingroup dispcontrol
//! Used in NvAPI_DISP_GetIFlipStateByDisplayName(). 
typedef struct 
{
    NvU32   version;
    NvU8    bDirectFlipCapable;
    NvU8    bIsInIFlipMode;
} NV_DISP_IFLIP_STATE, *PNV_DISP_IFLIP_STATE;

#define NV_DISP_IFLIP_STATE_VER   MAKE_NVAPI_VERSION(NV_DISP_IFLIP_STATE,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_DISP_GetIFlipStateByDisplayName
//
//! DESCRIPTION:     This API retrieves the info w.r.t. Iflip of a given display:
//                      - Whether the display is capable of Iflip
//                      - Whether the display is currently in Iflip state
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]     displayName  Name of display
//! \param [out]    pIFlipMode   IFlip mode for the display
//!
//! retval ::NVAPI_OK:                          IFlip state has been returned.
//! retval ::NVAPI_INVALID_POINTER:             Pointer passed in not valid.
//! retval ::NVAPI_API_NOT_INTIALIZED:          The NvAPI API needs to be initialized first
//! retval ::NVAPI_NO_IMPLEMENTATION:           This entrypoint not available
//! retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION  Struct has Incompatible version
//! retval ::NVAPI_ERROR:                       Miscellaneous error occurred
//!
//! \ingroup dispcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DISP_GetIFlipStateByDisplayName(const char *displayName, PNV_DISP_IFLIP_STATE pIFlipState);



////////////////////////////////////////////////////////////////////////////////////////
//
// MOSAIC allows a multi display target output scanout on a single source. 
//
// SAMPLE of MOSAIC 1x4 topo with 8 pixel horizontal overlap
//
//+-------------------------++-------------------------++-------------------------++-------------------------+
//|                         ||                         ||                         ||                         |
//|                         ||                         ||                         ||                         |
//|                         ||                         ||                         ||                         |
//|        DVI1             ||           DVI2          ||         DVI3            ||          DVI4           |
//|                         ||                         ||                         ||                         |
//|                         ||                         ||                         ||                         |
//|                         ||                         ||                         ||                         |
//|                         ||                         ||                         ||                         |
//+-------------------------++-------------------------++-------------------------++-------------------------+


//! \addtogroup mosaicapi
//! @{

#define NVAPI_MAX_MOSAIC_DISPLAY_ROWS       8
#define NVAPI_MAX_MOSAIC_DISPLAY_COLUMNS    8
#define NV_MOSAIC_MAX_DISPLAYS      (64)
//
// These bits are used to describe the validity of a topo.
//
#define NV_MOSAIC_TOPO_VALIDITY_VALID               0x00000000  //!< The topology is valid
#define NV_MOSAIC_TOPO_VALIDITY_MISSING_GPU         0x00000001  //!< Not enough SLI GPUs were found to fill the entire
                                                                //! topology. hPhysicalGPU will be 0 for these.
#define NV_MOSAIC_TOPO_VALIDITY_MISSING_DISPLAY     0x00000002  //!< Not enough displays were found to fill the entire
                                                                //! topology. displayOutputId will be 0 for these.
#define NV_MOSAIC_TOPO_VALIDITY_MIXED_DISPLAY_TYPES 0x00000004  //!< The topoogy is only possible with displays of the same
                                                                //! NV_GPU_OUTPUT_TYPE. Check displayOutputIds to make
                                                                //! sure they are all CRTs, or all DFPs.


//
//! This structure defines the topology details.
typedef struct 
{
    NvU32                version;              //!< Version of this structure
    NvLogicalGpuHandle   hLogicalGPU;          //!< Logical GPU for this topology 
    NvU32                validityMask;         //!< 0 means topology is valid with the current hardware.
                                               //! If not 0, inspect bits against NV_MOSAIC_TOPO_VALIDITY_*.
    NvU32                rowCount;             //!< Number of displays in a row
    NvU32                colCount;             //!< Number of displays in a column

    struct 
    {
        NvPhysicalGpuHandle hPhysicalGPU;      //!< Physical GPU to be used in the topology (0 if GPU missing)
        NvU32               displayOutputId;   //!< Connected display target (0 if no display connected)
        NvS32               overlapX;          //!< Pixels of overlap on left of target: (+overlap, -gap)
        NvS32               overlapY;          //!< Pixels of overlap on top of target: (+overlap, -gap)

    } gpuLayout[NVAPI_MAX_MOSAIC_DISPLAY_ROWS][NVAPI_MAX_MOSAIC_DISPLAY_COLUMNS];

} NV_MOSAIC_TOPO_DETAILS;

//! Macro for constructing te vesion field of NV_MOSAIC_TOPO_DETAILS
#define NVAPI_MOSAIC_TOPO_DETAILS_VER         MAKE_NVAPI_VERSION(NV_MOSAIC_TOPO_DETAILS,1)


//
//! These values refer to the different types of Mosaic topologies that are possible.  When
//! getting the supported Mosaic topologies, you can specify one of these types to narrow down
//! the returned list to only those that match the given type.
typedef enum
{
    NV_MOSAIC_TOPO_TYPE_ALL,                          //!< All mosaic topologies
    NV_MOSAIC_TOPO_TYPE_BASIC,                        //!< Basic Mosaic topologies
    NV_MOSAIC_TOPO_TYPE_PASSIVE_STEREO,               //!< Passive Stereo topologies
    NV_MOSAIC_TOPO_TYPE_SCALED_CLONE,                 //!< Not supported at this time
    NV_MOSAIC_TOPO_TYPE_PASSIVE_STEREO_SCALED_CLONE,  //!< Not supported at this time
    NV_MOSAIC_TOPO_TYPE_MAX,                          //!< Always leave this at end of the enum
} NV_MOSAIC_TOPO_TYPE;


//
//! This is a complete list of supported Mosaic topologies.
//!
//! Using a "Basic" topology combines multiple monitors to create a single desktop.
//!
//! Using a "Passive" topology combines multiples monitors to create a passive stereo desktop.
//! In passive stereo, two identical topologies combine - one topology is used for the right eye and the other identical //! topology (targeting different displays) is used for the left eye.  \n  
//! NOTE: common\inc\nvEscDef.h shadows a couple PASSIVE_STEREO enums.  If this
//!       enum list changes and effects the value of NV_MOSAIC_TOPO_BEGIN_PASSIVE_STEREO
//!       please update the corresponding value in nvEscDef.h
typedef enum
{
    NV_MOSAIC_TOPO_NONE,

    // 'BASIC' topos start here
    //
    // The result of using one of these Mosaic topos is that multiple monitors
    // will combine to create a single desktop.
    //
    NV_MOSAIC_TOPO_BEGIN_BASIC,
    NV_MOSAIC_TOPO_1x2_BASIC = NV_MOSAIC_TOPO_BEGIN_BASIC,
    NV_MOSAIC_TOPO_2x1_BASIC,
    NV_MOSAIC_TOPO_1x3_BASIC,
    NV_MOSAIC_TOPO_3x1_BASIC,
    NV_MOSAIC_TOPO_1x4_BASIC,
    NV_MOSAIC_TOPO_4x1_BASIC,
    NV_MOSAIC_TOPO_2x2_BASIC,
    NV_MOSAIC_TOPO_2x3_BASIC,
    NV_MOSAIC_TOPO_2x4_BASIC,
    NV_MOSAIC_TOPO_3x2_BASIC,
    NV_MOSAIC_TOPO_4x2_BASIC,
    NV_MOSAIC_TOPO_1x5_BASIC,
    NV_MOSAIC_TOPO_1x6_BASIC,
    NV_MOSAIC_TOPO_7x1_BASIC,

    // Add padding for 10 more entries. 6 will be enough room to specify every
    // possible topology with 8 or fewer displays, so this gives us a little
    // extra should we need it.
    NV_MOSAIC_TOPO_END_BASIC = NV_MOSAIC_TOPO_7x1_BASIC + 9,

    // 'PASSIVE_STEREO' topos start here
    //
    // The result of using one of these Mosaic topos is that multiple monitors
    // will combine to create a single PASSIVE STEREO desktop.  What this means is
    // that there will be two topos that combine to create the overall desktop.
    // One topo will be used for the left eye, and the other topo (of the
    // same rows x cols), will be used for the right eye.  The difference between
    // the two topos is that different GPUs and displays will be used.
    //
    NV_MOSAIC_TOPO_BEGIN_PASSIVE_STEREO,    // value shadowed in nvEscDef.h
    NV_MOSAIC_TOPO_1x2_PASSIVE_STEREO = NV_MOSAIC_TOPO_BEGIN_PASSIVE_STEREO,
    NV_MOSAIC_TOPO_2x1_PASSIVE_STEREO,
    NV_MOSAIC_TOPO_1x3_PASSIVE_STEREO,
    NV_MOSAIC_TOPO_3x1_PASSIVE_STEREO,
    NV_MOSAIC_TOPO_1x4_PASSIVE_STEREO,
    NV_MOSAIC_TOPO_4x1_PASSIVE_STEREO,
    NV_MOSAIC_TOPO_2x2_PASSIVE_STEREO,
    NV_MOSAIC_TOPO_END_PASSIVE_STEREO = NV_MOSAIC_TOPO_2x2_PASSIVE_STEREO + 4,


    //
    // Total number of topos.  Always leave this at the end of the enumeration.
    //
    NV_MOSAIC_TOPO_MAX  //! Total number of topologies.

} NV_MOSAIC_TOPO;


//
//! This is a "topology brief" structure.  It tells you what you need to know about
//! a topology at a high level. A list of these is returned when you query for the
//! supported Mosaic information.
//!
//! If you need more detailed information about the topology, call
//! NvAPI_Mosaic_GetTopoGroup() with the topology value from this structure.
typedef struct 
{
    NvU32                        version;            //!< Version of this structure
    NV_MOSAIC_TOPO               topo;               //!< The topology
    NvU32                        enabled;            //!< 1 if topo is enabled, else 0
    NvU32                        isPossible;         //!< 1 if topo *can* be enabled, else 0

} NV_MOSAIC_TOPO_BRIEF;

//! Macro for constructing the version field of NV_MOSAIC_TOPO_BRIEF
#define NVAPI_MOSAIC_TOPO_BRIEF_VER         MAKE_NVAPI_VERSION(NV_MOSAIC_TOPO_BRIEF,1)


//
//! Basic per-display settings that are used in setting/getting the Mosaic mode
typedef struct _NV_MOSAIC_DISPLAY_SETTING_V1
{
    NvU32                        version;            //!< Version of this structure
    NvU32                        width;              //!< Per-display width
    NvU32                        height;             //!< Per-display height
    NvU32                        bpp;                //!< Bits per pixel
    NvU32                        freq;               //!< Display frequency
} NV_MOSAIC_DISPLAY_SETTING_V1;

typedef struct NV_MOSAIC_DISPLAY_SETTING_V2
{
    NvU32                        version;            //!< Version of this structure
    NvU32                        width;              //!< Per-display width
    NvU32                        height;             //!< Per-display height
    NvU32                        bpp;                //!< Bits per pixel
    NvU32                        freq;               //!< Display frequency
    NvU32                        rrx1k;              //!< Display frequency in x1k
} NV_MOSAIC_DISPLAY_SETTING_V2;

typedef NV_MOSAIC_DISPLAY_SETTING_V2 NV_MOSAIC_DISPLAY_SETTING;

//! Macro for constructing the version field of NV_MOSAIC_DISPLAY_SETTING
#define NVAPI_MOSAIC_DISPLAY_SETTING_VER1         MAKE_NVAPI_VERSION(NV_MOSAIC_DISPLAY_SETTING_V1,1)
#define NVAPI_MOSAIC_DISPLAY_SETTING_VER2         MAKE_NVAPI_VERSION(NV_MOSAIC_DISPLAY_SETTING_V2,2)
#define NVAPI_MOSAIC_DISPLAY_SETTING_VER          NVAPI_MOSAIC_DISPLAY_SETTING_VER2


//
// Set a reasonable max number of display settings to support
// so arrays are bound.
//
#define NV_MOSAIC_DISPLAY_SETTINGS_MAX 40  //!< Set a reasonable maximum number of display settings to support
                                           //! so arrays are bound.


//
//! This structure is used to contain a list of supported Mosaic topologies
//! along with the display settings that can be used.
typedef struct _NV_MOSAIC_SUPPORTED_TOPO_INFO_V1
{
    NvU32                          version;                                         //!< Version of this structure
    NvU32                          topoBriefsCount;                                 //!< Number of topologies in below array
    NV_MOSAIC_TOPO_BRIEF           topoBriefs[NV_MOSAIC_TOPO_MAX];                  //!< List of supported topologies with only brief details
    NvU32                          displaySettingsCount;                            //!< Number of display settings in below array
    NV_MOSAIC_DISPLAY_SETTING_V1   displaySettings[NV_MOSAIC_DISPLAY_SETTINGS_MAX]; //!< List of per display settings possible

} NV_MOSAIC_SUPPORTED_TOPO_INFO_V1;

typedef struct _NV_MOSAIC_SUPPORTED_TOPO_INFO_V2
{
    NvU32                          version;                                         //!< Version of this structure
    NvU32                          topoBriefsCount;                                 //!< Number of topologies in below array
    NV_MOSAIC_TOPO_BRIEF           topoBriefs[NV_MOSAIC_TOPO_MAX];                  //!< List of supported topologies with only brief details
    NvU32                          displaySettingsCount;                            //!< Number of display settings in below array
    NV_MOSAIC_DISPLAY_SETTING_V2   displaySettings[NV_MOSAIC_DISPLAY_SETTINGS_MAX]; //!< List of per display settings possible

} NV_MOSAIC_SUPPORTED_TOPO_INFO_V2;

typedef NV_MOSAIC_SUPPORTED_TOPO_INFO_V2 NV_MOSAIC_SUPPORTED_TOPO_INFO;

//! Macro forconstructing  the version field of NV_MOSAIC_SUPPORTED_TOPO_INFO
#define NVAPI_MOSAIC_SUPPORTED_TOPO_INFO_VER1         MAKE_NVAPI_VERSION(NV_MOSAIC_SUPPORTED_TOPO_INFO_V1,1)
#define NVAPI_MOSAIC_SUPPORTED_TOPO_INFO_VER2         MAKE_NVAPI_VERSION(NV_MOSAIC_SUPPORTED_TOPO_INFO_V2,2)
#define NVAPI_MOSAIC_SUPPORTED_TOPO_INFO_VER          NVAPI_MOSAIC_SUPPORTED_TOPO_INFO_VER2


//
// Indices to use to access the topos array within the mosaic topology
#define NV_MOSAIC_TOPO_IDX_DEFAULT       0

#define NV_MOSAIC_TOPO_IDX_LEFT_EYE      0
#define NV_MOSAIC_TOPO_IDX_RIGHT_EYE     1
#define NV_MOSAIC_TOPO_NUM_EYES          2


//
//! This defines the maximum number of topos that can be in a topo group.
//! At this time, it is set to 2 because our largest topo group (passive
//! stereo) only needs 2 topos (left eye and right eye).
//!
//! If a new topo group with more than 2 topos is added above, then this
//! number will also have to be incremented.
#define NV_MOSAIC_MAX_TOPO_PER_TOPO_GROUP 2 


//
//! This structure defines a group of topologies that work together to create one
//! overall layout.  All of the supported topologies are represented with this
//! structure.
//!
//! For example, a 'Passive Stereo' topology would be represented with this
//! structure, and would have separate topology details for the left and right eyes.
//! The count would be 2.  A 'Basic' topology is also represented by this structure,
//! with a count of 1.
//!
//! The structure is primarily used internally, but is exposed to applications in a
//! read-only fashion because there are some details in it that might be useful
//! (like the number of rows/cols, or connected display information).  A user can
//! get the filled-in structure by calling NvAPI_Mosaic_GetTopoGroup().
//!
//! You can then look at the detailed values within the structure.  There are no
//! entrypoints which take this structure as input (effectively making it read-only).
typedef struct 
{
    NvU32                      version;              //!< Version of this structure
    NV_MOSAIC_TOPO_BRIEF       brief;                //!< The brief details of this topo
    NvU32                      count;                //!< Number of topos in array below
    NV_MOSAIC_TOPO_DETAILS     topos[NV_MOSAIC_MAX_TOPO_PER_TOPO_GROUP];

} NV_MOSAIC_TOPO_GROUP;

//! Macro for constructing the version field of NV_MOSAIC_TOPO_GROUP
#define NVAPI_MOSAIC_TOPO_GROUP_VER         MAKE_NVAPI_VERSION(NV_MOSAIC_TOPO_GROUP,1)

//! @}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Mosaic_GetSupportedTopoInfo
//
//! DESCRIPTION:     This API returns information on the topologies and display resolutions
//!                  supported by Mosaic mode.
//!
//!                  NOTE: Not all topologies returned can be set immediately.
//!                        See 'OUT' Notes below.
//!
//!                  Once you get the list of supported topologies, you can call
//!                  NvAPI_Mosaic_GetTopoGroup() with one of the Mosaic topologies if you need
//!                  more information about it.
//!
//!     <b>'IN' Notes:</b>  pSupportedTopoInfo->version must be set before calling this function.
//!                  If the specified version is not supported by this implementation,
//!                  an error will be returned (NVAPI_INCOMPATIBLE_STRUCT_VERSION).
//!
//!     <b>'OUT' Notes:</b> Some of the topologies returned might not be valid for one reason or
//!                  another.  It could be due to mismatched or missing displays.  It
//!                  could also be because the required number of GPUs is not found.
//!                  At a high level, you can see if the topology is valid and can be enabled
//!                  by looking at the pSupportedTopoInfo->topoBriefs[xxx].isPossible flag.
//!                  If this is true, the topology can be enabled. If it
//!                  is false, you can find out why it cannot be enabled by getting the
//!                  details of the topology via NvAPI_Mosaic_GetTopoGroup().  From there,
//!                  look at the validityMask of the individual topologies.  The bits can
//!                  be tested against the NV_MOSAIC_TOPO_VALIDITY_* bits.
//!
//!                  It is possible for this function to return NVAPI_OK with no topologies
//!                  listed in the return structure.  If this is the case, it means that
//!                  the current hardware DOES support Mosaic, but with the given configuration
//!                  no valid topologies were found.  This most likely means that SLI was not
//!                  enabled for the hardware. Once enabled, you should see valid topologies
//!                  returned from this function.
//!    
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//!
//! \param [in,out]  pSupportedTopoInfo  Information about what topologies and display resolutions
//!                                      are supported for Mosaic.
//! \param [in]      type                The type of topologies the caller is interested in
//!                                      getting. See NV_MOSAIC_TOPO_TYPE for possible values.
//!
//! \retval ::NVAPI_OK                          No errors in returning supported topologies.
//! \retval ::NVAPI_NOT_SUPPORTED               Mosaic is not supported with the existing hardware.
//! \retval ::NVAPI_INVALID_ARGUMENT            One or more arguments passed in are invalid.
//! \retval ::NVAPI_API_NOT_INTIALIZED          The NvAPI API needs to be initialized first.
//! \retval ::NVAPI_NO_IMPLEMENTATION           This entrypoint not available.
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION The version of the structure passed in is not
//                                              compatible with this entry point.
//! \retval ::NVAPI_ERROR:                      Miscellaneous error occurred.
//!
//! \ingroup mosaicapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Mosaic_GetSupportedTopoInfo(NV_MOSAIC_SUPPORTED_TOPO_INFO *pSupportedTopoInfo, NV_MOSAIC_TOPO_TYPE type);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Mosaic_GetSupportedTopoInfoEx
//
//! DESCRIPTION:     This API returns information on the topologies and display resolutions
//!                  supported by Mosaic.
//!
//!                  This function is equivalent to calling NvAPI_Mosaic_GetSupportedTopoInfo(), and
//!                  then calling NvAPI_Mosaic_GetTopoGroup() for each topology.
//!
//!                  If pTopoGroups and pDisplaySettngs are NULL, then pTopoGroupCount and
//!                  pDisplaySettingsCount will be set to the number of supported Mosaic topologies
//!                  and the number of supported display modes.
//!
//!                  If pTopoGroups and pDisplaySettings are not NULL, then pTopoGroupCount and
//!                  pDisplaySettingsCount contain the maximum number of topologies and display
//!                  modes to return. On return, pTopoGroupCount and pDisplaySettingsCount will
//!                  be set to the number of topologies and modes that were returned.
//!
//!                  NOTE: Not all topologies returned can be immediately set.
//!                        See 'OUT' Notes below.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]     type                    The type of topology the caller is interested
//!                                         in getting. See ::NV_MOSAIC_TOPO_TYPE for possible
//!                                         values.
//! \param [out]    pTopoGroups             The details of each supported Mosaic topology.
//! \param [in,out] pTopoGroupCount         A pointer to the number of SLI topologies.
//! \param [out]    pDisplaySettings        The list of supported display modes.
//! \param [in,out] pDisplaySettingsCount   A pointer to the number of display modes.
//!
//!     'OUT' Notes: Some of the topologies returned might not be valid for one reason or
//!                  another. It could be due to mismatched or missing displays. It could
//!                  also be because the required number of GPUs is not found. At a high
//!                  level, you can see if the topology is valid and can be enabled by looking
//!                  at the pTopoGroups[xxx].brief.isPossible flag. If this is true, the
//!                  topology can be enabled. Otherwise, if it is false, you can find out why
//!                  it cannot be enabled by looking at the validityMask of the individual
//!                  topologies. The bits can be tested against the NV_MOSAIC_TOPO_VALIDITY_*
//!                  bits.
//!
//!                  It is possible for this function to return NVAPI_OK with no topologies
//!                  listed in the array. If this is the case, it means that the current
//!                  hardware DOES support Mosaic, but with the given configuration no
//!                  valid topologies were found. This most likely means that SLI was not
//!                  enabled for the hardware. Once enabled, you should see valid topologies
//!                  returned from this function.
//!
//! \retval ::NVAPI_OK                          No errors in returning supported topologies
//! \retval ::NVAPI_NOT_SUPPORTED               Mosaic is not supported with the existing hardware
//! \retval ::NVAPI_INVALID_ARGUMENT            One or more args passed in are invalid
//! \retval ::NVAPI_API_NOT_INTIALIZED          The NvAPI API needs to be initialized first
//! \retval ::NVAPI_NO_IMPLEMENTATION           This entrypoint not available
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION The version of the structure passed in is not
//                                              compatible with this entrypoint
//! \retval ::NVAPI_ERROR                       Miscellaneous error occurred
//!
//! \ingroup mosaicapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Mosaic_GetSupportedTopoInfoEx(NV_MOSAIC_TOPO_TYPE type,
                                                    NV_MOSAIC_TOPO_GROUP *pTopoGroups,
                                                    NvU32 *pTopoGroupCount,
                                                    NV_MOSAIC_DISPLAY_SETTING *pDisplaySettings,
                                                    NvU32 *pDisplaySettingsCount);






///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Mosaic_GetTopoGroup
//
//! DESCRIPTION:     This API returns a structure filled with the details
//!                  of the specified Mosaic topology.
//!
//!                  If the pTopoBrief passed in matches the current topology,
//!                  then information in the brief and group structures
//!                  will reflect what is current. Thus the brief would have
//!                  the current 'enable' status, and the group would have the
//!                  current overlap values. If there is no match, then the
//!                  returned brief has an 'enable' status of FALSE (since it
//!                  is obviously not enabled), and the overlap values will be 0.
//!
//!     <b>'IN' Notes:</b>  pTopoGroup->version must be set before calling this function.
//!                  If the specified version is not supported by this implementation,
//!                  an error will be returned (NVAPI_INCOMPATIBLE_STRUCT_VERSION).
//!
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]     pTopoBrief        The topology for getting the details
//!                                   This must be one of the topology briefs
//!                                   returned from NvAPI_Mosaic_GetSupportedTopoInfo().
//! \param [in,out] pTopoGroup        The topology details matching the brief
//!
//! \retval ::NVAPI_OK                          Details were retrieved successfully.
//! \retval ::NVAPI_NOT_SUPPORTED               Mosaic is not supported with the existing hardware.
//! \retval ::NVAPI_INVALID_ARGUMENT            One or more argumentss passed in are invalid.
//! \retval ::NVAPI_API_NOT_INTIALIZED          The NvAPI API needs to be initialized first.
//! \retval ::NVAPI_NO_IMPLEMENTATION           This entrypoint not available.
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION The version of the structure passed in is not
//                                              compatible with this entry point.
//! \retval ::NVAPI_ERROR:                      Miscellaneous error occurred.
//!
//! \ingroup mosaicapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Mosaic_GetTopoGroup(NV_MOSAIC_TOPO_BRIEF *pTopoBrief, NV_MOSAIC_TOPO_GROUP *pTopoGroup);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Mosaic_GetOverlapLimits
//
//! DESCRIPTION:     This API returns the X and Y overlap limits required if
//!                  the given Mosaic topology and display settings are to be used.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]   pTopoBrief          The topology for getting limits
//!                                   This must be one of the topo briefs
//!                                   returned from NvAPI_Mosaic_GetSupportedTopoInfo().
//! \param [in]   pDisplaySetting     The display settings for getting the limits.
//!                                   This must be one of the settings
//!                                   returned from NvAPI_Mosaic_GetSupportedTopoInfo().
//! \param [out]  pMinOverlapX        X overlap minimum
//! \param [out]  pMaxOverlapX        X overlap maximum
//! \param [out]  pMinOverlapY        Y overlap minimum
//! \param [out]  pMaxOverlapY        Y overlap maximum
//!
//! \retval ::NVAPI_OK                          Details were retrieved successfully.
//! \retval ::NVAPI_NOT_SUPPORTED               Mosaic is not supported with the existing hardware.
//! \retval ::NVAPI_INVALID_ARGUMENT            One or more argumentss passed in are invalid.
//! \retval ::NVAPI_API_NOT_INTIALIZED          The NvAPI API needs to be initialized first.
//! \retval ::NVAPI_NO_IMPLEMENTATION           This entrypoint not available.
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION The version of the structure passed in is not
//!                                             compatible with this entry point.
//! \retval ::NVAPI_ERROR                       Miscellaneous error occurred.
//!
//! \ingroup mosaicapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Mosaic_GetOverlapLimits(NV_MOSAIC_TOPO_BRIEF *pTopoBrief, NV_MOSAIC_DISPLAY_SETTING *pDisplaySetting, NvS32 *pMinOverlapX, NvS32 *pMaxOverlapX, NvS32 *pMinOverlapY, NvS32 *pMaxOverlapY);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Mosaic_SetCurrentTopo
//
//! DESCRIPTION:     This API sets the Mosaic topology and performs a mode switch 
//!                  using the given display settings.
//!
//!                  If NVAPI_OK is returned, the current Mosaic topology was set
//!                  correctly.  Any other status returned means the
//!                  topology was not set, and remains what it was before this
//!                  function was called.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]     pTopoBrief        The topology to set. This must be one of the topologies returned from
//!                                   NvAPI_Mosaic_GetSupportedTopoInfo(), and it must have an isPossible value of 1.
//! \param [in]     pDisplaySetting   The per display settings to be used in the Mosaic mode. This must be one of the
//!                                   settings returned from NvAPI_Mosaic_GetSupportedTopoInfo().
//! \param [in]     overlapX          The pixel overlap to use between horizontal displays (use positive a number for
//!                                   overlap, or a negative number to create a gap.) If the overlap is out of bounds
//!                                   for what is possible given the topo and display setting, the overlap will be clamped.
//! \param [in]     overlapY          The pixel overlap to use between vertical displays (use positive a number for
//!                                   overlap, or a negative number to create a gap.) If the overlap is out of bounds for
//!                                   what is possible given the topo and display setting, the overlap will be clamped.
//! \param [in]     enable            If 1, the topology being set will also be enabled, meaning that the mode set will
//!                                   occur.  \n
//!                                   If 0, you don't want to be in Mosaic mode right now, but want to set the current
//!                                   Mosaic topology so you can enable it later with NvAPI_Mosaic_EnableCurrentTopo().
//!
//! \retval  ::NVAPI_OK                          The Mosaic topology was set.
//! \retval  ::NVAPI_NOT_SUPPORTED               Mosaic is not supported with the existing hardware.
//! \retval  ::NVAPI_INVALID_ARGUMENT            One or more argumentss passed in are invalid.
//! \retval  ::NVAPI_TOPO_NOT_POSSIBLE           The topology passed in is not currently possible.
//! \retval  ::NVAPI_API_NOT_INTIALIZED          The NvAPI API needs to be initialized first.
//! \retval  ::NVAPI_NO_IMPLEMENTATION           This entrypoint not available.
//! \retval  ::NVAPI_INCOMPATIBLE_STRUCT_VERSION The version of the structure passed in is not
//!                                              compatible with this entrypoint.
//! \retval  ::NVAPI_MODE_CHANGE_FAILED          There was an error changing the display mode.
//! \retval  ::NVAPI_ERROR                       Miscellaneous error occurred.
//!
//! \ingroup mosaicapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Mosaic_SetCurrentTopo(NV_MOSAIC_TOPO_BRIEF *pTopoBrief, NV_MOSAIC_DISPLAY_SETTING *pDisplaySetting, NvS32 overlapX, NvS32 overlapY, NvU32 enable);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Mosaic_GetCurrentTopo
//
//! DESCRIPTION:     This API returns information for the current Mosaic topology.
//!                  This includes topology, display settings, and overlap values.
//!
//!                  You can call NvAPI_Mosaic_GetTopoGroup() with the topology
//!                  if you require more information.
//!
//!                  If there isn't a current topology, then pTopoBrief->topo will
//!                  be NV_MOSAIC_TOPO_NONE.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [out]     pTopoBrief       The current Mosaic topology
//! \param [out]     pDisplaySetting  The current per-display settings
//! \param [out]     pOverlapX        The pixel overlap between horizontal displays
//! \param [out]     pOverlapY        The pixel overlap between vertical displays
//!
//! \retval ::NVAPI_OK                          Success getting current info.
//! \retval ::NVAPI_NOT_SUPPORTED               Mosaic is not supported with the existing hardware.
//! \retval ::NVAPI_INVALID_ARGUMENT            One or more argumentss passed in are invalid.
//! \retval ::NVAPI_API_NOT_INTIALIZED          The NvAPI API needs to be initialized first.
//! \retval ::NVAPI_NO_IMPLEMENTATION           This entry point not available.
//! \retval ::NVAPI_ERROR                       Miscellaneous error occurred.
//!
//! \ingroup mosaicapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Mosaic_GetCurrentTopo(NV_MOSAIC_TOPO_BRIEF *pTopoBrief, NV_MOSAIC_DISPLAY_SETTING *pDisplaySetting, NvS32 *pOverlapX, NvS32 *pOverlapY);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Mosaic_EnableCurrentTopo
//
//! DESCRIPTION:     This API enables or disables the current Mosaic topology
//!                  based on the setting of the incoming 'enable' parameter.
//!
//!                  An "enable" setting enables the current (previously set) Mosaic topology.
//!                  Note that when the current Mosaic topology is retrieved, it must have an isPossible value of 1 or
//!                  an error will occur.
//!
//!                  A "disable" setting disables the current Mosaic topology.
//!                  The topology information will persist, even across reboots.
//!                  To re-enable the Mosaic topology, call this function
//!                  again with the enable parameter set to 1.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]   enable               1 to enable the current Mosaic topo, 0 to disable it.
//!
//! \retval ::NVAPI_OK                 The Mosaic topo was enabled/disabled.
//! \retval ::NVAPI_NOT_SUPPORTED      Mosaic is not supported with the existing hardware.
//! \retval ::NVAPI_INVALID_ARGUMENT   One or more arguments passed in are invalid.
//! \retval ::NVAPI_TOPO_NOT_POSSIBLE  The current topology is not currently possible.
//! \retval ::NVAPI_MODE_CHANGE_FAILED There was an error changing the display mode.
//! \retval ::NVAPI_ERROR:             Miscellaneous error occurred.
//!
//! \ingroup mosaicapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Mosaic_EnableCurrentTopo(NvU32 enable);

//! \ingroup mosaicapi
//! @{
typedef struct _NV_MOSAIC_GRID_TOPO_DISPLAY_V1
{
    NvU32                       displayId;              //!< DisplayID of the display
    NvS32                       overlapX;               //!< (+overlap, -gap)
    NvS32                       overlapY;               //!< (+overlap, -gap)
    NV_ROTATE                   rotation;               //!< Rotation of display
    NvU32                       cloneGroup;             //!< Reserved, must be 0
} NV_MOSAIC_GRID_TOPO_DISPLAY_V1;

typedef struct _NV_MOSAIC_DISPLAY
{
    NvS32           positionX;                      //!< Display location x co-ordinate in given coordinate system
    NvS32           positionY;                      //!< Display location y co-ordinate in given coordinate system
    NvU32           width;                          //!< Display width
    NvU32           height;                         //!< Display height
} NV_MOSAIC_DISPLAY;

typedef enum _NV_PIXEL_SHIFT_TYPE
{
    NV_PIXEL_SHIFT_TYPE_NO_PIXEL_SHIFT            = 0,          //!< No pixel shift will be applied to this display.
    NV_PIXEL_SHIFT_TYPE_2x2_TOP_LEFT_PIXELS       = 1,          //!< This display will be used to scanout top left pixels in 2x2 PixelShift configuration
    NV_PIXEL_SHIFT_TYPE_2x2_BOTTOM_RIGHT_PIXELS   = 2,          //!< This display will be used to scanout bottom right pixels in 2x2 PixelShift configuration
} NV_PIXEL_SHIFT_TYPE;

typedef struct _NV_MOSAIC_GRID_TOPO_DISPLAY_V2
{
    NvU32                               version;                //!< Version of this structure

    NvU32                               displayId;              //!< DisplayID of the display
    NvS32                               overlapX;               //!< (+overlap, -gap)
    NvS32                               overlapY;               //!< (+overlap, -gap)
    NV_ROTATE                           rotation;               //!< Rotation of display
    NvU32                               cloneGroup;             //!< Reserved, must be 0
    NV_PIXEL_SHIFT_TYPE                 pixelShiftType;         //!< Type of the pixel shift enabled display
} NV_MOSAIC_GRID_TOPO_DISPLAY_V2;

typedef struct _NV_MOSAIC_GRID_TOPO_DISPLAY_V3
{
    NvU32                               version;                //!< Version of this structure

    NvU32                               displayId;              //!< DisplayID of the display
    NvS32                               overlapX;               //!< (+overlap, -gap)
    NvS32                               overlapY;               //!< (+overlap, -gap)
    NV_ROTATE                           rotation;               //!< Rotation of display
    NvU32                               cloneGroup;             //!< Reserved, must be 0
    NV_PIXEL_SHIFT_TYPE                 pixelShiftType;         //!< Type of the pixel shift enabled display
    NV_MOSAIC_DISPLAY                   physicalDimensions;     //!< Physical dimension of display in DD coordinate space, scale 1 unit = 1 micrometer
    NV_MOSAIC_DISPLAY                   logicalDimensions;      //!< Logical dimension of display in Pixel based coordinate space, scale 1 unit = 1 pixel
    NV_MOSAIC_DISPLAY                   physicalDisplayRegion;  //!< Physical dimension of display region in DD coordinate space, scale 1 unit = 1 micrometer
    NV_MOSAIC_DISPLAY                   logicalDisplayRegion;   //!< Logical dimension of display region in Pixel based coordinate space, scale 1 unit = 1 pixel
    NvU32                               rotationReserved;       //!< Display rotation in degrees from 0 to 360. Currently reserved.
} NV_MOSAIC_GRID_TOPO_DISPLAY_V3;

typedef NV_MOSAIC_GRID_TOPO_DISPLAY_V3          NV_MOSAIC_GRID_TOPO_DISPLAY;

#define NV_MOSAIC_GRID_TOPO_DISPLAY_VER         MAKE_NVAPI_VERSION(NV_MOSAIC_GRID_TOPO_DISPLAY_V3,3)

typedef struct _NV_MOSAIC_SURFACE_V1
{
    NvU32                       version;                        //!< Version of this structure
    
    NV_MOSAIC_DISPLAY           physicalDimensions;             //!< Physical Dimensions of the mosaic surface, scale 1 unit = 1 micrometer

    NV_MOSAIC_DISPLAY           logicalDimensions;              //!< Logical Dimensions of the mosaic surface in pixels

} NV_MOSAIC_SURFACE_V1;

typedef NV_MOSAIC_SURFACE_V1          NV_MOSAIC_SURFACE;

#define NV_MOSAIC_SURFACE_VER         MAKE_NVAPI_VERSION(NV_MOSAIC_SURFACE,1)

#ifndef NV_MOSAIC_GRID_TOPO_DISPLAY_VER

typedef NV_MOSAIC_GRID_TOPO_DISPLAY_V1           NV_MOSAIC_GRID_TOPO_DISPLAY;

#endif

typedef struct _NV_MOSAIC_GRID_TOPO_V1
{
    NvU32                          version;                            //!< Version of this structure
    NvU32                          rows;                               //!< Number of rows
    NvU32                          columns;                            //!< Number of columns
    NvU32                          displayCount;                       //!< Number of display details
    NvU32                          applyWithBezelCorrect : 1;          //!< When enabling and doing the modeset, do we switch to the bezel-corrected resolution
    NvU32                          immersiveGaming : 1;                //!< Enable as immersive gaming instead of Mosaic SLI (for Quadro-boards only)
    NvU32                          baseMosaic : 1;                     //!< Enable as Base Mosaic (Panoramic) instead of Mosaic SLI (for NVS and Quadro-boards only)
    NvU32                          driverReloadAllowed : 1;            //!< If necessary, reloading the driver is permitted (for Vista and above only). Will not be persisted. Value undefined on get.
    NvU32                          acceleratePrimaryDisplay : 1;       //!< Enable SLI acceleration on the primary display while in single-wide mode (For Immersive Gaming only). Will not be persisted. Value undefined on get.
    NvU32                          reserved : 27;                      //!< Reserved, must be 0
    NV_MOSAIC_GRID_TOPO_DISPLAY_V1 displays[NV_MOSAIC_MAX_DISPLAYS];   //!< Displays are done as [(row * columns) + column]
    NV_MOSAIC_DISPLAY_SETTING_V1   displaySettings;                    //!< Display settings
} NV_MOSAIC_GRID_TOPO_V1;

typedef struct _NV_MOSAIC_GRID_TOPO_V2
{
    NvU32                          version;                            //!< Version of this structure
    NvU32                          rows;                               //!< Number of rows
    NvU32                          columns;                            //!< Number of columns
    NvU32                          displayCount;                       //!< Number of display details
    NvU32                          applyWithBezelCorrect : 1;          //!< When enabling and doing the modeset, do we switch to the bezel-corrected resolution
    NvU32                          immersiveGaming : 1;                //!< Enable as immersive gaming instead of Mosaic SLI (for Quadro-boards only)
    NvU32                          baseMosaic : 1;                     //!< Enable as Base Mosaic (Panoramic) instead of Mosaic SLI (for NVS and Quadro-boards only)
    NvU32                          driverReloadAllowed : 1;            //!< If necessary, reloading the driver is permitted (for Vista and above only). Will not be persisted. Value undefined on get.
    NvU32                          acceleratePrimaryDisplay : 1;       //!< Enable SLI acceleration on the primary display while in single-wide mode (For Immersive Gaming only). Will not be persisted. Value undefined on get.
    NvU32                          pixelShift : 1;                     //!< Enable Pixel shift
    NvU32                          reserved : 26;                      //!< Reserved, must be 0
    NV_MOSAIC_GRID_TOPO_DISPLAY_V2 displays[NV_MOSAIC_MAX_DISPLAYS];   //!< Displays are done as [(row * columns) + column]
    NV_MOSAIC_DISPLAY_SETTING_V1   displaySettings;                    //!< Display settings
} NV_MOSAIC_GRID_TOPO_V2;

typedef struct _NV_MOSAIC_GRID_TOPO_V3
{
    NvU32                          version;                            //!< Version of this structure
    NvU32                          rows;                               //!< Number of rows
    NvU32                          columns;                            //!< Number of columns
    NvU32                          displayCount;                       //!< Number of display details
    NvU32                          applyWithBezelCorrect : 1;          //!< When enabling and doing the modeset, do we switch to the bezel-corrected resolution
    NvU32                          immersiveGaming : 1;                //!< Enable as immersive gaming instead of Mosaic SLI (for Quadro-boards only)
    NvU32                          baseMosaic : 1;                     //!< Enable as Base Mosaic (Panoramic) instead of Mosaic SLI (for NVS and Quadro-boards only)
    NvU32                          driverReloadAllowed : 1;            //!< If necessary, reloading the driver is permitted (for Vista and above only). Will not be persisted. Value undefined on get.
    NvU32                          acceleratePrimaryDisplay : 1;       //!< Enable SLI acceleration on the primary display while in single-wide mode (For Immersive Gaming only). Will not be persisted. Value undefined on get.
    NvU32                          pixelShift : 1;                     //!< Enable Pixel shift
    NvU32                          usePrimaryDisplayIndex : 1;         //!< Enable using the display at index (passed in primaryDisplayIndex field) as Primary Display
    NvU32                          dissimilarDisplays : 1;             //!< Enable using Dissimilar displays
    NvU32                          reserved : 24;                      //!< Reserved, must be 0
    NV_MOSAIC_GRID_TOPO_DISPLAY_V3 displays[NV_MOSAIC_MAX_DISPLAYS];   //!< Displays are done as [(row * columns) + column]
    NV_MOSAIC_DISPLAY_SETTING_V2   displaySettings;                    //!< Display settings
    NvU32                          primaryDisplayIndex;                //!< primary display from displays array
    NV_MOSAIC_SURFACE              spanSurface;                        //!< Mosaic Surface properties 
    NvU32                          virtualDisplayId;                   //!< Reserved for future use
} NV_MOSAIC_GRID_TOPO_V3;

typedef NV_MOSAIC_GRID_TOPO_V3           NV_MOSAIC_GRID_TOPO;

//! Macro for constructing the version field of ::NV_MOSAIC_GRID_TOPO
#define NV_MOSAIC_GRID_TOPO_VER1         MAKE_NVAPI_VERSION(NV_MOSAIC_GRID_TOPO_V1,1)
#define NV_MOSAIC_GRID_TOPO_VER2         MAKE_NVAPI_VERSION(NV_MOSAIC_GRID_TOPO_V2,2)
#define NV_MOSAIC_GRID_TOPO_VER3         MAKE_NVAPI_VERSION(NV_MOSAIC_GRID_TOPO_V3,3)
#define NV_MOSAIC_GRID_TOPO_VER          NV_MOSAIC_GRID_TOPO_VER3

#ifndef NV_MOSAIC_GRID_TOPO_VER

typedef NV_MOSAIC_GRID_TOPO_V2           NV_MOSAIC_GRID_TOPO;

//! Macro for constructing the version field of ::NV_MOSAIC_GRID_TOPO
#define NV_MOSAIC_GRID_TOPO_VER          NV_MOSAIC_GRID_TOPO_VER2

#endif

//! @}


//! \ingroup mosaicapi
//! @{
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Mosaic_SetGridTopology
//
//! \fn NvAPI_Mosaic_SetGridTopology(NV_MOSAIC_GRID_TOPO *pGridTopology, NvU32 enable)
//! DESCRIPTION:     This API sets a grid-based Mosaic topology and does a 
//!                  mode change using the given display settings.
//!
//!                  If NVAPI_OK is returned, the requested Mosaic topo was set
//!                  correctly.  Any other status returned means the
//!                  topo was not set, and remains what it was before this
//!                  function was called. It is possible for this API to return
//!                  success, but the displays enabled have an issue, leading
//!                  to a black screen.
//!
//!                  Note: Not all exposed features are available on all 
//!                  platforms.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]     pGridTopology     The topology details to set.
//! \param [in]     enable            If 1, the topo being set will also be enabled,
//!                                   meaning that the mode set will occur.  
//!                                   Passing a 0 means you don't want to be in
//!                                   Mosaic mode right now, but want to set the current
//!                                   Mosaic topo so you can enable it later with
//!                                   NvAPI_Mosaic_EnableCurrentTopo().
//!
//! \return    This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//! \retval ::NVAPI_NO_ACTIVE_SLI_TOPOLOGY        GPUs are not currently in SLI
//! \retval ::NVAPI_INVALID_COMBINATION           The current SLI set does not support Mosaic SLI or Immersive Gaming
//! \retval ::NVAPI_SLI_RENDERING_MODE_NOTALLOWED The current display configuration cannot be used for the requested 
//!                                               mosaic topology (for instance, having the displays only in the center 
//!                                               of the SLI topology), or does not support center display
//!                                               acceleration
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Mosaic_SetGridTopology(NV_MOSAIC_GRID_TOPO *pGridTopology, NvU32 enable);

//! @}

//! \ingroup mosaicapi
//! @{
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Mosaic_GetMosaicCapabilities
//
//! \fn NvAPI_Mosaic_GetMosaicCapabilities(NV_GPU_VALID_GPU_TOPOLOGIES *pSliTopology, NV_MOSAIC_CAPS *pCaps) 
//! DESCRIPTION:     This API returns a set of capabilities based on a provided
//!                  SLI topology. The pSliTopology is the same parameter as
//!                  used for NvAPI_SetGpuTopologies. If more than one SLI 
//!                  topology is marked to be active, only the first active 
//!                  topology will be validated.
//!                  At least one topology in pSliTopology must have the 
//!                  NV_GPU_TOPOLOGY_ACTIVE flag set. This does not require the
//!                  topology to be currently active, but marks which topology
//!                  will have the capabilities retrieved for.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]       pSliTopology    SLI topology for capabilties query
//! \param [out]      pCaps           Capabilities for Mosaic SLI
//!
//! \retval ::NVAPI_OK                          Capabilities have been returned.
//! \retval ::NVAPI_INVALID_ARGUMENT            One or more argumenets passed in are invalid.
//! \retval ::NVAPI_API_NOT_INTIALIZED          The NvAPI API needs to be initialized first.
//! \retval ::NVAPI_NO_ACTIVE_SLI_TOPOLOGY      No topology had the ::NV_GPU_TOPOLOGY_ACTIVE flag marked.
//! \retval ::NVAPI_NO_IMPLEMENTATION           This entrypoint is not available.
//! \retval ::NVAPI_ERROR                       Miscellaneous error occurred.
//
///////////////////////////////////////////////////////////////////////////////

//! See NvAPI_Mosaic_GetMosaicCapabilities{}.
typedef struct
{
    NvU32  version;                          //!< Must be set to ::NV_MOSAIC_CAPS_VER.
    NvU32  bSupportsImmersiveGaming : 1;     //!< These GPUs could enter immersive gaming if proper displays are attached.
    NvU32  bSupportsMosaicSli : 1;           //!< Supports QuadroPlex Mosaic SLI.
    NvU32  bSupportsGlobalRotation : 1;      //!< All displays must share rotation.
    NvU32  bSupportsPerDisplayRotation : 1;  //!< Each display may have a different rotation.
    NvU32  bSupportsPerDisplaySettings : 1;  //!< Each display may have a different resolution.
    NvU32  bSupportsOverlap : 1;             //!< Overlap is supported (+overlap).
    NvU32  bSupportsGaps : 1;                //!< Gap is supported (-overlap).
    NvU32  bSupportsUnevenGapping : 1;       //!< Allows for each display to have different overlap values.
    NvU32  bSupportsBaseMosaic : 1;          //!< These GPUs could enter base Mosaic if proper displays are attached
    NvU32  reserved : 23;                    //!< Reserved, must be 0
} NV_MOSAIC_CAPS_V1;

//! See NvAPI_Mosaic_GetMosaicCapabilities{}.
typedef struct
{
    NvU32  version;                          //!< Must be set to ::NV_MOSAIC_CAPS_VER.
    NvU32  bSupportsImmersiveGaming : 1;     //!< These GPUs could enter immersive gaming if proper displays are attached.
    NvU32  bSupportsMosaic : 1;              //!< Supports Mosaic.
    NvU32  bSupportsGlobalRotation : 1;      //!< All displays must share rotation.
    NvU32  bSupportsPerDisplayRotation : 1;  //!< Each display may have a different rotation.
    NvU32  bSupportsPerDisplaySettings : 1;  //!< Each display may have a different resolution.
    NvU32  bSupportsOverlap : 1;             //!< Overlap is supported (+overlap).
    NvU32  bSupportsGaps : 1;                //!< Gap is supported (-overlap).
    NvU32  bSupportsUnevenGapping : 1;       //!< Allows for each display to have different overlap values.
    NvU32  bSupportsPassiveStereo : 1;       //!< Allows passive stereo using clone groups.
    NvU32  bSupportsPixelShift : 1;          //!< Supports Pixel Shift mode. 
    NvU32  reserved : 22;                    //!< Reserved, must be 0
} NV_MOSAIC_CAPS_V2;

typedef NV_MOSAIC_CAPS_V2 NV_MOSAIC_CAPS;

//! Macro for constructing the version field of NV_MOSAIC_CAPS
#define NV_MOSAIC_CAPS_VER1                 MAKE_NVAPI_VERSION(NV_MOSAIC_CAPS_V1,1)
#define NV_MOSAIC_CAPS_VER2                 MAKE_NVAPI_VERSION(NV_MOSAIC_CAPS_V2,2)
#define NV_MOSAIC_CAPS_VER                  NV_MOSAIC_CAPS_VER2

NVAPI_INTERFACE NvAPI_Mosaic_GetMosaicCapabilities(NV_GPU_VALID_GPU_TOPOLOGIES *pSliTopology, NV_MOSAIC_CAPS *pCaps);
//! @}

//! \ingroup mosaicapi
//! @{
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Mosaic_GetMosaicCapabilitiesEx
//
//! \fn NvAPI_Mosaic_GetMosaicCapabilitiesEx(NV_GPU_TOPOLOGY *pTopology, NV_MOSAIC_CAPS *pCaps)
//! DESCRIPTION:     This API returns a set of capabilities based on a provided
//!                  SLI topology. If pTopology only contains a single GPU,
//!                  then the capabilities of that particular GPU are returned.
//!                  This does not require the topology to be currently active.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! since Release R290
//!
//! \param [in]       pTopology       GPU Topology for querying capabilities
//! \param [out]      pCaps           Capabilities for Mosaic
//!
//! \return    This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with
//!            specific meaning for this API, they are listed below.
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_Mosaic_GetMosaicCapabilitiesEx(NV_GPU_TOPOLOGY *pTopology, NV_MOSAIC_CAPS *pCaps);
//! @}

//! SUPPORTED OS:  Windows XP and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Mosaic_GetSingleGpuMosaicCaps
//
//! DESCRIPTION:     This API returns the set of capabilities for a
//!                  physical GPU when used by itself (not as part of an SLI
//!                  topology).
//!
//!                  If hPysGpu is NULL, then pCaps will specify whether SLI
//!                  Mosaic, Surround Gaming, and Base Mosaic are supported on any GPU or SLI
//!                  topology.
//!
//! \param [in]      hPhysGpu         Physical GPU for capabilities query
//! \param [out]     pCaps            Capabilities for Mosaic SLI
//!
//! \retval ::NVAPI_OK:                          Capabilties have been returned.
//! \retval ::NVAPI_INVALID_ARGUMENT:            One or more args passed in are invalid.
//! \retval ::NVAPI_API_NOT_INTIALIZED:          The NvAPI API needs to be initialized first
//! \retval ::NVAPI_NO_IMPLEMENTATION:           This entrypoint not available
//! \retval ::NVAPI_ERROR:                       Miscellaneous error occurred
//!
//! \ingroup mosaicapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Mosaic_GetSingleGpuMosaicCaps(NvPhysicalGpuHandle hPhysGpu, NV_MOSAIC_CAPS *pCaps);



#define NV_MOSAIC_DISPLAYCAPS_PROBLEM_DISPLAY_ON_INVALID_GPU        NV_BIT(0)
#define NV_MOSAIC_DISPLAYCAPS_PROBLEM_DISPLAY_ON_WRONG_CONNECTOR    NV_BIT(1)
#define NV_MOSAIC_DISPLAYCAPS_PROBLEM_NO_COMMON_TIMINGS             NV_BIT(2)
#define NV_MOSAIC_DISPLAYCAPS_PROBLEM_NO_EDID_AVAILABLE             NV_BIT(3)
#define NV_MOSAIC_DISPLAYCAPS_PROBLEM_MISMATCHED_OUTPUT_TYPE        NV_BIT(4)
#define NV_MOSAIC_DISPLAYCAPS_PROBLEM_NO_DISPLAY_CONNECTED          NV_BIT(5)
#define NV_MOSAIC_DISPLAYCAPS_PROBLEM_NO_GPU_TOPOLOGY               NV_BIT(6)
#define NV_MOSAIC_DISPLAYCAPS_PROBLEM_NOT_SUPPORTED                 NV_BIT(7)
#define NV_MOSAIC_DISPLAYCAPS_PROBLEM_NO_SLI_BRIDGE                 NV_BIT(8)
#define NV_MOSAIC_DISPLAYCAPS_PROBLEM_ECC_ENABLED                   NV_BIT(9)
#define NV_MOSAIC_DISPLAYCAPS_PROBLEM_GPU_TOPOLOGY_NOT_SUPPORTED    NV_BIT(10)



//! \ingroup mosaicapi
//! @{
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Mosaic_GetDisplayCapabilities
//
//! \fn NvAPI_Mosaic_GetDisplayCapabilities(NV_MOSAIC_DISPLAY_CAPS *pDisplayCaps)
//! DESCRIPTION:     This API returns a set of capabilities based on a provided
//!                  displays. The caller uses this function to determine if a
//!                  given set of displays, regardless of SLI topology, would
//!                  support Mosaic SLI / Immersive Gaming. This API can also
//!                  assist in identifying if a display would be compatible, 
//!                  but is currently plugged into the wrong connector of a GPU.
//! 
//!                  Problem flags are SLI-agnostic. This API will not verify
//!                  that all displays are on the same SLI topology.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in,out]      pDisplayCaps   List of display capabilities and 
//!                                     problem codes, as well as list of
//!                                     valid display settings shared by the
//!                                     selected monitors.
//!
//! \retval ::NVAPI_OK                          The display capabilities have been returned.
//! \retval ::NVAPI_INVALID_ARGUMENT            One or more arguments passed in are invalid.
//! \retval ::NVAPI_API_NOT_INTIALIZED          The NvAPI API needs to be initialized first.
//! \retval ::NVAPI_NO_IMPLEMENTATION           This entrypoint is not available.
//! \retval ::NVAPI_ERROR                       Miscellaneous error occurred.
//
///////////////////////////////////////////////////////////////////////////////


//! See ::NV_MOSAIC_DISPLAY_CAPS.
typedef struct
{
    NvU32  displayId;                       //!< (IN) DisplayID of display
    NvU32  problemFlags;                    //!< (OUT) Any problem flags found (NV_MOSAIC_DISPLAYCAPS_PROBLEM_*)
    NvU32  supportsRotation : 1;            //!< (OUT) This display can be rotated
    NvU32  reserved : 31;                   //!< (OUT) reserved
} NV_MOSAIC_DISPLAY_DETAILS;

//! See NvAPI_Mosaic_GetDisplayCapabilities().
typedef struct _NV_MOSAIC_DISPLAY_CAPS_V1
{
    NvU32  version;                         //!< (IN) Must be NV_MOSAIC_DISPLAY_CAPS_VER
    NvU32  displayCount;                    //!< (IN) Number of valid displays in displays array
    NV_MOSAIC_DISPLAY_DETAILS   displays[NVAPI_MAX_DISPLAYS];   //!< (IN/OUT) Array of individual displays, the first 
                                                                //!< display will be used to validate the remaining displays 
                                                                //!< for EDID matching. There is other order dependency.
    NvU32  displaySettingsCount;            //!< (OUT) Number of valid display settings found
    NV_MOSAIC_DISPLAY_SETTING_V1   displaySettings[NV_MOSAIC_DISPLAY_SETTINGS_MAX];    //!< (OUT) List of common timings
    NvU32  problemFlags;                    //!< (OUT) Any problem flags found (NV_MOSAIC_DISPLAYCAPS_PROBLEM_*)
} NV_MOSAIC_DISPLAY_CAPS_V1;


#define NV_MOSAIC_DISPLAY_CAPS_MAX      1600

//! See NvAPI_Mosaic_GetDisplayCapabilities().
typedef struct _NV_MOSAIC_DISPLAY_CAPS_V2
{
    NvU32  version;                         //!< (IN) Must be NV_MOSAIC_DISPLAY_CAPS_VER
    NvU32  displayCount;                    //!< (IN) Number of valid displays in displays array
    NV_MOSAIC_DISPLAY_DETAILS   displays[NVAPI_MAX_DISPLAYS];   //!< (IN/OUT) Array of individual displays, the first
                                                                //!< display will be used to validate the remaining displays
                                                                //!< for EDID matching. There is other order dependency.
    NvU32  displaySettingsCount;            //!< (OUT) Number of valid display settings found
    NV_MOSAIC_DISPLAY_SETTING_V1   displaySettings[NV_MOSAIC_DISPLAY_CAPS_MAX];    // (OUT) List of common timings
    NvU32  problemFlags;                    //!< (OUT) Any problem flags found (NV_MOSAIC_DISPLAYCAPS_PROBLEM_*)
} NV_MOSAIC_DISPLAY_CAPS_V2;

typedef struct _NV_MOSAIC_DISPLAY_CAPS_V3
{
    NvU32  version;                         //!< (IN) Must be NV_MOSAIC_DISPLAY_CAPS_VER
    NvU32  displayCount;                    //!< (IN) Number of valid displays in displays array
    NV_MOSAIC_DISPLAY_DETAILS   displays[NVAPI_MAX_DISPLAYS];   //!< (IN/OUT) Array of individual displays, the first
                                                                //!< display will be used to validate the remaining displays
                                                                //!< for EDID matching. There is other order dependency.
    NvU32  displaySettingsCount;            //!< (OUT) Number of valid display settings found
    NV_MOSAIC_DISPLAY_SETTING_V2   displaySettings[NV_MOSAIC_DISPLAY_CAPS_MAX];    // (OUT) List of common timings
    NvU32  problemFlags;                    //!< (OUT) Any problem flags found (NV_MOSAIC_DISPLAYCAPS_PROBLEM_*)
} NV_MOSAIC_DISPLAY_CAPS_V3;


typedef NV_MOSAIC_DISPLAY_CAPS_V3           NV_MOSAIC_DISPLAY_CAPS;

//! Macro for constructing the version field of ::NV_MOSAIC_DISPLAY_CAPS_V1
#define NV_MOSAIC_DISPLAY_CAPS_VER1         MAKE_NVAPI_VERSION(NV_MOSAIC_DISPLAY_CAPS_V1,1)

//! Macro for constructing the version field of ::NV_MOSAIC_DISPLAY_CAPS_V2
#define NV_MOSAIC_DISPLAY_CAPS_VER2         MAKE_NVAPI_VERSION(NV_MOSAIC_DISPLAY_CAPS_V2,2)

//! Macro for constructing the version field of ::NV_MOSAIC_DISPLAY_CAPS_V3
#define NV_MOSAIC_DISPLAY_CAPS_VER3         MAKE_NVAPI_VERSION(NV_MOSAIC_DISPLAY_CAPS_V3,3)

//! Macro for constructing the version field of ::NV_MOSAIC_DISPLAY_CAPS
#define NV_MOSAIC_DISPLAY_CAPS_VER          NV_MOSAIC_DISPLAY_CAPS_VER3


NVAPI_INTERFACE NvAPI_Mosaic_GetDisplayCapabilities(NV_MOSAIC_DISPLAY_CAPS *pDisplayCaps);

//! @}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Mosaic_GetGridOverlapLimits
//
//! \fn NvAPI_Mosaic_GetGridOverlapLimits(NV_MOSAIC_GRID_TOPO *pGridTopology, NV_MOSAIC_OVERLAP_LIMITS *pOverlapLimits)
//! DESCRIPTION:     This API returns the X and Y overlap limits required if
//!                  the given Mosaic topology and display settings are to be used.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]      pGridTopology       The topology to get limits for.
//! \param [out]     pOverlapLimits      The total and per-display overlap limits for the grid.
//!
//! \retval ::NVAPI_OK:                          Details were retrieved successfully
//! \retval ::NVAPI_NOT_SUPPORTED:               Mosaic is not supported with the existing hardware
//! \retval ::NVAPI_INVALID_ARGUMENT:            One or more args passed in are invalid.
//! \retval ::NVAPI_API_NOT_INTIALIZED:          The NvAPI API needs to be initialized first
//! \retval ::NVAPI_NO_IMPLEMENTATION:           This entrypoint not available
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION: The version of the structure passed in is not
//!                                                     compatible with this entrypoint
//! \retval ::NVAPI_ERROR:                       Miscellaneous error occurred
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup mosaicapi
typedef struct
{
    NvU32 version;
    NvS32 minDispX;  //!< The minimum X overlap for each display.
    NvS32 maxDispX;  //!< The maximum X overlap for each display.
    NvS32 minDispY;  //!< The minimum Y overlap for each display.
    NvS32 maxDispY;  //!< The maximum Y overlap for each display.
    NvS32 minTotalX; //!< The minimum total X overlap for the entire grid.
    NvS32 maxTotalX; //!< The maximum total X overlap for the entire grid.
    NvS32 minTotalY; //!< The minimum total Y overlap for the entire grid.
    NvS32 maxTotalY; //!< The maximum total Y overlap for the entire grid.
} NV_MOSAIC_OVERLAP_LIMITS;

//! \ingroup mosaicapi
#define NV_MOSAIC_OVERLAP_LIMITS_VER         MAKE_NVAPI_VERSION(NV_MOSAIC_OVERLAP_LIMITS,1)

//! \ingroup mosaicapi
NVAPI_INTERFACE NvAPI_Mosaic_GetGridOverlapLimits(NV_MOSAIC_GRID_TOPO *pGridTopology, NV_MOSAIC_OVERLAP_LIMITS *pOverlapLimits);



//! \ingroup mosaicapi
//! @{
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Mosaic_EnumGridTopologies
//
//! \fn NvAPI_Mosaic_EnumGridTopologies(NvU32 index, NvU32 flags, NV_MOSAIC_GRID_TOPO *pGridTopology, NvU8* bEnabled)
//! DESCRIPTION:     This API retrieves the current grid topology information
//!                  for Mosaic SLI.
//!
//!                  If there has been no existing call to set a topology
//!                  (either enabled or disable), this call will return 
//!                  ::NVAPI_DATA_NOT_FOUND. If the existing data is no longer
//!                  valid due to display connectors being moved, or GPUs
//!                  being moved, ::NVAPI_DATA_NOT_FOUND will also be returned.
//!                  This API does not validate whether SLI is currently 
//!                  enabled.
//!
//!                  When enumerating all current grid topologies, ::NVAPI_DATA_NOT_FOUND will
//!                  be returned when there are no more topologies.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]     index               A zero-based index to enumerate
//!                                     multiple applied grid topologies.
//! \param [in]     flags               This field controls which data is returned.
//!                                          By default, all known topologies are returned.
//!                                          A known topology is either an active topology
//!                                          or a topology which has been disabled and not
//!                                          included in another topology. Unless specified,
//!                                          topology validity will be applied during enum,
//!                                          and topologies which are no longer valid will
//!                                          not be returned (ex: a monitor was disconnected).
//!                                          Only topologies which have been enabled in the 
//!                                          past will be returned, this API will not 
//!                                          enumerate all possible topologies. To determine 
//!                                          all possible topologies, manually create each 
//!                                          possible topology and validate each using 
//!                                          NvAPI_Mosaic_GetDisplayCapabilities. 
//!
//! \param [in,out] pGridTopology       The topology details of the current
//!                                     topology. On input, version must be
//!                                     properly set, all other fields are ignored.
//! \param [out] bEnabled            (May pass in NULL to ignore)
//!                                     -1 if Mosaic is enabled, 
//!                                     -0 if Mosaic is currently disabled.
//!
//! \retval ::NVAPI_OK                          Mosaic topology was set.
//! \retval ::NVAPI_NOT_SUPPORTED               Mosaic is not supported with the existing hardware.
//! \retval ::NVAPI_INVALID_ARGUMENT            One or more arguments passed in are invalid.
//! \retval ::NVAPI_API_NOT_INTIALIZED          The NvAPI API needs to be initialized first.
//! \retval ::NVAPI_NO_IMPLEMENTATION           This entrypoint is not available.
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION The version of the structure passed in is not
//!                                             compatible with this entrypoint.
//! \retval ::NVAPI_DATA_NOT_FOUND              There was no existing valid topology information.
//! \retval ::NVAPI_ERROR                       Miscellaneous error occurred.
//
///////////////////////////////////////////////////////////////////////////////


#define NVAPI_MOSAIC_ENUMGRIDTOPOS_FLAG_ACTIVE_ONLY       NV_BIT(0)
#define NVAPI_MOSAIC_ENUMGRIDTOPOS_FLAG_NO_VALIDATION     NV_BIT(1)

NVAPI_INTERFACE NvAPI_Mosaic_EnumGridTopologies(NvU32 index, NvU32 flags, NV_MOSAIC_GRID_TOPO *pGridTopology, NvU8* bEnabled);

//! @}



//! SUPPORTED OS:  Windows Vista and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Mosaic_GetDisplayViewportsByResolution
//
//! DESCRIPTION:     This API returns the viewports that would be applied on
//!                  the requested display.
//!
//! \param [in]      displayId       Display ID of a single display in the active
//!                                  mosaic topology to query.
//! \param [in]      srcWidth        Width of full display topology. If both
//!                                  width and height are 0, the current
//!                                  resolution is used.
//! \param [in]      srcHeight       Height of full display topology. If both
//!                                  width and height are 0, the current
//!                                  resolution is used.
//! \param [out]     viewports       Array of NV_RECT viewports which represent
//!                                  the displays as identified in
//!                                  NvAPI_Mosaic_EnumGridTopologies. If the
//!                                  requested resolution is a single-wide
//!                                  resolution, only viewports[0] will
//!                                  contain the viewport details, regardless
//!                                  of which display is driving the display.
//! \param [out]     bezelCorrected  Returns 1 if the requested resolution is
//!                                  bezel corrected. May be NULL.
//!
//! \retval ::NVAPI_OK                          Capabilties have been returned.
//! \retval ::NVAPI_INVALID_ARGUMENT            One or more args passed in are invalid.
//! \retval ::NVAPI_API_NOT_INTIALIZED          The NvAPI API needs to be initialized first
//! \retval ::NVAPI_MOSAIC_NOT_ACTIVE           The display does not belong to an active Mosaic Topology
//! \retval ::NVAPI_NO_IMPLEMENTATION           This entrypoint not available
//! \retval ::NVAPI_ERROR                       Miscellaneous error occurred
//!
//! \ingroup mosaicapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Mosaic_GetDisplayViewportsByResolution(NvU32 displayId, NvU32 srcWidth, NvU32 srcHeight, NV_RECT viewports[NV_MOSAIC_MAX_DISPLAYS], NvU8* bezelCorrected);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Mosaic_GetBezelPeeking
//
//! DESCRIPTION:     This API returns the current state of bezel peeking. Any
//!                  displayId of the current topology can be passed.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      displayId        Display ID of one of the displays in 
//!                                   the Mosaic topology.
//! \param [out]     pActive          Returns 1 if the bezel peeking is 
//!                                   active, otherwise, returns 0.
//!
//! \retval ::NVAPI_OK:                          Capabilities have been returned.
//! \retval ::NVAPI_INVALID_ARGUMENT:            One or more args passed in are invalid.
//! \retval ::NVAPI_API_NOT_INTIALIZED:          The NvAPI API needs to be initialized first
//! \retval ::NVAPI_MOSAIC_NOT_ACTIVE:           The display does not belong to an active Mosaic Topology
//! \retval ::NVAPI_NO_IMPLEMENTATION:           This entrypoint not available
//! \retval ::NVAPI_ERROR:                       Miscellaneous error occurred
//!
//! \ingroup mosaicapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Mosaic_GetBezelPeeking(NvU32 displayId, NvU8* pActive);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Mosaic_SetBezelPeeking
//
//! DESCRIPTION:     This API sets the current state of bezel peeking. Any
//!                  displayId of the current topology can be passed.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      displayId      Display ID of one of the displays in 
//!                                 the Mosaic topology.
//! \param [in]      active         Set to 1 to enable bezel peeking.
//!                                 Set to 0 to disable bezel peeking.
//!
//! \retval ::NVAPI_OK:                          Capabilties have been returned.
//! \retval ::NVAPI_INVALID_ARGUMENT:            One or more args passed in are invalid.
//! \retval ::NVAPI_API_NOT_INTIALIZED:          The NvAPI API needs to be initialized first
//! \retval ::NVAPI_MOSAIC_NOT_ACTIVE:           The display does not belong to an active Mosaic Topology
//! \retval ::NVAPI_NO_IMPLEMENTATION:           This entrypoint not available
//! \retval ::NVAPI_ERROR:                       Miscellaneous error occurred
//!
//! \ingroup mosaciapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Mosaic_SetBezelPeeking(NvU32 displayId, NvU8 active);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Mosaic_GetResolutionPruning
//
//! \fn NvAPI_Mosaic_GetResolutionPruning(NvU32 displayId, NV_MOSAIC_RESOLUTION_PRUNING *resList)
//! DESCRIPTION:     This API returns the full list of mosaic base resolutions
//!                  and whether they are visible as mosaic with and without
//!                  bezel correction.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      displayId          DisplayID of a display in the mosaic
//!                                     topology to retrieve the pruning list
//!                                     from.
//! \param [in,out]  resList            On input, only version is valid. On
//!                                     success, this structure will be filled
//!                                     with the details of all the 
//!                                     single-wide resolutions and whether
//!                                     they expose a mosaic resolution or a
//!                                     bezel-corrected mosaic resolution. 
//! 
//! retval ::NVAPI_OK:                          Capabilties have been returned.
//! retval ::NVAPI_INVALID_ARGUMENT:            One or more args passed in are invalid.
//! retval ::NVAPI_API_NOT_INTIALIZED:          The NvAPI API needs to be initialized first
//! retval ::NVAPI_NO_IMPLEMENTATION:           This entrypoint not available
//! retval ::NVAPI_ERROR:                       Miscellaneous error occurred
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup mosaicapi
#define NV_MOSAIC_RESOLUTION_PRUNING_MAX_RESOLUTIONS     100

//! \ingroup mosaicapi
typedef struct
{
    NvU32               version;                //!< Must be NV_MOSAIC_RESOLUTION_PRUNING_VER
    NvU32               count;                  //!< IN - count of calid allowedResolutions[] entries
    NvU32               skipModeEnumeration : 1; //!< IN - Skip re-enumeration of modelist. Only used during NvAPI_Mosaic_SetResolutionPruning.
    NvU32               reserved : 31;           //!< IN - Reserved, must be 0.
    struct
    {
        NvU16           width;
        NvU16           height;
        NvU32           allowMosaicResolution : 1;
        NvU32           allowBezelCorrectedMosaicResolution : 1;
        NvU32           isDefaultResolution : 1;
        NvU32           isCurrentResolution : 1;        //!< Note, this will only be set if the current resolution is the active mosaic resolution, not a base resolution
        NvU32           reserved : 28;                  //!< Reserved, must be 0
    } resolutionList[NV_MOSAIC_RESOLUTION_PRUNING_MAX_RESOLUTIONS];
} NV_MOSAIC_RESOLUTION_PRUNING;

//! \ingroup mosaicapi
#define NV_MOSAIC_RESOLUTION_PRUNING_VER1       MAKE_NVAPI_VERSION(NV_MOSAIC_RESOLUTION_PRUNING,1)
//! \ingroup mosaicapi
#define NV_MOSAIC_RESOLUTION_PRUNING_VER        NV_MOSAIC_RESOLUTION_PRUNING_VER1

//! \ingroup mosaicapi
NVAPI_INTERFACE NvAPI_Mosaic_GetResolutionPruning(NvU32 displayId, NV_MOSAIC_RESOLUTION_PRUNING *resList);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Mosaic_SetResolutionPruning
//
//! DESCRIPTION:     This API applies resolution pruning to the driver. This
//!                  list must be in the same order and size as the list 
//!                  returned by NvAPI_Mosaic_GetResolutionPruning(), or an error
//!                  will be returned. You cannot prune the current resolution
//!                  unless Mosaic is currently in single-wide or disabled.
//!
//! NOTE:            If the current active resolution is not enabled, it will
//!                  be enabled automatically.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      displayId      DisplayID of a display in the mosaic
//!                                 topology to retrieve the pruning list
//!                                 from.
//! \param [in]      resList        Details which resolutions should have
//!                                 mosaic resolutions and bezel-corrected
//!                                 mosaic resolutions exported from the
//!                                 display driver. A forced mode 
//!                                 re-enumeration will occur after the 
//!                                 change is applied.
//! 
//! \retval ::NVAPI_OK:                          Capabilities have been returned.
//! \retval ::NVAPI_INVALID_ARGUMENT:            One or more args passed in are invalid.
//! \retval ::NVAPI_API_NOT_INTIALIZED:          The NvAPI API needs to be initialized first
//! \retval ::NVAPI_NO_IMPLEMENTATION:           This entrypoint not available
//! \retval ::NVAPI_ERROR:                       Miscellaneous error occurred
//!
//! \ingroup mosaciapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Mosaic_SetResolutionPruning(NvU32 displayId, NV_MOSAIC_RESOLUTION_PRUNING *resList);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Mosaic_GetMosaicViewports
//
//! DESCRIPTION:     This API returns the viewport information for a mosaic mode
//!                  passed in by the user.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pGridTopology        A grid topology to calculate the
//!                                       viewport information. Does not need
//!                                       to be currently active.
//! \param [in]      baseWidth            Width of a single display in the 
//!                                       topology.
//! \param [in]      baseHeight           Height of a single display in the 
//!                                       topology.
//! \param [in]      bezelCorrected       If set to 1, returns the details for
//!                                       bezel corrected. If set to 0, returns
//!                                       the details without bezel correction.
//! \param [out]     totalWidth           May be NULL. If passed, will return
//!                                       the total width of the mosaic.
//! \param [out]     totalHeight          May be NULL. If passed, will return
//!                                       the total height of the mosaic.
//! \param [out]     viewports            Array will be filled in with the
//!                                       individual viewport details for
//!                                       the topology.
//! 
//! \retval ::NVAPI_OK                          Capabilities have been returned.
//! \retval ::NVAPI_INVALID_ARGUMENT            One or more args passed in are invalid.
//! \retval ::NVAPI_API_NOT_INITIALIZED         The NvAPI API needs to be initialized first
//! \retval ::NVAPI_NO_IMPLEMENTATION           This entrypoint not available
//! \retval ::NVAPI_ERROR                       Miscellaneous error occurred
//! \ingroup mosaciapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Mosaic_GetMosaicViewports(NV_MOSAIC_GRID_TOPO *pGridTopology, 
                                                NvU32 baseWidth, 
                                                NvU32 baseHeight, 
                                                NvU8 bezelCorrected, 
                                                NvU32* totalWidth, 
                                                NvU32* totalHeight, 
                                                NV_RECT viewports[NV_MOSAIC_MAX_DISPLAYS]);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Mosaic_SetDisplayGrids
//
//! DESCRIPTION:     Sets a new display topology, replacing any existing topologies
//!                  that use the same displays.
//!
//!                  This function will look for an SLI configuration that will
//!                  allow the display topology to work.
//!
//!                  To revert to a single display, specify that display as a 1x1
//!                  grid.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]      pGridTopologies    The topology details to set.
//! \param [in]      gridCount          The number of elements in the pGridTopologies array.
//! \param [in]      setTopoFlags       Zero or more of the NVAPI_MOSAIC_SETDISPLAYTOPO_FLAG_*
//!                                     flags.
//!
//!
//! \retval ::NVAPI_OK                          Capabilities have been returned.
//! \retval ::NVAPI_INVALID_ARGUMENT            One or more args passed in are invalid.
//! \retval ::NVAPI_API_NOT_INTIALIZED          The NvAPI API needs to be initialized first
//! \retval ::NVAPI_NO_IMPLEMENTATION           This entrypoint not available
//! \retval ::NVAPI_NO_ACTIVE_SLI_TOPOLOGY      No matching GPU topologies could be found.
//! \retval ::NVAPI_TOPO_NOT_POSSIBLE           One or more of the display grids are not valid.
//! \retval ::NVAPI_ERROR                       Miscellaneous error occurred
//! \ingroup mosaicapi 
///////////////////////////////////////////////////////////////////////////////


//! Do not change the current GPU topology. If the NO_DRIVER_RELOAD bit is not
//! specified, then it may still require a driver reload.
#define NV_MOSAIC_SETDISPLAYTOPO_FLAG_CURRENT_GPU_TOPOLOGY NV_BIT(0)

//! Do not allow a driver reload. That is, stick with the same master GPU as well as the
//! same SLI configuration.
#define NV_MOSAIC_SETDISPLAYTOPO_FLAG_NO_DRIVER_RELOAD     NV_BIT(1)

//! When choosing a GPU topology, choose the topology with the best performance.
//! Without this flag, it will choose the topology that uses the smallest number
//! of GPU's.
#define NV_MOSAIC_SETDISPLAYTOPO_FLAG_MAXIMIZE_PERFORMANCE NV_BIT(2)

//! Do not return an error if no configuration will work with all of the grids.
#define NV_MOSAIC_SETDISPLAYTOPO_FLAG_ALLOW_INVALID        NV_BIT(3)

NVAPI_INTERFACE NvAPI_Mosaic_SetDisplayGrids(__in_ecount(gridCount) NV_MOSAIC_GRID_TOPO *pGridTopologies, __in NvU32 gridCount, __in NvU32 setTopoFlags);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Mosaic_SetDisplayGridsWithSLI
//
//! \fn NvAPI_Mosaic_SetDisplayGridsWithSLI
//! DESCRIPTION:     Sets a new display topology, replacing any existing topologies
//!                  that use the same displays.
//!
//!                  This function will enable the given SLI configuration before
//!                  applying the display topology.
//!
//!                  To revert to a single display, specify that display as a 1x1
//!                  grid.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]      pGpuTopologies     The GPU topologies to set.
//! \param [in]      pGridTopologies    The topology details to set.
//! \param [in]      gridCount          The number of elements in the pGridTopologies array.
//!
//! \return    This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//! \retval ::NVAPI_TOPO_NOT_POSSIBLE           One or more of the display grids are not valid.
//! \ingroup mosaicapi 
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Mosaic_SetDisplayGridsWithSLI(__in NV_GPU_VALID_GPU_TOPOLOGIES *pGpuTopologies, __in_ecount(gridCount) NV_MOSAIC_GRID_TOPO *pGridTopologies, __in NvU32 gridCount);


//! \ingroup mosaicapi
//! Indicates that a display's position in the grid is sub-optimal.
#define NV_MOSAIC_DISPLAYTOPO_WARNING_DISPLAY_POSITION            NV_BIT(0)

//! \ingroup mosaicapi
//! Indicates that SetDisplaySettings would need to perform a driver reload.
#define NV_MOSAIC_DISPLAYTOPO_WARNING_DRIVER_RELOAD_REQUIRED      NV_BIT(1)

//! \ingroup mosaicapi
typedef struct
{
    NvU32 version;
    NvU32 errorFlags;            //!< (OUT) Any of the NV_MOSAIC_DISPLAYTOPO_ERROR_* flags.
    NvU32 warningFlags;          //!< (OUT) Any of the NV_MOSAIC_DISPLAYTOPO_WARNING_* flags.

    NvU32 displayCount;          //!< (OUT) The number of valid entries in the displays array.
    struct
    {
        NvU32 displayId;             //!< (OUT) The DisplayID of this display.
        NvU32 errorFlags;            //!< (OUT) Any of the NV_MOSAIC_DISPLAYCAPS_PROBLEM_* flags.
        NvU32 warningFlags;          //!< (OUT) Any of the NV_MOSAIC_DISPLAYTOPO_WARNING_* flags.

        NvU32  supportsRotation : 1; //!< (OUT) This display can be rotated
        NvU32  reserved : 31;        //!< (OUT) reserved
    } displays[NVAPI_MAX_DISPLAYS];
} NV_MOSAIC_DISPLAY_TOPO_STATUS;

//! \ingroup mosaicapi
#define NV_MOSAIC_DISPLAY_TOPO_STATUS_VER         MAKE_NVAPI_VERSION(NV_MOSAIC_DISPLAY_TOPO_STATUS,1)


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Mosaic_ValidateDisplayGridsWithSLI
//
//! \fn NvAPI_Mosaic_ValidateDisplayGridsWithSLI
//! \code
//! DESCRIPTION:     Determines if a list of grid topologies is valid.
//!
//!                  This function works the same way as NvAPI_Mosaic_ValidateDisplayGrids90, except
//!                  that the caller specifies an SLI configuration, rather than having NvAPI choose
//!                  one.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! PARAMETERS:      pGpuTopologies(IN):  The GPU topologies to use.
//!                  pGridTopologies(IN): The array of grid topologies to verify.
//!                  pTopoStatus(IN/OUT): The array of problems and warnings with each topology.
//!                  gridCount(IN):       The number of elements in the pGridTopologies and
//!                                       pTopoStatus arrays.
//!
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status.
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \ingroup mosaicapi
NVAPI_INTERFACE NvAPI_Mosaic_ValidateDisplayGridsWithSLI(__in NV_GPU_VALID_GPU_TOPOLOGIES *pGpuTopologies,
        __in_ecount(gridCount) NV_MOSAIC_GRID_TOPO *pGridTopologies,
        __inout_ecount_full(gridCount) NV_MOSAIC_DISPLAY_TOPO_STATUS *pTopoStatus,
        __in NvU32 gridCount);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Mosaic_ValidateDisplayGrids
//
//! DESCRIPTION:     Determines if a list of grid topologies is valid. It will choose an SLI
//!                  configuration in the same way that NvAPI_Mosaic_SetDisplayGrids() does.
//!
//!                  On return, each element in the pTopoStatus array will contain any errors or
//!                  warnings about each grid topology. If any error flags are set, then the topology
//!                  is not valid. If any warning flags are set, then the topology is valid, but
//!                  sub-optimal.
//!
//!                  If the ALLOW_INVALID flag is set, then it will continue to validate the grids
//!                  even if no SLI configuration will allow all of the grids. In this case, a grid
//!                  grid with no matching GPU topology will have the error
//!                  flags NO_GPU_TOPOLOGY or NOT_SUPPORTED set.
//!
//!                  If the ALLOW_INVALID flag is not set and no matching SLI configuration is
//!                  found, then it will skip the rest of the validation and return
//!                  NVAPI_NO_ACTIVE_SLI_TOPOLOGY.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]      setTopoFlags       Zero or more of the NVAPI_MOSAIC_SETDISPLAYTOPO_FLAG_*
//!                                     flags.
//! \param [in]      pGridTopologies    The array of grid topologies to verify.
//! \param [in,out]  pTopoStatus        The array of problems and warnings with each grid topology.
//! \param [in]      gridCount          The number of elements in the pGridTopologies and
//!                                     pTopoStatus arrays.
//!
//!
//! \retval ::NVAPI_OK:                          Capabilities have been returned.
//! \retval ::NVAPI_INVALID_ARGUMENT:            One or more args passed in are invalid.
//! \retval ::NVAPI_API_NOT_INTIALIZED:          The NvAPI API needs to be initialized first
//! \retval ::NVAPI_NO_IMPLEMENTATION:           This entrypoint not available
//! \retval ::NVAPI_NO_ACTIVE_SLI_TOPOLOGY:      No matching GPU topologies could be found.
//! \retval ::NVAPI_ERROR:                       Miscellaneous error occurred
//!
//! \ingroup mosaicapi 
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Mosaic_ValidateDisplayGrids(__in NvU32 setTopoFlags,
        __in_ecount(gridCount) NV_MOSAIC_GRID_TOPO *pGridTopologies,
        __inout_ecount_full(gridCount) NV_MOSAIC_DISPLAY_TOPO_STATUS *pTopoStatus,
        __in NvU32 gridCount);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Mosaic_EnumDisplayModes
//
//! DESCRIPTION:     Determines the set of available display modes for a given grid topology.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]      pGridTopology         The grid topology to use.
//! \param [in,out]  pDisplaySettings      A pointer to an array of display settings to populate,
//!                                        or NULL to find out the total number of available modes.
//! \param [in,out]  pDisplayCount         If pDisplaySettings is not NULL, then pDisplayCount
//!                                        should point to the number of elements in the
//!                                        pDisplaySettings array. On return, it will contain the
//!                                        number of modes that were actually returned. If
//!                                        pDisplaySettings is NULL, then pDisplayCount will receive
//!                                        the total number of modes that are available.
//!
//!
//! \retval ::NVAPI_OK                          Capabilities have been returned.
//! \retval ::NVAPI_INVALID_ARGUMENT            One or more args passed in are invalid.
//! \retval ::NVAPI_API_NOT_INTIALIZED          The NvAPI API needs to be initialized first
//! \retval ::NVAPI_NO_IMPLEMENTATION           This entrypoint not available
//! \retval ::NVAPI_ERROR                       Miscellaneous error occurred
//!
//! \ingroup mosaciapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Mosaic_EnumDisplayModes(__in NV_MOSAIC_GRID_TOPO *pGridTopology,
        __inout_ecount_part_opt(*pDisplayCount, *pDisplayCount) NV_MOSAIC_DISPLAY_SETTING *pDisplaySettings,
        __inout NvU32 *pDisplayCount);


//! SUPPORTED OS:  Windows 7 and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Mosaic_ChooseGpuTopologies
//
//! DESCRIPTION:     Chooses an SLI configuration for a list of grid topologies.
//!
//!                  This function will look for a valid SLI configuration that will allow
//!                  each of the grid topologies to work.
//!
//!                  On return, the displayGpuIndex field of each active GPU topology will specify
//!                  the master GPU for that topology.
//!
//!                  If the CURRENT_GPU_TOPOLOGY flag is set, then it will keep the same physical
//!                  GPU's in each logical GPU, but it may change the master GPU. If the
//!                  NO_DRIVER_RELOAD flag is set, then it will not change the current GPU topology
//!                  at all, but will still verify that the GPU topology is valid.
//!
//! \param [in]      pGridTopologies   The grid topologies to use.
//! \param [in]      gridCount         The number of elements in the pGridTopologies array.
//! \param [in]      setTopoFlags      Zero or more of the NVAPI_MOSAIC_SETDISPLAYTOPO_FLAG_*
//!                                    flags.
//! \param [out]     pGpuTopologies    The chosen SLI configuration.
//!
//!
//! \retval ::NVAPI_OK                          Capabilties have been returned.
//! \retval ::NVAPI_INVALID_ARGUMENT            One or more args passed in are invalid.
//! \retval ::NVAPI_API_NOT_INTIALIZED          The NvAPI API needs to be initialized first
//! \retval ::NVAPI_NO_IMPLEMENTATION           This entrypoint not available
//! \retval ::NVAPI_NO_ACTIVE_SLI_TOPOLOGY      No matching GPU topologies could be found.
//! \retval ::NVAPI_ERROR                       Miscellaneous error occurred
//!
//! \ingroup mosaicapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Mosaic_ChooseGpuTopologies(__in_ecount(gridCount) NV_MOSAIC_GRID_TOPO *pGridTopologies,
        __in NvU32 gridCount,
        __in NvU32 setTopoFlags,
        __inout NV_GPU_VALID_GPU_TOPOLOGIES *pGpuTopologies);


//! SUPPORTED OS:  Windows 7 and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Mosaic_EnumDisplayGrids
//
//! DESCRIPTION:     Enumerates the current active grid topologies. This includes Mosaic, IG, and
//!                  Panoramic topologies, as well as single displays.
//!
//!                  If pGridTopologies is NULL, then pGridCount will be set to the number of active
//!                  grid topologies.
//!
//!                  If pGridTopologies is not NULL, then pGridCount contains the maximum number of
//!                  grid topologies to return. On return, pGridCount will be set to the number of
//!                  grid topologies that were returned.
//!
//! \param [out]     pGridTopologies   The list of active grid topologies.
//! \param [in,out]  pGridCount        A pointer to the number of grid topologies returned.
//!
//! \retval ::NVAPI_OK                          Capabilties have been returned.
//! \retval ::NVAPI_END_ENUMERATION             There are no more topologies to return.
//! \retval ::NVAPI_INVALID_ARGUMENT            One or more args passed in are invalid.
//! \retval ::NVAPI_API_NOT_INTIALIZED          The NvAPI API needs to be initialized first
//! \retval ::NVAPI_NO_IMPLEMENTATION           This entrypoint not available
//! \retval ::NVAPI_ERROR                       Miscellaneous error occurred
//!
//! \ingroup mosaicapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Mosaic_EnumDisplayGrids(__inout_ecount_part_opt(*pGridCount, *pGridCount) NV_MOSAIC_GRID_TOPO *pGridTopologies,
        __inout NvU32 *pGridCount);

//! SUPPORTED OS:  Windows XP and higher
//!
 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Mosaic_EnumPossibleConfigs
//
//! \fn NvAPI_Mosaic_EnumPossibleConfigs(NV_MOSAIC_CONFIG* configs, NvU32* configCount, NvU32* maxConfigCount, NV_MOSAIC_CONFIG_FILTER* filter, NvU32 flags)
//! DESCRIPTION:                     This API retrieves the list of possible configs for Mosaic.
//!
//! \param [in,out]  configs         Array of configurations, passed by the caller, to be filled in with the requested
//!                                  data. If the array is too small, the call will report *configCount smaller than 
//!                                  *maxConfigCount. On input, only version is required to be set. If using with 
//!                                  filters, then appropriate fields must be filled in, as defined by the valid filters.
//!                                  This API only reads input from the 0th element of the array. On return, these configs
//!                                  are sorted to return configurations from best configuration to worst configuration. 
//!                                  Newer board architectures take priority over older board architectures, then number
//!                                  of GPUs.
//!
//! \param [in,out]  configCount     On input, the length of the array of configs. On return, contains the number of
//!                                  valid entries in the configs array. If this field is zero, an error is returned
//!                                  and the required length is provided in maxConfigCount. If maxConfigCount is NULL and
//!                                  configCount is 0 (or configs == NULL), an invalid parameter error will be returned.
//!
//! \param [out]    maxConfigCount   On return, this field will contain the maximum number of configs which would be
//!                                  returned. If this number is greater than *configCount, the API has only returned
//!                                  a subset of the configurations. This field is optional, and may be NULL.
//!
//! \param [in]     filter           Either one of the predefined filters (NV_MOSAIC_FILTER_*) or a pointer to the filter
//!                                  structure which defines how to filter the results. If this is NULL, all possible
//!                                  results are returned.
//!
//! \param [in]     flags            A bitmask of NV_MOSAIC_FLAGS_* entries to control the behavior of this API
//!
//! Notes:
//!  The filters are used to control which entries are returned. If no GPU list is provided, the API will only return 
//! up to a single valid and a single invalid configuration per GPU topology. If the GPU topology is provided, the API 
//! will return one configuration 
//! per displayCount. The elements returned will always favor valid over rewire, and rewire over invalid. 
//!
//! \retval ::NVAPI_INSUFFICIENT_BUFFER     The configCount is less than the required size. configCount will be set to the required size.
//! \retval ::NVAPI_END_ENUMERATION         The requested configurations results in no results.
//!
//! \ingroup mosaicapi
///////////////////////////////////////////////////////////////////////////////
 
//! \ingroup mosaicapi
typedef struct {
    NvU32 version;                                          //!< Version of filter structure

    NvU32 isValid : 1;                                      //!< If true, only return configurations which require no hardware changes to apply. A driver reload may still be required
    NvU32 includesDisplays : 1;                             //!< If true, the displayIds array contains displays which must be part of the configuration to be returned
    NvU32 excludesDisplays : 1;                             //!< If true, the displayIds array contains displays which must not be part of the configuration to be returned
    NvU32 includesGpus     : 1;                             //!< If true, only return configurations which include GPUs specified in the gpus array
    NvU32 excludesGpus     : 1;                             //!< If true, only return configurations which do not include GPUs specified in the gpus array
    NvU32 supportsSurround : 1;                             //!< If true, only return configurations which support surround
    NvU32 supportsMosaic   : 1;                             //!< If true, only return configurations which support mosaic
    NvU32 noReloadRequired : 1;                             //!< If true, only return configurations which do not require a driver reload to apply. This implies isValid
    NvU32 noRewireRequired : 1;                             //!< If true, only return configurations which do not require displays to be moved to a different GPU. This implies isValid
    NvU32 noBridgeChangeRequired : 1;                       //!< If true, only return configurations which do not require an SLI bridge to be added or moved
 
    NvU32 reserved : 22;                                    //!< Reserved, must be 0
 
    // Displays
    NvS32 minDisplayCount;                                  //!< The minimum number of displays required. Ignored if 0. 
    NvS32 maxDisplayCount;                                  //!< The maximum number of displays required. Ignored if 0.
    NvU32 suppliedDisplays;                                 //!< The number of valid elements in the displayIds array. Ignored unless includesDisplays or excludesDisplays is true
    NvU32 displayIds[NV_MOSAIC_MAX_DISPLAYS];               //!< An array of displayIds, used by includesDisplays and excludesDisplays
 
    // GPUs
    NvS32 minGpuCount;                                      //!< The minimum number of GPUs required. Ignored if 0.
    NvS32 maxGpuCount;                                      //!< The maximum number of GPUs required. Ignored if 0.
    NvU32 suppliedGpus;                                     //!< The number of valid elements in the gpus array. Ignored unless includesGpus or excludesGpus is true
    NvPhysicalGpuHandle gpus[NVAPI_MAX_GPU_PER_TOPOLOGY];   //!< An array of gpu handles, used by includesGpus and excludesGpus
} NV_MOSAIC_CONFIG_FILTER;
 
//! \ingroup mosaicapi
//! @{
#define NV_MOSAIC_FILTER_NONE               ((NV_MOSAIC_CONFIG_FILTER*) 0)  //!< Same as NULL, request all configurations
#define NV_MOSAIC_FILTER_VALID              ((NV_MOSAIC_CONFIG_FILTER*) 1)  //!< Use in place of NV_MOSAIC_CONFIG_FILTER to simplify requesting all valid topologies
#define NV_MOSAIC_FILTER_SURROUND           ((NV_MOSAIC_CONFIG_FILTER*) 2)  //!< Use in place of NV_MOSIAC_CONFIG_FILTER to simplify requesting all surround topologies
#define NV_MOSAIC_FILTER_MOSAIC             ((NV_MOSAIC_CONFIG_FILTER*) 3)  //!< Use in place of NV_MOSAIC_CONFIG_FILTER to simplify requesting all mosaic topologies
 
#define NV_MOSAIC_CONFIG_FILTER_VER1        MAKE_NVAPI_VERSION(NV_MOSAIC_CONFIG_FILTER, 1)
#define NV_MOSAIC_CONFIG_FILTER_VER         NV_MOSAIC_CONFIG_FILTER_VER1
 
 
#define NV_MOSAIC_FLAGS_CACHED          NV_BIT(0)   //!< This causes the API to use cached information about the GPUs and displays. It is recommended that the first call in a series not use the cached flag, then subsequent calls in a series use this flag to reduce the number of queries done to the hardware. Cached mode is not thread safe against uncached mode, so it is up to the caller to ensure that while one thread is using cached mode, no other thread makes an uncached query.
//! @}
 
//! \ingroup mosaicapi
//! @{
typedef struct {
    NvU32 displayId;                    //!< (OUT) The displayId associated to the display details
    NvU32 problemFlags;                 //!< (OUT) A bitmask of different problems associated with use of this display in the detailed configuration (See NV_MOSAIC_DISPLAYCAPS_PROBLEM_* for list of problem flags)
    NvU32 requiredGpuId;                //!< (OUT) The GPU to have this display connected to for this display topology. This will be 0 if problemFlags does not contain NV_MOSAIC_DISPLAYCAPS_PROBLEM_DISPLAY_ON_INVALID_GPU
    NvU32 requiredConnector;            //!< (OUT) The connector for which this display must be connected for this display topology. This will be 0 if problemFlags does not contain NV_MOSAIC_DISPLAYCAPS_PROBLEM_DISPLAY_ON_WRONG_CONNECTOR
 
    NvU32 supportsSingleRotation : 1;   //!< (OUT) This display can be rotated independently of the rest of the displays in the configuration
    NvU32 supportsUniqueSettings : 1;   //!< (OUT) This display can have display settings (resolution/timing) independently of the rest of the displays in the configuration
    NvU32 canBePrimary : 1;             //!< (OUT) This display can be the primary display of the Mosaic/Surround topology

    NvU32 reserved : 29;                //!< (OUT) Reserved
} NV_MOSAIC_CONFIG_DISPLAY;


typedef struct {
    NvU32 version;

    // Displays
    NvU32 displayCount;                 //!< (OUT) The number of displays in this configuration
    NV_MOSAIC_CONFIG_DISPLAY displays[NV_MOSAIC_MAX_DISPLAYS];  //!< (OUT) List of displays, in arbitrary order
 
    // GPU Topology
    NV_GPU_TOPOLOGY gpuTopology;        //!< (OUT) The GPU topology for this configuration. For a single-GPU topology, this will be filled with 0
    NvU32 problemFlags;                 //!< (OUT) A bitmask of different problems associated with use of this configuration (See NV_MOSAIC_DISPLAYCAPS_PROBLEM_* for list of problem flags)
 
    // Single bit settings
    NvU32 mosaic : 1;                   //!< (OUT) This configuration is a Mosaic configuration
    NvU32 surround : 1;                 //!< (OUT) This configuration is a Surround configuration
    NvU32 supportsRotation : 1;         //!< (OUT) This configuration supports all displays rotated the same way (Portrait or Landscape)
    NvU32 supportsPassiveStereo : 1;    //!< (OUT) This configuration supports passive stereo
 
    NvU32 reserved : 28;                //!< (OUT) Reserved
 
} NV_MOSAIC_CONFIG;
//! @}

#define NV_MOSAIC_CONFIG_VER1           MAKE_NVAPI_VERSION(NV_MOSAIC_CONFIG, 1)
#define NV_MOSAIC_CONFIG_VER            NV_MOSAIC_CONFIG_VER1

//! \ingroup mosaicapi
NVAPI_INTERFACE NvAPI_Mosaic_EnumPossibleConfigs(NV_MOSAIC_CONFIG* configs, NvU32* configCount, NvU32* maxConfigCount, NV_MOSAIC_CONFIG_FILTER* filter, NvU32 flags);


//! SUPPORTED OS:  Windows XP and higher
//!
 
//! \ingroup mosaicapi
//! @{
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Mosaic_GetResolutions
//! \fn NvAPI_Mosaic_GetResolutions(__in NvU32 displayId, __inout_ecount(*resListCount) NV_MOSAIC_RESOLUTION* resList, __inout NvU32* resListCount, __in_opt NV_MOSAIC_GRID_TOPO* pGridTopo)
//! DESCRIPTION:    This API returns an array of resolutions for a grid topology.
//!
//!                 If no predictive grid topology is provided, the current grid
//!                 topology is returned.
//!
//!                 If a predictive grid topology is provided, that topology is
//!                 used to calculate the answers. This list will not set the
//!                 defaultResolution or isVisible bits.
//!
//!                 To retrieve the number of resolutions, resList must be NULL and
//!                 resListCount must be set to 0.
//!
//! \param [in]     displayId        Any displayId of the mosaic topology in question
//!
//! \param [in,out] resList          The array of resolutions
//!
//! \param [in,out] resListCount     On input, the length of the array of resolutions. On return, contains the number of
//!                                  valid resolutions. If the array is too small, an error is returned
//!                                  and the required length is provided in resListCount.
//!
//! \param [in]     pGridTopo        May provide a grid topology to return the results against. displayId must be one of
//!                                  the displays provided in the grid topology. This argument may be NULL, in which case
//!                                  the currently applied grid topology, active or not, will be used.
//!
//! \retval ::NVAPI_INSUFFICIENT_BUFFER     The configCount is less than the required size. configCount will be set to the required size.
//!
///////////////////////////////////////////////////////////////////////////////

typedef struct 
{
    NvU32                       version;                //!< Version of this structure
    NvU32                       width;                  //!< Per-display width
    NvU32                       height;                 //!< Per-display height
    NvU32                       freq;                   //!< Display frequency
    NvU32                       singleWide : 1;         //!< This resolution is a single-wide resolution
    NvU32                       mosaic : 1;             //!< This resolution is a mosaic or surround resolution
    NvU32                       bezelCorrected : 1;     //!< This resolution has bezel correction
    NvU32                       defaultResolution : 1;  //!< This resolution is a default resolution
    NvU32                       isVisible : 1;          //!< This resolution is visible
	NvU32                       isPreferred : 1;        //!< This resolution is preferred. This could only be used as an out parameter in NvAPI_Mosaic_GetResolutions.
    NvU32                       reserved : 26;          //!< Reserved
} NV_MOSAIC_RESOLUTION;

#define NV_MOSAIC_RESOLUTION_VER1       MAKE_NVAPI_VERSION(NV_MOSAIC_RESOLUTION, 1)
#define NV_MOSAIC_RESOLUTION_VER        NV_MOSAIC_RESOLUTION_VER1

NVAPI_INTERFACE NvAPI_Mosaic_GetResolutions(__in NvU32 displayId, __inout_ecount(*resListCount) NV_MOSAIC_RESOLUTION* resList, __inout NvU32* resListCount, __in_opt NV_MOSAIC_GRID_TOPO* pGridTopo);
//! @}
 
//! SUPPORTED OS:  Windows XP and higher
//!
 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Mosaic_SetResolutions
//
//! DESCRIPTION:    This API allows setting the isVisible flags on a grid topology. All other
//!                 fields must be the same as the NvAPI_Mosaic_GetResolutions API call reports.
//!
//! \param [in]     displayId        Any displayId of the mosaic topology in question
//!
//! \param [in]     resList          The array of resolutions
//!
//! \param [inout]  resListCount     The length of the array of resolutions.
//!
//! \retval ::NVAPI_INSUFFICIENT_BUFFER     The configCount is less than the required size. configCount will be set to the required size.
//!
//! \ingroup mosaicapi
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_Mosaic_SetResolutions(__in NvU32 displayId, __in_ecount(resListCount) NV_MOSAIC_RESOLUTION* resList, __in NvU32 resListCount);



////////////////////////////////////////////////////////////////////////////////////////
//
// ###########################################################################
// DELME_RUSS - DELME_RUSS - DELME_RUSS - DELME_RUSS - DELME_RUSS - DELME_RUSS
//
//   Below is the Phase 1 Mosaic stuff, the Phase 2 stuff above is what will remain
//   once Phase 2 is complete.  For a small amount of time, the two will co-exist.  As
//   soon as apps (nvapichk, NvAPITestMosaic, and CPL) are updated to use the Phase 2
//   entrypoints, the code below will be deleted.
//
// DELME_RUSS - DELME_RUSS - DELME_RUSS - DELME_RUSS - DELME_RUSS - DELME_RUSS
// ###########################################################################
//
// Supported topos 1x4, 4x1 and 2x2 to start with.
// 
// Selected scan out targets can be one per GPU or more than one on the same GPU.
//
// SAMPLE of MOSAIC 1x4 SCAN OUT TOPO with 8 pixel horizontal overlap
//
//+-------------------------++-------------------------++-------------------------++-------------------------+
//|                         ||                         ||                         ||                         |
//|                         ||                         ||                         ||                         |
//|                         ||                         ||                         ||                         |
//|        DVI1             ||           DVI2          ||         DVI3            ||          DVI4           |
//|                         ||                         ||                         ||                         |
//|                         ||                         ||                         ||                         |
//|                         ||                         ||                         ||                         |
//|                         ||                         ||                         ||                         |
//+-------------------------++-------------------------++-------------------------++-------------------------+


//! \addtogroup mosaicapi
//! @{

//! Used in NV_MOSAIC_TOPOLOGY.
#define NVAPI_MAX_MOSAIC_DISPLAY_ROWS       8

//! Used in NV_MOSAIC_TOPOLOGY.
#define NVAPI_MAX_MOSAIC_DISPLAY_COLUMNS    8 

//! Used in NV_MOSAIC_TOPOLOGY.
#define NVAPI_MAX_MOSAIC_TOPOS              16

//! Used in NvAPI_GetCurrentMosaicTopology() and NvAPI_SetCurrentMosaicTopology().
typedef struct 
{
    NvU32 version;                             //!< Version number of the mosaic topology
    NvU32 rowCount;                            //!< Horizontal display count
    NvU32 colCount;                            //!< Vertical display count

    struct 
    {
        NvPhysicalGpuHandle hPhysicalGPU;      //!< Physical GPU to be used in the topology
        NvU32               displayOutputId;   //!< Connected display target
        NvS32               overlapX;          //!< Pixels of overlap on the left of target: (+overlap, -gap)
        NvS32               overlapY;          //!< Pixels of overlap on the top of target: (+overlap, -gap)

    } gpuLayout[NVAPI_MAX_MOSAIC_DISPLAY_ROWS][NVAPI_MAX_MOSAIC_DISPLAY_COLUMNS];

} NV_MOSAIC_TOPOLOGY;

//! Used in NV_MOSAIC_TOPOLOGY.
#define NVAPI_MOSAIC_TOPOLOGY_VER         MAKE_NVAPI_VERSION(NV_MOSAIC_TOPOLOGY,1)

//! Used in NvAPI_GetSupportedMosaicTopologies().
typedef struct 
{
    NvU32                   version;                                    
    NvU32                   totalCount;                     //!< Count of valid topologies
    NV_MOSAIC_TOPOLOGY      topos[NVAPI_MAX_MOSAIC_TOPOS];  //!< Maximum number of topologies

} NV_MOSAIC_SUPPORTED_TOPOLOGIES;

//! Used in NV_MOSAIC_SUPPORTED_TOPOLOGIES. 
#define NVAPI_MOSAIC_SUPPORTED_TOPOLOGIES_VER         MAKE_NVAPI_VERSION(NV_MOSAIC_SUPPORTED_TOPOLOGIES,1)

//!@}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GetSupportedMosaicTopologies
//
//! DESCRIPTION:     This API returns all valid Mosaic topologies.
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 177
//!
//! \param [out] pMosaicTopos                   An array of valid Mosaic topologies.
//!
//! \retval      NVAPI_OK                       Call succeeded; 1 or more topologies were returned
//! \retval      NVAPI_INVALID_ARGUMENT         One or more arguments are invalid
//! \retval      NVAPI_MIXED_TARGET_TYPES       Mosaic topology is only possible with all targets of the same NV_GPU_OUTPUT_TYPE.
//! \retval      NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found
//! \retval      NVAPI_NOT_SUPPORTED            Mosaic is not supported with GPUs on this system.
//! \retval      NVAPI_NO_ACTIVE_SLI_TOPOLOGY   SLI is not enabled, yet needs to be, in order for this function to succeed.
//!
//! \ingroup     mosaicapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetSupportedMosaicTopologies(NV_MOSAIC_SUPPORTED_TOPOLOGIES *pMosaicTopos);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GetCurrentMosaicTopology
//
//! DESCRIPTION:     This API gets the current Mosaic topology.
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 177
//!
//! \param [out] pMosaicTopo                    The current Mosaic topology
//! \param [out] pEnabled                       TRUE if returned topology is currently enabled, else FALSE
//!
//! \retval      NVAPI_OK                       Call succeeded
//! \retval      NVAPI_INVALID_ARGUMENT         One or more arguments are invalid
//! \retval      NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found
//! \retval      NVAPI_NOT_SUPPORTED            Mosaic is not supported with GPUs on this system.
//! \retval      NVAPI_NO_ACTIVE_SLI_TOPOLOGY   SLI is not enabled, yet needs to be, in order for this function to succeed.
//!
//! \ingroup     mosaicapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetCurrentMosaicTopology(NV_MOSAIC_TOPOLOGY *pMosaicTopo, NvU32 *pEnabled);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_SetCurrentMosaicTopology
//
//! DESCRIPTION:     This API sets the Mosaic topology, and enables it so that the
//!                  Mosaic display settings are enumerated upon request.
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 177
//!
//! \param [in]  pMosaicTopo                    A valid Mosaic topology
//!
//! \retval      NVAPI_OK                       Call succeeded
//! \retval      NVAPI_INVALID_ARGUMENT         One or more arguments are invalid
//! \retval      NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found
//! \retval      NVAPI_NOT_SUPPORTED            Mosaic is not supported with GPUs on this system.
//! \retval      NVAPI_NO_ACTIVE_SLI_TOPOLOGY   SLI is not enabled, yet needs to be, in order for this function to succeed.
//!
//! \ingroup     mosaicapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetCurrentMosaicTopology(NV_MOSAIC_TOPOLOGY *pMosaicTopo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_EnableCurrentMosaicTopology
//
//! DESCRIPTION:    This API enables or disables the current Mosaic topology. 
//!                 When enabling, the last Mosaic topology will be set.
//!
//!                  - If enabled, enumeration of display settings will include valid Mosaic resolutions.  
//!                  - If disabled, enumeration of display settings will not include Mosaic resolutions.
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 177
//!
//! \param [in]  enable                         TRUE to enable the Mosaic Topology, FALSE to disable it.
//!
//! \retval      NVAPI_OK                       Call succeeded
//! \retval      NVAPI_INVALID_ARGUMENT         One or more arguments are invalid
//! \retval      NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found
//! \retval      NVAPI_NOT_SUPPORTED            Mosaic is not supported with GPUs on this system.
//! \retval      NVAPI_NO_ACTIVE_SLI_TOPOLOGY   SLI is not enabled, yet needs to be, in order for this function to succeed.
//!
//! \ingroup     mosaicapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_EnableCurrentMosaicTopology(NvU32 enable);


///////////////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_Mosaic_GetSymmetricOrderedDisplayIds
//
//! DESCRIPTION: This API is independent of the topology or the grid. It returns symmetric ordered display IDs for all possible outputs on the GPU.
//!              Displays on the same index of the display ID array for two GPUs can be a part of the mosaic topology since they are symmetric.
//!              In case of DPMST, it will return entries for each unique auxiliary address present in the stream. Each connected display ID is
//!              identified with the isConnected flag.
//! HOW TO USE: 1. The first call should be made to get the all display ID count. To get the display ID count, send in 
//!                  a) hPhysicalGpu    - a valid GPU handle(enumerated using NvAPI_EnumPhysicalGPUs()) as input,      
//!                  b) pDisplayIds     - NULL, as we just want to get the display ID count.                            
//!                  c) pDisplayIdCount - a valid pointer to NvU32, whose value is set to ZERO.                        
//!                If all parameters are correct and this call is successful, this call will return the display ID's count. 
//!             2. To get the display ID array, make the second call to NvAPI_Mosaic_GetSymmetricOrderedDisplayIds() with   
//!                  a) hPhysicalGpu    - should be same value which was sent in first call,                           
//!                  b) pDisplayIds     - pointer to the display ID array allocated by caller based on display ID count,   
//!                                       eg. malloc(sizeof(NV_GPU_DISPLAYIDS) * pDisplayIdCount).                     
//!                  c) pDisplayIdCount - a valid pointer to NvU32. This indicates for how many display IDs            
//!                                       the memory is allocated(pDisplayIds) by the caller.                         
//!                If all parameters are correct and this call is successful, this call will return the display ID array and actual
//!                display ID count (which was obtained in the first call to NvAPI_Mosaic_GetSymmetricOrderedDisplayIds).
//!                If the input display ID count is  less than the actual display ID count, it will overwrite the input and give the
//!                pDisplayIdCount as actual count and the API will return NVAPI_INSUFFICIENT_BUFFER.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]     hPhysicalGpu         GPU selection.
//! \param [in,out] DisplayIds           Pointer to an array of NV_GPU_DISPLAYIDS structures, each entry represents one displayID 
//!                                      and its attributes.
//! \param [in,out] pDisplayIdCount      As input, this parameter indicates the number of display's id's for which caller has 
//!                                      allocated the memory. As output, it will return the actual number of display IDs.
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \retval  NVAPI_INSUFFICIENT_BUFFER  When the input buffer(pDisplayIds) is less than the actual number of display IDs, this API 
//!                                     will return NVAPI_INSUFFICIENT_BUFFER. 
//!
//! \ingroup mosaicapi
////////////////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Mosaic_GetSymmetricOrderedDisplayIds(__in NvPhysicalGpuHandle hPhysicalGpu, __inout_ecount_part_opt(*pDisplayIdCount, *pDisplayIdCount) NV_GPU_DISPLAYIDS* pDisplayIds, __inout NvU32* pDisplayIdCount);


typedef enum _NV_SPAN_CONFIG_FLAGS
{
    NV_SPAN_CONFIG_NONE                              = 0x00000000,
    NV_SPAN_CONFIG_GET_PREFERRED_CONFIG              = 0x00000001,
    NV_SPAN_CONFIG_GET_SURFACE_LOGICAL_RESOLUTION    = 0x00000002,
} NV_SPAN_CONFIG_FLAGS;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Mosaic_GetDisplayPhysicalArrangement
//
//! DESCRIPTION:    This API maps the passed displays in the physical coordiante space (display height, width, rotation, position) of the driver.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \since Release: 343
//!
//! \param [in,out]  pTopoDisplays          array of NV_MOSAIC_TOPO_DISPLAY conatining the displayIds as input
//! \param [in]      displayCount           number of elements in the input array
//!
//! \return    This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//!
//! \ingroup     mosaicapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Mosaic_GetDisplayPhysicalArrangement(__in_ecount(displayCount) NV_MOSAIC_GRID_TOPO_DISPLAY *pTopoDisplays, __in NvU32 displayCount);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Mosaic_GetPossibleConfig
//
//! DESCRIPTION:    This API get the default/recommended bookend display config for the given set of displays.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \since Release: 343
//!
//! \param [in,out]  pGridTopo    Contains the displays for which we what to query possible config.
//! \param [in]      flag         Flags as defined in NV_SPAN_CONFIG_FLAGS. Set only one of them.   
//!
//! \return    This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//!
//! \ingroup     mosaicapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Mosaic_GetPossibleConfig(__inout NV_MOSAIC_GRID_TOPO *pGridTopo, __in NvU32 flag);


//! \ingroup viscompapi
//! @{
#define NVAPI_MAX_GPUS_PER_VISUAL_COMPUTING_DEVICE    8
#define NVAPI_MAX_VISUAL_COMPUTING_DEVICES            8
#define NVAPI_MAX_HIC_DEVICES                         4
//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_EnumVisualComputingDevices
//
//!   DESCRIPTION: This API returns an array of Visual Computing Device handles. A Visual Computing Device handle
//!                represents one or more GPUs acting in concert as a single Visual Computing Device.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 180
//!
//! \param [out]  nvComputeHandles   The caller provides an array of handles, which must contain at least 
//!                                  NVAPI_MAX_VISUAL_COMPUTING_DEVICES elements. The API will zero out the entire array, 
//!                                  and then fill in one or more handles. If an error occurs, the array is invalid.
//! \param [out] *pSystemCount       The caller provides the storage space. NvAPI_EnumVisualComputingDevices sets *pSystemCount
//!                                  to indicate how many of the elements in the nvComputeHandles[] array are valid.
//!
//! \retval ::NVAPI_INVALID_ARGUMENT           nvComputingHandle or pSystemCount is NULL.
//! \retval ::NVAPI_OK                         One or more handles were returned.
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND    The queried Graphics system does not have any Visual Computing Device.
//! \retval ::NVAPI_ERROR 
//!
//! \ingroup viscompapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_EnumVisualComputingDevices(NvVisualComputingDeviceHandle nvComputeHandles[NVAPI_MAX_VISUAL_COMPUTING_DEVICES], NvU32 *pSystemCount);


//! \ingroup viscompapi
//! Used in _NV_VISUAL_COMPUTING_DEVICE_INFO.
typedef enum _NV_VISUAL_COMPUTING_DEVICE_PERFORMANCE_MODE
{
    NV_VISUAL_COMPUTING_DEVICE_PERFORMANCE_MODE_ON = 1,
    NV_VISUAL_COMPUTING_DEVICE_PERFORMANCE_MODE_OFF = 2,
    NV_VISUAL_COMPUTING_DEVICE_PERFORMANCE_MODE_NOT_SUPPORTED = -1,

} NV_VISUAL_COMPUTING_DEVICE_PERFORMANCE_MODE;


//! \ingroup viscompapi
//! Used in NvAPI_VCD_GetDeviceInfo().
typedef struct _NV_VISUAL_COMPUTING_DEVICE_INFO
{
    NvU32                               version;
    NvAPI_LongString                    productName;
    NvAPI_LongString                    serialNumber;
    NvAPI_ShortString                   firmwareVersion;                    //!< major number.minor number
    NvU32                               buildDateYear;                      //!< Build date: year the system was built.
    NvU32                               buildDateWeek;                      //!< Build date: week the system was built.
    NvAPI_ShortString                   hardwareVersion;                    //!< Version of the hardware spin
    NV_VISUAL_COMPUTING_DEVICE_PERFORMANCE_MODE  perfMode;                  //!< System performance mode

    NvPhysicalGpuHandle gpuHandle[NVAPI_MAX_GPUS_PER_VISUAL_COMPUTING_DEVICE];//!< Associated physical GPU handles.

} NV_VISUAL_COMPUTING_DEVICE_INFO;




//! \ingroup viscompapi
//! Macro for constructing the version field of  _NV_VISUAL_COMPUTING_DEVICE_INFO, 
#define NV_VISUAL_COMPUTING_DEVICE_INFO_VER  MAKE_NVAPI_VERSION(NV_VISUAL_COMPUTING_DEVICE_INFO,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_VCD_GetDeviceInfo
//
//!   DESCRIPTION: This API returns Visual Computing Device information.
//!
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 180
//!
//! \param [in]    nvComputingHandle  The enumerated Visual Computing Device handle retrieved from NvAPI_EnumVisualComputingDevices.
//! \param [out]   pVisInfo           Contains the retrieved Visual Computing Device information with the associated GPU handles.
//!                                   pVisInfo->version needs to be set to ::NV_VISUAL_COMPUTING_DEVICE_INFO_VER for the API to succeed.
//!
//! \retval ::NVAPI_INVALID_ARGUMENT        nvComputingHandle or pVisInfo is NULL
//! \retval ::NVAPI_OK
//! \retval ::NVAPI_ERROR
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND The queried Graphics system does not have any Visual Computing Device.
//!
//! \ingroup viscompapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_VCD_GetDeviceInfo(NvVisualComputingDeviceHandle nvComputingHandle, NV_VISUAL_COMPUTING_DEVICE_INFO *pVisInfo);







//! \addtogroup viscompapi
//! @{

typedef enum _NV_HIC_TYPE
{
    NV_HIC_TYPE_UNKNOWN = 0, //!< HIC type unknown.
    NV_HIC_TYPE_SHIC       , //!< Single HIC.
    NV_HIC_TYPE_DOHIC      , //!< Dual HIC.
    NV_HIC_TYPE_GHIC         //!< Graphics HIC.
} NV_HIC_TYPE;

typedef struct _NV_VCD_TOPOLOGY_TARGET
{
    NvU32                         version;
    NvVisualComputingDeviceHandle nvComputingHandle; //!<Visual Computing Device handle
    NvU32                         gpuCount;
    NvPhysicalGpuHandle           nvGpuHandles[NVAPI_MAX_GPUS_PER_VISUAL_COMPUTING_DEVICE]; //!< associated physical gpu handles.
} NV_VCD_TOPOLOGY_TARGET;

//! Macro for constructing the version field of ::NV_VCD_TOPOLOGY_TARGET
#define NV_VCD_TOPOLOGY_TARGET_VER  MAKE_NVAPI_VERSION(NV_VCD_TOPOLOGY_TARGET,1)

typedef struct _NV_HIC_TOPOLOGY
{
    NvU32                       version;
    NvHICHandle                 nvHICHandle;
    NvU32                       vcdCount; //VCD target count associated with this HIC
    NV_VCD_TOPOLOGY_TARGET      vcdTarget[NVAPI_MAX_VISUAL_COMPUTING_DEVICES]; //Array of VCD's associated with one HIC
    NV_HIC_TYPE                 nvHICType;
} NV_HIC_TOPOLOGY;

//! Macro for constructing the version field of ::NV_HIC_TOPOLOGY
#define NV_HIC_TOPOLOGY_VER  MAKE_NVAPI_VERSION(NV_HIC_TOPOLOGY,1)

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_HIC_QueryTopology
//
//! \code
//!   DESCRIPTION: Returns Topology of Host Interface Cards presented in a system, for each HIC returns associated Visual Computing Devices and corresponding GPU's.
//!
//!   PARAMETERS:  nvHICTopologies[OUT] - The caller provides an array of HICTopologies. Topology contains number of HIC's 
//!                                       presented in the system, for each HIC returns associated Visual Computing Devices and corresponding GPU handles.
//!                pTopoCount[OUT] - The caller provides the storage space. *pTopoCount indicates how many of the elements in the nvHICTopologies are valid.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! RETURN STATUS: NVAPI_INVALID_ARGUMENT: nvHICTopologies or pTopoCount is NULL
//!                NVAPI_OK: nvHICTopologies was populated.
//!                NVAPI_ERROR: the operation failed.
//!                NVAPI_NVIDIA_DEVICE_NOT_FOUND: The queried Graphics system does not have any Host Interface Card.
//! \endcode
//! \ingroup viscompapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_HIC_QueryTopology(NV_HIC_TOPOLOGY nvHICTopologies[NVAPI_MAX_HIC_DEVICES], NvU32 *pTopoCount);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_VCD_UpdatePerformanceMode
//
//!   DESCRIPTION: This API enables or disables the Visual Computing Device high performance mode.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 180
//!
//! \param [in]   nvComputingHandle   The enumerated Visual Computing Device handle retrieved from NvAPI_EnumVisualComputingDevices().
//! \param [in]   systemPerfMode      The valid value to switch to the new performance mode.
//!
//! \retval ::NVAPI_INVALID_ARGUMENT  Any values other than NV_VISUAL_COMPUTING_DEVICE_PERFORMANCE_MODE_ON
//!                                   and NV_VISUAL_COMPUTING_DEVICE_PERFORMANCE_MODE_OFF are invalid.
//! \retval ::NVAPI_OK               
//! \retval ::NVAPI_NOT_SUPPORTED     This controller does not support performance mode.
//! \retval ::NVAPI_ERROR
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND  The queried Graphics system does not have any Visual Computing Device.
//!
//! \ingroup viscompapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_VCD_UpdatePerformanceMode(NvVisualComputingDeviceHandle nvComputingHandle, NV_VISUAL_COMPUTING_DEVICE_PERFORMANCE_MODE systemPerfMode);



//! \addtogroup viscompapi
//! @{
#define NV_POWER_SUPPLY_STATE_NORMAL                    0x00000001    //!< Normal operation
#define NV_POWER_SUPPLY_STATE_ABNORMAL                  0x00000002    //!< Power Shut down
//Additional Abnormal power states
#define NV_POWER_SUPPLY_STATE_ABNORMAL_HIGH_VOLTAGE     0x00000008    //!< Output shutdown due to high-voltage
#define NV_POWER_SUPPLY_STATE_ABNORMAL_FAN_FAILURE      0x00000010    //!< Fan failure
#define NV_POWER_SUPPLY_STATE_ABNORMAL_HEATSINK         0x00000040    //!< Alarm - "Heatsink over temperature"
#define NV_POWER_SUPPLY_STATE_ABNORMAL_LIMIT_REACHED    0x00000080    //!< Current limit reached
#define NV_POWER_SUPPLY_STATE_ABNORMAL_OUTPUT_THRESHOLD 0x00000100    //!< Output voltage below UV alarm threshold
#define NV_POWER_SUPPLY_STATE_ABNORMAL_LOW_VOLTAGE      0x00000200    //!< Output shut down due to low-voltage
#define NV_POWER_SUPPLY_STATE_ABNORMAL_I2C_REMOTE_OFF   0x00001000    //!< Shutdown due to I2C remote off command
#define NV_POWER_SUPPLY_STATE_ABNORMAL_DISABLE          0x00002000    //!< Shutdown due to MOD_DISABLE input
#define NV_POWER_SUPPLY_STATE_ABNORMAL_SHORT_PIN        0x00004000    //!< Shutdown due to short pin transition
//! @}

//! \ingroup viscompapi
//! Used in _NV_POWER_SUPPLY_INFO,
typedef enum _NV_POWER_SUPPLY_TYPE
{
    NV_POWER_SUPPLY_VALERE = 1,
    NV_POWER_SUPPLY_DELTA,

} NV_POWER_SUPPLY_TYPE;


//! \ingroup viscompapi
//! Used in NvAPI_VCD_GetPowerSupplyInfo().
typedef struct _NV_POWER_SUPPLY_INFO
{
    NvU32                   version;
    NV_POWER_SUPPLY_TYPE    psuType;    //!< Power supply make
    NvU32                   voltage;    //!< in volts
    NvU32                   current;    //!< in amps
    NvU32                   stateFlags; //!< One or more power state flags - normal or abnormal

} NV_POWER_SUPPLY_INFO;




//! \ingroup viscompapi
//! Macro for constructing the version field of _NV_POWER_SUPPLY_INFO 
#define NV_POWER_SUPPLY_INFO_VER  MAKE_NVAPI_VERSION(NV_POWER_SUPPLY_INFO,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_VCD_GetPowerSupplyInfo
//
//!   DESCRIPTION: This API returns power supply information on the Visual Computing Device.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 180
//!
//! \param [in]    nvComputingHandle            The enumerated Visual Computing Device handle retrieved from NvAPI_EnumVisualComputingDevices().
//! \param [out]   pPowerInfo                   Contains the retrieved Power Supply information for the selected Visual Computing Device.
//!                                             pPowerInfo->version must be set to NV_POWER_SUPPLY_INFO_VER for the API to succeed.
//!
//! \retval ::NVAPI_INVALID_ARGUMENT         nvComputingHandle or pPowerInfo is NULL
//! \retval ::NVAPI_OK                       Information successfully in pPowerInfo.
//! \retval ::NVAPI_ERROR
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND  The queried Graphics system does not have any Visual Computing Device.
//!
//! \ingroup viscompapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_VCD_GetPowerSupplyInfo(NvVisualComputingDeviceHandle nvComputingHandle, NV_POWER_SUPPLY_INFO *pPowerInfo);

#define NVAPI_MAX_GSYNC_DEVICES                       4

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_VCD_GetAssociatedGSyncs
//
//! \code 
//!   DESCRIPTION: Returns all the GSync devices attached to a Visual Computing Device(VCD)
//!
//!   PARAMETERS:  nvComputingHandle[IN] - The enumerated Visual Computing Device handle retrieved from NvAPI_EnumVisualComputingDevices.
//!                nvGSyncHandles[OUT] - The caller provides an array of handles, which must contain at least 
//!                NVAPI_MAX_GSYNC_DEVICES elements. The API will fill in one or more handles. If an error occurs, the array is invalid.
//!
//!                *gsyncCount[OUT] - The caller provides the storage space. NvAPI_VCD_GetAssociatedGSyncs
//!                sets *gsyncCount to indicate how many of the elements in the nvGSyncHandles[] array are valid.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \return      This API can return any of the error codes enumerated in #NvAPI_Status. 
//! RETURN STATUS: NVAPI_INVALID_ARGUMENT: One of the arguments is NULL.
//!                NVAPI_OK: Information retrieved successfully.
//!                NVAPI_ERROR: The operation failed.
//!                NVAPI_NVIDIA_DEVICE_NOT_FOUND: The queried Graphics system does not have any Visual Computing Device.
//!                NVAPI_NOT_SUPPORTED: The queried Visual Computing Device does not support GSync Cards.
//! \endcode
//! \ingroup viscompapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_VCD_GetAssociatedGSyncs(NvVisualComputingDeviceHandle nvComputingHandle, NvGSyncDeviceHandle nvGSyncHandles[NVAPI_MAX_GSYNC_DEVICES], NvU32 *gsyncCount);


//! \addtogroup gsyncapi
//! @{


// Sync Display APIs

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_EnumSyncDevices
//
//!   DESCRIPTION: This API returns an array of Sync device handles. A Sync device handle represents a
//!                single Sync device on the system.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \since Release: 313
//!
//! \param [out] nvGSyncHandles-  The caller provides an array of handles, which must contain at least
//!                               NVAPI_MAX_GSYNC_DEVICES elements. The API will zero out the entire array and then fill in one
//!                               or more handles. If an error occurs, the array is invalid.
//! \param [out] *gsyncCount-     The caller provides the storage space. NvAPI_GSync_EnumSyncDevices
//!                               sets *gsyncCount to indicate how many of the elements in the nvGSyncHandles[] array are valid.
//!                               If an error occurs, *gsyncCount will be set to zero.
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. 
//!          If there are return error codes with specific meaning for this API, they are listed below.
//! \retval ::NVAPI_INVALID_ARGUMENT         nvGSyncHandles or gsyncCount is NULL.
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND  The queried Graphics system does not have any Sync Device.
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GSync_EnumSyncDevices(__out NvGSyncDeviceHandle nvGSyncHandles[NVAPI_MAX_GSYNC_DEVICES], __out NvU32 *gsyncCount);



// GSync boardId values
#define NVAPI_GSYNC_BOARD_ID_P358 856		//!< GSync board ID 0x358, see NV_GSYNC_CAPABILITIES
#define NVAPI_GSYNC_BOARD_ID_P2060 8288		//!< GSync board ID 0x2060, see NV_GSYNC_CAPABILITIES 


//! Used in NvAPI_GSync_QueryCapabilities().
typedef struct _NV_GSYNC_CAPABILITIES_V1
{
    NvU32   version;						//!< Version of the structure
    NvU32   revId;							//!< FPGA Revision (low 4 bits) and Board ID (high 4 bits)
    NvU32   boardId;						//!< Board ID
    NvU32   revision;						//!< FPGA Revision
    NvU32   capFlags;						//!< Capabilities of the Sync board. Reserved for future use
    NvU32   maxSyncSkew;					//!< Maximum units of sync skew the board supports
    NvU32   syncSkewResolution;				//!< Number of nanoseconds that one unit of sync skew corresponds to
    NvU32   maxStartDelay;					//!< Maximum units of sync start delay the board supports
    NvU32   startDelayResolution;			//!< Number of nanoseconds that one unit of sync start delay corresponds to 
} NV_GSYNC_CAPABILITIES_V1;

typedef NV_GSYNC_CAPABILITIES_V1 NV_GSYNC_CAPABILITIES;


//! \ingroup gsyncapi
//! Macro for constructing the version field of NV_GSYNC_CAPABILITIES.
#define NV_GSYNC_CAPABILITIES_VER1  MAKE_NVAPI_VERSION(NV_GSYNC_CAPABILITIES_V1,1)
#define NV_GSYNC_CAPABILITIES_VER NV_GSYNC_CAPABILITIES_VER1


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_QueryCapabilities
//
//!   DESCRIPTION: This API returns the capabilities of the Sync device.
//!
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \since Release: 313
//!
//! \param [in]    hNvGSyncDevice-        The handle for a Sync device for which the capabilities will be queried.
//! \param [inout] *pNvGSyncCapabilities- The caller provides the storage space. NvAPI_GSync_QueryCapabilities() sets
//!                                       *pNvGSyncCapabilities to the version and capabilities details of the Sync device
//!                                       If an error occurs, *pNvGSyncCapabilities will be set to NULL.
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. 
//!          If there are return error codes with specific meaning for this API, they are listed below.
//! \retval ::NVAPI_INVALID_ARGUMENT         hNvGSyncDevice is NULL.
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND  The queried Graphics system does not have any Sync Device.
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GSync_QueryCapabilities(__in NvGSyncDeviceHandle hNvGSyncDevice, __inout NV_GSYNC_CAPABILITIES *pNvGSyncCapabilities);



//! Connector values for a GPU. Used in NV_GSYNC_GPU.
typedef enum _NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR
{
    NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_NONE         = 0,
    NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_PRIMARY      = 1,
    NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_SECONDARY    = 2,
    NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_TERTIARY     = 3,
    NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_QUARTERNARY  = 4,
} NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR;

//! Display sync states. Used in NV_GSYNC_DISPLAY.
typedef enum _NVAPI_GSYNC_DISPLAY_SYNC_STATE
{
    NVAPI_GSYNC_DISPLAY_SYNC_STATE_UNSYNCED         = 0,
    NVAPI_GSYNC_DISPLAY_SYNC_STATE_SLAVE            = 1,
    NVAPI_GSYNC_DISPLAY_SYNC_STATE_MASTER           = 2,
} NVAPI_GSYNC_DISPLAY_SYNC_STATE;

typedef struct _NV_GSYNC_GPU
{
    NvU32                               version;            //!< Version of the structure
    NvPhysicalGpuHandle                 hPhysicalGpu;       //!< GPU handle
    NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR  connector;          //!< Indicates which connector on the device the GPU is connected to.
    NvPhysicalGpuHandle                 hProxyPhysicalGpu;  //!< GPU through which hPhysicalGpu is connected to the Sync device (if not directly connected)
                                                            //!<  - this is NULL otherwise
    NvU32                               isSynced : 1;       //!< Whether this GPU is sync'd or not.
    NvU32                               reserved : 31;      //!< Should be set to ZERO
} NV_GSYNC_GPU;

typedef struct _NV_GSYNC_DISPLAY
{
    NvU32                               version;            //!< Version of the structure
    NvU32                               displayId;          //!< display identifier for displays.The GPU to which it is connected, can be retireved from NvAPI_SYS_GetPhysicalGpuFromDisplayId
    NvU32                               isMasterable : 1;   //!< Can this display be the master? (Read only)
    NvU32                               reserved : 31;      //!< Should be set to ZERO
    NVAPI_GSYNC_DISPLAY_SYNC_STATE      syncState;          //!< Is this display slave/master
                                                            //!< (Retrieved with topology or set by caller for enable/disable sync)
} NV_GSYNC_DISPLAY;

#define NV_GSYNC_DISPLAY_VER  MAKE_NVAPI_VERSION(NV_GSYNC_DISPLAY,1)
#define NV_GSYNC_GPU_VER      MAKE_NVAPI_VERSION(NV_GSYNC_GPU,1)


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_GetTopology
//
//!   DESCRIPTION: This API returns the topology for the specified Sync device.
//!
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \since Release: 313
//!
//! \param [in]       hNvGSyncDevice-     The caller provides the handle for a Sync device for which the topology will be queried.
//! \param [in, out]  gsyncGpuCount-      It returns number of GPUs connected to Sync device
//! \param [in, out]  gsyncGPUs-          It returns info about GPUs connected to Sync device
//! \param [in, out]  gsyncDisplayCount-  It returns number of active displays that belongs to Sync device
//! \param [in, out]  gsyncDisplays-      It returns info about all active displays that belongs to Sync device
//!
//! HOW TO USE: 1) make a call to get the number of GPUs connected OR displays synced through Sync device
//!                by passing the gsyncGPUs OR gsyncDisplays as NULL respectively. Both gsyncGpuCount and gsyncDisplayCount can be retrieved in same call by passing
//!                both gsyncGPUs and gsyncDisplays as NULL
//!                On call success:
//!             2) Allocate memory based on gsyncGpuCount(for gsyncGPUs) and/or gsyncDisplayCount(for gsyncDisplays) then make a call to populate gsyncGPUs and/or gsyncDisplays respectively.
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. 
//!          If there are return error codes with specific meaning for this API, they are listed below.
//! \retval ::NVAPI_INVALID_ARGUMENT               hNvGSyncDevice is NULL.
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND        The queried Graphics system does not have any Sync Device.
//! \retval ::NVAPI_INSUFFICIENT_BUFFER            When the actual number of GPUs/displays in the topology exceed the number of elements allocated for SyncGPUs/SyncDisplays respectively.
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GSync_GetTopology(__in NvGSyncDeviceHandle hNvGSyncDevice, __inout_opt NvU32 *gsyncGpuCount,  __inout_ecount_part_opt(*gsyncGpuCount, *gsyncGpuCount) NV_GSYNC_GPU *gsyncGPUs,
                                        __inout_opt NvU32 *gsyncDisplayCount, __inout_ecount_part_opt(*gsyncDisplayCount, *gsyncDisplayCount) NV_GSYNC_DISPLAY *gsyncDisplays);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_SetSyncStateSettings
//
//!   DESCRIPTION: Sets a new sync state for the displays in system.
//!
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \since Release: 313
//!
//! \param [in]  gsyncDisplayCount-			The number of displays in gsyncDisplays.
//! \param [in]  pGsyncDisplays-			The caller provides the structure containing all displays that need to be synchronized in the system. 
//!											The displays that are not part of pGsyncDisplays, will be un-synchronized.
//! \param [in]  flags-						Reserved for future use.
//!
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. 
//!          If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval ::NVAPI_INVALID_ARGUMENT			If the display topology or count not valid.
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND		The queried Graphics system does not have any Sync Device.
//! \retval ::NVAPI_INVALID_SYNC_TOPOLOGY       1.If any mosaic grid is partial.
//!                                             2.If timing(HVisible/VVisible/refreshRate) applied of any display is different. 
//!                                             3.If There is a across GPU mosaic grid in system and that is not a part of pGsyncDisplays.
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GSync_SetSyncStateSettings(__in NvU32 gsyncDisplayCount, __in_ecount(gsyncDisplayCount) NV_GSYNC_DISPLAY *pGsyncDisplays, __in NvU32 flags);


//! \ingroup gsyncapi

//! Source signal edge to be used for output pulse. See NV_GSYNC_CONTROL_PARAMS.
typedef enum _NVAPI_GSYNC_POLARITY
{
    NVAPI_GSYNC_POLARITY_RISING_EDGE     = 0,
    NVAPI_GSYNC_POLARITY_FALLING_EDGE    = 1,
    NVAPI_GSYNC_POLARITY_BOTH_EDGES      = 2,
} NVAPI_GSYNC_POLARITY;

//! Used in NV_GSYNC_CONTROL_PARAMS.
typedef enum _NVAPI_GSYNC_VIDEO_MODE
{
    NVAPI_GSYNC_VIDEO_MODE_NONE          = 0,
    NVAPI_GSYNC_VIDEO_MODE_TTL           = 1,
    NVAPI_GSYNC_VIDEO_MODE_NTSCPALSECAM  = 2,
    NVAPI_GSYNC_VIDEO_MODE_HDTV          = 3,
    NVAPI_GSYNC_VIDEO_MODE_COMPOSITE     = 4,
} NVAPI_GSYNC_VIDEO_MODE;

//! Used in NV_GSYNC_CONTROL_PARAMS.  
typedef enum _NVAPI_GSYNC_SYNC_SOURCE
{
    NVAPI_GSYNC_SYNC_SOURCE_VSYNC        = 0,
    NVAPI_GSYNC_SYNC_SOURCE_HOUSESYNC    = 1,
} NVAPI_GSYNC_SYNC_SOURCE;

//! Used in NV_GSYNC_CONTROL_PARAMS. 
typedef struct _NV_GSYNC_DELAY
{
    NvU32        version;          //!< Version of the structure
    NvU32        numLines;         //!< delay to be induced in number of horizontal lines.
    NvU32        numPixels;        //!< delay to be induced in number of pixels.
    NvU32        maxLines;         //!< maximum number of lines supported at current display mode to induce delay. Updated by NvAPI_GSync_GetControlParameters(). Read only.
	NvU32        minPixels;        //!< minimum number of pixels required at current display mode to induce delay. Updated by NvAPI_GSync_GetControlParameters(). Read only.
} NV_GSYNC_DELAY;

#define NV_GSYNC_DELAY_VER  MAKE_NVAPI_VERSION(NV_GSYNC_DELAY,1)

//! Used in NvAPI_GSync_GetControlParameters() and NvAPI_GSync_SetControlParameters().
typedef struct _NV_GSYNC_CONTROL_PARAMS
{
    NvU32                       version;            //!< Version of the structure
    NVAPI_GSYNC_POLARITY        polarity;           //!< Leading edge / Falling edge / both
    NVAPI_GSYNC_VIDEO_MODE      vmode;              //!< None, TTL, NTSCPALSECAM, HDTV
    NvU32                       interval;           //!< Number of pulses to wait between framelock signal generation
    NvS32                       skew;               //!< The time delay between the frame sync signal and the GPUs signal. This would be deprecated once CPL moves to new format.
    NvS32                       startDelay;         //!< Sync start delay for master. This would be deprecated once CPL moves to new format.
    NVAPI_GSYNC_SYNC_SOURCE     source;             //!< VSync/House sync
    NvU32                       interlaceMode:1;    //!< interlace mode for a Sync device
    NvU32                       reserved:31;        //!< should be set zero
	NV_GSYNC_DELAY              syncSkew;           //!< The time delay between the frame sync signal and the GPUs signal. 
    NV_GSYNC_DELAY              startupDelay;       //!< Sync start delay for master. 
} NV_GSYNC_CONTROL_PARAMS;

#define NV_GSYNC_CONTROL_PARAMS_VER  MAKE_NVAPI_VERSION(NV_GSYNC_CONTROL_PARAMS,1)


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_GetControlParameters
//
//!   DESCRIPTION: This API queries for sync control parameters as defined in NV_GSYNC_CONTROL_PARAMS.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \since Release: 313
//!
//! \param [in]    hNvGSyncDevice-   The caller provides the handle of the Sync device for which to get parameters
//! \param [inout] *pGsyncControls-  The caller provides the storage space. NvAPI_GSync_GetControlParameters() populates *pGsyncControls with values.
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. 
//!          If there are return error codes with specific meaning for this API, they are listed below.
//! \retval ::NVAPI_INVALID_ARGUMENT          hNvGSyncDevice is NULL.
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND   The queried Graphics system does not have any Sync Device.
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GSync_GetControlParameters(__in NvGSyncDeviceHandle hNvGSyncDevice, __inout NV_GSYNC_CONTROL_PARAMS *pGsyncControls);



//////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_SetControlParameters
//
//!   DESCRIPTION: This API sets control parameters as defined in NV_SYNC_CONTROL_PARAMS.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \since Release: 313
//!
//! \param [in]  hNvGSyncDevice-   The caller provides the handle of the Sync device for which to get parameters
//! \param [inout]  *pGsyncControls-  The caller provides NV_GSYNC_CONTROL_PARAMS. skew and startDelay will be updated to the applied values.
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. 
//!          If there are return error codes with specific meaning for this API, they are listed below.
//! \retval ::NVAPI_INVALID_ARGUMENT          hNvGSyncDevice is NULL.
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND   The queried Graphics system does not have any Sync Device.
//! \retval ::NVAPI_SYNC_MASTER_NOT_FOUND     Control Parameters can only be set if there is a Sync Master enabled on the Gsync card.
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GSync_SetControlParameters(__in NvGSyncDeviceHandle hNvGSyncDevice, __inout NV_GSYNC_CONTROL_PARAMS *pGsyncControls);




//! Used in NvAPI_GSync_AdjustSyncDelay()
typedef enum _NVAPI_GSYNC_DELAY_TYPE
{
	NVAPI_GSYNC_DELAY_TYPE_UNKNOWN			= 0,
    NVAPI_GSYNC_DELAY_TYPE_SYNC_SKEW     	= 1,
    NVAPI_GSYNC_DELAY_TYPE_STARTUP     		= 2
} NVAPI_GSYNC_DELAY_TYPE;

//////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_AdjustSyncDelay
//
//!   DESCRIPTION: This API adjusts the skew and startDelay to the closest possible values. Use this API before calling NvAPI_GSync_SetControlParameters for skew or startDelay.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \since Release: 319
//!
//! \param [in]  hNvGSyncDevice-   	The caller provides the handle of the Sync device for which to get parameters
//! \param [in]  delayType-   		Specifies whether the delay is syncSkew or startupDelay. 
//! \param [inout]  *pGsyncDelay-  	The caller provides NV_GSYNC_DELAY. skew and startDelay will be adjusted and updated to the closest values.
//! \param [out]  *syncSteps-  		This parameter is optional. It returns the sync delay in unit steps. If 0, it means either the NV_GSYNC_DELAY::numPixels is less than NV_GSYNC_DELAY::minPixels or NV_GSYNC_DELAY::numOfLines exceeds the NV_GSYNC_DELAY::maxLines.
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. 
//!          If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GSync_AdjustSyncDelay(__in NvGSyncDeviceHandle hNvGSyncDevice, __in NVAPI_GSYNC_DELAY_TYPE delayType, __inout NV_GSYNC_DELAY *pGsyncDelay, __out_opt NvU32* syncSteps);



//! Used in NvAPI_GSync_GetSyncStatus().
typedef struct _NV_GSYNC_STATUS
{
    NvU32 version;                          //!< Version of the structure
    NvU32 bIsSynced;                        //!< Is timing in sync?
    NvU32 bIsStereoSynced;                  //!< Does the phase of the timing signal from the GPU = the phase of the master sync signal?
    NvU32 bIsSyncSignalAvailable;           //!< Is the sync signal available?
} NV_GSYNC_STATUS;

//! Macro for constructing the version field for NV_GSYNC_STATUS.
#define NV_GSYNC_STATUS_VER  MAKE_NVAPI_VERSION(NV_GSYNC_STATUS,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_GetSyncStatus
//
//!   DESCRIPTION: This API queries the sync status of a GPU - timing, stereosync and sync signal availability.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \since Release: 313
//!
//! \param [in]  hNvGSyncDevice-     Handle of the Sync device
//! \param [in]  hPhysicalGpu-       GPU to be queried for sync status.
//! \param [out] *status-            The caller provides the storage space. NvAPI_GSync_GetSyncStatus() populates *status with
//!                                  values - timing, stereosync and signal availability. On error, *status is set to NULL.
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. 
//!          If there are return error codes with specific meaning for this API, they are listed below.
//! \retval ::NVAPI_INVALID_ARGUMENT          hNvGSyncDevice is NULL / SyncTarget is NULL.
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND   The queried Graphics system does not have any G-Sync Device.
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GSync_GetSyncStatus(__in NvGSyncDeviceHandle hNvGSyncDevice, __in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GSYNC_STATUS *status);


//! \ingroup gsyncapi

#define NVAPI_MAX_RJ45_PER_GSYNC    2

//! Used in NV_GSYNC_STATUS_PARAMS.
typedef enum _NVAPI_GSYNC_RJ45_IO
{
    NVAPI_GSYNC_RJ45_OUTPUT     = 0,
    NVAPI_GSYNC_RJ45_INPUT      = 1,
    NVAPI_GSYNC_RJ45_UNUSED     = 2 //!< This field is used to notify that the framelock is not actually present.

} NVAPI_GSYNC_RJ45_IO;

//! \ingroup gsyncapi
//! Used in NvAPI_GSync_GetStatusParameters().
typedef struct _NV_GSYNC_STATUS_PARAMS
{
    NvU32                       version;
    NvU32                       refreshRate;                                //!< The refresh rate
    NVAPI_GSYNC_RJ45_IO         RJ45_IO[NVAPI_MAX_RJ45_PER_GSYNC];          //!< Configured as input / output
    NvU32                       RJ45_Ethernet[NVAPI_MAX_RJ45_PER_GSYNC];    //!< Connected to ethernet hub? [ERRONEOUSLY CONNECTED!]
    NvU32                       houseSyncIncoming;                          //!< Incoming house sync frequency in Hz
    NvU32                       bHouseSync;                                 //!< Is house sync connected?
} NV_GSYNC_STATUS_PARAMS;


//! \ingroup gsyncapi
//! Macro for constructing the version field of NV_GSYNC_STATUS_PARAMS 
#define NV_GSYNC_STATUS_PARAMS_VER  MAKE_NVAPI_VERSION(NV_GSYNC_STATUS_PARAMS,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_GetStatusParameters
//
//!   DESCRIPTION: This API queries for sync status parameters as defined in NV_GSYNC_STATUS_PARAMS.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 313
//!
//! \param [in]  hNvGSyncDevice   The caller provides the handle of the GSync device for which to get parameters
//! \param [out] *pStatusParams   The caller provides the storage space. NvAPI_GSync_GetStatusParameters populates *pStatusParams with
//!                               values.
//! 
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. 
//!          If there are return error codes with specific meaning for this API, they are listed below.
//! \retval ::NVAPI_INVALID_ARGUMENT            hNvGSyncDevice is NULL / pStatusParams is NULL.
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND     The queried Graphics system does not have any GSync Device.
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GSync_GetStatusParameters(NvGSyncDeviceHandle hNvGSyncDevice, NV_GSYNC_STATUS_PARAMS *pStatusParams);

//! @}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_EnumGSyncDevices
//
//!   DESCRIPTION: This API returns an array of GSync device handles. A GSync device handle represents a
//!                single GSync device on the system.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \param [out] nvGSyncHandles   The caller provides an array of handles, which must contain at least
//!                               NVAPI_MAX_GSYNC_DEVICES elements. The API will zero out the entire array and then fill in one
//!                               or more handles. If an error occurs, the array is invalid.
//! \param [out] *gsyncCount      The caller provides the storage space. NvAPI_EnumGSyncDevices
//!                               sets *gsyncCount to indicate how many of the elements in the nvGSyncHandles[] array are valid.
//!                               If an error occurs, *gsyncCount will be set to zero.
//!
//! \retval ::NVAPI_INVALID_ARGUMENT         nvGSyncHandles or gsyncCount is NULL.
//! \retval ::NVAPI_OK                       One or more handles were returned.
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND  The queried Graphics system does not have any GSync Device.
//! \retval ::NVAPI_ERROR           
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_EnumGSyncDevices(NvGSyncDeviceHandle nvGSyncHandles[NVAPI_MAX_GSYNC_DEVICES], NvU32 *gsyncCount);


//! \addtogroup gsyncapi
//! @{

//Indicate the number of decimal places of accuracy that the G-Sync board supports when reporting/accepting refresh rates

//! Supported refresh rates reported to 2 decimal place accuracy.
#define NVAPI_GSYNC_CAPS_FLAG_FREQ_ACCURACY_2DPS  (0x00000001)

//! Supported refresh rates reported to 3 decimal place accuracy.
#define NVAPI_GSYNC_CAPS_FLAG_FREQ_ACCURACY_3DPS  (0x00000002)

//! Supported refresh rates reported to 4 decimal place accuracy.
#define NVAPI_GSYNC_CAPS_FLAG_FREQ_ACCURACY_4DPS  (0x00000004)

//Indicate the types of events that the G-Sync board can report back to the client

//! G-Sync board can report sync-lock events to the client.
#define NVAPI_GSYNC_CAPS_FLAG_SYNC_LOCK_EVENT     (0x80000000)

//! G-Sync board can report house-sync events to the client.
#define NVAPI_GSYNC_CAPS_FLAG_HOUSE_SYNC_EVENT    (0x40000000)

//! G-Sync board can report frame-count events to the client.
#define NVAPI_GSYNC_CAPS_FLAG_FRAME_COUNT_EVENT   (0x20000000)

//! G-Sync board revision is out of date. Update to latest revision.
#define NVAPI_GSYNC_CAPS_FLAG_REVISION_OUT_OF_DATE (0x00000010)

//! G-Sync board's current firmware revision is not supported with the GPUs. 
#define NVAPI_GSYNC_CAPS_FLAG_FIRMWARE_REVISION_NOT_SUPPORTED (0x00000020)

//gsync boardId values
#define NVAPI_GSYNC_BOARD_ID_P154 340 //!< GSync board ID 0x154, see NV_GSYNC_CAPABILITIES
#define NVAPI_GSYNC_BOARD_ID_P294 660 //!< GSync board ID 0x294, see NV_GSYNC_CAPABILITIES

//! @}

//! \addtogroup gsyncapi
//! @{

#define NVAPI_MAX_GPUS_PER_GSYNC                    4

//! Used in NV_GSYNC_TOPOLOGY.
typedef struct _NV_GSYNC_TOPOLOGY_TARGET
{
    NvU32                               version;
    NvPhysicalGpuHandle                 hPhysicalGpu;       //!< GPU handle
    NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR  connector;          //!< Indicates which connector on the device the GPU is connected to.
    NvPhysicalGpuHandle                 hProxyPhysicalGpu;  //!< GPU through which hPhysicalGpu is connected to the G-Sync device (if not directly connected)
                                                            //!<  - this is NULL otherwise
    NvU32                               bIsSynced;          //!< Whether this GPU is sync'd or not.
    NvU32                               displayCount;
    struct
    {
        NvDisplayHandle                 hNvDisplay;         //!< Handle for display (May be common for multiple displays if not in single view mode)
        NvU32                           displayMask;        //!< So the mask will distinguish among them
        NvU32                           bIsMasterable;      //!< Can this display be the master? (Read only)
        NVAPI_GSYNC_DISPLAY_SYNC_STATE  syncState;          //!< Is this display unsync'd/slave/master
                                                            //!< (Retrieved with topology or set by caller for enable/disable sync)
    } nvDisplays[NV_MAX_HEADS];     //!< May have 0 elements if no displays connected to GPU
                                    //!<  - And, this array needs to have at least one element when enabling / disabling sync.
} NV_GSYNC_TOPOLOGY_TARGET;

//! Macro for constructing the version field of NV_GSYNC_TOPOLOGY_TARGET. 
#define NV_GSYNC_TOPOLOGY_TARGET_VER  MAKE_NVAPI_VERSION(NV_GSYNC_TOPOLOGY_TARGET,1)


//! Used in NvAPI_GSync_QueryTopology().
typedef struct _NV_GSYNC_TOPOLOGY
{
    NvU32                       version;
    NvU32                       gsyncTargetCount;                       //!< The number of valid G-Sync targets
    NV_GSYNC_TOPOLOGY_TARGET    gsyncTarget[NVAPI_MAX_GPUS_PER_GSYNC];  //!< Array of G-Sync targets
} NV_GSYNC_TOPOLOGY;


//! @}



//! Macro for constructing the version field of NV_GSYNC_TOPOLOGY. 
#define NV_GSYNC_TOPOLOGY_VER  MAKE_NVAPI_VERSION(NV_GSYNC_TOPOLOGY,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_QueryTopology
//
//!   DESCRIPTION: This API returns the topology for the specified G-Sync device.
//!
//!                Note: Display handles can get invalidated on a modeset, so the calling applications need to
//!                requery the topology after every modeset.
//!   
//! \deprecated  Do not use this function - it is deprecated in release 307. Instead, use NvAPI_GSync_GetTopology.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]   hNvGSyncDevice  The caller provides the handle for a GSync device for which the topology will
//!                               be queried.
//! \param [out] *pNvGPUTopology  The caller provides the storage space. NvAPI_GSync_QueryTopology sets *pNvGPUTopology
//!                to an object containing an array of all GPUs connected to the GSync device, their connectors, handles of their
//!                proxy GPUs(handle of GPU through which a GPU is connected to the GSync device) and displays on each GPU.
//!                NvDisplayHandle may be same for multiple displays in the structure if in clone or Mosaic modes. This API will
//!                return data on all active heads associated with a GPU, even ones on the slaves.
//!                If an error occurs, *pNvGPUTopology will be set to NULL.
//!
//! \retval ::NVAPI_INVALID_ARGUMENT        hNvGSyncDevice is NULL.
//! \retval ::NVAPI_OK                      *pNvGPUTopology was populated.
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND The queried Graphics system does not have any GSync Device.
//! \retval ::NVAPI_ERROR
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 307. Instead, use NvAPI_GSync_GetTopology.")
NVAPI_INTERFACE NvAPI_GSync_QueryTopology(NvGSyncDeviceHandle hNvGSyncDevice, NV_GSYNC_TOPOLOGY *pNvGPUTopology);


//! \ingroup gsyncapi
//! Used in NvAPI_GSync_QueryStatusSignals().
typedef struct _NV_GSYNC_STATUS_SIGNALS
{
    NvU32   version;
    NvU32   RJ45[NVAPI_MAX_RJ45_PER_GSYNC];     //!< The RJ45 signals in Hz
    NvU32   house;                              //!< House sync signal in Hz
} NV_GSYNC_STATUS_SIGNALS;


//! \ingroup gsyncapi
//! Macro for constructing the version field of NV_GSYNC_STATUS_SIGNALS.
#define NV_GSYNC_STATUS_SIGNALS_VER  MAKE_NVAPI_VERSION(NV_GSYNC_STATUS_SIGNALS,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_QueryStatusSignals
//
//!   DESCRIPTION: This API returns the status signals of the RJ45 and house sync for the specified G-Sync device.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]   hNvGSyncDevice         Handle of the G-Sync device for which the status signals will be queried.
//! \param [out] *pNvGSyncStatusSignals  The caller provides the storage space. NvAPI_GSync_QueryStatusSignals() sets 
//!                                      *pNvGSyncStatusSignals to the values of the RJ45 and house sync. 
//!                                      House = 0 => No signal and RJ45 = ~0 => Signal detected, but no rate info available.
//!                                      If an error occurs, *pNvGSyncStatusSignals will be set to NULL.
//!
//! \retval ::NVAPI_INVALID_ARGUMENT         hNvGSyncDevice is NULL.
//! \retval ::NVAPI_OK                      *pNvGSyncStatusSignals was populated.
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND  The queried Graphics system does not have any GSync Device.
//! \retval ::NVAPI_ERROR
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GSync_QueryStatusSignals(NvGSyncDeviceHandle hNvGSyncDevice, NV_GSYNC_STATUS_SIGNALS *pNvGSyncStatusSignals);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_Signal_Event
//
//! \code
//!   DESCRIPTION: 1. Signal events coming from kmd/rm back to kmd to allow 
//!                further processing at kmd.
//!                2. Signal events for Sync state change.
//!
//!    PARAMETERS: hNvGSyncDevice[IN] - The caller provides the handle of the GSync device on 
//!                which the provided GPU is located. This can be NULL for systemwide events.
//!
//!                eventFlags[IN] - Notification flags. see NV_GSYNC_EVENT
//!
//!                
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! RETURN STATUS: NVAPI_OK: completed request.
//!                NVAPI_ERROR: The operation failed.
//! \endcode
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GSync_Signal_Event(__in_opt NvGSyncDeviceHandle hNvGSyncDevice, __in NvU32 eventFlags);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_EnableSync
//
//!   DESCRIPTION: This API synchronizes the displays (as master or slaves) at the refresh rate provided.
//!
//! \deprecated  Do not use this function - it is deprecated in release 307. Instead, use NvAPI_GSync_SetSyncStateSettings.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]       hNvGSyncDevice      Handle of the G-Sync device on which the provided GPU is located.
//! \param [out]      refreshRate         The desired refresh rate to be sync'd at. The value is in 0.0001 Hz.
//! \param [in,out]  *pNvGTopologyTarget  The caller provides the structure containing the GPU, and the displays
//!                                       on the GPU to be sync'd. Any display not sync'd will cause the corresponding
//!                                       handle in the structure to become NULL.
//!                                       If an error occurs, *pNvGTopologyTarget will be set to NULL.
//!
//! \retval ::NVAPI_INVALID_ARGUMENT         hNvGSyncDevice is NULL; pNvGTopologyTarget is NULL.
//! \retval ::NVAPI_OK                       Master display and/or slave displays were sync'd.
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND  The queried Graphics system does not have any G-Sync Device; does not have a GPU 
//!                                          attached to the G-ync device; display handles are invalid.
//! \retval ::NVAPI_ERROR
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 307. Instead, use NvAPI_GSync_SetSyncStateSettings.")
NVAPI_INTERFACE NvAPI_GSync_EnableSync(NvGSyncDeviceHandle hNvGSyncDevice, NV_GSYNC_TOPOLOGY_TARGET *pNvGTopologyTarget, NvU32 refreshRate);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_DisableSync
//
//!   DESCRIPTION: This API unsynchronizes the displays.
//!
//! \deprecated  Do not use this function - it is deprecated in release 307. Instead, use NvAPI_GSync_SetSyncStateSettings.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]      hNvGSyncDevice     The handle of the G-Sync device on which the provided GPU is located.
//! \param [in]      retainMaster       The caller provides whether to keep a display as master even after unsync'ing.
//! \param [in,out] *pNvGTopologyTarget The caller provides the structure containing the GPU, and the displays on the GPU to be unsync'd.
//!                                     If an error occurs, *pNvGTopologyTarget will be set to NULL.
//!
//! \retval ::NVAPI_INVALID_ARGUMENT         hNvGSyncDevice is NULL; pNvGTopologyTarget is NULL.
//! \retval ::NVAPI_OK                       Master and/or slave displays were unsync'd.
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND  The queried Graphics system does not have a G-Sync Device, or does not have a GPU attached to
//!                                          the G-Sync device.
//! \retval ::NVAPI_ERROR
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 307. Instead, use NvAPI_GSync_SetSyncStateSettings.")
NVAPI_INTERFACE NvAPI_GSync_DisableSync(NvGSyncDeviceHandle hNvGSyncDevice, NV_GSYNC_TOPOLOGY_TARGET *pNvGTopologyTarget, NvU32 retainMaster);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_SetSyncState
//
//! \code
//!   DESCRIPTION: Sets a new sync state for the displays contained in the given pNvGTopology.
//!                The refreshrate is taken into account in case at least a framelock master or slave is contained in the topology.
//!
//!    PARAMETERS: hNvGSyncDevice[IN] - The caller provides the handle of the GSync device on which the provided GPUs are located.
//!
//!                refreshRate[IN] - The caller provides the desired refresh rate to be synced at. The value is in 0.0001 Hertz
//!
//!                *pNvGTopology[IN|OUT] - The caller provides the structure containing all GPUs connected to a gsync device, and the
//!                displays on the GPUs to be synced. 
//!                Any display which should not be synced should get it's syncState set to NVAPI_GSYNC_DISPLAY_SYNC_STATE_UNSYNCED.
//!                The bIsSynced member of the NV_GSYNC_TOPOLOGY_TARGET is ignored in the call.
//!                This API ensures the atomicity. 
//!                This API takes care of all the Quadroplex models including D4 and non-Quadroplex.
//!
//!                If an error occurs, *pNvGTopology will be set to the current hw state.
//!                In case a gpu or displayhandle could not be found, the target is set the NULL.
//!
//! \deprecated  Do not use this function - it is deprecated in release 307. Instead, use NvAPI_GSync_SetSyncStateSettings.
//! SUPPORTED OS:  Windows XP and higher
//!
//! RETURN STATUS: NVAPI_INVALID_ARGUMENT: hNvGSyncDevice is NULL / pNvGTopology is NULL.
//!                NVAPI_OK: Master display and/or slave displays were synced.
//!                NVAPI_NVIDIA_DEVICE_NOT_FOUND: The queried Graphics system does not have any GSync Device / does not have a GPU attached to
//!                the GSync device / display handles are invalid.
//!                NVAPI_ERROR: The operation failed.
//! \endcode
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 307. Instead, use NvAPI_GSync_SetSyncStateSettings.")
NVAPI_INTERFACE NvAPI_GSync_SetSyncState(NvGSyncDeviceHandle hNvGSyncDevice, NV_GSYNC_TOPOLOGY *pNvGPUTopology, NvU32 refreshRate);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_UpdateSyncPolarity
//
//!   DESCRIPTION: This API sets which edge of the source signal to use to generate the output sync pulse - leading edge, falling edge, or both.
//!
//! \deprecated  Do not use this function - it is deprecated in release 307. Instead, use NvAPI_GSync_SetControlParameters.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]  hNvGSyncDevice   Handle of the G-Sync device for which to set the sync polarity.
//! \param [in]  polarity         Rising / Falling / Both
//!
//! \retval ::NVAPI_INVALID_ARGUMENT         hNvGSyncDevice is NULL; polarity is invalid.
//! \retval ::NVAPI_OK                       Polarity set.
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND  The queried graphics system does not have any G-Sync Device.
//! \retval ::NVAPI_ERROR
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 307. Instead, use NvAPI_GSync_SetControlParameters.")
NVAPI_INTERFACE NvAPI_GSync_UpdateSyncPolarity(NvGSyncDeviceHandle hNvGSyncDevice, NVAPI_GSYNC_POLARITY polarity);


//! \ingroup gsyncapi

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_UpdateVideoMode
//
//!   DESCRIPTION: This API sets the video mode to either None, TTL, NTSCPALSECAM, or HDTV.
//!
//! \deprecated  Do not use this function - it is deprecated in release 307. Instead, use NvAPI_GSync_SetControlParameters.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]    hNvGSyncDevice  Handle of the G-Sync device for which to set video mode.
//! \param [in]    vmode          The video mode - None, TTL, NTSCPALSECAM, or HDTV
//!
//! \retval ::NVAPI_INVALID_ARGUMENT        hNvGSyncDevice is NULL; vmode is invalid.
//! \retval ::NVAPI_OK                      Video mode set.
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND The queried Graphics system does not have any GSync Device.
//! \retval ::NVAPI_ERROR
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 307. Instead, use NvAPI_GSync_SetControlParameters.")
NVAPI_INTERFACE NvAPI_GSync_UpdateVideoMode(NvGSyncDeviceHandle hNvGSyncDevice, NVAPI_GSYNC_VIDEO_MODE vmode);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_UpdateSyncInterval
//
//!   DESCRIPTION: This API sets the sync interval, or the number of pulses to wait between sync signals.
//!
//! \deprecated  Do not use this function - it is deprecated in release 307. Instead, use NvAPI_GSync_SetControlParameters.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]  hNvGSyncDevice  Handle of the G-Sync device for which to set the sync interval.
//! \param [in]  interval        The number of pulses to skip for signal generation. 0 uses source, 1 gives half the frequency, and so on.
//!
//! \retval ::NVAPI_INVALID_ARGUMENT         hNvGSyncDevice is NULL / interval is invalid.
//! \retval ::NVAPI_OK                       Interval set.
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND  The queried Graphics system does not have any G-Sync Device.
//! \retval ::NVAPI_ERROR
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 307. Instead, use NvAPI_GSync_SetControlParameters.")
NVAPI_INTERFACE NvAPI_GSync_UpdateSyncInterval(NvGSyncDeviceHandle hNvGSyncDevice, NvU32 interval);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_UpdateSyncSkew
//
//!   DESCRIPTION: This API sets the sync skew.
//!
//! \deprecated  Do not use this function - it is deprecated in release 307. Instead, use NvAPI_GSync_SetControlParameters.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]   hNvGSyncDevice   Handle of the G-Sync device for which to set the skew.
//! \param [in]   skew             The time delay between the frame sync signal and the GPU's signal in units of 7.81 us; maximum 15.99 ms.
//!
//! \retval ::NVAPI_INVALID_ARGUMENT         hNvGSyncDevice is NULL / skew is invalid.
//! \retval ::NVAPI_OK                       Skew is set.
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND  The queried Graphics system does not have any G-Sync Device.
//! \retval ::NVAPI_ERROR
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 307. Instead, use NvAPI_GSync_SetControlParameters.")
NVAPI_INTERFACE NvAPI_GSync_UpdateSyncSkew(NvGSyncDeviceHandle hNvGSyncDevice, NvS32 skew);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_UpdateSyncStartDelay
//
//!   DESCRIPTION: This API sets the sync start delay for the master.
//!   
//! \deprecated  Do not use this function - it is deprecated in release 307. Instead, use NvAPI_GSync_SetControlParameters.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]  hNvGSyncDevice     Handle of the GSync device for which to set start delay
//! \param [in]  startDelay         The amount of time to wait before generating the first sync pulse, in units of 7.81 us; maximum 64 ms
//!
//! \retval ::NVAPI_INVALID_ARGUMENT          hNvGSyncDevice is NULL / startDelay is invalid.
//! \retval ::NVAPI_OK                        Delay set.
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND   The queried Graphics system does not have any G-Sync Device.
//! \retval ::NVAPI_ERROR
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 307. Instead, use NvAPI_GSync_SetControlParameters.")
NVAPI_INTERFACE NvAPI_GSync_UpdateSyncStartDelay(NvGSyncDeviceHandle hNvGSyncDevice, NvS32 startDelay);


//! \ingroup gsyncapi

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_UpdateSyncSource
//
//!   DESCRIPTION: This API sets the sync source for the G-Sync device provided.
//!   
//! \deprecated  Do not use this function - it is deprecated in release 307. Instead, use NvAPI_GSync_SetControlParameters.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]  hNvGSyncDevice     Handle of the GSync device for which to set the sync source.
//! \param [in]  source             Either VSync or House sync to be set as the source.
//!
//! \retval ::NVAPI_INVALID_ARGUMENT         hNvGSyncDevice is NULL; source is invalid.
//! \retval ::NVAPI_OK                       Source set.
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND   The queried Graphics system does not have any G-Sync Device.
//! \retval ::NVAPI_ERROR
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 307. Instead, use NvAPI_GSync_SetControlParameters.")
NVAPI_INTERFACE NvAPI_GSync_UpdateSyncSource(NvGSyncDeviceHandle hNvGSyncDevice, NVAPI_GSYNC_SYNC_SOURCE source);



//! \ingroup gsyncapi
//! Used in NvAPI_GSync_QuerySyncParameters().
typedef struct _NV_GSYNC_PARAMS
{
    NvU32                       version;
    NVAPI_GSYNC_POLARITY        polarity;           //!< Leading edge / Falling edge / both
    NVAPI_GSYNC_VIDEO_MODE      vmode;              //!< None, TTL, NTSCPALSECAM, HDTV
    NvU32                       interval;           //!< Number of pulses to wait between framelock signal generation
    NvS32                       skew;               //!< The time delay between the frame sync signal and the GPUs signal
    NvS32                       startDelay;         //!< Sync start delay for master
    NVAPI_GSYNC_SYNC_SOURCE     source;             //!< VSync / House sync
    NvU32                       refreshRate;        //!< The refresh rate
    NVAPI_GSYNC_RJ45_IO         RJ45_IO[NVAPI_MAX_RJ45_PER_GSYNC];          //!< Configured as input / output
    NvU32                       RJ45_Ethernet[NVAPI_MAX_RJ45_PER_GSYNC];    //!< Connected to ethernet hub? [ERRONEOUSLY CONNECTED!]
} NV_GSYNC_PARAMS;


//! \ingroup gsyncapi
//! Macro for contructing the version field of NV_GSYNC_PARAMS.
#define NV_GSYNC_PARAMS_VER  MAKE_NVAPI_VERSION(NV_GSYNC_PARAMS,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_QuerySyncParameters
//
//!   DESCRIPTION: Queries for all sync parameters as defined in NV_GSYNC_PARAMS
//!
//! \deprecated  Do not use this function - it is deprecated in release 313. Instead, use following functions: NvAPI_GSync_GetStatusParameters, and, NvAPI_GSync_GetControlParameters.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]   hNvGSyncDevice    Handle of the GSync device for which to set start delay
//! \param [out] *pVals             The caller provides the storage space. NvAPI_GSync_QuerySyncParameters() populates *pVals with
//!                                 values. On error, *pVals is set to NULL.
//!
//! \retval ::NVAPI_INVALID_ARGUMENT          hNvGSyncDevice is NULL.
//! \retval ::NVAPI_OK                       *pVals populated with values.
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND   The queried Graphics system does not have any G-Sync Device.
//! \retval ::NVAPI_ERROR
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 313. Instead, use following functions: NvAPI_GSync_GetStatusParameters, and, NvAPI_GSync_GetControlParameters.")
NVAPI_INTERFACE NvAPI_GSync_QuerySyncParameters(NvGSyncDeviceHandle hNvGSyncDevice, NV_GSYNC_PARAMS *pVals);



//! \ingroup gsyncapi
//////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_QuerySyncStatus
//
//!   DESCRIPTION: This API queries the sync status of a GPU - timing, stereosync and sync signal availability.
//!   
//! \deprecated  Do not use this function - it is deprecated in release 307. Instead, use NvAPI_GSync_GetSyncStatus.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]  hNvGSyncDevice     Handle of the GSync device for which to set start delay
//! \param [in]  gsyncTarget        GPU to be queried for sync status. The displays (if any are specified) are ignored.
//! \param [out] *pStatus           The caller provides the storage space. NvAPI_GSync_QuerySyncStatus() populates *pStatus with
//!                                 values - timing, stereosync and signal availability. On error, *pStatus is set to NULL.
//!
//! \retval ::NVAPI_INVALID_ARGUMENT          hNvGSyncDevice is NULL / gsyncTarget is NULL.
//! \retval ::NVAPI_OK                       *pStatus populated with values.
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND   The queried Graphics system does not have any G-Sync Device.
//! \retval ::NVAPI_ERROR
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 307. Instead, use NvAPI_GSync_GetSyncStatus.")
NVAPI_INTERFACE NvAPI_GSync_QuerySyncStatus(NvGSyncDeviceHandle hNvGSyncDevice, NV_GSYNC_TOPOLOGY_TARGET gsyncTarget, NV_GSYNC_STATUS *pStatus);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_UpdateInterlaceMode
//
//!   DESCRIPTION: This API enables/disables interlace mode for a G-Sync device.
//!   
//! \deprecated  Do not use this function - it is deprecated in release 307. Instead, use NvAPI_GSync_SetControlParameters.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]  hNvGSyncDevice     Handle of the GSync device for which to set start delay
//! \param [in]  state              Enable = 1, Disable = 0
//!
//! \retval ::NVAPI_INVALID_ARGUMENT          hNvGSyncDevice is NULL.
//! \retval ::NVAPI_OK                        Interlace mode enabled.
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND   The queried Graphics system does not have any G-Sync Device.
//! \retval ::NVAPI_ERROR
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 307. Instead, use NvAPI_GSync_SetControlParameters.")
NVAPI_INTERFACE NvAPI_GSync_UpdateInterlaceMode(NvGSyncDeviceHandle hNvGSyncDevice, NvU32 state);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_QueryInterlaceMode
//
//!   DESCRIPTION: This API queries the state of the interlace mode (enabled/disabled) for a G-Sync device
//!  
//! \deprecated  Do not use this function - it is deprecated in release 307. Instead, use NvAPI_GSync_GetControlParameters.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]   hNvGSyncDevice     Handle of the GSync device for which to set start delay
//! \param [out] *pState             Interlace mode enabled = 1, disabled = 0
//!
//! \retval ::NVAPI_INVALID_ARGUMENT          hNvGSyncDevice is NULL.
//! \retval ::NVAPI_OK                        Interlace mode returned.
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND   The queried Graphics system does not have any G-Sync Device.
//! \retval ::NVAPI_ERROR
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 307. Instead, use NvAPI_GSync_GetControlParameters.")
NVAPI_INTERFACE NvAPI_GSync_QueryInterlaceMode(NvGSyncDeviceHandle hNvGSyncDevice, NvU32 *pState);


//! \ingroup gsyncapi
//! @{

typedef enum _NVAPI_GSYNC_DIAGNOSTIC_LOCK_STATE
{
    NVAPI_GSYNC_DIAGNOSTIC_LOCK_NONE        = 0,
    NVAPI_GSYNC_DIAGNOSTIC_LOCK_FRAMELOCK   = 1,
    NVAPI_GSYNC_DIAGNOSTIC_LOCK_RASTERLOCK  = 3,
} NVAPI_GSYNC_DIAGNOSTIC_LOCK_STATE;

typedef enum _NVAPI_GSYNC_DIAGNOSTIC_RM_LOCK_STATE
{
    NVAPI_GSYNC_DIAGNOSTIC_RM_LOCK_NONE      = 0,
    NVAPI_GSYNC_DIAGNOSTIC_RM_LOCK_MASTER    = 1,
    NVAPI_GSYNC_DIAGNOSTIC_RM_LOCK_SLAVE     = 2,
} NVAPI_GSYNC_DIAGNOSTIC_RM_LOCK_STATE;

//! specify a signal path from or to the GPU
typedef enum _NVAPI_GSYNC_DIAGNOSTIC_PIN
{
    NVAPI_GSYNC_DIAGNOSTIC_PIN_INTERNAL  = 0,   //!< inside GPU between two heads
    NVAPI_GSYNC_DIAGNOSTIC_PIN_0         = 1,   //!< through different GPIO of GPU
    NVAPI_GSYNC_DIAGNOSTIC_PIN_1         = 2,
    NVAPI_GSYNC_DIAGNOSTIC_PIN_2         = 3,
    NVAPI_GSYNC_DIAGNOSTIC_PIN_3         = 4,
} NVAPI_GSYNC_DIAGNOSTIC_PIN;

typedef struct _NVAPI_GSYNC_DIAGNOSTIC_PARAMS
{
    NvU32                                version;
    NVAPI_GSYNC_DIAGNOSTIC_LOCK_STATE    masterLockState;       //!< master lock mode
    NVAPI_GSYNC_DIAGNOSTIC_PIN           masterLockPin;         //!< lock to which GPIO
    NVAPI_GSYNC_DIAGNOSTIC_LOCK_STATE    slaveLockState;
    NVAPI_GSYNC_DIAGNOSTIC_PIN           slaveLockPin;
    NVAPI_GSYNC_DIAGNOSTIC_PIN           stereoPin;
    NvU8                                 modeTweaking;          //!< whether display driver needs to be adjusted for better synchronization
    NVAPI_GSYNC_DIAGNOSTIC_RM_LOCK_STATE rmFramelockState;      //!< framelock state in RM
    NvU8                                 stereoLock;            //!< Is stereo locked?
    NvU8                                 syncLock;              //!< Is synced?
    NvU8                                 primary;               //!< Is primary or secondary?
    // Mode related information    
    NvU32                                refreshRateX10k;
    NvU32                                hBlankStart;
    NvU32                                hSyncEnd;
    NvU32                                hBlankEnd;
    NvU32                                hTotal;
    NvU32                                vBlankStart;
    NvU32                                vSyncEnd;
    NvU32                                vBlankEnd;
    NvU32                                vTotal;
    NvU32                                vInterlacedBlankEnd;
    NvU32                                vInterlacedBlankStart;
    NvU32                                pixelClockHz;
    NvU8                                 interlaced;
} NVAPI_GSYNC_DIAGNOSTIC_PARAMS;

//! Macro for constructing the version field of ::NVAPI_GSYNC_DIAGNOSTIC_PARAMS
#define NV_GSYNC_DIAGNOSTIC_PARAMS_VER  MAKE_NVAPI_VERSION(NVAPI_GSYNC_DIAGNOSTIC_PARAMS,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_Get_DiagnosticSettings
//
//! \code
//!   DESCRIPTION: Queries for all sync parameters as defined in NVAPI_GSYNC_DIAGNOSTIC_PARAMS
//!
//!    PARAMETERS: hNvDisplay[IN]  - The caller provides the handle of the display for which to get parameters
//!                outputId[IN] - In nView mode a displaymask is alse needed to define the monitor for which to get parameters
//!
//!                *pDiagParams[OUT] - The caller provides the storage space. NvAPI_GSync_Diag populates *pDiagParams with
//!                                        values. On error, *pDiagParams is set to NULL.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! RETURN STATUS: NVAPI_OK: *pDiagParams populated with values.
//!                NVAPI_INVALID_ARGUMENT: outputId/pDiagParams is NULL.
//!                NVAPI_EXPECTED_DISPLAY_HANDLE: invalid diaplay handle.
//!                NVAPI_ERROR: The operation failed.
//!                NVAPI_API_NOT_INTIALIZED
//!                NVAPI_INCOMPATIBLE_STRUCT_VERSION
//! \endcode
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GSync_Get_DiagnosticSettings(NvDisplayHandle hNvDisplay, NvU32 outputId, NVAPI_GSYNC_DIAGNOSTIC_PARAMS *pDiagParams);

//! \ingroup gsyncapi
//! @
typedef enum _NV_GSYNC_REG_OP_CMD
{
    NV_GSYNC_REG_OP_READ             = 0x00000001, //!< read operation
    NV_GSYNC_REG_OP_WRITE            = 0x00000002, //!< write operation
} NV_GSYNC_REG_OP_CMD;

typedef enum _NV_GSYNC_REG
{
    NV_GSYNC_REG_FLASH_BOOT_STATUS    = 0x00000001, //!<boot_status register
    NV_GSYNC_REG_FLASH_CMD            = 0x00000002, //!<flash command register
    NV_GSYNC_REG_FLASH_ADDRESS        = 0x00000003, //!<flash address register
    NV_GSYNC_REG_FLASH_DATA           = 0x00000004, //!<flash data register
    NV_GSYNC_REG_FLASH_CHECKSUM       = 0x00000005, //!<flash checksum register
    NV_GSYNC_REG_SOFT_RESET           = 0x00000006, //!<Soft Reset register
} NV_GSYNC_REG;

typedef struct _NV_GSYNC_REG_DATA
{
    NvU32              version;    //!< structure version 
    NV_GSYNC_REG_OP_CMD   cmd;
    NV_GSYNC_REG          reg;         //!< register
    NvU32                 value : 8;     //!< value in register. currently 8 bits used only
    NvU32                 reserved : 24; //!< reserved
} NV_GSYNC_REG_DATA;

#define NV_GSYNC_REG_DATA_VER  MAKE_NVAPI_VERSION(NV_GSYNC_REG_DATA, 1)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_RegOp
//
//!  DESCRIPTION: This API reads/writes gsync register. It is used to flash firmware.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 304
//!
//! \param [in]   hNvGSyncDevice  The caller provides the handle for a GSync device on which register is being read/written
//! \param [out]  regData   pointer to NV_GSYNC_REG_DATA
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. 
//!          If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GSync_RegOp(__in NvGSyncDeviceHandle hNvGSyncDevice, __inout NV_GSYNC_REG_DATA *regData);

//! \ingroup gsyncapi

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GSync_FPGAFlashHelper
//
//!  DESCRIPTION: This API does pre-flash and post-flash operations on Gsync card.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 304
//!
//! \param [in]   hNvGSyncDevice  The caller provides the handle for a GSync device on which register is being read/written
//! \param [in]   isPreFlash      It specifies whether caller wants to do pre-flash(isPreFlash = 1) operation or post-flash(isPreFlash = 0) operation.
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. 
//!          If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup gsyncapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GSync_FPGAFlashHelper(__in NvGSyncDeviceHandle hNvGSyncDevice, __in NvU8 isPreFlash);

//! @}

//! Prototype structure version, check common/inc/FrameDebuggerStruct.h for versions
//! currently supported by the driver!
//! \ingroup nsightapi
typedef struct _fdStatsReport
{
    NvU32 structVersion;
} fdStatsReport;

#define FD_STATS_REPORT_STRUCT_VERSION_V0 MAKE_NVAPI_VERSION(fdStatsReport, 0)

typedef void (__cdecl *fdStatsReportsCompletedCallback)(void *pCallbackData, fdStatsReport *pStartReport, NvU32 reportCount);

//-----------------------------------------------------------------------------
// DirectX APIs
//-----------------------------------------------------------------------------


//! \ingroup dx
//! Used in NvAPI_D3D10_GetCurrentSLIState(), and NvAPI_D3D_GetCurrentSLIState().
typedef struct
{
    NvU32 version;                    //!< Structure version
    NvU32 maxNumAFRGroups;            //!< [OUT] The maximum possible value of numAFRGroups
    NvU32 numAFRGroups;               //!< [OUT] The number of AFR groups enabled in the system
    NvU32 currentAFRIndex;            //!< [OUT] The AFR group index for the frame currently being rendered
    NvU32 nextFrameAFRIndex;          //!< [OUT] What the AFR group index will be for the next frame (i.e. after calling Present)
    NvU32 previousFrameAFRIndex;      //!< [OUT] The AFR group index that was used for the previous frame (~0 if more than one frame has not been rendered yet)
    NvU32 bIsCurAFRGroupNew;          //!< [OUT] Boolean: Is this frame the first time running on the current AFR group

} NV_GET_CURRENT_SLI_STATE;

//! \ingroup dx
#define NV_GET_CURRENT_SLI_STATE_VER  MAKE_NVAPI_VERSION(NV_GET_CURRENT_SLI_STATE,1)


#if defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
//! \ingroup dx
//! D3D_FEATURE_LEVEL supported - used in NvAPI_D3D11_CreateDevice() and NvAPI_D3D11_CreateDeviceAndSwapChain()
typedef enum
{
    NVAPI_DEVICE_FEATURE_LEVEL_NULL       = -1,
    NVAPI_DEVICE_FEATURE_LEVEL_10_0       = 0,
    NVAPI_DEVICE_FEATURE_LEVEL_10_0_PLUS  = 1,
    NVAPI_DEVICE_FEATURE_LEVEL_10_1       = 2,
    NVAPI_DEVICE_FEATURE_LEVEL_11_0       = 3,
} NVAPI_DEVICE_FEATURE_LEVEL;

#endif  //defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))

#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)

NV_DECLARE_HANDLE(NVDX_ObjectHandle);  // DX Objects
static const NVDX_ObjectHandle NVDX_OBJECT_NONE = 0;

#endif //if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)

//! \ingroup nsightapi
typedef enum
{
    PCD_NEXUS_FRAME_AND_DC_INDEX,  //!< [31:24] FrameID [23:0] DrawCallID
    PCD_NEXUS_DC_EXTRA_INFO,
    PCD_NEXUS_TRAP_HANDLER_DUMP_GPU_VIRTUAL_ADDRESS,
    
    // Compute specific slots
    PCD_NEXUS_COMPUTE_START,
    PCD_NEXUS_COMPUTE_FRAME_AND_DC_INDEX = PCD_NEXUS_COMPUTE_START,
    PCD_NEXUS_COMPUTE_DC_EXTRA_INFO,
    
    PCD_COUNT
} NvAPIPrivateConstDataSlot;

//! Prototype structure version, check common/inc/ShaderDebuggerStruct.h for versions
//! currently supported by the driver!
//! \ingroup nsightapi
typedef struct _sdRmHandlesCollection
{
    NvU32 structVersion;
} sdRmHandlesCollection;

//! \ingroup nsightapi
#define SD_RM_HANDLES_COLLECTION_STRUCT_VERSION_V0 MAKE_NVAPI_VERSION(sdRmHandlesCollection, 0)

//! Prototype structure version, check common/inc/ShaderDebuggerStruct.h for versions
//! currently supported by the driver!
//! \ingroup nsightapi
typedef struct _sdWarpSemaphoreReport
{
    NvU32 structVersion;
} sdWarpSemaphoreReport;

//! \ingroup nsightapi
#define SD_WARP_SEMAPHORE_REPORT_VERSION_V0 MAKE_NVAPI_VERSION(sdWarpSemaphoreReport, 0)

#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D_GetCurrentSLIState
//
//! DESCRIPTION:     This function returns the current SLI state for the specified device.  The structure
//!                  contains the number of AFR groups, the current AFR group index,
//!                  and what the AFR group index will be for the next frame. \p
//!                  pDevice can be either a IDirect3DDevice9 or ID3D10Device pointer.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 173
//!
//! \retval         NVAPI_OK     Completed request
//! \retval         NVAPI_ERROR  Error occurred
//!
//! \ingroup  dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_GetCurrentSLIState(IUnknown *pDevice, NV_GET_CURRENT_SLI_STATE *pSliState);
#endif //if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)

#if defined(_D3D9_H_)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_RegisterResource
//
//! DESCRIPTION:    This API binds a resource (surface/texture) so that it can be retrieved
//!                 internally by NVAPI.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//! \param [in]     pResource      surface/texture
//!
//! \return ::NVAPI_OK, ::NVAPI_ERROR 
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_RegisterResource(IDirect3DResource9* pResource);
#endif //defined(_D3D9_H_)
#if defined(_D3D9_H_)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_UnregisterResource
//
//! DESCRIPTION:     This API unbinds a resource (surface/texture) after use.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//! 
//! \param [in]     pResource    surface/texture
//!
//! \return ::NVAPI_OK, ::NVAPI_ERROR 
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_UnregisterResource(IDirect3DResource9* pResource);

#endif //defined(_D3D9_H_)



#if defined(_D3D9_H_)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_AliasSurfaceAsTexture
//
//! \fn NvAPI_D3D9_AliasSurfaceAsTexture(IDirect3DDevice9* pDev,
//!                                              IDirect3DSurface9* pSurface,
//!                                              IDirect3DTexture9 **ppTexture,
//!                                              DWORD dwFlag);
//!   DESCRIPTION: Create a texture that is an alias of a surface registered with NvAPI.  The
//!                new texture can be bound with IDirect3DDevice9::SetTexture().  Note that the texture must
//!                be unbound before drawing to the surface again.
//!                Unless the USE_SUPER flag is passed, MSAA surfaces will be resolved before
//!                being used as a texture.  MSAA depth buffers are resolved with a point filter,
//!                and non-depth MSAA surfaces are resolved with a linear filter.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]    pDev         The D3D device that owns the objects
//! \param [in]    pSurface     Pointer to a surface that has been registered with NvAPI 
//!                             to which a texture alias is to be provided
//! \param [out]   ppTexture    Fill with the texture created
//! \param [in]    dwFlag       NVAPI_ALIAS_SURFACE_FLAG to describe how to handle the texture
//!
//! \retval ::NVAPI_OK                  completed request
//! \retval ::NVAPI_INVALID_POINTER     A null pointer was passed as an argument
//! \retval ::NVAPI_INVALID_ARGUMENT    One of the arguments was invalid, probably dwFlag.
//! \retval ::NVAPI_UNREGISTERED_RESOURCE pSurface has not been registered with NvAPI
//! \retval ::NVAPI_ERROR               error occurred
//
///////////////////////////////////////////////////////////////////////////////


//! \ingroup dx
//! See NvAPI_D3D9_AliasSurfaceAsTexture().
typedef enum {
    NVAPI_ALIAS_SURFACE_FLAG_NONE                     = 0x00000000,
    NVAPI_ALIAS_SURFACE_FLAG_USE_SUPER                = 0x00000001,  //!< Use the surface's msaa buffer directly as a texture, rather than resolving. (This is much slower, but potentially has higher quality.)
    NVAPI_ALIAS_SURFACE_FLAG_MASK                     = 0x00000001
} NVAPI_ALIAS_SURFACE_FLAG;


//! \ingroup dx
NVAPI_INTERFACE NvAPI_D3D9_AliasSurfaceAsTexture(IDirect3DDevice9* pDev,
                                                 IDirect3DSurface9* pSurface,
                                                 IDirect3DTexture9 **ppTexture,
                                                 DWORD dwFlag);
#endif //defined(_D3D9_H_)
#if defined(_D3D9_H_)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_StretchRectEx
//
//! DESCRIPTION:     This API copies the contents of the source resource to the destination
//!                  resource.  This function can convert
//!                  between a wider range of surfaces than
//!                  IDirect3DDevice9::StretchRect.  For example, it can copy
//!                  from a depth/stencil surface to a texture.
//!
//!                  The source and destination resources *must* be registered
//!                  with NvAPI before being used with NvAPI_D3D9_StretchRectEx().
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]     pDevice             The D3D device that owns the objects.
//! \param [in]     pSourceResource     Pointer to the source resource.
//! \param [in]     pSrcRect            Defines the rectangle on the source to copy from.  If NULL, copy from the entire resource.
//! \param [in]     pDestResource       Pointer to the destination resource.
//! \param [in]     pDstRect            Defines the rectangle on the destination to copy to.  If NULL, copy to the entire resource.
//! \param [in]     Filter              Choose a filtering method: D3DTEXF_NONE, D3DTEXF_POINT, D3DTEXF_LINEAR.
//!
//! \retval ::NVAPI_OK                       completed request
//! \retval ::NVAPI_INVALID_POINTER          An invalid pointer was passed as an argument (probably NULL)
//! \retval ::NVAPI_INVALID_ARGUMENT         One of the arguments was invalid
//! \retval ::NVAPI_UNREGISTERED_RESOURCE    a resource was passed in without being registered
//! \retval ::NVAPI_ERROR                    error occurred
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_StretchRectEx(IDirect3DDevice9 * pDevice,
                                         IDirect3DResource9 * pSourceResource,
                                         CONST RECT * pSourceRect,
                                         IDirect3DResource9 * pDestResource,
                                         CONST RECT * pDestRect,
                                         D3DTEXTUREFILTERTYPE Filter);

#endif //defined(_D3D9_H_)
#if defined(_D3D9_H_)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_ClearRT
//
//! DESCRIPTION:     This API Clears the currently bound render target(s) with the 
//!                  given color
//!
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]     pDevice             The D3D device that owns the objects.
//! \param [in]     dwNumRects          The no of rectangles to clear. If 0, clear the entire surface (clipped to viewport)
//! \param [in]     pRects              Defines the rectangles to clear.  Should be NULL if dwNumRects == 0
//! \param [in]     r                   red component of the clear color
//! \param [in]     g                   green component of the clear color
//! \param [in]     b                   blue component of the clear color
//! \param [in]     a                   alpha component of the clear color
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_ClearRT(IDirect3DDevice9 * pDevice,
                                   NvU32 dwNumRects,
                                   CONST RECT * pRects,
                                   float r, float g, float b, float a);
#endif //if defined(_D3D9_H_)



#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D_GetObjectHandleForResource
//
//!   DESCRIPTION: This API gets a handle to a resource.
//!
//! \param [in]  pDev       The ID3D11Device, ID3D10Device or IDirect3DDevice9 to use
//! \param [in]  pResource  The ID3D10Resource, ID3D10Resource or IDirect3DResource9 from which
//!                         we want the NvAPI handle
//! \param [out]  pHandle   A handle to the resource
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \return ::NVAPI_OK if the handle was populated.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_GetObjectHandleForResource(
    IUnknown *pDevice,
    IUnknown *pResource,
    NVDX_ObjectHandle *pHandle);


#endif //if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)


#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D_SetDriverDebugState (for DX9/DX10)
//
//! DESCRIPTION:     This function sets the internal driver state that affects debugging code.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]        stateEnum    internal state to change (usually encoded as 'fourcc' name)
//! \param [in]        stateValue   new state value
//!
//! \retval ::NVAPI_OK     If the state changed was committed
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_SetDriverDebugState(IUnknown *pDev,
                                              NvU32     stateEnum,
                                              NvU32     stateValue);
#endif //defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)

#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
#if defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D_SetDriverDebugState (for DX11)
//
//! DESCRIPTION:     This function sets the internal driver state that affects debugging code.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! \param [in] stateEnum    internal state to change (usually encoded as 'fourcc' name)
//! \param [in] stateValue   new state value
//!
//! \retval ::NVAPI_OK     if the state changed was committed
//!
//! \ingroup dx 
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_SetDriverDebugState(ID3D11DeviceContext *pDc,
                                                NvU32                stateEnum,
                                                NvU32                stateValue);
#endif  //defined(__d3d11_h__)
#endif //defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)

#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D_SetDriverDebugString (for DX9/DX10)
//
//! DESCRIPTION:     This function sets the internal driver state that affects debugging code.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 349
//!
//! \param [in]        stateEnum    internal state to change (usually encoded as 'fourcc' name)
//! \param [in]        pStateString new state string
//!
//! \retval ::NVAPI_OK     If the state changed was committed
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_SetDriverDebugString(IUnknown        *pDev,
                                               NvU32            stateEnum,
                                               const wchar_t   *pStateString);
#endif //defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)

#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
#if defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D_SetDriverDebugString (for DX11)
//
//! DESCRIPTION:     This function sets the internal driver state that affects debugging code.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! \param [in] stateEnum    internal state to change (usually encoded as 'fourcc' name)
//! \param [in] pStateString new state string
//!
//! \retval ::NVAPI_OK     if the state changed was committed
//!
//! \ingroup dx 
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_SetDriverDebugString(ID3D11DeviceContext *pDc,
                                                 NvU32                stateEnum,
                                                 const wchar_t       *pStateString);
#endif  //defined(__d3d11_h__)
#endif //defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)

#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D_SetResourceHint
//
//! \fn NvAPI_D3D_SetResourceHint(IUnknown *pDev, NVDX_ObjectHandle obj,
//!                                          NVAPI_D3D_SETRESOURCEHINT_CATEGORY dwHintCategory, 
//!                                          NvU32 dwHintName, 
//!                                          NvU32 *pdwHintValue)
//!
//!   DESCRIPTION: This is a general purpose function for passing down various resource
//!                related hints to the driver. Hints are divided into categories
//!                and types within each category.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [in] pDev            The ID3D10Device or IDirect3DDevice9 that is a using the resource
//! \param [in] obj             Previously obtained HV resource handle
//! \param [in] dwHintCategory  Category of the hints
//! \param [in] dwHintName      A hint within this category
//! \param [in] *pdwHintValue   Pointer to location containing hint value
//!
//! \return an int which could be an NvAPI status or DX HRESULT code
//!
//! \retval ::NVAPI_OK               
//! \retval ::NVAPI_INVALID_ARGUMENT  
//! \retval ::NVAPI_INVALID_CALL     It is illegal to change a hint dynamically when the resource is already bound.
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//! \ingroup dx
//! Valid categories for NvAPI_D3D_SetResourceHint()
typedef enum _NVAPI_D3D_SETRESOURCEHINT_CATEGORY
{
    NVAPI_D3D_SRH_CATEGORY_SLI = 1
} NVAPI_D3D_SETRESOURCEHINT_CATEGORY;


//
//  NVAPI_D3D_SRH_SLI_APP_CONTROLLED_INTERFRAME_CONTENT_SYNC: 


//! \ingroup dx
//!  Types of SLI hints; \n
//!  NVAPI_D3D_SRH_SLI_APP_CONTROLLED_INTERFRAME_CONTENT_SYNC: Valid values : 0 or 1 \n
//!  Default value: 0 \n
//!  Explanation: If the value is 1, the driver will not track any rendering operations that would mark this resource as dirty, 
//!  avoiding any form of synchronization across frames rendered in parallel in multiple GPUs in AFR mode.
typedef enum _NVAPI_D3D_SETRESOURCEHINT_SLI
{
    NVAPI_D3D_SRH_SLI_APP_CONTROLLED_INTERFRAME_CONTENT_SYNC = 1
}  NVAPI_D3D_SETRESOURCEHINT_SLI;

//! \ingroup dx
NVAPI_INTERFACE NvAPI_D3D_SetResourceHint(IUnknown *pDev, NVDX_ObjectHandle obj,
                                          NVAPI_D3D_SETRESOURCEHINT_CATEGORY dwHintCategory, 
                                          NvU32 dwHintName, 
                                          NvU32 *pdwHintValue);
#endif //defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)

#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D_BeginResourceRendering
//
//! \fn NvAPI_D3D_BeginResourceRendering(IUnknown *pDev, NVDX_ObjectHandle obj, NvU32 Flags)
//!   DESCRIPTION: This function tells the driver that the resource will begin to receive updates. It must be used in combination with NvAPI_D3D_EndResourceRendering(). 
//!                The primary use of this function is allow the driver to initiate early inter-frame synchronization of resources while running in AFR SLI mode. 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]  pDev         The ID3D10Device or IDirect3DDevice9 that is a using the resource
//! \param [in]  obj          Previously obtained HV resource handle
//! \param [in]  Flags        The flags for functionality applied to resource while being used.
//!
//! \retval ::NVAPI_OK                Function succeeded, if used properly and driver can initiate proper sync'ing of the resources.
//! \retval ::NVAPI_INVALID_ARGUMENT  Bad argument(s) or invalid flag values
//! \retval ::NVAPI_INVALID_CALL      Mismatched begin/end calls
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup dx
//! Used in NvAPI_D3D_BeginResourceRendering().
typedef enum  _NVAPI_D3D_RESOURCERENDERING_FLAG
{
    NVAPI_D3D_RR_FLAG_DEFAULTS                 = 0x00000000,  //!< All bits set to 0 are defaults.
    NVAPI_D3D_RR_FLAG_FORCE_DISCARD_CONTENT    = 0x00000001,  //!< (bit 0) The flag forces to discard previous content of the resource regardless of the NvApiHints_Sli_Disable_InterframeSync hint
    NVAPI_D3D_RR_FLAG_FORCE_KEEP_CONTENT       = 0x00000002,   //!< (bit 1) The flag forces to respect previous content of the resource regardless of the NvApiHints_Sli_Disable_InterframeSync hint
    NVAPI_D3D_RR_FLAG_MULTI_FRAME              = 0x00000004   //!< (bit 2) The flag hints the driver that content will be used for many frames. If not specified then the driver assumes that content is used only on the next frame
} NVAPI_D3D_RESOURCERENDERING_FLAG;

//! \ingroup dx
NVAPI_INTERFACE NvAPI_D3D_BeginResourceRendering(IUnknown *pDev, NVDX_ObjectHandle obj, NvU32 Flags);

#endif //defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)


#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D_EndResourceRendering
//
//!   DESCRIPTION: This function tells the driver that the resource is done receiving updates. It must be used in combination with
//!                NvAPI_D3D_BeginResourceRendering(). 
//!                The primary use of this function is allow the driver to initiate early inter-frame syncs of resources while running in AFR SLI mode. 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]  pDev         The ID3D10Device or IDirect3DDevice9 thatis a using the resource
//! \param [in]  obj          Previously obtained HV resource handle
//! \param [in]  Flags        Reserved, must be zero
//
//! \retval ::NVAPI_OK                Function succeeded, if used properly and driver can initiate proper sync'ing of the resources.
//! \retval ::NVAPI_INVALID_ARGUMENT  Bad argument(s) or invalid flag values
//! \retval ::NVAPI_INVALID_CALL      Mismatched begin/end calls
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_EndResourceRendering(IUnknown *pDev, NVDX_ObjectHandle obj, NvU32 Flags);
#endif //if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)



#if defined(_D3D9_H_) || defined(__d3d10_h__)

///////////////////////////////////////////////////////////////////////////////
// NVAPI Query Types
///////////////////////////////////////////////////////////////////////////////

//! \ingroup dx
//! Used in NvAPI_D3D_CreateQuery() and NvAPI_D3D_Query_GetType().
typedef enum _NVAPI_D3D_QUERY_TYPE
{
    NVAPI_D3D_QUERY_TYPE_RESERVED0       = 0,
    NVAPI_D3D_QUERY_TYPE_RESERVED1       = 1,
    NVAPI_D3D_QUERY_TYPE_RESERVED2       = 2,
    NVAPI_D3D_QUERY_TYPE_RESERVED3       = 3,
    NVAPI_D3D_QUERY_TYPE_PMTRIGGER       = 0,
    NVAPI_D3D_QUERY_TYPE_ZCULL_STATS     = 1,
    NVAPI_D3D_QUERY_TYPE_FE_TIMESTAMP    = 2,
    NVAPI_D3D_QUERY_TYPE_DA_TIMESTAMP    = 3,
    NVAPI_D3D_QUERY_TYPE_ROP_TIMESTAMP   = 4,
}NVAPI_D3D_QUERY_TYPE;


//! \ingroup dx
//! See NvAPI_D3D_Query_GetData().
typedef enum _NVAPI_D3D_QUERY_GETDATA_FLAGS
{
    NVAPI_D3D_QUERY_GETDATA_FLUSH      = 0,
    NVAPI_D3D_QUERY_GETDATA_DONOTFLUSH = 1
}NVAPI_D3D_QUERY_GETDATA_FLAGS;


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D_CreateQuery
//
//! DESCRIPTION:     This API creates NVIDIA-specific D3D Query Objects. For DirectX 11, if a device is supplied the query will
//!                  always execute on the immediate context.  This makes sense for almost all queries since GetData is
//!                  invalid on deferred contexts. If a DirectX 11 context is supplied, the query will always execute on that context.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]      pDeviceOrContext    The D3D9, D3D10, D3D11 device, or D3D11 device context to create this query object on
//! \param [in]      type                Type of the query to be created (see NVAPI_D3D_QUERY_TYPE)
//! \param [out]     pHandle             The handle to the Query object
//!
//!
//! \retval ::NVAPI_OK - completed request
//! \retval ::NVAPI_INVALID_POINTER - pDevice was NULL
//! \retval ::NVAPI_INVALID_ARGUMENT - one of the arguments was not valid
//! \retval ::NVAPI_OUT_OF_MEMORY - unable to allocate sufficient memory to complete the call
//! \retval ::NVAPI_ERROR - error occurred
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_CreateQuery(IUnknown *pDeviceOrContext, NVAPI_D3D_QUERY_TYPE type, NVDX_ObjectHandle *pHandle);

#endif //defined(_D3D9_H_) || defined(__d3d10_h__)
#if defined(_D3D9_H_) || defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D_DestroyQuery
//
//! DESCRIPTION:    This API destroys NVIDIA-specific Direct3D query objects.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]    queryHandle      The handle to the Query object
//!
//! \retval ::NVAPI_OK 
//! \retval ::NVAPI_INVALID_HANDLE  The Query object handle is invalid.
//! \retval ::NVAPI_INVALID_CALL    The call could not be completed.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_DestroyQuery(NVDX_ObjectHandle queryHandle);

#endif //defined(_D3D9_H_) || defined(__d3d10_h__)
#if defined(_D3D9_H_) || defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D_Query_Begin
//
//! DESCRIPTION:     This API mark the beginning of a series of commands.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]    queryHandle      The handle to the Query object
//!
//! \retval ::NVAPI_OK 
//! \retval ::NVAPI_INVALID_HANDLE  The Query object handle is invalid.
//! \retval ::NVAPI_INVALID_CALL    The call could not be completed.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_Query_Begin(NVDX_ObjectHandle queryHandle);

#endif //defined(_D3D9_H_) || defined(__d3d10_h__)
#if defined(_D3D9_H_) || defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D_Query_End
//
//! DESCRIPTION:    This API marks the end of a series of commands.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]    queryHandle      The handle to the Query object
//!
//! \retval ::NVAPI_OK 
//! \retval ::NVAPI_INVALID_HANDLE  The Query object handle is invalid.
//! \retval ::NVAPI_INVALID_CALL    The call could not be completed.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_Query_End(NVDX_ObjectHandle queryHandle);

#endif //defined(_D3D9_H_) || defined(__d3d10_h__)
#if defined(_D3D9_H_) || defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D_Query_GetData
//
//! DESCRIPTION:     This API polls a queried resource to get the query state or a query result.
//!                  This makes it possible to get data from the GPU or the driver asynchronously.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]     queryHandle         The handle to the Query object
//! \param [in]     dwSize              Size of the data to retrieve or 0;
//!                                     This value can be obtained with NvAPI_D3D_Query_GetDataSize().
//! \param [in]     dwGetDataFlags      Optional flags; can be 0 or any combination of NVAPI_D3D_QUERY_GETDATA_FLAGS
//! \param [out]    pData               Address of memory that will receive the data 
//!                                     If NULL, GetData will be used only to check status.
//!
//! \retval ::NVAPI_OK 
//! \retval ::NVAPI_INVALID_HANDLE  The Query object handle is invalid
//! \retval ::NVAPI_INVALID_CALL    The call could not be completed
//! \retval ::NVAPI_DATA_NOT_FOUND  The Queried data was not yet available
//! \retval ::NVAPI_ERROR 
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_Query_GetData(NVDX_ObjectHandle queryHandle, void* pData, UINT dwSize, UINT dwGetDataFlags);

#endif //defined(_D3D9_H_) || defined(__d3d10_h__)
#if defined(_D3D9_H_) || defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D_Query_GetDataSize
//
//! DESCRIPTION:    This API gets the size of the data (in bytes) that is output when calling
//!                 NvAPI_D3D_Query_GetData().
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]     queryHandle         The handle to the Query object
//! \param [out]    pDwSize             The requested size
//! 
//! \retval ::NVAPI_OK             
//! \retval ::NVAPI_INVALID_HANDLE   the Query object handle is invalid
//! \retval ::NVAPI_INVALID_POINTER  pDwSize is NULL
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_Query_GetDataSize(NVDX_ObjectHandle queryHandle, UINT *pDwSize);

#endif //defined(_D3D9_H_) || defined(__d3d10_h__)
#if defined(_D3D9_H_) || defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D_Query_GetType
//
//! DESCRIPTION:    This API gets the NVAPI_D3D_QUERY_TYPE of the given query object.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]    queryHandle         The handle to the Query object
//! \param [out]   pType               The requested NVAPI_D3D_QUERY_TYPE value
//!
//! \retval ::NVAPI_OK 
//! \retval ::NVAPI_INVALID_HANDLE   the Query object handle is invalid
//! \retval ::NVAPI_INVALID_POINTER  pType is NULL
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_Query_GetType(NVDX_ObjectHandle queryHandle, NVAPI_D3D_QUERY_TYPE *pType);

#endif //defined(_D3D9_H_) || defined(__d3d10_h__)
#if defined(_D3D9_H_) || defined(__d3d10_h__)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D_GetDeviceKmtHandle
//
//!   DESCRIPTION: This function retrieves the KMT handle for the specified device.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//! \param [in] pDev     The target device
//! \param [out]phDevice The device's KMT handle
//!
//! \return NVAPI_OK if and only if phDevice was populated with a valid KMT handle
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_GetDeviceKmtHandle(IUnknown *pDev,
                                             NvU64* phDevice);

#endif //defined(_D3D9_H_) || defined(__d3d10_h__)
#if defined(_D3D9_H_) || defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D_CudaInteropFunction
//
//!   DESCRIPTION: This API is a container for a number of CUDA interop functions, including
//!                open/close interop, register/unregister resource, map/unmap
//!                resource, and sync.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//! \param [in]   pDev       The ID3D10Device or IDirect3DDevice9 to use
//! \param [in]   dwFunction Identifier for the interop function to call
//! \param [in]   pData      The data that will be used by the method
//!
//! \return NVAPI_OK if the call succeeded
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_CudaInteropFunction(IUnknown *pDev,
                                              UINT dwFunction,
                                              void *pData);

#endif //defined(_D3D9_H_) || defined(__d3d10_h__)
#if defined(_D3D9_H_) || defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D_CudaInteropGetObjectHandle
//
//!   DESCRIPTION: This API gets a handle to a resource for use by CUDA.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//! \param [in]  pDev       The ID3D10Device or IDirect3DDevice9 to use
//! \param [in]  pResource  The IDirect3DResource9 or ID3D10Resource to which
//!                         we want the NvAPI handle
//! \param [out] pHandle    A handle to the resource
//!
//! \return  NVAPI_OK if the handle was populated.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_CudaInteropGetObjectHandle(
    IUnknown *pDevice,
    IUnknown *pResource,
    NVDX_ObjectHandle *pHandle);

#endif  // #if defined(_D3D9_H_) || defined(__d3d10_h__)

#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D_RegisterApp
//
//! DESCRIPTION:    This API allows known DirectX 11, DirectX 10, or DirectX 9 applications to register themselves in order to enable specific driver modes.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \param [in] userAppId  A predetermined NVIDIA-specified number that the driver uses to 
//!                        turn on application-specific features.
//!                        If the code is not recognized, it would return ::NVAPI_NOT_SUPPORTED.
//!                        Otherwise, it would return ::NVAPI_OK.
//!
//! \retval ::NVAPI_ERROR             Registration failed.
//! \retval ::NVAPI_OK                The application is supported.
//! \retval ::NVAPI_INVALID_ARGUMENT  Bad parameters were given.
//!
//! \ingroup dx 
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_RegisterApp(IUnknown *pDev, NvU32 userAppId);
#endif // defined(_D3D9_H_) || defined(__d3d10_h__)





//-----------------------------------------------------------------------------
// Direct3D9 APIs
//-----------------------------------------------------------------------------

#if defined(_D3D9_H_) && defined(__cplusplus)

//! \ingroup dx
//! @{

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_CreatePathContextNV
//
//! \fn NvAPI_D3D9_CreatePathContextNV(IDirect3DDevice9* pDevice, NvU32* context)
//!     DESCRIPTION:   This API call is part of the DX implementation of the 
//!                  NV Path Library.
//!                  Creates a new NVPL context.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   pDevice  Direct3D 9 device
//! \param [out]  context  NVPL context
//!
//!\return NvAPI status code or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------
// NV Path Library data types
//--------------------------------------------------------------------------------------

typedef enum _NV_PATH_DATATYPE
{
    NV_BYTE                        = 0,
    NV_UNSIGNED_BYTE,
    NV_SHORT,
    NV_UNSIGNED_SHORT,
    NV_INT,
    NV_UNSIGNED_INT,
    NV_FLOAT,
    NV_FIXED
} NvPathDataType;

typedef enum _NV_PATH_PARAMTYPE
{
    PATH_QUALITY_NV             = 0x8ED8,
    FILL_RULE_NV                = 0x8ED9,
    STROKE_CAP0_STYLE_NV        = 0x8EE0,
    STROKE_CAP1_STYLE_NV        = 0x8EE1,
    STROKE_CAP2_STYLE_NV        = 0x8EE2,
    STROKE_CAP3_STYLE_NV        = 0x8EE3,
    STROKE_JOIN_STYLE_NV        = 0x8EE8,
    STROKE_MITER_LIMIT_NV       = 0x8EE9
} NVPathParamType;

typedef enum _NV_PATH_FILLRULE
{
    EVEN_ODD_NV                 = 0x8EF0,
    NON_ZERO_NV                 = 0x8EF1
} NVPathFillRule;

typedef enum _NV_PATH_CAPSTYLE
{
    CAP_BUTT_NV                 = 0x8EF4,
    CAP_ROUND_NV                = 0x8EF5,
    CAP_SQUARE_NV               = 0x8EF6,
    CAP_TRIANGLE_NV             = 0x8EF7
} NVPathCapStyle;

typedef enum _NV_PATH_JOINSTYLE
{
    JOIN_MITER_NV               = 0x8EFC,
    JOIN_ROUND_NV               = 0x8EFD,
    JOIN_BEVEL_NV               = 0x8EFE,
    JOIN_CLIPPED_MITER_NV       = 0x8EFF
} NVPathJoinStyle;

typedef enum _NV_PATH_TARGETTYPE
{
    MATRIX_PATH_TO_CLIP_NV      = 0x8F04,
    MATRIX_STROKE_TO_PATH_NV    = 0x8F05,
    MATRIX_PATH_COORD0_NV       = 0x8F08,
    MATRIX_PATH_COORD1_NV       = 0x8F09,
    MATRIX_PATH_COORD2_NV       = 0x8F0A,
    MATRIX_PATH_COORD3_NV       = 0x8F0B
} NVPathTargetType;

typedef enum _NV_PATH_MODE
{
    FILL_PATH_NV                = 0x8F18,
    STROKE_PATH_NV              = 0x8F19
} NVPathMode;

typedef enum _NV_PATH_CMD
{
    MOVE_TO_NV                  = 0x00,
    LINE_TO_NV                  = 0x01,
    QUADRATIC_BEZIER_TO_NV      = 0x02,
    CUBIC_BEZIER_TO_NV          = 0x03,
    START_MARKER_NV             = 0x20,
    CLOSE_NV                    = 0x21,
    STROKE_CAP0_NV              = 0x40,
    STROKE_CAP1_NV              = 0x41,
    STROKE_CAP2_NV              = 0x42,
    STROKE_CAP3_NV              = 0x43,
} NVPathCmd;


NVAPI_INTERFACE NvAPI_D3D9_CreatePathContextNV(IDirect3DDevice9* pDevice, NvU32* context);

//! @}

#endif //defined(_D3D9_H_) && defined(__cplusplus)




#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_DestroyPathContextNV
//
//!     DESCRIPTION:   This API call is part of the DX implementation of the 
//!                  NV Path Library.
//!                  Destroys a NVPL context. This function *MUST* be called
//!                    on all created path contexts or else memory leaks will
//!                    occur.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]      context  NVPL context
//!
//! \return ::NVAPI_OK or ::NVAPI_INVALID_ARGUMENT
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_DestroyPathContextNV(NvU32 context);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_CreatePathNV
//
//!     DESCRIPTION:   This API call is part of the DX implementation of the 
//!                  NV Path Library.
//!                  Creates a NVPL path. 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]        context      NVPL context
//! \param [in]        datatype      Type of path vertex data
//! \param [in]        numCommands      Number of commands in path
//! \param [in]        commands      Path command buffer
//!
//! \param [out]    path          Path handle
//!
//! \return   NvAPI status code or DX HRESULT code
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_CreatePathNV(NvU32 context, NvPathDataType datatype, NvU32 numCommands, const NvU8* commands, NvU32* path);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_DeletePathNV
//
//!     DESCRIPTION:   This API call is part of the DX implementation of the 
//!                  NV Path Library.
//!                  Destroys a NVPL path. This function *MUST* be called
//!                    on all created paths or else memory leaks will occur.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]    path  NVPL path handle
//!
//! \return ::NVAPI_OK or ::NVAPI_INVALID_ARGUMENT
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_DeletePathNV(NvU32 path);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_PathVerticesNV
//
//!     DESCRIPTION:   This API call is part of the DX implementation of the 
//!                  NV Path Library.
//!                  Sets vertex data for a path.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]          path  NVPL path handle
//! \param [in        vertices  vertex data
//!
//! \return  NvAPI status code or DX HRESULT code
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_PathVerticesNV(NvU32 path, const void* vertices);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_PathParameterfNV
//
//!     DESCRIPTION:   This API call is part of the DX implementation of the 
//!                  NV Path Library.
//!                  Sets a path rendering parameter of type float
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//!           INPUT:    path - NVPL path handle
//!           INPUT:    paramType - parameter name
//!           INPUT:    param - parameter value
//!
//! \return   NvAPI status code or DX HRESULT code
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_PathParameterfNV(NvU32 path, NVPathParamType paramType, float param);
#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_PathParameteriNV
//
//!     DESCRIPTION:   This API call is part of the DX implementation of the 
//!                  NV Path Library.
//!                  Sets a path rendering parameter of type int
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]        path      NVPL path handle
//! \param [in]        paramType parameter name
//! \param [in]        param     parameter value
//!
//! \return   NvAPI status code or DX HRESULT code
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_PathParameteriNV(NvU32 path, NVPathParamType paramType, int param);
#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_PathMatrixNV
//
//!     DESCRIPTION:   This API call is part of the DX implementation of the 
//!                  NV Path Library.
//!                  Sets a transformation matrix
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]     context  NVPL context handle
//! \param [in]     target   type of transformation
//! \param [in]     value  matrix values
//!
//! \return  NvAPI status code or DX HRESULT code
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_PathMatrixNV(NvU32 context, NVPathTargetType paramType, const float* value);
#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_PathDepthNV
//
//!     DESCRIPTION:   This API call is part of the DX implementation of the 
//!                  NV Path Library.
//!                  Sets the current path depth
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]    context   NVPL context handle
//! \param [in]       value     depth value
//!
//! \return  NvAPI status code or DX HRESULT code
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_PathDepthNV(NvU32 context, float value);
#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_PathClearDepthNV
//
//!     DESCRIPTION:   This API call is part of the DX implementation of the 
//!                  NV Path Library.
//!                  Clears the depth buffer
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  context  NVPL context handle
//! \param [in]  value    depth value
//!
//! \return  NvAPI status code or DX HRESULT code
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_PathClearDepthNV(NvU32 context, float value);
#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_PathEnableDepthTestNV
//
//!     DESCRIPTION:   This API call is part of the DX implementation of the 
//!                 NV Path Library.
//!                  Enables / Disables depth testing
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//!           INPUT:    context - NVPL context handle
//!           INPUT:    enable - enable depth test if true, else disable
//!
//! RETURN STATUS: a NvAPI status code or DX HRESULT code
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_PathEnableDepthTestNV(NvU32 context, bool enable);
#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_PathEnableColorWriteNV
//
//!     DESCRIPTION:   This API call is part of the DX implementation of the 
//!                  NV Path Library.
//!                  Enables / Disables color write
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]    context  NVPL context handle
//! \param [in] enable   enable color write if true, else disable
//!
//! \return NvAPI status code or DX HRESULT code
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_PathEnableColorWriteNV(NvU32 context, bool enable);
#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_DrawPathNV
//
//!     DESCRIPTION:   This API call is part of the DX implementation of the 
//!                  NV Path Library.
//!                  Draws the path.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]    path  NVPL path handle
//! \param [in] mode  path rendering mode
//!
//! \return NvAPI status code or DX HRESULT code
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_DrawPathNV(NvU32 path, NVPathMode mode);


#endif //defined(_D3D9_H_) && defined(__cplusplus)

#if defined(_D3D9_H_) && defined(__cplusplus)
//! SUPPORTED OS:  Windows XP and higher
//!

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_GetSurfaceHandle
//
//!  This function gets the handle of a given surface. This handle uniquely 
//!  identifies the surface through all NvAPI entries.
//!
//!
//! \since Release: 313
//!
//! \param [in]     pSurface  Surface to be identified
//! \param [out]    pHandle    Will be filled by the return handle
//!
//! \return An int which could be an NvAPI status or DX HRESULT code
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_GetSurfaceHandle(IDirect3DSurface9 *pSurface, 
                                        NVDX_ObjectHandle *pHandle);

#endif //defined(_D3D9_H_) && defined(__cplusplus)

#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_GetOverlaySurfaceHandle
//
//! \fn NvAPI_D3D9_GetOverlaySurfaceHandles(IDirect3DDevice9 *pDev, NV_OVLY_SURFS_INFO *pInfo)
//!   DESCRIPTION: This function gets the surface handles for the YUY2 overlay surfaces created.
//!
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 175
//!
//!   \param [in]  pDev  Device whose YUY2 surface handles need to be retrieved.
//!
//!   \param [out] pInfo Array (see NV_OVLY_SURFS_INFO) of surface handles (NVDX_ObjectHandle) that will be filled by
//!                the driver. The array has to initialized before it is passed on to 
//!                the function. The handles are populated in the order in which they 
//!                are created. For example, the handle of the first surface created will be
//!                stored in pHandle[0], second surface will be stored in pHandle[1], and so on.
//!
//! \return  An int which could be an NvAPI status or DX HRESULT code
//////////////////////////////////////////////////////////////////////////////


//! \ingroup dx
//! Used in NV_OVLY_SURFS_INFO.
#define MAX_OVLY_SURFS     6

//! \ingroup dx
//! Overlay surface handle and other information - used in NvAPI_D3D9_GetOverlaySurfaceHandles().
typedef struct _NV_OVLY_SURFS_INFO
{
    NVDX_ObjectHandle  handle[MAX_OVLY_SURFS];
    unsigned int       numSurfs;
}NV_OVLY_SURFS_INFO;


//! \ingroup dx
NVAPI_INTERFACE NvAPI_D3D9_GetOverlaySurfaceHandles(IDirect3DDevice9 *pDev, NV_OVLY_SURFS_INFO *pInfo);
#endif //defined(_D3D9_H_) && defined(__cplusplus)



#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_GetTextureHandle
//
//!  This function gets the handle of a given DirectX 9 texture.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \param [in]    pTexture   Surface to be identified
//! \param [out]   pHandle    Will be filled by the return handle
//!
//! \return An int which could be an NvAPI status or DX HRESULT code
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_GetTextureHandle(IDirect3DTexture9 *pTexture, 
                                        NVDX_ObjectHandle *pHandle);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_GpuSyncGetHandleSize
//
//!  This function returns the size of the init and copy sync handles. These handles are
//!  then allocated and initialized to zero by the application.
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 90
//!
//! \param [out]    pInitHandleSize   size of GpuSync init handle
//! \param [out]    pMapHandleSize    size of GpuSync copy handle
//!
//! \return An int which could be an NvAPI status or DX HRESULT code
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_GpuSyncGetHandleSize(IDirect3DDevice9 *pDev, 
                                            unsigned int *pInitHandleSize,
                                            unsigned int *pMapHandleSize);
#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_GpuSyncInit
//
//! This function sets up sync functionality.
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 90
//!
//! \return An int which could be an NvAPI status or DX HRESULT code
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_GpuSyncInit(IDirect3DDevice9 *pDev, 
                                            void * syncInitData);
#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_GpuSyncEnd
//
//! This function tears down sync structures.
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 90
//!
//! \return An int which could be an NvAPI status or DX HRESULT code
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_GpuSyncEnd(IDirect3DDevice9 *pDev, 
                                            void * syncData);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_GpuSyncMapTexBuffer
//
//! This function maps a texture to receive OpenGL data.
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 90
//!
//! \return An int which could be an NvAPI status or DX HRESULT code
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_GpuSyncMapTexBuffer(IDirect3DDevice9 *pDev, 
                                            IDirect3DTexture9 *pTexture,
                                            void * syncData);
#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_GpuSyncMapSurfaceBuffer
//
//!  This function maps a texture to receive OpenGL data.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//!  \return    An int which could be an NvAPI status or DX HRESULT code
//!  \ingroup   dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_GpuSyncMapSurfaceBuffer(IDirect3DDevice9 *pDev, 
                                                   IDirect3DSurface9 *pSurface,
                                                   void * syncData);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_GpuSyncMapVertexBuffer
//
//! This function maps a vertex buffer to receive OpenGL data.
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 90
//!
//! \return An int which could be an NvAPI status or DX HRESULT code
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_GpuSyncMapVertexBuffer(IDirect3DDevice9 *pDev, 
                                            IDirect3DVertexBuffer9 *pVertexBuffer,
                                            void * syncData);
#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_GpuSyncMapIndexBuffer
//
//!   This function maps an index buffer to receive OpenGL data.
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 177
//!
//!  \return  An int which could be an NvAPI status or DX HRESULT code
//!  \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_GpuSyncMapIndexBuffer(IDirect3DDevice9 *pDev, 
                                            IDirect3DIndexBuffer9 *pIndexBuffer,
                                            void * syncData);
#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_SetPitchSurfaceCreation
//
//!   This function forces the next CreateTexture()/CreateRenderTarget() call to use pitch surfaces.
//!   The action is applied only once for the next surface. Set Signature==0 to make sure this is disabled.
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 177
//!
//!  \return   An int which could be an NvAPI status or DX HRESULT code
//!  \ingroup  dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_SetPitchSurfaceCreation(IDirect3DDevice9 *pDev, 
                                                   NvU32 Signature);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_GpuSyncAcquire
//
//! This function acquires a semaphore for synchronization control of a mapped buffer.
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 90
//!
//! \param [in] accessMode Acquire mapped buffer read/write access
//!
//! \return An int which could be an NvAPI status or DX HRESULT code
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_GpuSyncAcquire(IDirect3DDevice9 *pDev, 
                                            void * syncData);
#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_GpuSyncRelease
//
//! This function releases a semaphore for synchronization control of a mapped buffer.
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 90
//!
//! \param [in] accessMode  Release mapped buffer read/write access
//!
//! \return An int which could be an NvAPI status or DX HRESULT code
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_GpuSyncRelease(IDirect3DDevice9 *pDev, 
                                            void * syncData);
#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_GetCurrentRenderTargetHandle
//
//!  This function gets the handle of the current render target or z-buffer.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \param [in]  pDev     Device whose current render target is to be identified
//!
//! \param [out] pHandle  Will be filled by the return handle
//!
//! \return An int which could be an NvAPI status or DX HRESULT code
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_GetCurrentRenderTargetHandle(IDirect3DDevice9 *pDev,
                                            NVDX_ObjectHandle *pHandle);
#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_GetCurrentZBufferHandle
//
//! 
//!  This function gets the handle of the current z-buffer.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \param [in]  pDev     Device whose current z-buffer is to be identified
//!
//! \param [out] pHandle  Will be filled by the return handle
//!
//! \return An int which could be an NvAPI status or DX HRESULT code
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_GetCurrentZBufferHandle(IDirect3DDevice9 *pDev,
                                               NVDX_ObjectHandle *pHandle);
#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_GetIndexBufferHandle
//
//!  This function gets the handle of a given DirectX 9 index buffer.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \param [in]   pIndexBuffer  Index Buffer to be identified
//! \param [out]  pHandle       Will be filled by the return handle
//!
//! \return An int which could be an NvAPI status or DX HRESULT code
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_GetIndexBufferHandle(IDirect3DIndexBuffer9 *pIndexBuffer, 
                                        NVDX_ObjectHandle *pHandle);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_GetVertexBufferHandle
//
//!  This function gets the handle of a given DirectX 9 vertex buffer.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \param [in]    pVertexBuffer  Vertex Buffer to be identified
//! \param [out]   pHandle        Will be filled by the return handle
//!
//! \return An int which could be an NvAPI status or DX HRESULT code
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_GetVertexBufferHandle(IDirect3DVertexBuffer9 *pVertexBuffer, 
                                        NVDX_ObjectHandle *pHandle);


#endif //defined(_D3D9_H_) && defined(__cplusplus)



#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_CreateTexture
//
//! \fn NvAPI_D3D9_CreateTexture(IDirect3DDevice9 *pDev,
//!   DESCRIPTION: This function creates a texture with special properties. \note The texture 
//!                is always created in "POOL_DEFAULT", not managed. \p
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 173
//!
//!   \param [in]  pDev         The device to get primary surface from Width,Height,Levels,Format 
//!   \param [in]  Width        Width of the top-level of the texture, in pixels. 
//!                             (See MS DirectX interface Direct3D9Device::CreateTexture.)
//!   \param [in]  Height       Height of the top-level of the texture, in pixels.
//!                             (See MS DirectX interface Direct3D9Device::CreateTexture.)
//!   \param [in]  Level        Number of levels in the texture. 
//!                             (See MS DirectX interface Direct3D9Device::CreateTexture.)
//!   \param [in]  Flags        The flags for special texture creation - \p
//!                - FORCEVIDMEM  This will force the texture into video memory, 
//!                               if that cannot be done, the texture creation will fail.
//!                - FORCELINEAR  Ensure the texture is stored in pitched-linear layout.
//!                - NOTMOVABLE   Indicates the texture should not be moved once allocated.
//!                               This is usually used to accommodate a 3rd party DMA engine.
//!                               \note This is only a hint, the OS may still move the texture
//!                                     under memory-constrained circumstances.
//!   \param [in]  format       Describes the format of all levels in the texture. (See the MS DirectX SDK D3DFORMAT enumerated type) 
//!   \param [out] ppTexture    Fill with the texture created. (See MS DirectX SDK IDirect3DTexture9 interface) 
//!   \param [out] pHandle      If non-NULL, fill with the NVDX handle of the created texture.
//
//////////////////////////////////////////////////////////////////////////////


//!  \addtogroup dx
//! @{
#define NV_SURFACEFLAG_FORCEVIDMEM      0x00000001  //!< Flag for texture creation in NvAPI_D3D9_CreateTexture() 
#define NV_SURFACEFLAG_FORCELINEAR      0x00000010  //!< Flag for texture creation in NvAPI_D3D9_CreateTexture() 
#define NV_SURFACEFLAG_NOTMOVABLE       0x00000100  //!< Flag for texture creation in NvAPI_D3D9_CreateTexture() 
//! @}


//!   \ingroup  dx
NVAPI_INTERFACE NvAPI_D3D9_CreateTexture(IDirect3DDevice9 *pDev,
                                         NvU32 Width, NvU32 Height, NvU32 Level,
                                         NvU32 Flags, D3DFORMAT Format,
                                         IDirect3DTexture9 **ppTexture,
                                         NVDX_ObjectHandle *pHandle = 0);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_AliasPrimaryAsTexture
//
//!  This function creates a texture that is an alias of the current device's primary surface.
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 80
//!
//! \param [in]     pDev       The device from which to get the primary surface
//! \param [in]     dwIndex    The index to the primary flipchain of device (usually 0)
//! \param [out]    ppTexture  Fill with the texture created
//! \param [out]    pHandle    If non-NULL, fill with the NVDX handle of the created texture
//!
//! \return An int which could be an NvAPI status or DX HRESULT code
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_AliasPrimaryAsTexture(IDirect3DDevice9 *pDev, 
                                            NvU32 dwIndex,
                                            IDirect3DTexture9 **ppTexture,
                                            NVDX_ObjectHandle *pHandle = 0);
#endif //defined(_D3D9_H_) && defined(__cplusplus)



#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_PresentSurfaceToDesktop
//
//! \fn NvAPI_D3D9_PresentSurfaceToDesktop(IDirect3DDevice9 *pDev,
//!  This function presents a given surface to the desktop. This interface can be
//!  used to start a full-screen flipping mode even within windowed Direct 3D application.
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 80
//!
//! \param [in]    pDev              The device (display) to present to 
//! \param [in]    surfaceHandle     The surface handle obtained from NVD3D9_GetSurfaceHandle().
//!                                  NOTE: NVDX_OBJECT_NONE means restore
//! \param [in]    dwFlipFlags       Flags to indicate SYNC mode (other bits reserved and must be 0)
//! \param [in]    dwExcludeDevices  This is a bitmask (usually 0) to indicate which device
//!                                  will be EXCLUDED from this present. This is only
//!                                  effective when used in a Clone mode configuration where
//!                                  the application wants one monitor to show the specially
//!                                  rendered screen and the other the normal desktop.
//!
//! \note It is application's responsibility to determine which devices are
//!       available on the current Clone mode configuration, through nvcpl interfaces.
//!
//! \return An int which could be an NvAPI status or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////


//! Parameters used for dwFlipFlags (All other bits reserved) - See NvAPI_D3D9_PresentSurfaceToDesktop()
//! \addtogroup dwFlipFlags
//! @{
#define NV_FLIPFLAG_VSYNC               0x00000001  //!< SYNCMODE         (bit 0:1) - 0:NOSYNC, 1:VSYNC, 2:HSYNC
#define NV_FLIPFLAG_HSYNC               0x00000002
#define NV_FLIPFLAG_TRIPLEBUFFERING     0x00000004  //!< TRIPLEBUFFERING  (bit 2)   - 0: DoubleBuffer, 1:TripleBuffer or more
//! @}


//! \ingroup dx
NVAPI_INTERFACE NvAPI_D3D9_PresentSurfaceToDesktop(IDirect3DDevice9 *pDev, 
                                               NVDX_ObjectHandle surfaceHandle, 
                                               NvU32 dwFlipFlags,
                                               NvU32 dwExcludeDevices = 0);
#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
// 
// FUNCTION_NAME: NvAPI_D3D9_CreateVideoBegin
//
//!  DESCRIPTION:  This function signals the driver that the application will next create a set of 
//!                D3DFMT_X8R8G8B8 render targets for overlay use. The call will fail 
//!                if the driver/hardware doesn't support this mode, in which case the 
//!                application should fall back to the traditional overlay (with driver 
//!                internal overlay buffers). If this call returns successfully, then 
//!                before the driver sees _CreateVideoEnd, all D3DFMT_A8R8G8B8 render 
//!                targets will be allocated as overlay surfaces. 
//!                See _CreateVideo, \ref NV_CVFLAG_EXTERNAL_OVERLAY flag for more details.
//!                This interface is only available on Windows Vista.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 165
//!
//! \param [in]    pDev        The device (display) to present to
//!
//! \return        An int which could be an NvAPI status or DX HRESULT code
//! \ingroup       dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_CreateVideoBegin(IDirect3DDevice9 *pDev);
#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
// 
// FUNCTION_NAME: NvAPI_D3D9_CreateVideoEnd
//
//!  DESCRIPTION:  This function signals the driver that the application has finished creating 
//!                D3DFMT_X8R8G8B8 render targets for overlays.
//!                See _CreateVideo, \ref NV_CVFLAG_EXTERNAL_OVERLAY flag for more details.
//!                This interface is only available on Windows Vista.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 165
//!
//!  \param [in]   pDev    The device (display) to present to
//!
//!  \return       An int which could be an NvAPI status or DX HRESULT code
//!  \ingroup      dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_CreateVideoEnd(IDirect3DDevice9 *pDev);

#endif //defined(_D3D9_H_) && defined(__cplusplus)



#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
// 
// FUNCTION_NAME: NvAPI_D3D9_CreateVideo
//
//! \fn NvAPI_D3D9_CreateVideo(IDirect3DDevice9 *pDev,
//!  This function allocates and initializes video resources for playback within a D3D9 context.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 90
//!
//! \param [in]  pDev              The device (display) to present to
//! \param [in]  pCVParams         Pointer to the create video paramater structures. See NV_DX_CREATE_VIDEO_PARAMS1.
//!
//! \return  An int which could be an NvAPI status or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////////////



//! \addtogroup cvflags
//! Create Video Flags - See NV_DX_CREATE_VIDEO_PARAMS1
//! @{

//! Overlay will be used
#define NV_CVFLAG_OVERLAY                   0x00000001 

//! Change source size or flip queue hint once overlay
//! resources have already been allocated.  Be wary
//! of upward allocating new resources, if there is
//! a failure, be prepared to deallocate everything
//! and start from scratch.     
#define NV_CVFLAG_OVERLAY_REINIT            0x00000002      

//! Use overlay surfaces allocated by the application. This flag
//! is supported only in NV_DX_CREATE_VIDEO_PARAMS_VER2 and above 
//! on Windows Vista. 
//!
//! The application sets this flag to indicate that the driver should
//! not allocate any internal overlay buffers, and the first
//! dwNumOvlSurfs surfaces in pCVParams->hOvlSurfs[] will be used for
//! overlay scan-out directly. The driver will validate these surfaces
//! against the following conditions, and fail the call otherwise: 
//!
//! -# No less than NV_CV_MIN_OVERLAY_SURFACE_NUMBER and no more than
//!    NV_CV_MAX_OVERLAY_SURFACE_NUMBER should be passed in.
//! -# Only surface handles of D3DFMT_A8R8G8B8 render targets created
//!    inside a pair of _CreateVideoBegin ()/_CreateVideoEnd() should be
//!    used.
//! -# The size of the surfaces must be identical to the target display.
//!
//! If all of the above condictions are met for each of the surfaces,
//! then the driver will not allocate any internal overlay buffers. Upon
//! _PresentVideo(), the source surface will be used for overlay scan-
//! out directly without the driver copying the content to an overlay
//! buffer first.
#define NV_CVFLAG_EXTERNAL_OVERLAY          0x00000004      

//! Forces full screen video on secondary device to be
//! disabled in multihead modes, regardless of user setting
#define NV_CVFLAG_2ND_FORCE_DISABLE         0x00010000

//! Forces full screen video on secondary device to be
//! enabled on the default device in multihead modes, 
//! regardless of user setting      
#define NV_CVFLAG_2ND_FORCE_ENABLE          0x00020000

//! Forces full screen video on secondary device to be
//! enabled on the primary device in clone mode, 
//! regardless of user setting      
#define NV_CVFLAG_2ND_FORCE_ENABLE1         0x00040000

//! If another application owns the secondary full-screen
//! device, forcibly take possession of it.      
#define NV_CVFLAG_2ND_COMMANDEER            0x00100000 

//! Is the target display secondary display when in Dualview mode     
#define NV_CVFLAG_SECONDARY_DISPLAY         0x01000000     
//! @}

//! \ingroup dx
//! Used in NvAPI_D3D9_CreateVideo()
typedef struct
{
    NvU32 version;       //!< Version of the CreateVideoParams structure
    NvU32 cvFlags;       //!< Initialization flags (See \ref cvflags for description)
    NvU32 flipQueueHint; //!< If an overlay is allocated, this indicates the desired number of flips
                         //!  to be queued (minimum of 1). A larger number is better for performance,
                         //!  but also consumes more frame buffer resources. This number should be
                         //!  set according to the number of fields/frames that can be decoded in
                         //!  advance of presentation. For example, if the decoder cannot decode in advance and
                         //!  must display immediately after decoding a frame, then set this to 1.
                         //!  If the decoder is decoding field content one frame at a time, then it
                         //!  is decoding one field ahead - set this to 2.  If the decoder
                         //!  can decode n flips ahead, then set this to n+1.  If the GPU has
                         //!  constrained frame buffer resources, then set this number lower, and also
                         //!  reduce the decode-ahead pipeline resources accordingly.
    NvU32 maxSrcWidth;   //!< Maximum video source width
    NvU32 maxSrcHeight;  //!< Maximum video source height
} NV_DX_CREATE_VIDEO_PARAMS1;

//! \ingroup dx
#define NV_CV_MIN_OVERLAY_SURFACE_NUMBER    2

//! \ingroup dx
#define NV_CV_MAX_OVERLAY_SURFACE_NUMBER    6

//! \ingroup dx
//! Used in NvAPI_D3D9_CreateVideo()
typedef struct
{
    NvU32 version;       //!< Version of the CreateVideoParams structure 
    NvU32 cvFlags;       //!< Initialization flags (See \ref cvflags for description)
    NvU32 flipQueueHint; //!< If an overlay is allocated, this indicates the desired number of flips
                         //!  to be queued (minimum of 1). A larger number is better for performance,
                         //!  but also consumes more frame buffer resources. This number should be
                         //!  set according to the number of fields/frames that can be decoded in
                         //!  advance of presentation. For example, if the decoder cannot decode in advance and
                         //!  must display immediately after decoding a frame, then set this to 1.
                         //!  If the decoder is decoding field content one frame at a time, then it
                         //!  is decoding one field ahead - set this to 2.  If the decoder
                         //!  can decode n flips ahead, then set this to n+1.  If the GPU has
                         //!  constrained frame buffer resources, then set this number lower, and also
                         //!  reduce the decode-ahead pipeline resources accordingly.
    NvU32 maxSrcWidth;   //!< Maximum video source width
    NvU32 maxSrcHeight;  //!< Maximum video source height
    NvU32 dwNumOvlSurfs; //!< Number of surfaces that the application intends to use for the   
                         //!  overlay (also refer to the NV_CVFLAG_EXTERNAL_OVERLAY flag)
    NVDX_ObjectHandle hOvlSurfs[NV_CV_MAX_OVERLAY_SURFACE_NUMBER];  //!< Handles to the surfaces that the application intends to use
                                                                    //!  for the overlay (also refer to the NV_CVFLAG_EXTERNAL_OVERLAY flag)
} NV_DX_CREATE_VIDEO_PARAMS2;

//! \ingroup dx
typedef NV_DX_CREATE_VIDEO_PARAMS2  NV_DX_CREATE_VIDEO_PARAMS;

//! \ingroup dx
#define NV_DX_CREATE_VIDEO_PARAMS_VER1  MAKE_NVAPI_VERSION(NV_DX_CREATE_VIDEO_PARAMS1,1)

//! \ingroup dx
#define NV_DX_CREATE_VIDEO_PARAMS_VER2  MAKE_NVAPI_VERSION(NV_DX_CREATE_VIDEO_PARAMS2,2)

//! \ingroup dx
#define NV_DX_CREATE_VIDEO_PARAMS_VER   NV_DX_CREATE_VIDEO_PARAMS_VER2



//! \ingroup dx
NVAPI_INTERFACE NvAPI_D3D9_CreateVideo(IDirect3DDevice9 *pDev, 
                                       NV_DX_CREATE_VIDEO_PARAMS *pCVParams);
#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
// 
// FUNCTION_NAME: NvAPI_D3D9_FreeVideo
//
//! This function releases all video resources.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 95
//!      
//! \param [in] pDev   The device (display) to present to
//!
//! \return An int which could be an NvAPI status or DX HRESULT code
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_FreeVideo(IDirect3DDevice9 *pDev);

#endif //defined(_D3D9_H_) && defined(__cplusplus)



#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_PresentVideo
//
//! \fn NvAPI_D3D9_PresentVideo(IDirect3DDevice9 *pDev, 
//!   This function signals a final and complete frame ready for presentation.
//!   It can optionally render to the overlay, but should be called
//!   regardless of whether any actual rendering occurs.  If the
//!   user has enabled full screen video in a multi-head mode,
//!   this frame will also be rendered on the secondary device.
//!
//! \note Use NV_DX_PRESENT_VIDEO_PARAMS_VER in the "version" method for both 32 bit and 64 bit
//!       callers.  For older drivers that do not support 64 bit callers, 32 bit callers
//!       should use the evaluation of MAKE_NVAPI_VERSION(NV_DX_PRESENT_VIDEO_PARAMS1,1)
//!       in that field.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \param [in]   pDev             The device (display) to present to
//! \param [in]   pPVParams        The present video parameters structure. See NV_DX_PRESENT_VIDEO_PARAMS1. 
//!
//! \return An int which could be an NvAPI status or DX HRESULT code
//!
//!                NVAPI_DEVICE_BUSY - This return value indicates the flip request was dropped 
//!                because the hardware flip queue was too deep, thus no more present requests can be 
//!                accepted at the moment. \n
//!
//!                When an external overlay is used (for "external overlay" please refer to NvAPI_D3D9_CreateVideoBegin(),  
//!                NvAPI_D3D9_CreateVideoEnd(), and VER2-only descriptions of NvAPI_D3D9_CreateVideo()), 
//!                a failure in _PresentVideo means the current front (on-screen) buffer will remain  
//!                unchanged. In this case the application should be careful not to render to the current 
//!                front buffer, as it will cause video tearing. The application could retry presenting 
//!                the same frame during the next V-Sync, or continue with rendering the next frame to a 
//!                back buffer.
//
///////////////////////////////////////////////////////////////////////////////

//! \addtogroup pvflags
//! PresentVideo flags - See NV_DX_PRESENT_VIDEO_PARAMS1
//! @{

//! Field is odd
#define NV_PVFLAG_ODD           0x00000001      

//! Field is even
#define NV_PVFLAG_EVEN          0x00000002 

//! Indicates that this frame is protected and guarantees full 
//! screen video will not display this frame on any secondary device.
//! Conversely, not setting this indicates an unprotected frame.     
#define NV_PVFLAG_PROTECTED     0x00000004 
     
//! Indicates progressive frame. If the odd or even flags are set
//! in conjunction with this, it indicates the original field that
//! generated this deinterlaced frame, and attempts to synchronize
//! this presentation to the corresponding display field of an
//! interlaced display
#define NV_PVFLAG_PROGRESSIVE   0x00000008      

//! Show the overlay. \n
//! If the application is minimized or obscured, continue to call NvAPI_D3D9_PresentVideo()
//! for every complete frame without this flag set. \n
//! If enabled, the unprotected video will continue to play in full-screen mode
//! on the secondary device, using the pixel aspect cached from
//! the last time a frame was shown. To change the pixel aspect while hidden,
//! the caller must "show" a frame at least once with a new clipped source and 
//! destination rectangle.  This shown frame can be rendered invisible with
//! appropriate color key selection.
#define NV_PVFLAG_SHOW          0x00000010      

//! Move overlay position without waiting for vblank.
//! The only parameters used are dwDstX, dwDstY, and NV_PVFLAG_SHOW.
#define NV_PVFLAG_FAST_MOVE     0x00000020     

//! If set, blocking flips, wait until the flip queue can accept another flip.
//! A non-blocking flip will return an error if the flip cannot be queued yet.
#define NV_PVFLAG_WAIT          0x00000040      

//! Video data is completely unchanged from the previous flip (used for telecine)
#define NV_PVFLAG_REPEAT        0x00000080

//! Use destination color key.
#define NV_PVFLAG_DST_KEY       0x00000100     

//! Indicates that the overlay is playing full-screen on the desktop.
//! This bit is used to automatically overscan the image on TVs.
#define NV_PVFLAG_FULLSCREEN    0x00000200      

//! Set the current time.
#define NV_PVFLAG_SET_STAMP     0x00001000 

//! If set, use timestamps. \n
//! If not set, flip on the next vblank.     
#define NV_PVFLAG_USE_STAMP     0x00002000     

//! Use source color key.
#define NV_PVFLAG_SRC_KEY       0x00004000
//! @}

//! \ingroup dxvidcontrol
//! Used in NvAPI_D3D9_PresentVideo().
typedef struct 
{
    NvU32 version;                   //!< Structure version
    NVDX_ObjectHandle surfaceHandle; //!< The surface handle obtained from NvAPI_D3D9_GetSurfaceHandle
                                     //!  or NvAPI_D3D9_GetCurrentRenderTargetHandle
    NvU32 pvFlags;                   //!< Presentation flags (See \ref pvflags for description)
    NvU32 colourKey;                 //!< Colour key to use if NV_PVFLAG_DST_KEY is set
    NvU32 timeStampLow;              //
                                     //
    NvU32 timeStampHigh;             //
    NvU32 flipRate;                  //!< Set to the current flip rate.
                                     //!  Set to zero if the frame to be presented is a still frame.
    NvSBox srcUnclipped;             //!< Unclipped source rectangle of the entire frame of data
    NvSBox srcClipped;               //!< Cropped source rectangle.  It is the caller's responsibility to crop
                                     //!  the source if the desktop crops the destination.
    NvSBox dst;                      // 
} NV_DX_PRESENT_VIDEO_PARAMS1;

//! \ingroup dxvidcontrol
typedef NV_DX_PRESENT_VIDEO_PARAMS1 NV_DX_PRESENT_VIDEO_PARAMS;

#ifdef _WIN32
//! \ingroup dxvidcontrol
#define NV_DX_PRESENT_VIDEO_PARAMS_VER1  MAKE_NVAPI_VERSION(NV_DX_PRESENT_VIDEO_PARAMS1,1)
#endif //_WIN32


//! \ingroup dxvidcontrol
#define NV_DX_PRESENT_VIDEO_PARAMS_VER  MAKE_NVAPI_VERSION(NV_DX_PRESENT_VIDEO_PARAMS1,2)



//! \ingroup dxvidcontrol
NVAPI_INTERFACE NvAPI_D3D9_PresentVideo(IDirect3DDevice9 *pDev, 
                                        NV_DX_PRESENT_VIDEO_PARAMS *pPVParams);

#endif //defined(_D3D9_H_) && defined(__cplusplus)

#if defined(_D3D9_H_) && defined(__cplusplus)
//! SUPPORTED OS:  Windows Vista and higher
//!
//! \addtogroup dxvidcontrol
//! @{

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION_NAME: NvAPI_D3D9_VideoSetStereoInfo
//
//! \fn NvAPI_D3D9_VideoSetStereoInfo(IDirect3DDevice9 *pDev,
//!                                            NV_DX_VIDEO_STEREO_INFO *pStereoInfo);
//! \code
//!   DESCRIPTION: This api specifies the stereo format of a surface, so that the
//!                surface could be used for stereo video processing or compositing. 
//!                In particular, this api could be used to link the left and right 
//!                views of a decoded picture.
//!
//! \since Release: 313
//!
//!         INPUT: pDev        - The device on which the stereo surface will be used
//!                pStereoInfo - The stereo format of the surface
//!
//! RETURN STATUS: an int which could be an NvAPI status or DX HRESULT code
//! \endcode
///////////////////////////////////////////////////////////////////////////////

#ifndef NV_STEREO_VIDEO_FORMAT_DEFINE
#define NV_STEREO_VIDEO_FORMAT_DEFINE


typedef enum _NV_STEREO_VIDEO_FORMAT
{
    NV_STEREO_VIDEO_FORMAT_NOT_STEREO         = 0,

    NV_STEREO_VIDEO_FORMAT_SIDE_BY_SIDE_LR    = 1,
    NV_STEREO_VIDEO_FORMAT_SIDE_BY_SIDE_RL    = 2,
    NV_STEREO_VIDEO_FORMAT_TOP_BOTTOM_LR      = 3,
    NV_STEREO_VIDEO_FORMAT_TOP_BOTTOM_RL      = 4,
    NV_STEREO_VIDEO_FORMAT_ROW_INTERLEAVE_LR  = 5,
    NV_STEREO_VIDEO_FORMAT_ROW_INTERLEAVE_RL  = 6,
    NV_STEREO_VIDEO_FORMAT_TWO_FRAMES_LR      = 7,
    NV_STEREO_VIDEO_FORMAT_MONO_PLUS_OFFSET   = 8,

    NV_STEREO_VIDEO_FORMAT_LAST               = 9,
} NV_STEREO_VIDEO_FORMAT;

#endif // NV_STEREO_VIDEO_FORMAT_DEFINE


typedef struct _NV_DX_VIDEO_STEREO_INFO {
    NvU32                     dwVersion;         //!< Must be NV_DX_VIDEO_STEREO_INFO_VER
    NVDX_ObjectHandle         hSurface;          //!< The surface whose stereo format is to be set
    NVDX_ObjectHandle         hLinkedSurface;    //!< The linked surface (must be valid when eFormat==NV_STEREO_VIDEO_FORMAT_TWO_FRAMES_LR)
    NV_STEREO_VIDEO_FORMAT    eFormat;           //!< Stereo format of the surface
    NvS32                     sViewOffset;       //!< Signed offset of each view (positive offset indicating left view is shifted left)
    BOOL                      bStereoEnable;     //!< Whether stereo rendering should be enabled (if FALSE, only left view will be used)
} NV_DX_VIDEO_STEREO_INFO;

//! Macro for constructing the version field of ::NV_DX_VIDEO_STEREO_INFO
#define NV_DX_VIDEO_STEREO_INFO_VER  MAKE_NVAPI_VERSION(NV_DX_VIDEO_STEREO_INFO,1)

NVAPI_INTERFACE NvAPI_D3D9_VideoSetStereoInfo(IDirect3DDevice9 *pDev,
                                              NV_DX_VIDEO_STEREO_INFO *pStereoInfo);

//! @}
#endif //defined(_D3D9_H_) && defined(__cplusplus)


#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_SetGamutData
//
//! \fn NvAPI_D3D9_SetGamutData(IDirect3DDevice9 *pDev, NvU32 outputId, NV_GAMUT_FORMAT format, NV_GAMUT_METADATA *pGamutData)
//! DESCRIPTION:     This API sets the Gamut Boundary Description (GBD) data.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 175
//!
//! \param [in]     pDev        The device (display) to present to.
//! \param [in]     outputId    The display output ID, which can be determined using NvAPI_GetAssociatedDisplayOutputId()
//!                             for an intended display. 
//! \param [in]     format      The format of GBD data structure.                    
//! \param [in]     pGamutData  The GBD data.
//!
//! \retval  ::NVAPI_OK 
//! \retval  ::NVAPI_ERROR 
//! \retval  ::NVAPI_INVALID_ARGUMENT
//
/////////////////////////////////////////////////////////////////////////////////


//! \ingroup dx
//! Gamut format data - used in NvAPI_D3D9_SetGamutData().
typedef enum _NV_GAMUT_FORMAT
{
    NV_GAMUT_FORMAT_VERTICES   = 0,
    NV_GAMUT_FORMAT_RANGE,
} NV_GAMUT_FORMAT;


//! \ingroup dx
//! Gamut range metadata - used in NV_GAMUT_METADATA.
typedef struct _NV_GAMUT_METADATA_RANGE
{
    // Header
    NvU32    GBD_Color_Space:3;
    NvU32    GBD_Color_Precision:2;
    NvU32    Rsvd:2;                    //!< Must be set to 0
    NvU32    Format_Flag:1;             //!< Must be set to 1

    // Packaged data
    NvU32    Min_Red_Data:12;
    NvU32    Max_Red_Data:12;
    NvU32    Min_Green_Data:12;
    NvU32    Max_Green_Data:12;
    NvU32    Min_Blue_Data:12;
    NvU32    Max_Blue_Data:12;
} NV_GAMUT_METADATA_RANGE;


//! \ingroup dx
//! Gamut vertices metadata - used in NV_GAMUT_METADATA.
typedef struct _NV_GAMUT_METADATA_VERTICES
{
    // Header  
    NvU32    GBD_Color_Space:3;
    NvU32    GBD_Color_Precision:2;
    NvU32    Rsvd:1;
    NvU32    Facet_Mode:1;            //!< Must be set to 0
    NvU32    Format_Flag:1;                //!< Must be set to 0
    NvU32    Number_Vertices_H:8;        //!< Must be set to 0
    NvU32    Number_Vertices_L:8;        //!< Must be set to 4
   
    // Packaged data
    NvU32    Black_Y_R:12;
    NvU32    Black_Cb_G:12;
    NvU32    Black_Cr_B:12;
    NvU32    Red_Y_R:12;
    NvU32    Red_Cb_G:12;
    NvU32    Red_Cr_B:12;
    NvU32    Green_Y_R:12;
    NvU32    Green_Cb_G:12;
    NvU32    Green_Cr_B:12;
    NvU32    Blue_Y_R:12;
    NvU32    Blue_Cb_G:12;
    NvU32    Blue_Cr_B:12;
} NV_GAMUT_METADATA_VERTICES;


//! \ingroup dx
//! Gamut boundary description data - used in NvAPI_D3D9_SetGamutData().
typedef struct _NV_GAMUT_METADATA
{
   union
   {
        NV_GAMUT_METADATA_RANGE     rangeData;
        NV_GAMUT_METADATA_VERTICES  verticesData;        
   }data;
}NV_GAMUT_METADATA;


//! \ingroup dx
NVAPI_INTERFACE NvAPI_D3D9_SetGamutData(IDirect3DDevice9 *pDev, NvU32 outputId, NV_GAMUT_FORMAT format, NV_GAMUT_METADATA *pGamutData);


#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
//! \ingroup dx
//! @{
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_SetSurfaceCreationLayout
//
//! \fn NvAPI_D3D9_SetSurfaceCreationLayout(IDirect3DDevice9            *pDev,
//!                                                 NVAPI_SURFACE_LAYOUT_STRUCT *pSurfaceLayout);
//! \code
//!   DESCRIPTION: This call will be used primarily for testing VIC for MCP89.
//!                This will set up the layout of surfaces that are created through CreateSurface calls
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!         INPUT: pDev                          The device (display) to present to
//!                pSurfaceLayout                The pointer to the surface layout
//!                Surface layouts supported right now include Block-Linear (BL), 
//!                Pitch-Linear (PL) and Tiled (16x16)
//! 
//! RETURN STATUS: an int which could be an NvAPI status or DX HRESULT code
//! \endcode
///////////////////////////////////////////////////////////////////////////////
typedef enum _NVAPI_SURFACE_LAYOUT
{
    NVAPI_SURFACE_LAYOUT_BL    = 0,
    NVAPI_SURFACE_LAYOUT_PL    = 1,
    NVAPI_SURFACE_LAYOUT_TILED = 2,
} NVAPI_SURFACE_LAYOUT;

typedef struct _NVAPI_SURFACE_LAYOUT_STRUCT
{
    BOOL                 bEnableLayoutOverride;
    NVAPI_SURFACE_LAYOUT slLayout;
    DWORD                reserved[4];
    
} NVAPI_SURFACE_LAYOUT_STRUCT;


NVAPI_INTERFACE NvAPI_D3D9_SetSurfaceCreationLayout(IDirect3DDevice9            *pDev,
                                                    NVAPI_SURFACE_LAYOUT_STRUCT *pSurfaceLayout);

//! @}

#endif //defined(_D3D9_H_) && defined(__cplusplus)



#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_Video_GetVideoCapabilities
//
//! \fn NvAPI_D3D9_GetVideoCapabilities(IDirect3DDevice9 *pDev,
//!   DESCRIPTION: This function gets the GPU's video processing capabilities. The caller is responsible for furnishing
//!                the inputs within the NVAPI_VIDEO_CAPS_PACKET. This packet shall contain the output 
//!                consisting of the supported video features for the current configuration. The number of 
//!                NVAPI_VIDEO_CAPS will match the number of input video streams for which the capabilites
//!                have been requested. Multiple supported video profiles may be returned that would include
//!                a combination of various video features.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 158
//!                
//!   \param [in]  pDev             The device (display) to present to
//!   \param [in]  version          Version of the NV_DX_VIDEO_CAPS structure
//!   \param [in]  videoCaps        NVAPI_VIDEO_CAPS_PACKET containing both the 
//!                                 input Video Source information for which the capabilities
//!                                 are requested, as well as the output available 
//!                                 supported video features for the current configuration.
//!
//!  \return  An int which could be an NvAPI status or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////



//! \ingroup dxvidcontrol
//! Used in _NVAPI_VIDEO_SRC_INFO.
typedef enum _NV_CODEC
{
    NV_CODEC_TYPE_NONE,     
    NV_CODEC_TYPE_MPEG2, 
    NV_CODEC_TYPE_H264,
    NV_CODEC_TYPE_VC1,
    NV_CODEC_TYPE_MVC,
} NV_CODEC;




//! Current video surface to be played back. \n
//! Used in _NVAPI_VIDEO_CAPS_PACKET.
//! \ingroup dxvidcontrol
typedef struct _NVAPI_VIDEO_SRC_INFO
{
    NvU32       srcWidth;   //!< Input video width 
    NvU32       srcHeight;  //!< Input video height
    NV_CODEC    codecType;  //!< One of the available NV_CODEC's
    NvU32       avgBitrate; //!< Average bit rate for each stream in Kbps
    NvU64       reserved1;  //!< reserved for future expansion
    NvU64       reserved2;
} NVAPI_VIDEO_SRC_INFO;



//! Current desktop resolution. \n
//! Used in _NVAPI_VIDEO_CAPS_PACKET.
//! \ingroup dxvidcontrol
typedef struct _NVAPI_DESKTOP_RES
{
    NvU32 width;            //!< Current resolution width
    NvU32 height;           //!< Current resolution height
    NvU32 bitsPerPixel;     //!< Current resolution depth
    NvU32 refreshRate;      //!< Current display refresh rate
    NvU64 reserved1;        //!< Reserved for future expansion
    NvU64 reserved2;
} NVAPI_DESKTOP_RES;


//! \addtogroup dxvidcontrol
//! @{
#define NV_DEINTERLACE_PIXADAPTIVE_BIT      0   //!< Hardware pixel adaptive deinterlacing available
#define NV_VID_ENHANCE_EDGE_ENHANCE_BIT     0   //!< Edge enhancement present
#define NV_VID_ENHANCE_NOISE_REDUCTION_BIT  1   //!< Noise reduction present
 
#define NV_COLOR_CTRL_PROCAMP_BIT           0   //!< ProCamp is supported
#define NV_COLOR_CTRL_COLOR_TEMP_BIT        1   //!< Color temp control supported
#define NV_COLOR_CTRL_COLORSPACE_601_BIT    2   //!< Color space format ITU-R BT.601 supported
#define NV_COLOR_CTRL_COLORSPACE_709_BIT    3   //!< Color space format ITU-R BT.709 supported
#define NV_COLOR_CTRL_COLORSPACE_RGB_BIT    4   //!< Color space format RGB supported
 
#define NV_GAMMA_Y_BIT                      0   //!< Y-Gamma controls present
#define NV_GAMMA_RGB_BIT                    1   //!< RGB-Gamma controls present
#define NV_MISC_CAPS_INV_TELECINE_BIT       0   //!< Inverse telecine is available
//! @}


//! Available video post-process features.\n
//! Used in _NVAPI_VIDEO_CAPS.
//! \ingroup dxvidcontrol
typedef struct _NVAPI_VIDEO_PROCESSING_CAPS 
{
    NvU64               deinterlaceMode;    //!< Possible deinterlace modes supported, "check NV_DEINTERLACE_xxx bits"
    NvU64               videoEnhance;       //!< Possible HW postproc enhancements e.g. NR, EE, "check NV_VID_ENHANCE_xxx bits"
    NvU64               colorControl;       //!< Color control is supported, "check NV_COLOR_xxx bits"
    NvU64               gamma;              //!< Available gamma conversions, "check NV_GAMMA_xxx bits"
    NvU64               miscCaps;           //!< Miscellaneous post processing caps supported, "check NV_MISC_CAPS_xxx bits"
    NvU64               reserved1;          //!< Rserved for future use
    NvU64               reserved2;
    NvU64               reserved3;
} NVAPI_VIDEO_PROCESSING_CAPS;



//! \addtogroup vidFeature
//! Video feature cap bits. \n
//! Used in \ref _NVAPI_VIDEO_CAPS.
//! @{
#define NV_VID_FEATURE_NO_SYNC_FLIPS_BIT            0   //!< When this bit is set, the application needs to lock the RGB render target
                                                        //!< before calling RGB overlay to present video.
                                                        //!< In general this bit is set for G7x, and not set for G8x and later chips.
#define NV_VID_FEATURE_HALF_RES_ON_INTERLACED_BIT   1   //!< When this bit is set, it means that GPU can only show half resolution
                                                        //!< video on the interlaced display, which is true for G7x. The application
                                                        //!< needs a special workaround to show full-resolution video.
#define NV_VID_FEATURE_DX_PROTECTION_VERSION_2      2   //!< When this bit it set, the driver supports version 2 of
                                                        //!< DirectX video protection.
#define NV_VID_FEATURE_STEREO_VIDEO_BIT             3   //!< When this bit is set, the driver supports stereo
                                                        //!< VPBlit/VBBlitHD using NvAPI_D3D9_VideoSetStereoInfo().
//! @}

//! \ingroup vidFeature
#define NV_VID_FEATURE_STEREO_OVERLAY_VIDEO_BIT     4   //!< When this bit is set, it means the driver supports stereo overlay through                                                                    //!< VPBlit/VBBlitHD using NvAPI_D3D9_VideoSetStereoInfo.


//! \addtogroup perfLevel
//! Performance level bits. \n
//! Used in \ref _NVAPI_VIDEO_CAPS.
//! @{
#define NV_PERF_LEVEL_RED_BIT                       0   //!< When this bit is set, the GPU CANNOT support HD DVD/BluRay disc playback
#define NV_PERF_LEVEL_YELLOW_BIT                    1   //!< When this bit is set, the GPU meets the minimum requirement for
                                                        //!< HD DVD/BluRay disc playback
#define NV_PERF_LEVEL_GREEN_BIT                     2   //!< When this bit is set, the GPU can support HD DVD/BluRay disc playback.
#define NV_PERF_LEVEL_AERO_BIT                      3   //!< When this bit is set, it means the GPU can support HD/BD playback with Aero enabled.
#define NV_PERF_LEVEL_FRUC_BIT                      4   //!< When this bit is set, it means the GPU can support FRUC.
#define NV_PERF_LEVEL_3DBD_COMPOSITE_BIT            6   //!< When this bit is set, it means the GPU can support compositing for 3DBD
//! @}


//! Available video decode and post-process features \n
//! Used in _NVAPI_VIDEO_CAPS_PACKET.
//! \ingroup dxvidcontrol
typedef struct _NVAPI_VIDEO_CAPS
{
    NvU32                       maxFlipRate;    //!< Maximum flipping rate supported 
    NV_CODEC                    hwDecode;       //!< Supported codec for HW decoding
    NvU64                       vidFeature;     //!< Indicates presence of special video processing features
    NvU32                       perfLevel;      //!< GPU dependent level; can be red, yellow, or green
    NvU32                       numVidProfiles; //!< Number of returned video profiles              
    NvU32                       maxResPixels;   //!< Number of pixels in the max screen resolution supported at maxFlipRate for the input
                                                //!  codecType (refer to codecType field of the NVAPI_VIDEO_SRC_INFO structure).
    NvU32                       reserved1;
    NVAPI_VIDEO_PROCESSING_CAPS vidProcCaps[NV_MAX_VID_PROFILES];
} NVAPI_VIDEO_CAPS;

//! \addtogroup dxvidcontrol
//! @{
#define NVAPI_VIDEO_CAPS_PACKET_VER 2
#define RENDER_MODE_DWM_BIT         0
#define RENDER_MODE_OVERLAY_BIT     1
#define RENDER_MODE_STEREO_FULLSCREEN_BIT 2
//! @}



//! Used in _NV_DX_VIDEO_CAPS. 
//! \ingroup dxvidcontrol
typedef struct _NVAPI_VIDEO_CAPS_PACKET
{              
    NvU32                   packetVer;                      //!< (IN) Packet version that needs to match NVAPI_VIDEO_CAPS_PACKET_VER
    NvU32                   numVidStreams;                  //!< (IN) Number of streams for which the video caps are requested
    NVAPI_VIDEO_SRC_INFO    vidSrcInfo[NV_MAX_VID_STREAMS]; //!< (IN) Video source info
    NVAPI_DESKTOP_RES       res[NV_MAX_HEADS];              //!< (IN) Current desktop resolution(s)
    NvU64                   renderMode;                     //!< (IN) Requested rendering mode for the video source
    NvU64                   totalFB;                        //!< (OUT) Total framebuffer supported
    NvU16                   NumExtOvlBufNeeded;             //!< (OUT) Recommended number of external overlay buffers
    NvU16                   reserved1;                      //!< (IN/OUT) Reserved for future expansion
    NvU32                   reserved2;                      //!< (IN/OUT)
    NVAPI_VIDEO_CAPS        videoCaps[NV_MAX_VID_STREAMS];  //!< (OUT) Available video features for requested video streams
} NVAPI_VIDEO_CAPS_PACKET;



//! Used in NvAPI_D3D9_GetVideoCapabilities().
//! \ingroup dxvidcontrol
typedef struct _NV_DX_VIDEO_CAPS
{
    NvU32                   version;                        //!< (IN) NVAPI version that matched NV_DX_VIDEO_CAPS_VER
    NVAPI_VIDEO_CAPS_PACKET videoCapsPacket;                //!< (IN/OUT)
} NV_DX_VIDEO_CAPS;


//! \ingroup dxvidcontrol 
#define NV_DX_VIDEO_CAPS_VER  MAKE_NVAPI_VERSION(NV_DX_VIDEO_CAPS,1)


//! SUPPORTED OS:  Windows XP and higher
//!
//!  \ingroup dxvidcontrol
NVAPI_INTERFACE NvAPI_D3D9_GetVideoCapabilities(IDirect3DDevice9 *pDev, 
                                                NV_DX_VIDEO_CAPS *pVideoCaps);

#endif //defined(_D3D9_H_) && defined(__cplusplus)



#if defined(_D3D9_H_) && defined(__cplusplus)

//! \ingroup dx
//! @{
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_QueryVideoInfo
//
//! \fn NvAPI_D3D9_QueryVideoInfo(IDirect3DDevice9 *pDev,
//!                                       NVAPI_D3D9_QUERY_VIDEO_INFO *pQueryInfo)
//!   DESCRIPTION: Extensible NvAPI command for mechanism to retrieve various video related information
//!                The information may not be specific to the GPU, but will appear like it is from the 
//!                application's POV. The calling application can various query commands, and fill in the
//!                appropriate structure packet (if necessary), for the specified command. The list of 
//!                queries available to the application and exposed through this command is intended to be
//!                customizable so we only need to expose as much as needed.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   pDev              The D3D9 device
//! \param [in]   pQueryInfo        NVAPI_D3D9_QUERY_VIDEO_INFO containing the type of query to 
//!                                 perform and returned information.
//!
//! \return An int which could be an NvAPI status or DX HRESULT code
//!
///////////////////////////////////////////////////////////////////////////////



//! Query video info commands
typedef enum _NVAPI_D3D9_QUERY_COMMAND
{
    NVAPI_D3D9_QUERY_NULL_CMD                       = 0,    //!< Null command
    NVAPI_D3D9_QUERY_STEREO_INFO_CMD                = 1,    //!< Stereo video information
    NVAPI_D3D9_QUERY_COLOR_INFO_CMD                 = 2,    //!< Color space and range information
} NVAPI_D3D9_QUERY_COMMAND;


//! Query stereo input formats
typedef enum _NV_QUERY_STEREO_INFO_FORMAT
{
    NVAPI_QUERY_STEREO_INFO_FORMAT_NOT_STEREO           = 0x00000000,
    NVAPI_QUERY_STEREO_INFO_FORMAT_SIDE_BY_SIDE_LR      = 0x00000001,
    NVAPI_QUERY_STEREO_INFO_FORMAT_SIDE_BY_SIDE_RL      = 0x00000002,
    NVAPI_QUERY_STEREO_INFO_FORMAT_TOP_BOTTOM_LR        = 0x00000004,
    NVAPI_QUERY_STEREO_INFO_FORMAT_TOP_BOTTOM_RL        = 0x00000008,
    NVAPI_QUERY_STEREO_INFO_FORMAT_ROW_INTERLEAVE_LR    = 0x00000010,
    NVAPI_QUERY_STEREO_INFO_FORMAT_ROW_INTERLEAVE_RL    = 0x00000020,
    NVAPI_QUERY_STEREO_INFO_FORMAT_TWO_FRAMES_LR        = 0x00000040,
    NVAPI_QUERY_STEREO_INFO_FORMAT_MONO_PLUS_OFFSET     = 0x00000080,
} NV_QUERY_STEREO_INFO_FORMAT;

#define NVAPI_QUERY_STEREO_INFO_FORMAT_ALL              NVAPI_QUERY_STEREO_INFO_FORMAT_SIDE_BY_SIDE_LR      | \
                                                        NVAPI_QUERY_STEREO_INFO_FORMAT_SIDE_BY_SIDE_RL      | \
                                                        NVAPI_QUERY_STEREO_INFO_FORMAT_TOP_BOTTOM_LR        | \
                                                        NVAPI_QUERY_STEREO_INFO_FORMAT_TOP_BOTTOM_RL        | \
                                                        NVAPI_QUERY_STEREO_INFO_FORMAT_ROW_INTERLEAVE_LR    | \
                                                        NVAPI_QUERY_STEREO_INFO_FORMAT_ROW_INTERLEAVE_RL    | \
                                                        NVAPI_QUERY_STEREO_INFO_FORMAT_TWO_FRAMES_LR        | \
                                                        NVAPI_QUERY_STEREO_INFO_FORMAT_MONO_PLUS_OFFSET

//! Query stereo info packet
typedef struct _NVAPI_QUERY_STEREO_INFO
{
    NvU32   dwFormats;                              //!< (OUT) Mask of supported stereo formats
    NvU32   bIsSupported        : 1;                //!< (OUT) Whether stereo is supported
    NvU32   bIsEnabled          : 1;                //!< (OUT) Whether stereo is current enabled
    NvU32   dwReserved1         :30;                //!< (IN/OUT) Future expansion
    NvU32   dwReserved2[4];                         //!< (IN/OUT) Future expansion
} NVAPI_QUERY_STEREO_INFO;

//! Query color colorspace formats
typedef enum _NVAPI_QUERY_COLOR_INFO_COLORSPACE
{
    NVAPI_QUERY_COLOR_INFO_COLORSPACE_NONE          = 0x00000000,
    NVAPI_QUERY_COLOR_INFO_COLORSPACE_601           = 0x00000001,
    NVAPI_QUERY_COLOR_INFO_COLORSPACE_709           = 0x00000002,
    NVAPI_QUERY_COLOR_INFO_COLORSPACE_RGB           = 0x00000004,

} NVAPI_QUERY_COLOR_INFO_COLORSPACE;

#define NVAPI_QUERY_COLOR_INFO_COLORSPACE_ALL       NVAPI_QUERY_COLOR_INFO_COLORSPACE_601   | \
                                                    NVAPI_QUERY_COLOR_INFO_COLORSPACE_709   | \
                                                    NVAPI_QUERY_COLOR_INFO_COLORSPACE_RGB

//! Query color info packet
typedef struct _NVAPI_QUERY_COLOR_INFO
{
    NvU32   dwColorSpaces;                          //!< (OUT) Mask of supported color spaces
    NvU32   dwReserved[4];                          //!< (IN/OUT) Future expansion
} NVAPI_QUERY_COLOR_INFO;

//! Query video info packet
typedef struct _NVAPI_DX_QUERY_VIDEO_INFO
{
    NvU32                               dwVersion;          //!< (IN) NVAPI version that matched NV_DX_QUERY_INFO_VER
    NVAPI_D3D9_QUERY_COMMAND            eQueryCommand;      //!< (IN) Type of query to perform or information requested
    union
    {
        NVAPI_QUERY_STEREO_INFO         stStereoInfo;       //!< (OUT)
        NVAPI_QUERY_COLOR_INFO          stColorInfo;        //!< (OUT)
    };
} NVAPI_D3D9_QUERY_VIDEO_INFO;

//! Macro for constructing the version field of ::NVAPI_D3D9_QUERY_VIDEO_INFO
#define NVAPI_D3D9_QUERY_VIDEO_INFO_VER  MAKE_NVAPI_VERSION(NVAPI_D3D9_QUERY_VIDEO_INFO,1)


NVAPI_INTERFACE NvAPI_D3D9_QueryVideoInfo(IDirect3DDevice9 *pDev,
                                          NVAPI_D3D9_QUERY_VIDEO_INFO *pQueryInfo);

//! @}


#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_EnableStereoOverlay
//
//!   DESCRIPTION: Turns on stereo overlay if supported. Should be done
//!                before app creates Overlay.
//!
//! \return ::NVAPI_ERROR or ::NVAPI_OK
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
//! SUPPORTED OS:  Windows Vista and higher
//!
NVAPI_INTERFACE NvAPI_D3D9_EnableStereoOverlay(IDirect3DDevice9 *pDev);


#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_RestoreDesktop
//
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \return  NVAPI_ERROR or NVAPI_OK
//!
//! \note This is not an interface, this is just a short-hand helper
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
inline int NvAPI_D3D9_RestoreDesktop(IDirect3DDevice9 *pDev)
{
    return NvAPI_D3D9_PresentSurfaceToDesktop(pDev,NVDX_OBJECT_NONE,0);
}

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_AliasPrimaryFromDevice
//
//! This function creates an alias surface from the given pDevFrom's primary swap chain.
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 80
//!
//! \param [in]    pDevTo      Where new surfaces created in
//! \param [in]    pDevFrom    Where the surfaces aliased from
//! \param [in]    dwIndex     Index to the primary flipchain of pDevFrom
//!          
//! \param [out]   ppSurf      Filled with new surface pointer (to be released by the caller)
//! \param [out]   pHandle     (optional) If non-NULL, filled with SurfaceHandle of the surface
//!                            The same can be achieved by calling NVD3D9_GetSurfaceHandle afterwards.
//!
//! \return An int which could be an NvAPI status or DX HRESULT code
//! \ingroup dx
//////////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_AliasPrimaryFromDevice(IDirect3DDevice9 *pDevTo, 
                                              IDirect3DDevice9 *pDevFrom, 
                                              NvU32 dwIndex,
                                              IDirect3DSurface9 **ppSurf,
                                              NVDX_ObjectHandle *pHandle = 0);
#endif //defined(_D3D9_H_) && defined(__cplusplus)




#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_SetResourceHint
//
//! \fn NvAPI_D3D9_SetResourceHint(IDirect3DDevice9 *pDev, NVDX_ObjectHandle obj,
//!                This API has been deprecated.  
//!                This is a general purpose function for passing down various resource 
//!                related hints to the driver. Hints are divided into categories
//!                and types within each cateroy. 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 95
//!
//! \param [in]   pDev           Valid device context
//! \param [in]   obj            Previously obtained HV resource handle 
//! \param [in]   dwHintCategory Category of the hints
//! \param [in]   dwHintType     A hint within this category
//! \param [in]  *pdwHintValue   Pointer to location containing hint value
//! \param [out] *dwHintValue    Receives previous value of this hint.
//!
//! \return An int which could be an NvAPI status or DX HRESULT code
//
////////////////////////////////////////////////////////////////////////////////

//! Available hint categories / hint names:
//! - SLI:
//! \ingroup dx
typedef enum _NVAPI_SETRESOURCEHINT_CATEGORY
{
    NvApiHints_Sli = 1,

}  NVAPI_SETRESOURCEHINT_CATEGORY;


  //! Types of SLI hints;
  //! NvApiHints_Sli_InterframeAwareForTexturing - deprecated
  //!
  //! Default value: zero
  //! \ingroup dx
typedef enum _NVAPI_SETRESOURCEHINT_SLI_HINTS
{
    NvApiHints_Sli_InterframeAwareForTexturing = 1,

}  NVAPI_SETRESOURCEHINT_SLI_HINTS;

//
// end of categories


//! \ingroup dx
NVAPI_INTERFACE NvAPI_D3D9_SetResourceHint(IDirect3DDevice9 *pDev, NVDX_ObjectHandle obj, 
                            NVAPI_SETRESOURCEHINT_CATEGORY dwHintCategory, NvU32 dwHintName, NvU32 *pdwHintValue);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_Lock
//
//! \fn NvAPI_D3D9_Lock(IDirect3DDevice9 *pDev, NVDX_ObjectHandle obj, NvU32 dwLockFlags,
//!  This function locks and unlocks a given surface identified by handle. This
//!  function can provide CPU access to all object including
//!  RTs, ZBs, textures, VBs and IBs.
//!
//! \note 
//! - (a) Do not use this if an object can be accessed using normal DX9 means.
//! - (b) Lock should be called right before CPU access, and Unlock called right after
//!     the access is completed. Any 3D rendering or state change may cause the locked
//!     surface to be lost. When that happens, trying to access the cached CPU 
//!     address may cause the application to crash.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \return An int which could be an NvAPI status or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------

//! \ingroup dx
#define NV_ACCESSFLAG_READONLY  0x00000001 // TBD: do these go with dwLockFlags?

//! \ingroup dx
#define NV_ACCESSFLAG_DISCARD   0x00000002


//! \ingroup dx
NVAPI_INTERFACE NvAPI_D3D9_Lock(IDirect3DDevice9 *pDev, NVDX_ObjectHandle obj, NvU32 dwLockFlags,
                            void **ppAddress, NvU32 *pPitch);
#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_Unlock
//
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 80
//!
//! \return An int which could be an NvAPI status or DX HRESULT code
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_Unlock(IDirect3DDevice9 *pDev, NVDX_ObjectHandle obj);

#endif //defined(_D3D9_H_) && defined(__cplusplus)



#if defined(_D3D9_H_) && defined(__cplusplus)
#ifndef NV_VIDEO_COMPONENTS_DEFINE
#define NV_VIDEO_COMPONENTS_DEFINE

///////////////////////////////////////////////////////////////////////////////
// Structs and enums related to Video state
///////////////////////////////////////////////////////////////////////////////


//! \ingroup dxvidstate
//! Used in NVAPI_GET_VIDEO_STATE_COMPONENT \n
//! Components related to the video state
typedef enum _NVAPI_VIDEO_STATE_COMPONENT_ID
{
    NVAPI_VIDEO_STATE_COMPONENT_ID_NONE     = -1,   //!< Placeholder for invalid component ID
    NVAPI_VIDEO_STATE_COMPONENT_BRIGHTNESS      ,   //!< Permits control of video's brightness value
    NVAPI_VIDEO_STATE_COMPONENT_CONTRAST        ,   //!< Allows control of video's contrast value
    NVAPI_VIDEO_STATE_COMPONENT_HUE             ,   //!< To control the hue value
    NVAPI_VIDEO_STATE_COMPONENT_SATURATION      ,   //!< Allows control of video's saturation value
    NVAPI_VIDEO_STATE_COMPONENT_COLORTEMP       ,   //!< Allows control of the color temperature value
    NVAPI_VIDEO_STATE_COMPONENT_Y_GAMMA         ,   //!< To set the Y-gamma values
    NVAPI_VIDEO_STATE_COMPONENT_RGB_GAMMA_R     ,   //!< To set the R value of RGB gamma
    NVAPI_VIDEO_STATE_COMPONENT_RGB_GAMMA_G     ,   //!< To set the G value of RGB gamma
    NVAPI_VIDEO_STATE_COMPONENT_RGB_GAMMA_B     ,   //!< To set the B value of RGB gamma
    NVAPI_VIDEO_STATE_COMPONENT_COLOR_SPACE     ,   //!< Permits choice of various color spaces using VIDEO_COMP_ALGO_COLOR_SPACE_xxx
    NVAPI_VIDEO_STATE_COMPONENT_COLOR_RANGE     ,   //!< Allows setting between a limited/full color range using VIDEO_COMP_ALGO_COLOR_RANGE_xxx
    NVAPI_VIDEO_STATE_COMPONENT_PLAYBACK_PROFILE,   //!< Permits using special postprocessing for Adobe Flash 9 Content
    NVAPI_VIDEO_STATE_COMPONENT_DEINTERLACE     ,   //!< To set various types of deinterlacing algorithms
    NVAPI_VIDEO_STATE_COMPONENT_SCALING         ,   //!< Allows setting video scaling algorithms
    NVAPI_VIDEO_STATE_COMPONENT_CADENCE         ,   //!< Allows control of the cadence algorithms
    NVAPI_VIDEO_STATE_COMPONENT_NOISE_REDUCE    ,   //!< Allows setting post-processing noise reduction values
    NVAPI_VIDEO_STATE_COMPONENT_EDGE_ENHANCE    ,   //!< Permits post-processing edge enhancement value adjustment
    NVAPI_VIDEO_STATE_COMPONENT_OVERDRIVE       ,   //!< To control the overdrive feature
    NVAPI_VIDEO_STATE_COMPONENT_SPLITSCREEN     ,   //!< To permit setting a splitscreen using one of VIDEO_COMP_ALGO_SPLITSCREEN_xxx
    NVAPI_VIDEO_STATE_COMPONENT_DEBLOCKING      ,   //!< Allows out-of-loop deblocking
    NVAPI_VIDEO_STATE_COMPONENT_DYNAMIC_CONTRAST,   //!< Permits control of video's dynamic contrast value
    NVAPI_VIDEO_STATE_COMPONENT_GREEN_STRETCH   ,   //!< Permits control of green stretch
    NVAPI_VIDEO_STATE_COMPONENT_BLUE_STRETCH    ,   //!< Allows control of blue enhancement
    NVAPI_VIDEO_STATE_COMPONENT_SKIN_TONE_CORRECTION, //!< Allows skin-tone correction for video
    NVAPI_VIDEO_STATE_COMPONENT_GAMUT_REMAPPING ,   //!< Applies gamut remapping on video
    NVAPI_VIDEO_STATE_COMPONENT_2DTO3D          ,   //!< Converts 2D video to 3D stereo video
    NVAPI_VIDEO_STATE_COMPONENT_3D_ANALYSIS     ,   //!< Analyzing 3D stereo video
    NVAPI_VIDEO_STATE_COMPONENT_FRC             ,   //!< Frame Rate Converter
    NVAPI_VIDEO_STATE_COMPONENT_BEN             ,   //!< Applies deblocking on video
    NVAPI_VIDEO_STATE_COMPONENT_ID_LAST         ,   //!< All valid components defined before this one
} NVAPI_VIDEO_STATE_COMPONENT_ID;


//! Dynamic contrast value - kept for backward compatibility.  
#define NVAPI_VIDEO_STATE_COMPONENT_DYNAMIC_CONSTRAST  NVAPI_VIDEO_STATE_COMPONENT_DYNAMIC_CONTRAST  


//! \ingroup dxvidstateypes
//! See \ref #NVAPI_VIDEO_COMPONENT_ALGORITHM.
#define VIDEO_COMP_ALGO_CUSTOM_BASE 64


//! \ingroup dxvidstate
//! Used in NVAPI_GET_VIDEO_STATE_COMPONENT. \n
//! Algorithms controlling various video components
typedef enum _NVAPI_VIDEO_COMPONENT_ALGORITHM
{
    VIDEO_COMP_ALGO_COLOR_SPACE_601                  = 0,  //!< Use the ITU-R BT.601 standard in color-space conversion for xxx_COLOR_SPACE component
    VIDEO_COMP_ALGO_COLOR_SPACE_709                  = 1,  //!< Use the ITU-R BT.709 standard in color-space conversion for xxx_COLOR_SPACE component
    VIDEO_COMP_ALGO_COLOR_SPACE_CUSTOM_04            = VIDEO_COMP_ALGO_CUSTOM_BASE+4, //!< Use custom color matrix
    VIDEO_COMP_ALGO_COLOR_RANGE_STD                  = 0,  //!< Full range of (0-255) for xxx_COLOR_RANGE component, equivalent to Microsoft's DXVADDI_NOMINALRANGE::DXVADDI_NominalRange_0_255
    VIDEO_COMP_ALGO_COLOR_RANGE_EXT                  = 1,  //!< Limited range of (16-235) for xxx_COLOR_RANGE component, equivalent to Microsoft's DXVADDI_NOMINALRANGE::DXVADDI_NominalRange_16_235
    VIDEO_COMP_ALGO_PLAYBACK_PROFILE_NONE            = 0,  //!< Use no playback profile
    VIDEO_COMP_ALGO_PLAYBACK_PROFILE_ADOBE_FLASH_9   = 1,  //!< Use the internet video enhancement postprocessing for Adobe Flash 9 
    VIDEO_COMP_ALGO_DEINTERLACE_NONE                 = 0,  //!< No deinterlacing is done
    VIDEO_COMP_ALGO_DEINTERLACE_BOB                  = 1,  //!< Perform Bob deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_WEAVE                = 2,  //!< Use weave deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_SIMPLE_ADAPTIVE      = 3,  //!< Perform a simple motion adaptive deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_GRADIENT_SIMPLE      = 4,  //!< Use a simple gradient deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_GRADIENT_FULL        = 5,  //!< Use advanced gradient deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_ADAPTIVE_FOUR_FIELD  = 6,  //!< Perform four field motion adaptive deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_DIR_SPATIAL          = 7,  //!< User directional spatial deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_ADVANCED             = 8,  //!< Perform proprietary advanced deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_GPU_CAPABLE          = 9,  //!< Best available but GPU dependent. (video driver decides dynamically)
    VIDEO_COMP_ALGO_DEINTERLACE_MEDIAN               = 10,  //!< Best available but GPU dependent. (video driver decides dynamically)
    VIDEO_COMP_ALGO_DEINTERLACE_DIR_SPATIAL_LIGHT    = 11,  //!< Best available but GPU dependent. (video driver decides dynamically)
    VIDEO_COMP_ALGO_DEINTERLACE_DIR_SPATIAL_SD       = 12,  //!< Best available but GPU dependent. (video driver decides dynamically)
    VIDEO_COMP_ALGO_DEINTERLACE_DIR_SPATIAL_HD       = 13,  //!< Best available but GPU dependent. (video driver decides dynamically)
    VIDEO_COMP_ALGO_DEINTERLACE_ONE_PASS             = 14,  //!< Best available but GPU dependent. (video driver decides dynamically)
    VIDEO_COMP_ALGO_DEINTERLACE_COMPUTE              = 15,  //!< Best available but GPU dependent. (video driver decides dynamically)
    VIDEO_COMP_ALGO_DEINTERLACE_CUSTOM_00            = VIDEO_COMP_ALGO_CUSTOM_BASE+0,    //!< Use custom Deinterlacing algorithm
    VIDEO_COMP_ALGO_DEINTERLACE_CUSTOM_01            = VIDEO_COMP_ALGO_CUSTOM_BASE+1,    //!< Use custom Deinterlacing algorithm
    VIDEO_COMP_ALGO_SCALING_ALG_SIMPLE               = 0,  //!< Do scaling using a simple algorithm       
    VIDEO_COMP_ALGO_SCALING_ALG_4x4FILTER            = 1,  //!< Perform scaling using a 4x4 filter
    VIDEO_COMP_ALGO_SCALING_ALG_8x8FILTER            = 2,  //!< Perform scaling using a 8x8 filter
    VIDEO_COMP_ALGO_SCALING_ALG_CUSTOM_00            = VIDEO_COMP_ALGO_CUSTOM_BASE+0,    //!< Use custom scaling component
    VIDEO_COMP_ALGO_SCALING_ALG_CUSTOM_01            = VIDEO_COMP_ALGO_CUSTOM_BASE+1,    //!< Use custom scaling component
    VIDEO_COMP_ALGO_CADENCE_NONE                     = 0,  //!< Turn cadence OFF
    VIDEO_COMP_ALGO_CADENCE_SIMPLE                   = 1,  //!< Use simple cadence detection
    VIDEO_COMP_ALGO_CADENCE_VOF                      = 2,  //!< Use video on film cadence detection
    VIDEO_COMP_ALGO_CADENCE_COMPUTE                  = 3,  //!< Use compute cadence detection
    VIDEO_COMP_ALGO_CADENCE_GPU_CAPABLE              = 4,  //!< Best available but GPU dependent. (video driver decides dynamically)
    VIDEO_COMP_ALGO_NOISE_REDUCE_PUREVIDEO           = 0,  //!< Use PureVideo noise reduction
    VIDEO_COMP_ALGO_NOISE_REDUCE_CUSTOM_00           = VIDEO_COMP_ALGO_CUSTOM_BASE+0,  //!< Use custom noise reduction
    VIDEO_COMP_ALGO_NOISE_REDUCE_CUSTOM_01           = VIDEO_COMP_ALGO_CUSTOM_BASE+1,  //!< Use custom noise reduction
    VIDEO_COMP_ALGO_EDGE_ENHANCE_PUREVIDEO           = 0,  //!< Use PureVideo Sharpening Filter
    VIDEO_COMP_ALGO_EDGE_ENHANCE_CUSTOM_00           = VIDEO_COMP_ALGO_CUSTOM_BASE+0,  //!< Use custom Sharpening Filter
    VIDEO_COMP_ALGO_EDGE_ENHANCE_CUSTOM_01           = VIDEO_COMP_ALGO_CUSTOM_BASE+1,  //!< Use custom Sharpening Filter
    VIDEO_COMP_ALGO_OVERDRIVE_SIMPLE                 = 0,  //!< Use simple overdrive algorithm
    VIDEO_COMP_ALGO_SPLITSCREEN_TYPE_NORMAL          = 0,  //!< Set the splitscreen in normal mode
    VIDEO_COMP_ALGO_SPLITSCREEN_TYPE_REPEATED        = 1,  //!< Set the splitscreen to be repeated
    VIDEO_COMP_ALGO_SPLITSCREEN_TYPE_ON_MIRROR       = 2,  //!< Set the splitscreen as a mirror
    VIDEO_COMP_ALGO_DYNAMIC_CONTRAST_PRESET_NONE     = 0,  //!< Use the value setting for dynamic contrast instead of a preset
    VIDEO_COMP_ALGO_DYNAMIC_CONTRAST_PRESET_LOW      = 1,  //!< Turn the dynamic contrast to a low setting
    VIDEO_COMP_ALGO_DYNAMIC_CONTRAST_PRESET_MEDIUM   = 2,  //!< Turn the dynamic contrast to a medium setting
    VIDEO_COMP_ALGO_DYNAMIC_CONTRAST_PRESET_HIGH     = 3,  //!< Turn the dynamic contrast to a high setting
    VIDEO_COMP_ALGO_GREEN_STRETCH_PRESET_NONE        = 0,  //!< Use the value setting for green stretch instead of a preset
    VIDEO_COMP_ALGO_GREEN_STRETCH_PRESET_LOW         = 1,  //!< Set the green stretch to a low setting
    VIDEO_COMP_ALGO_GREEN_STRETCH_PRESET_MEDIUM      = 2,  //!< Set the green stretch to a medium setting
    VIDEO_COMP_ALGO_GREEN_STRETCH_PRESET_HIGH        = 3,  //!< Set the green stretch to a high setting
    VIDEO_COMP_ALGO_BLUE_STRETCH_PRESET_NONE         = 0,  //!< Use the value setting for blue stretch instead of a preset   
    VIDEO_COMP_ALGO_BLUE_STRETCH_PRESET_LOW          = 1,  //!< Set the blue stretch to a low setting
    VIDEO_COMP_ALGO_BLUE_STRETCH_PRESET_MEDIUM       = 2,  //!< Set the blue stretch to a medium setting
    VIDEO_COMP_ALGO_BLUE_STRETCH_PRESET_HIGH         = 3,  //!< Set the blue stretch to a high setting
    VIDEO_COMP_ALGO_SKIN_TONE_CORRECTION_PRESET_NONE = 0,  //!< Use the value setting for skin tone correction instead of a preset  
    VIDEO_COMP_ALGO_SKIN_TONE_CORRECTION_PRESET_SQUEEZE = 1,  //!< Turn the skin tone correction to a low setting
    VIDEO_COMP_ALGO_SKIN_TONE_CORRECTION_PRESET_RED     = 2,  //!< Turn the skin tone correction to a medium setting
    VIDEO_COMP_ALGO_SKIN_TONE_CORRECTION_PRESET_YELLOW  = 3,  //!< Turn the skin tone correction to a high setting
    VIDEO_COMP_ALGO_GAMUT_REMAPPING_CUSTOM_00        = VIDEO_COMP_ALGO_CUSTOM_BASE+0, //!< Use custom 3x3 gamut remapping matrix
    VIDEO_COMP_ALGO_GAMUT_REMAPPING_CUSTOM_01        = VIDEO_COMP_ALGO_CUSTOM_BASE+1, //!< Use custom 3x3 gamut remapping matrix
    VIDEO_COMP_ALGO_2DTO3D_CUSTOM_00                 = VIDEO_COMP_ALGO_CUSTOM_BASE+0, //!< Use custom 2Dto3D conversion
    VIDEO_COMP_ALGO_2DTO3D_CUSTOM_01                 = VIDEO_COMP_ALGO_CUSTOM_BASE+1, //!< Use custom 2Dto3D conversion
    VIDEO_COMP_ALGO_3D_ANALYSIS_CUSTOM_00            = VIDEO_COMP_ALGO_CUSTOM_BASE+0, //!< Use custom 3DAnalysis algorithm
    VIDEO_COMP_ALGO_3D_ANALYSIS_CUSTOM_01            = VIDEO_COMP_ALGO_CUSTOM_BASE+1, //!< Use custom 3DAnalysis algorithm
    VIDEO_COMP_ALGO_FRC_CUSTOM_00                    = VIDEO_COMP_ALGO_CUSTOM_BASE+0, //!< Use custom frame rate converter
    VIDEO_COMP_ALGO_FRC_CUSTOM_01                    = VIDEO_COMP_ALGO_CUSTOM_BASE+1, //!< Use custom frame rate converter
    VIDEO_COMP_ALGO_BEN_CUSTOM_00                    = VIDEO_COMP_ALGO_CUSTOM_BASE+0, //!< Use custom deblocking algorithm
    VIDEO_COMP_ALGO_BEN_CUSTOM_01                    = VIDEO_COMP_ALGO_CUSTOM_BASE+1, //!< Use custom deblocking algorithm

} NVAPI_VIDEO_COMPONENT_ALGORITHM;


//! \ingroup dxvidstate
//! Used in NVAPI_GET_VIDEO_STATE_COMPONENT. \n
//! Bit masks for enabling video components at various resolutions
typedef enum _NVAPI_VIDEO_COMPONENT_ENABLE
{
    VIDEO_COMP_ENA_480i     = 0x00000001, //!< component is enabled at 480i video resolution
    VIDEO_COMP_ENA_480p     = 0x00000002, //!< component is enabled at 480p video resolution
    VIDEO_COMP_ENA_576i     = 0x00000004, //!< component is enabled at 576i video resolution
    VIDEO_COMP_ENA_576p     = 0x00000008, //!< component is enabled at 576p video resolution
    VIDEO_COMP_ENA_720p     = 0x00000010, //!< component is enabled at 720p video resolution
    VIDEO_COMP_ENA_1080i    = 0x00000020, //!< component is enabled at 1080i video resolution
    VIDEO_COMP_ENA_1080p    = 0x00000040, //!< component is enabled at 1080p video resolution
} NVAPI_VIDEO_COMPONENT_ENABLE;


//! \ingroup dxvidstate
//! Used in NvAPI_D3D9_GetVideoState(). \n
//! Packet that facilitates retrieving information about a video component
typedef struct _NVAPI_GET_VIDEO_STATE_COMPONENT
{
    NvU32   version;                    //!< (IN)  NVAPI version that matches NVAPI_GET_VIDEO_STATE_COMPONENT_VER
    NvU32   componentID;                //!< (IN)  identify the individual component, one of NVAPI_VIDEO_STATE_COMPONENT_xxx enums
    NvU32   bIsSupported        : 1;    //!< (OUT) set if this component feature is supported
    NvU32   bIsOverridenByUser  : 1;    //!< (OUT) set if component is overriden by user's choice
    NvU32   reserved1           : 30;   //!< (OUT) reserved for future expansion
    NvU32   isEnabled;                  //!< (OUT) set if component is enabled, one or more of NVAPI_VIDEO_COMPONENT_ENABLE bitmasks
    NvU32   minValue;                   //!< (OUT) minimum valid value
    NvU32   maxValue;                   //!< (OUT) maximum valid value
    NvU32   totalSteps;                 //!< (OUT) number of steps between min and max
    NvU32   defaultValue;               //!< (OUT) pre-defined NVIDIA default
    NvU32   unityValue;                 //!< (OUT) unity is the disable value for a component
    NvU32   currentValueActive;         //!< (OUT) value in use
    NvU64   defaultAlgo;                //!< (OUT) default algorithm, one or more of NVAPI_VIDEO_COMPONENT_ALGORITHM enums
    NvU64   currentAlgoActive;          //!< (OUT) algorithm in use, one or more of NVAPI_VIDEO_COMPONENT_ALGORITHM enums
    union
    {
        NvU64 qwReserved[9];
        struct
        {            
            NvU32   dwAppKey;           //!< (IN) Secret key to authenticate the caller, ONLY used in NvAPI_SetVideoState
            NvU32   bTopPriority   : 1; //!< (OUT)Indicates that these settings have precedence over D3D NvAPI settings, ONLY valid in NvAPI_GetVideoState
            NvU32   bHasCustomAlgo : 1; //!< (OUT)Indicates whether an out-of-process application has custom algorithm data
            NvU32   bReserved      : 30;//!< (OUT)Reserved for expansion   
            struct
            {
                NvU64   pData;          //!< (IN) Buffer to hold the retrieved custom algo data
                NvU32   dwSize;         //!< (IN) Size in bytes of the above buffer, must be <= NVAPI_VIDEO_STATE_MAX_CUSTOM_ALGO_SIZE.
            } customAlgo;

        } appInfo; 
    };         
} NVAPI_GET_VIDEO_STATE_COMPONENT;


//! \ingroup dxvidstate
//! Used in NVAPI_GET_VIDEO_STATE_COMPONENT.
#define NVAPI_GET_VIDEO_STATE_COMPONENT_VER  MAKE_NVAPI_VERSION(NVAPI_GET_VIDEO_STATE_COMPONENT,1)


//! \ingroup dxvidstate
//! Used in NVAPI_SET_VIDEO_STATE_COMPONENT. \n
//! Return status after attempting to set a video component 
typedef enum _NVAPI_VIDEO_COMP_RETURN_STATUS
{
    VIDEO_COMP_STATUS_SUCCESS                   = 0x00000000, //!< Video component is set successfully
    VIDEO_COMP_STATUS_UNSUCCESSFUL              = 0x00000001, //!< Failed to set video component
    VIDEO_COMP_STATUS_COMPONENT_NOT_SUPPORTED   = 0x00000002, //!< Video component is not supported
    VIDEO_COMP_STATUS_VALUE_OUT_OF_RANGE        = 0x00000004, //!< Video component's value is invalid and does not fall into range
    VIDEO_COMP_STATUS_ALGO_NOT_RECOGNIZED       = 0x00000008, //!< Video component's algorithm is invalid 
    VIDEO_COMP_STATUS_OVERRIDDEN_BY_USER        = 0x00000010, //!< Request not completed because of user-mandated override
    VIDEO_COMP_STATUS_Y_GAMMA_ENABLED           = 0x00000020, //!< Cannot set RGB-gamma because Y-Gamma is already enabled
    VIDEO_COMP_STATUS_RGB_GAMMA_ENABLED         = 0x00000040, //!< Cannot set Y-gamma because RGB-Gamma is already enabled
} NVAPI_VIDEO_COMP_RETURN_STATUS;


// Packet containing information to allow setting the video component

//! \ingroup dxvidstate 
#define NVAPI_VIDEO_STATE_MAX_CUSTOM_ALGO_SIZE 128


//! \ingroup dxvidstate
//! Packet containing information to allow setting the video component. \n
//! Used in NvAPI_D3D9_SetVideoState().
typedef struct _NVAPI_SET_VIDEO_STATE_COMPONENT
{
    NvU32   version;                        //!< (IN) NVAPI version that matches NVAPI_SET_VIDEO_STATE_COMPONENT_VER
    NvU32   componentID;                    //!< (IN) identify the individual component, one of NVAPI_VIDEO_STATE_COMPONENT_xxx enums
    NvU32   enable;                         //!< (IN) flag to enable setting of component, one or more of NVAPI_VIDEO_COMPONENT_ENABLE bitmasks
    NvU32   setToValue;                     //!< (IN) value to use
    NvU64   setToAlgo;                      //!< (IN) algorithm to use
    NvU32   retStatus;                      //!< (OUT) result of video-component-set operation; a combination of VIDEO_COMP_STATUS_xxx bitmasks 
    NvU32   reserved;
    union
    {
        NvU64 qwReserved[4];
        struct
        {
            NvU32   dwAppKey;               //!< (IN) Secret key to authenticate the caller, ONLY used in NvAPI_SetVideoState()
            NvU32   bTopPriority       : 1; //!< (IN) Force these settings to have priority over D3D NvAPI settings, ONLY valid in NvAPI_GetVideoState()
            NvU32   bHasCustomAlgo     : 1; //!< (IN) Out-of-process application has custom algorithm data
            NvU32   bReserved          : 30;//!< (IN) reserved for expansion
            struct
            {
                NvU64   pData;              //!< (IN) (Used only when bHasCustomAlgo == 1) Pointer to the custom algorithm data.
                NvU32   dwSize;             //!< (IN) (Used only when bHasCustomAlgo == 1) Size in Bytes of the custom algorithm data, must be <= NVAPI_VIDEO_STATE_MAX_CUSTOM_ALGO_SIZE.
            } customAlgo;
        } appInfo; 
    }; 
} NVAPI_SET_VIDEO_STATE_COMPONENT;


//! \ingroup dxvidstate
//! Used in NVAPI_SET_VIDEO_STATE_COMPONENT.
#define NVAPI_SET_VIDEO_STATE_COMPONENT_VER  MAKE_NVAPI_VERSION(NVAPI_SET_VIDEO_STATE_COMPONENT,1)

#endif // NV_VIDEO_COMPONENTS_DEFINE


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_GetVideoState
//
//!   DESCRIPTION: This function returns the video state component for the specified component ID.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 170
//!
//!   \param [in]     pDev              The Direct3D device for which the component is requested
//!   \param [in,out] pGetVidStateComp  NVAPI_GET_VIDEO_STATE_COMPONENT packet containing
//!                                     a valid component ID
//!
//!   \return  An int which could be an NvAPI status (NVAPI_OK, NVAPI_INVALID_ARGUMENT,
//!            NVAPI_INCOMPATIBLE_STRUCT_VERSION, NVAPI_ERROR) or DX HRESULT code
//!
//!   \ingroup dxvidstate
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_GetVideoState(IDirect3DDevice9 *pDev, 
                                         NVAPI_GET_VIDEO_STATE_COMPONENT *pGetVidStateComp);
#endif //defined(_D3D9_H_) && defined(__cplusplus)



#if defined(_D3D9_H_) && defined(__cplusplus)
/////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_SetVideoState
//
//!   DESCRIPTION: This function sets a particular video state component for the specific component ID.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 170
//! 
//!   \param [in]       pDev              The Direct3D device for which the component-set is requested
//!   \param [in,out]   pSetVidStateComp  NVAPI_SET_VIDEO_STATE_COMPONENT packet containing
//!                                       the video component information to be applied 
//!
//!   \return  An int which could be an NvAPI status (NVAPI_OK, NVAPI_INVALID_ARGUMENT,
//!            NVAPI_INCOMPATIBLE_STRUCT_VERSION, NVAPI_ERROR) or DX HRESULT code
//!
//!   \ingroup dxvidstate                
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_SetVideoState(IDirect3DDevice9 *pDev, 
                                         NVAPI_SET_VIDEO_STATE_COMPONENT *pSetVidStateComp);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_EnumVideoFeatures
//
//! \fn NvAPI_D3D9_EnumVideoFeatures(IDirect3DDevice9 *pDev, NVAPI_DX_VIDEO_FEATURE_DETAILS *pVideoFeatureDetails)
//!   DESCRIPTION:  This API enumerates all video features supported on the current configuration.
//! 
//!                 - First, the client should call the function with VF_GET_COUNT flag set. This will return the total 
//!                  feature count. 
//!                 - Then the client calls this function again iteratively, with the VF_GET_DETAILS flag until all of 
//!                  the features are enumerated.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 185
//!
//! \return An int which could be an NvAPI status or DX HRESULT code
//
///////////////////////////////////////////////////////////////////////////////
// enums and structs related to Video Features

//! \addtogroup dxvidfeatures
//! @{


#define NVAPI_MAX_FEATURES_PER_PACKET   3 //!< Maximum number of structs that can fit into dwArgs[20] of nvdxExtensionData struct

// Update the nvVidFeatureNames[] array in nvd3d.cpp when adding a new Feature ID.
//! Video feature IDs; used in _NVAPI_VIDEO_FEATURE_DETAILS
typedef enum _NVAPI_VIDEO_FEATURE
{
    NVAPI_VF_UNKNOWN = 0,
    NVAPI_VF_MPEG2SDDecodeAcceleration,
    NVAPI_VF_MPEG2HDDecodeAcceleration,
    NVAPI_VF_VC1SDDecodeAcceleration,
    NVAPI_VF_VC1HDDecodeAcceleration,
    NVAPI_VF_H264SDDecodeAcceleration,
    NVAPI_VF_H264HDDecodeAcceleration,
    NVAPI_VF_WMV9SDDecodeAcceleration,
    NVAPI_VF_WMV9HDDecodeAcceleration,
    NVAPI_VF_ProcAmp,
    NVAPI_VF_ColorTemperatureCorrection,
    NVAPI_VF_ColorSpaceConversion,
    NVAPI_VF_GammaCorrection,
    NVAPI_VF_OverDrive,
    NVAPI_VF_DynamicContrastEnhancement,
    NVAPI_VF_StretchBlueGreenSkin,
    NVAPI_VF_AdaptiveDeInterlacing,
    NVAPI_VF_NoiseReduction,
    NVAPI_VF_EdgeEnhancement,
    NVAPI_VF_InverseTelecine,
    NVAPI_VF_Scaling,
    NVAPI_VF_VideoMirror,
    NVAPI_VF_Blend,
    NVAPI_VF_DxvaHDTest,
    NVAPI_VF_GamutRemap,
    NVAPI_VF_MftXcode,
    NVAPI_VF_SkinToneCorrection,
    NVAPI_VF_MftYUY2Xcode,
    NVAPI_VF_MftDivxXcode,
    NVAPI_VF_MftWmv9Encode,
    NVAPI_VF_DynamicPState,    
    NVAPI_VF_PostProcessVIC,
    NVAPI_VF_MVCHDDecodeAcceleration,
    NVAPI_VF_SVCHDDecodeAcceleration,
    NVAPI_VF_SimpleScaling,
    NVAPI_VF_VP8HDDecodeAcceleration,
    NVAPI_VF_VP9HDDecodeAcceleration,
    NVAPI_VF_ID_LAST,
} NVAPI_VIDEO_FEATURE;

// Update the nvVidEngineNames[] array in nvd3d.cpp when adding a new Engine name.
//! Video feature engine names; used in _NVAPI_VIDEO_FEATURE_DETAILS
typedef enum _NVAPI_VIDEO_ENGINES
{
    NVAPI_VE_UNKNOWN = 0,
    NVAPI_VE_PixelShader,
    NVAPI_VE_MPEG2Decoder,
    NVAPI_VE_VideoProcessor1,
    NVAPI_VE_VideoProcessor2,
    NVAPI_VE_MSDEC,
    NVAPI_VE_VIC,
} NVAPI_VIDEO_ENGINES;

// Update the nvVidEntryPointNames[] array in nvd3d.cpp when adding a new Entry point in this enum.
//! Video driver entry point; used in _NVAPI_VIDEO_FEATURE_DETAILS 
typedef enum _NVAPI_VIDEO_DRIVER_ENTRY_POINT
{
    NVAPI_EP_UNKNOWN = 0,
    NVAPI_EP_DecodeEndFrame,
    NVAPI_EP_OverlayTransfer,
    NVAPI_EP_DIBlitEx,
    NVAPI_EP_VideoProcessBlt,
    NVAPI_EP_D3DBlt,
    NVAPI_EP_Blit32,
    NVAPI_EP_VPBltHD,
} NVAPI_VIDEO_DRIVER_ENTRY_POINT;



//! Used in _NVAPI_VIDEO_FEATURE_DESCRIPTOR
typedef enum _NVAPI_VIDEO_FEATURE_GET_FLAG
{
    NVAPI_VF_GET_COUNT = 0,
    NVAPI_VF_GET_DETAILS,
} NVAPI_VIDEO_FEATURE_GET_FLAG;


//! Used in _NVAPI_VIDEO_FEATURE_DESCRIPTOR
typedef struct _NVAPI_VIDEO_FEATURE_DETAILS
{
    NVAPI_VIDEO_FEATURE            eFeature;
    NVAPI_VIDEO_ENGINES            eEngine;
    NVAPI_VIDEO_DRIVER_ENTRY_POINT eEntryPoint;
    NvU32                          dwReserved;
} NVAPI_VIDEO_FEATURE_DETAILS;

//! Returns the strings for each feature to the client. \n
//! Used in _NVAPI_DX_VIDEO_FEATURE_DETAILS
typedef struct _NVAPI_VID_FEATURE_STRINGS
{
    NVAPI_VIDEO_FEATURE eFeature;
    NvAPI_ShortString   szFeature; //!< Feature name
    NvAPI_ShortString   szEngine; //!< Video engine name
    NvAPI_ShortString   szDrvEntryPoint; //!< drv Entry Point name
    NvAPI_ShortString   szReserved1; //!< Reserved for future expansion
} NVAPI_VID_FEATURE_STRINGS;


//! Macro for constructing the version field of NVAPI_VIDEO_FEATURE_DESCRIPTOR
#define NVAPI_VIDEO_FEATURE_DESCRIPTOR_VER  1


//! Used in _NVAPI_DX_VIDEO_FEATURE_DETAILS
typedef struct _NVAPI_VIDEO_FEATURE_DESCRIPTOR
{
    NvU32                          version;                     //!< (IN) Version that matches NVAPI_VIDEO_FEATURE_DETAILS_PACKET_VER
    NVAPI_VIDEO_FEATURE_GET_FLAG   eVideoFeatureGetID;          //!< (IN) Get total feature count or feature details
    NvU32                          dwVFCount;                   //!< (OUT) Feature count returned
    NvU32                          dwStartVFCount;              //!< (IN) Starting surface count when reading the data
    NVAPI_VIDEO_FEATURE_DETAILS    astFeatureDetails[NVAPI_MAX_FEATURES_PER_PACKET]; //!< (OUT) Array of video feature details
    NvU32                          adwReserved[4];              //!< (IN/OUT) Reserved for future expansion
} NVAPI_VIDEO_FEATURE_DESCRIPTOR;


//! Used in NvAPI_D3D9_EnumVideoFeatures().
typedef struct _NVAPI_DX_VIDEO_FEATURE_DETAILS
{
    NvU32                           version;              //!< (IN) NVAPI version that matched NVAPI_DX_VIDEO_FEATURE_DETAILS_VER
    NVAPI_VIDEO_FEATURE_DESCRIPTOR  videoFeaturesPacket;  //!< (IN/OUT)
    NVAPI_VID_FEATURE_STRINGS       astFeatureDescNames[NVAPI_MAX_FEATURES_PER_PACKET]; //!< (OUT) Descriptor strings 
} NVAPI_DX_VIDEO_FEATURE_DETAILS;

//! Macro for constructing the version field of _NVAPI_DX_VIDEO_FEATURE_DETAILS
#define NVAPI_DX_VIDEO_FEATURE_DETAILS_VER MAKE_NVAPI_VERSION(NVAPI_DX_VIDEO_FEATURE_DETAILS,1)

//! @}

//! \ingroup dxvidfeatures
NVAPI_INTERFACE NvAPI_D3D9_EnumVideoFeatures(IDirect3DDevice9 *pDev, NVAPI_DX_VIDEO_FEATURE_DETAILS *pVideoFeatureDetails);




#endif //defined(_D3D9_H_) && defined(__cplusplus)



#if defined(_D3D9_H_) && defined(__cplusplus)

//////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_GetSLIInfo
//
//! \fn NvAPI_D3D9_GetSLIInfo(IDirect3DDevice9 *pDev, NV_SLI_INFO *pSliInfo)
//! This API is obsolete, please use NvAPI_D3D_GetCurrentSLIState().
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 100
//!
//!
//! \retval   NVAPI_OK                      Completed request
//! \retval   NVAPI_NO_ACTIVE_SLI_TOPOLOGY  SLI is not active on this device
//! \retval   NVAPI_ERROR                   Error occurred
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup dx
//! Used in NV_SLI_INFO
typedef enum _NV_SLI_MODE
{
    NV_SLI_RENDERING_MODE_AUTOSELECT  = 0,     //!< AutoSelect
    NV_SLI_RENDERING_MODE_AFR         = 1,     //!< Alternate Frames
    NV_SLI_RENDERING_MODE_SFR         = 2,     //!< Split Frame
    NV_SLI_RENDERING_MODE_SINGLE      = 3,      //!< Single GPU
    NV_SLI_RENDERING_MODE_AFR_OF_SFR  = 4      //!< AFR of SFR

} NV_SLI_MODE;

//! \ingroup dx
//! Used in NvAPI_D3D9_GetSLIInfo()
typedef struct
{
    NvU32 version;                       //!< Structure version

    NV_SLI_MODE         mode;            //!< [OUT] Current SLI mode
    NvU32               gpus;            //!< [OUT] Number of GPUs
} NV_SLI_INFO;


//! \ingroup dx
#define NV_SLI_INFO_VER  MAKE_NVAPI_VERSION(NV_SLI_INFO,1)



//! \ingroup dx
NVAPI_INTERFACE NvAPI_D3D9_GetSLIInfo(IDirect3DDevice9 *pDev, NV_SLI_INFO *pSliInfo);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_SetSLIMode
//
//! This function sets the SLI rendering mode for the Direct 3D device. The NVAPI_SLI_RENDERING_MODE_NOTALLOWED
//!                 return status occurs when SLI mode is enabled in the middle of a rendering. An application may try
//!                 to recreate/reset device and perform the call again. The normal way to set up SLI mode
//!                 is immediately after CreateDevice() or Reset(). The NVAPI_NO_ACTIVE_SLI_TOPOLOGY value is
//!                 returned when SLI is not active on this device.
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 100
//!
//! \retval    NVAPI_OK                             Completed request
//! \retval    NVAPI_NO_ACTIVE_SLI_TOPOLOGY         SLI is not active on this device
//! \retval    NVAPI_SLI_RENDERING_MODE_NOTALLOWED  Setup of SLI mode is not possible right now
//! \retval    NVAPI_INVALID_ARGUMENT               Invalid rendering mode
//! \retval    NVAPI_ERROR                          Error occurred
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_SetSLIMode(IDirect3DDevice9 *pDev, NV_SLI_MODE SliMode);



#endif //defined(_D3D9_H_) && defined(__cplusplus)




#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_QueryAAOverrideMode
//
//! \fn NvAPI_D3D9_QueryAAOverrideMode(IDirect3DDevice9 *pDev, NvU32* pRenderingSampleCount, NvU32* pBufferSampleCount, NvU32* pAAMode)
//! DESCRIPTION:    This function returns the antialiasing level selected through NVCPL, 
//!                 the corresponding buffer requirement, and the equivalent multisample quality.                  
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!                   
//! \param [in]     pDev                    The Direct3D device for which the component is requested
//! \param [out]    pRenderingSampleCount   The number of equivalent sample counts for this AA method, 0 indicates no AA set in the control panel
//! \param [out]    pBufferSampleCount      The number of buffer samples required for every pixel, 0 indicates no AA set in the control panel
//! \param [out]    pAAMode                 The AA mode that is currently selected
//!                                             
//! \retval         NVAPI_OK                Completed request
//! \retval         NVAPI_ERROR             Error occurred
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup dx
//! Used in NvAPI_D3D9_QueryAAOverrideMode().
enum
{
    NVAPI_AAMODE_VCAA             = 0x00000001,    //!< The current AA method is one of the VCAA methods
    NVAPI_AAMODE_SLIAA            = 0x00000002,    //!< The current AA method is one of the SLI-AA methods
    NVAPI_AAMODE_VCAA_HIGHQUALITY = 0x00000004     //!< The current AA method is a VCAA high-quality method
};



//! \ingroup dx
NVAPI_INTERFACE NvAPI_D3D9_QueryAAOverrideMode(IDirect3DDevice9 *pDev, NvU32* pRenderingSampleCount, NvU32* pBufferSampleCount, NvU32* pAAMode);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_D3D9_VideoSurfaceEncryptionControl
//
//! \fn NvAPI_D3D9_VideoSurfaceEncryptionControl(IDirect3DDevice9 *pDev, NVAPI_VIDSURF_ENCRYPT_CTRL_PARAMS *pVidSurfEncrCtrlParams)
//!  DESCRIPTION:   This API is deprecated. 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 165
//! 
//! \retval  NVAPI_NOT_SUPPORTED               Deprecated 
//
///////////////////////////////////////////////////////////////////////////////

//! \addtogroup dxvidcontrol
//! @{

//! Video Surface Encryption Control Commands, 
//! used in \ref NVAPI_VIDSURF_ENCRYPT_CTRL_PARAMS.
typedef enum 
{
    NVAPI_VIDSURF_ENCRYPT_CMD_NULL              = 0x00, //!< Null command
    NVAPI_VIDSURF_ENCRYPT_CMD_GET_GUID_COUNT    = 0x01, //!< Get GUID count
    NVAPI_VIDSURF_ENCRYPT_CMD_GET_GUIDS         = 0x02, //!< Get GUIDs
    NVAPI_VIDSURF_ENCRYPT_CMD_SET_GUID          = 0x03, //!< Set GUID
    NVAPI_VIDSURF_ENCRYPT_CMD_ENABLE            = 0x04, //!< Enable encryption
    NVAPI_VIDSURF_ENCRYPT_CMD_SET_KEY           = 0x05, //!< Set key
    NVAPI_VIDSURF_ENCRYPT_CMD_SET_IV            = 0x06  //!< Set IV
} NVAPI_VIDSURF_ENCRYPT_COMMANDS;


//! Used in NVAPI_VIDSURF_ENCRYPT_CTRL_GET_GUIDS
#define NVAPI_VIDSURF_ENCRYPT_MAX_GUIDS        (4)


//! Used in NVAPI_VIDSURF_ENCRYPT_CTRL_PARAMS
typedef struct
{
    NvU32   dwGuidCount;                                // (OUT)
} NVAPI_VIDSURF_ENCRYPT_CTRL_GET_GUID_COUNT;


//! Used in NVAPI_VIDSURF_ENCRYPT_CTRL_PARAMS
typedef struct
{
    GUID    guids[NVAPI_VIDSURF_ENCRYPT_MAX_GUIDS];     // (OUT)
} NVAPI_VIDSURF_ENCRYPT_CTRL_GET_GUIDS;


//! Used in NVAPI_VIDSURF_ENCRYPT_CTRL_PARAMS
typedef struct
{
    GUID    guid;                                       // (IN)
} NVAPI_VIDSURF_ENCRYPT_CTRL_SET_GUID;


//! Used in NVAPI_VIDSURF_ENCRYPT_CTRL_PARAMS
typedef struct
{
    IDirect3DSurface9  *pSurface;                       // D3D9 surface ptr (IN)
    NvU32               bEnable;                        // (IN)
} NVAPI_VIDSURF_ENCRYPT_CTRL_ENABLE;


//! Used in NVAPI_VIDSURF_ENCRYPT_CTRL_PARAMS
typedef struct
{
    NvU32   dwEncryptKeyProtectionMode;
    NvU32   dwEncryptKeyProtectionIdentifier;
    NvU32   dwKey[4];                                   // (IN)
} NVAPI_VIDSURF_ENCRYPT_CTRL_SET_KEY;


//! Used in NVAPI_VIDSURF_ENCRYPT_CTRL_PARAMS
typedef struct
{
    NvU32   dwEncryptKeyProtectionMode;
    NvU32   dwEncryptKeyProtectionIdentifier;
    NvU32   dwIV[4];                                    // (IN)
} NVAPI_VIDSURF_ENCRYPT_CTRL_SET_IV;


//! Used in NvAPI_D3D9_VideoSurfaceEncryptionControl()
typedef struct
{
    NvU32               version;                        // structure version (IN)
    NvU32               dwCommand;                      // command (IN)
    union
    {
        NVAPI_VIDSURF_ENCRYPT_CTRL_GET_GUID_COUNT       GetGuidCount;
        NVAPI_VIDSURF_ENCRYPT_CTRL_GET_GUIDS            GetGuids;
        NVAPI_VIDSURF_ENCRYPT_CTRL_SET_GUID             SetGuid;
        NVAPI_VIDSURF_ENCRYPT_CTRL_ENABLE               Enable;
        NVAPI_VIDSURF_ENCRYPT_CTRL_SET_KEY              SetKey;
        NVAPI_VIDSURF_ENCRYPT_CTRL_SET_IV               SetIV;
    };
} NVAPI_VIDSURF_ENCRYPT_CTRL_PARAMS;


#define NVAPI_VIDSURF_ENCRYPT_CTRL_PARAMS_VER \
    MAKE_NVAPI_VERSION(NVAPI_VIDSURF_ENCRYPT_CTRL_PARAMS,1)

//! @}



//! \ingroup dxvidcontrol
NVAPI_INTERFACE NvAPI_D3D9_VideoSurfaceEncryptionControl(IDirect3DDevice9 *pDev, NVAPI_VIDSURF_ENCRYPT_CTRL_PARAMS *pVidSurfEncrCtrlParams);


#endif //defined(_D3D9_H_) && defined(__cplusplus)



#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_D3D9_DMA
//
//! \fn NvAPI_D3D9_DMA(IDirect3DDevice9 *pDev, NVAPI_D3D9_DMA_PARAMS *pVideoDMAParams)
//!
//! DESCRIPTION:     This API lets the caller perform a number of functions related to
//!                  the efficient DMA transfer of data between a Direct3D/DirectX 9 surface and
//!                  user-allocated system memory.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 190
//!
//! \retval ::NVAPI_OK                           Completed request
//! \retval ::NVAPI_ERROR                        Miscellaneous error occurred
//! \retval ::NVAPI_INVALID_ARGUMENT             Invalid input parameter.
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION  The version of struct NVAPI_D3D9_DMA_PARAMS
//!                                              is not supported.
///////////////////////////////////////////////////////////////////////////////

//! \addtogroup dxdma
//! @{

//! Direct3D/DirectX 9 DMA commands used in _NVAPI_D3D9_DMA_PARAMS.
typedef enum _NVAPI_D3D9_DMA_COMMANDS
{
    NVAPI_D3D9_DMA_CMD_NULL         = 0x00,             //!< Null command
    NVAPI_D3D9_DMA_CMD_DESCRIBE     = 0x01,             //!< Describe allocation requirements - See _NVAPI_D3D9_DMA_DESCRIBE_PARAMS for parameters.
    NVAPI_D3D9_DMA_CMD_MAP          = 0x02,             //!< Map user-allocated system memory - See _NVAPI_D3D9_DMA_MAP_PARAMS for parameters.
    NVAPI_D3D9_DMA_CMD_UNMAP        = 0x03,             //!< Unmap user-allocated system memory - See _NVAPI_D3D9_DMA_UNMAP_PARAMS for parameters.
    NVAPI_D3D9_DMA_CMD_REG_EVENT    = 0x04,             //!< Register user-mode event handle - See _NVAPI_D3D9_DMA_EVENT_PARAMS for parameters.
    NVAPI_D3D9_DMA_CMD_UNREG_EVENT  = 0x05,             //!< Unregister user-mode event handle - See _NVAPI_D3D9_DMA_EVENT_PARAMS for parameters. 
    NVAPI_D3D9_DMA_CMD_TRANSFER     = 0x06,             //!< Transfer between user system memory and Direct3D/DirectX 9 surface
                                                        //!< See  _NVAPI_D3D9_DMA_TRANSFER_PARAMS for parameters.
    NVAPI_D3D9_DMA_CMD_COLOR_MATRIX = 0x07,             //!< Set up the color matrix for the transfer
} NVAPI_D3D9_DMA_COMMANDS;


//! Specifies the direction of the DMA transfer.
//! See NVAPI_D3D9_DMA_TRANSFER_PARAMS for more details.
typedef enum _NVAPI_D3D9_DMA_TRANSFER_DIR
{
    NVAPI_D3D9_DMA_TRANSFER_DIR_UPLOAD     = 0x00,      //!< Transfer from user system memory to Direct3D/DirectX 9 surface.
    NVAPI_D3D9_DMA_TRANSFER_DIR_DOWNLOAD   = 0x01,      //!< Transfer from Direct3D/DirectX 9 surface to user system memory.
} NVAPI_D3D9_DMA_TRANSFER_DIR;


//! Specifies the type of the DMA transfer.
//! See NVAPI_D3D9_DMA_TRANSFER_PARAMS for more details.
typedef enum _NVAPI_D3D9_DMA_TRANSFER_TYPE
{
    NVAPI_D3D9_DMA_TRANSFER_TYPE_PROGRESSIVE    = 0x00, //!< Transfer progressive frame.
    NVAPI_D3D9_DMA_TRANSFER_TYPE_INTERLACED     = 0x01, //!< Transfer both fields and keep the result interleaved.
    NVAPI_D3D9_DMA_TRANSFER_TYPE_BOB_TOP_FIELD  = 0x02, //!< Perform bob deinterlacing on the top field.
    NVAPI_D3D9_DMA_TRANSFER_TYPE_BOB_BTM_FIELD  = 0x03, //!< Perform bob deinterlacing on the bottom field.
} NVAPI_D3D9_DMA_TRANSFER_TYPE;


#define NVAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_STD_MASK (NVAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_STD_601|NVAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_STD_709|NVAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_STD_240|NVAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_STD_CUSTOM)

#define NVAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_RANGE_MASK (NVAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_RANGE_FULL| NVAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_RANGE_LIM)

//! Specifies the type of the color space and range.
//! See ::NVAPI_D3D9_DMA_CMD_COLOR_MATRIX for more details
typedef enum _NVAPI_D3D9_DMA_COLOR_MATRIX_FLAGS
{
    NVAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_STD_601         = 0x01, //!< Color Standard: 601
    NVAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_STD_709         = 0x02, //!< Color Standard: 709
    NVAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_STD_240         = 0x04, //!< Color Standard: 240
    NVAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_STD_CUSTOM      = 0x08, //!< Color Standard: Custom
    NVAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_RANGE_FULL      = 0x10, //!< Color Range: Full [0 .. 255]
    NVAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_RANGE_LIM       = 0x20, //!< Color Range: Limited [16 .. 235]
} NVAPI_D3D9_DMA_COLOR_MATRIX_FLAGS;



//! Parameter data structure for the NVAPI_D3D9_DMA_CMD_DESCRIBE command (See ::_NVAPI_D3D9_DMA_COMMANDS.)
//! Given the surface dimension and format as input, the command
//! provides the driver requirements (such as alignment) for memory allocation.
typedef struct _NVAPI_D3D9_DMA_DESCRIBE_PARAMS
{
    NvU32                       dwWidth;                //!< width (IN)
    NvU32                       dwHeight;               //!< height (IN)
    NvU32                       dwFormat;               //!< FOURCC format (IN)
    NvU32                       dwPitch;                //!< pitch (OUT)
    NvU32                       dwSize;                 //!< size (OUT)
    NvU32                       dwAlignment;            //!< alignment (OUT)
} NVAPI_D3D9_DMA_DESCRIBE_PARAMS;


//! Parameter data structure for the NVAPI_D3D9_DMA_CMD_MAP command. (See ::_NVAPI_D3D9_DMA_COMMANDS.)
//! The command maps user-allocated system memory buffer to an NVIDIA DirectX object handle.
//! The pMemory buffer must satisfy the driver requirements.
//! Supported FOURCC formats are: NV12, YV12, YUY2
typedef struct _NVAPI_D3D9_DMA_MAP_PARAMS
{
    NvU32                       dwWidth;                //!< width (IN)
    NvU32                       dwHeight;               //!< height (IN)
    NvU32                       dwFormat;               //!< FOURCC format (IN)
    void                       *pMemory;                //!< memory pointer (IN)
    NVDX_ObjectHandle           hSysmemSurface;         //!< sysmem surface handle (OUT)
} NVAPI_D3D9_DMA_MAP_PARAMS;


//! Parameter data structure for the NVAPI_D3D9_DMA_CMD_UNMAP command. (See ::_NVAPI_D3D9_DMA_COMMANDS.)
//! The command unmaps the user-allocated system memory buffer.
typedef struct _NVAPI_D3D9_DMA_UNMAP_PARAMS
{
    NVDX_ObjectHandle           hSysmemSurface;         //<! sysmem surface handle (IN)
} NVAPI_D3D9_DMA_UNMAP_PARAMS;


//! Parameter data structure for the NVAPI_D3D9_DMA_CMD_REG_EVENT
//! command and the NVAPI_D3D9_DMA_CMD_UNREG_EVENT command. (See ::_NVAPI_D3D9_DMA_COMMANDS.)
//! The commands register or unregister a user-mode event handle with the Direct3D/DireectX 9 device.
typedef struct _NVAPI_D3D9_DMA_EVENT_PARAMS
{
    HANDLE                      hCompletionEvent;       //!< user-mode event handle (IN)
} NVAPI_D3D9_DMA_EVENT_PARAMS;



//! Parameter data structure for the NVAPI_D3D9_DMA_CMD_TRANSFER command. (See ::_NVAPI_D3D9_DMA_COMMANDS.)
//! The command performs DMA transfers between system memory buffer and the Direct3D/DirectX 9 surface.
//! It supports both upload and download directions, and supports scaling, color space and pixel format conversion.
//! A NULL rectangle indicates that the entire surface is used. \n
//! The last reserved word is used to specify the scaling interpolation method
//! and whether the source transfer rect has floating point co-ordinates.
//! Floating point rects and smoothing levels are applied to NV12/IYUV/YV12->ARGB transfers only.
typedef struct _NVAPI_D3D9_DMA_TRANSFER_PARAMS
{
    NVAPI_D3D9_DMA_TRANSFER_DIR     direction;          //!< Direction of the transfer (IN)
    NVDX_ObjectHandle               hSysmemSurface;     //!< sysmem surface handle (IN)
    RECT*                           pSysmemSurfaceRect; //!< sysmem surface rectangle (IN)
    NVDX_ObjectHandle               hD3D9Surface;       //!< D3D9 surface handle (IN)
    RECT*                           pD3D9SurfaceRect;   //!< floatSrcRectFlag=0 => (RECT *) D3D9 Surface rectangle with integral co-ords (IN)
                                                        //!< floatSrcRectFlag=1 => (RECTF *)D3D9 Surface rectangle with float co-ords appended to integral co-ords (IN)

    HANDLE                          hCompletionEvent;   //!< Completion event handle (IN)
    NVAPI_D3D9_DMA_TRANSFER_TYPE    transferType;       //!< Type of the transfer (IN)
    NvU32                           floatSrcRectFlag:1; //!< 1=>pD3D9SurfaceRectF has float co-ords appended (IN)
    NvU32                           smoothingLevel:2;   //!< Type of interpolation for scaling. 
                                                        //!< 0=>Bilinear, 1=>Nearest Neighbor, 2,3=>Reserved for future.
    NvU32                           reserved:17;           //!< Reserved for future expansion (IN / OUT)
    NvU32                           reservedFlagValid:12;//!< Secret keyword that implies floatSrcRectFlag/smoothingLevel flags are valid (IN)
} NVAPI_D3D9_DMA_TRANSFER_PARAMS;



//! Used in _NVAPI_D3D9_DMA_COLOR_MATRIX_PARAMS.
#define NVAPI_D3D9_DMA_COLOR_MATRIX_SIZE            12

//! parameter data structure for the NVAPI_D3D9_DMA_CMD_COLOR_MATRIX command \n
//! Specifies the flags for the color spaces and color range.
//! Currently color Spaces 601 and 709 are available inside the driver. For others, the input
//! color matrix [cm0-cm11] will be used. It has the following format for a YUV to RGB color conversion
//! \code   
//!   | cm0  cm1  cm2 |    | y |   | cm9  |    | r |
//!   | cm3  cm4  cm5 | * (| u | + | cm10 |) = | g |
//!   | cm6  cm7  cm8 |    | v |   | cm11 |    | b |
//!  i.e.  MATRIX * (YUV + const) = RGB
//! \endcode
//!  The offsets cm9..cm11 are divided by 255.
typedef struct _NVAPI_D3D9_DMA_COLOR_MATRIX_PARAMS
{
   NvU32                             colorMatrixFlags;  //!< NVAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_XX flags to define the color space and range.
   float*                            colorMatrix;       //!< 4x3 float array containing the matrix (NVAPI_D3D9_DMA_COLOR_MATRIX_SIZE)
} NVAPI_D3D9_DMA_COLOR_MATRIX_PARAMS;



//! Used in NvAPI_D3D9_DMA(). 
typedef struct _NVAPI_D3D9_DMA_PARAMS
{
    NvU32               version;                        //!< Structure version (IN)
    NvU32               dwCommand;                      //!< Command (IN)
    union
    {
        NVAPI_D3D9_DMA_DESCRIBE_PARAMS     DescribeParams;
        NVAPI_D3D9_DMA_MAP_PARAMS          MapParams;
        NVAPI_D3D9_DMA_UNMAP_PARAMS        UnmapParams;
        NVAPI_D3D9_DMA_EVENT_PARAMS        EventParams;
        NVAPI_D3D9_DMA_TRANSFER_PARAMS     TransferParams;
        NVAPI_D3D9_DMA_COLOR_MATRIX_PARAMS ColorMatrixParams;
    };
} NVAPI_D3D9_DMA_PARAMS;


//! Macro for constructing the version field of _NVAPI_D3D9_DMA_PARAMS.
#define NVAPI_D3D9_DMA_PARAMS_VER \
    MAKE_NVAPI_VERSION(NVAPI_D3D9_DMA_PARAMS, 1)

//! @}


//! \ingroup dxdma
NVAPI_INTERFACE NvAPI_D3D9_DMA(IDirect3DDevice9 *pDev,
    NVAPI_D3D9_DMA_PARAMS *pVideoDMAParams);

#endif //defined(_D3D9_H_) && defined(__cplusplus)



#if defined(_D3D9_H_) && defined(__cplusplus)
//! SUPPORTED OS:  Windows XP and higher
//!

//! \ingroup dx
//! @{

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION_NAME: NvAPI_D3D9_EnableStereo
//
//! \fn NvAPI_D3D9_EnableStereo(IDirect3DDevice9 *pDev,
//!     NVAPI_D3D9_ENABLE_STEREO_PARAMS *pEnableStereoParams)
//!   DESCRIPTION:   This API allows an approved application to enable stereo viewing
//!                  on an HDMI 1.4 TV.
//!
//! \retval ::NVAPI_OK                 completed request
//! \retval ::NVAPI_INVALID_ARGUMENT   the vendor ID and/or response is invalid
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION   the version of NVAPI_D3D9_ENABLE_STEREO_PARAMS struct not supported.
//
///////////////////////////////////////////////////////////////////////////////

//! D3D9 Enable Stereo Commands
typedef enum _NVAPI_D3D9_ENABLE_STEREO_COMMANDS
{
    NVAPI_D3D9_ENABLE_STEREO_CMD_CHALLENGE = 0x01,
    NVAPI_D3D9_ENABLE_STEREO_CMD_RESPONSE  = 0x02,
} NVAPI_D3D9_ENABLE_STEREO_COMMANDS;

//! D3D9 Enable Stereo Constants
#define NVAPI_D3D9_ENABLE_STEREO_CHALLENGE_SIZE     16
//! D3D9 Enable Stereo Constants
#define NVAPI_D3D9_ENABLE_STEREO_RESPONSE_SIZE      20

//
//! Parameter data structure for the NVAPI_D3D9_ENABLE_STEREO_CMD_CHALLENGE command - 
//! This command requests a random challenge from driver.
//! It must be invoked before the NVAPI_D3D9_ENABLE_STEREO_CMD_RESPONSE command.
typedef struct _NVAPI_D3D9_ENABLE_STEREO_CHALLENGE_PARAMS
{
    NvU8 challenge[NVAPI_D3D9_ENABLE_STEREO_CHALLENGE_SIZE];    //!< random challenge from driver (OUT)
} NVAPI_D3D9_ENABLE_STEREO_CHALLENGE_PARAMS;

//
//! Parameter data structure for the NVAPI_D3D9_ENABLE_STEREO_CMD_RESPONSE command
//!
//! The application must possess the following information in order to calculate a valid response:
//! - vendorGUID: a unique ID assigned to the application vendor by NVIDIA;
//! - vendorKEY:  a secret key issued to the application vendor by NVIDIA;
//!
//! The response is calculated as HMAC(vendorKEY, (vendorGUID || challenge))
//! where HMAC is the Keyed-Hash Message Authentication Code using SHA-1 as the
//! underlying hash function. See FIPS Publication 198 for details of the algorithm.
typedef struct _NVAPI_D3D9_ENABLE_STEREO_RESPONSE_PARAMS
{
    NvGUID vendorGUID;                                          //!< vendor GUID from app (IN)
    NvU8   response[NVAPI_D3D9_ENABLE_STEREO_RESPONSE_SIZE];    //!< response from the app (IN)
} NVAPI_D3D9_ENABLE_STEREO_RESPONSE_PARAMS;

typedef struct _NVAPI_D3D9_ENABLE_STEREO_PARAMS
{
    NvU32 version;                      //!< structure version (IN)
    NvU32 dwCommand;                    //!< command (IN)
    union
    {
        NVAPI_D3D9_ENABLE_STEREO_CHALLENGE_PARAMS   ChallengeParams;
        NVAPI_D3D9_ENABLE_STEREO_RESPONSE_PARAMS    ResponseParams;
    };
} NVAPI_D3D9_ENABLE_STEREO_PARAMS_V1;

typedef NVAPI_D3D9_ENABLE_STEREO_PARAMS_V1      NVAPI_D3D9_ENABLE_STEREO_PARAMS;
#define NVAPI_D3D9_ENABLE_STEREO_PARAMS_VER1    MAKE_NVAPI_VERSION(NVAPI_D3D9_ENABLE_STEREO_PARAMS_V1, 1)
#define NVAPI_D3D9_ENABLE_STEREO_PARAMS_VER     NVAPI_D3D9_ENABLE_STEREO_PARAMS_VER1

NVAPI_INTERFACE NvAPI_D3D9_EnableStereo(IDirect3DDevice9 *pDev,
    NVAPI_D3D9_ENABLE_STEREO_PARAMS *pEnableStereoParams);

//! @}

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_StretchRect
//
//! DESCRIPTION:    This API copies the contents of the source rectangle to the
//!                  destination rectangle.  This function can convert
//!                  between a wider range of surfaces than
//!                  IDirect3DDevice9::StretchRect. For example, it can copy
//!                  from a depth/stencil surface to a texture.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//! \param [in]      pDev       The D3D device that owns the objects.
//! \param [in]      hSrcObj    Handle to the source object.
//! \param [in]      pSrcRect   Defines the rectangle on the source to copy from.  If NULL, copy from the entire object.
//! \param [in]      hDstObj    Handle to the destination object.
//! \param [in]      pDstRect   Defines the rectangle on the destination to copy to.  If NULL, copy to the entire object.
//! \param [in]      Filter     Choose a filtering method: D3DTEXF_NONE, D3DTEXF_POINT, D3DTEXF_LINEAR.
//!
//! \return ::NVAPI_OK,    
//!         ::NVAPI_INVALID_POINTER, 
//!         ::NVAPI_INVALID_ARGUMENT, 
//!         ::NVAPI_ERROR 
//!
//! \ingroup dxvidcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_StretchRect(IDirect3DDevice9 *pDev,
                                       NVDX_ObjectHandle hSrcObj,
                                       CONST RECT * pSourceRect,
                                       NVDX_ObjectHandle hDstObj,
                                       CONST RECT * pDestRect,
                                       D3DTEXTUREFILTERTYPE Filter);



#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_CreateRenderTarget
//
//! DESCRIPTION:     This API is deprecated.
//! 
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 190
//!
//! \retval ::NVAPI_NOT_SUPPORTED  deprecated
//
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_CreateRenderTarget(IDirect3DDevice9 *pDev,
                                              UINT Width,
                                              UINT Height,
                                              D3DFORMAT Format,
                                              D3DMULTISAMPLE_TYPE MultiSample,
                                              DWORD MultisampleQuality,
                                              BOOL Lockable,
                                              IDirect3DSurface9** ppSurface,
                                              NVDX_ObjectHandle *pHandle = NULL);

#endif //defined(_D3D9_H_) && defined(__cplusplus)



//-----------------------------------------------------------------------------
// DirectX + BDVMA private API
//-----------------------------------------------------------------------------



#if defined(_D3D9_H_) && defined(__cplusplus)

//////////////////////////////////////////////////////////////////////////////                      
//
// FUNCTION NAME: NvAPI_D3D9_BDVMA_Alloc
//
//! \fn NvAPI_D3D9_BDVMA(IDirect3DDevice9 *pDev, NV_BDVMA_INFO *pBDVMAInfo)
//! 
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \return NVAPI_OK if the call succeeded
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup dx
//! Used in NvAPI_D3D9_BDVMA().
typedef struct 
{
    NvU32               version;                //!< structure version (IN)

    NvU32               dwFunction;             //!< [OUT] 1 is Alloc, 2 is Free, 3 is Map, 4 is UnMap
    NvU32               dwSize;                 //!< [IN] Size of the allocation
    NvU32               hAllocHandle;           //!< [OUT/IN] RM handle of the alloc
    NvU64               qwPhysVidOffset;        //!< [OUT/IN] Physical offset of the memory allocated in the frame buffer
    void *              pCPUPtr;                //!< [OUT/IN] CPU mapping
    void *              pMemAllocPtr;           //!< [OUT/IN] pointer to MEMALLOCATION
    NvU32               ulPageSize;             //!< [OUT/IN] Pagesize of the allocation
} NV_BDVMA_INFO;


//! \ingroup dx 
NVAPI_INTERFACE NvAPI_D3D9_BDVMA(IDirect3DDevice9 *pDev, NV_BDVMA_INFO *pBDVMAInfo);


#endif // defined(_D3D9_H_) && defined(__cplusplus)

//-----------------------------------------------------------------------------
// DirectX + nvFBC private API
//-----------------------------------------------------------------------------


// this need to be kept in sync with the defines in nvUMFBC.cpp

//Removing if _D3D9_H_ condition because this structure is also used by D3D1x and above (see NvAPI_D3D1x_IFR_SetUpTargetBufferToSys)
#if defined(__cplusplus)


//! \ingroup dx
typedef enum 
{

    // include in NDA for IFR
    // This will be deprecated from NDA starting with GRID SDK 2.2
    NVFBC_FORMAT_ARGB               =      0,      //!< ARGB 
    NVFBC_FORMAT_RGB                =      1,      //!< RGB packed
    NVFBC_FORMAT_YUV_420            =      2,      //!< YYYYUV
    NVFBC_FORMAT_RGB_PLANAR         =      3,      //!< RGB planar, RRRRRRRR GGGGGGGG BBBBBBBB
    NVFBC_FORMAT_RGB_XOR            =      4,      //!< XOR RGB
    NVFBC_FORMAT_YUV_444            =      5,      //!< YUV444
    NVFBC_FORMAT_NV12               =      6,      //!< NV12
    NVFBC_FORMAT_NOT_SUPPORTED      =      7       //

}NVFBC_BUFFER_FORMAT;

typedef enum
{
    NVFBC_CAPS_YUV444_NATIVE_SUPPORT =  0
} NVFBC_CAPS_TYPE;

#endif //defined(__cplusplus)


#if defined(_D3D9_H_) && defined(__cplusplus)

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_D3D9_NVFBC_CreateCaptureBuffer
//! \fn NvAPI_D3D9_NVFBC_CreateCaptureBuffer(IDirect3DDevice9 *pDev, NV_NVFBC_INFO *pNVFBCInfo)
//! 
//! \return NVAPI_OK if the call succeeded
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup dx
typedef struct 
{
    NvU32               version;                //!< structure version (IN)
    NvU32               dwSize;                 //!< [IN] Size of the allocation
} NV_NVFBC_INFO;

typedef struct : public NV_NVFBC_INFO
{
    NvU32               dwFlags;                 //!< [IN] allocation flags:
} NV_NVFBC_INFO4;

typedef struct : public NV_NVFBC_INFO4
{
    NvU32               dwAllocSize;             //!< [OUT] size of allocated capture buffer
} NV_NVFBC_INFO5;

typedef enum _NVAPI_NV_NVFBC_CREATEFLAGS
{
    NVAPI_NVFBC_FLAG_CREATESTEREO     = 0x00000001, //!< Tell KMD to bloat allocation to ~2x dwSize (2x + alignment) for stereo capture
    NVAPI_NVFBC_FLAG_ARGB_Z_HINTSDATA = 0x00000002, // 
} NVAPI_NV_NVFBC_CREATEFLAGS;

// each time the struct version needs to be updated
// sync the structure version to NVFBC_DLL_VERSION (defined in NvFBC.h) 
#define NVAPI_NV_NVFBC_INFO_VER5        MAKE_NVAPI_VERSION(NV_NVFBC_INFO,0x22)
#define NVAPI_NV_NVFBC_INFO_VER         NVAPI_NV_NVFBC_INFO_VER5

//! SUPPORTED OS:  Windows Vista and higher
//!
//! \ingroup dx
NVAPI_INTERFACE NvAPI_D3D9_NVFBC_CreateCaptureBuffer(IDirect3DDevice9 *pDev, NV_NVFBC_INFO *pNVFBCInfo);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_D3D9_NVFBC_DestroyCaptureBuffer
//! \fn NvAPI_D3D9_NVFBC_DestroyCaptureBuffer(IDirect3DDevice9 *pDev)
//!
//! \return NVAPI_OK if the call succeeded
//
///////////////////////////////////////////////////////////////////////////////

//! SUPPORTED OS:  Windows Vista and higher
//!
//! \ingroup dx
NVAPI_INTERFACE NvAPI_D3D9_NVFBC_DestroyCaptureBuffer(IDirect3DDevice9 *pDev);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_NVFBC_CopyCaptureBufferToCUDA
//! \fn NVAPI_INTERFACE NvAPI_D3D9_NVFBC_CaptureBufferToCUDA
//!
//! \return NVAPI_OK if the call succeeded
//
///////////////////////////////////////////////////////////////////////////////


//! SUPPORTED OS:  Windows Vista and higher
//!
//! \ingroup dx
NVAPI_INTERFACE NvAPI_D3D9_NVFBC_CaptureBufferToCUDA(IDirect3DDevice9 *pDev, void * pNvFBCFrameGrabInfo, IDirect3DVertexBuffer9 *pVertexBuffer, DWORD dwFlags);

#endif //defined(_D3D9_H_) && defined(__cplusplus)

#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_NVFBC_CaptureBufferToCUDAWithFormat
//! \fn NVAPI_INTERFACE NvAPI_D3D9_NVFBC_CaptureBufferToCUDAWithFormat
//!
//! \return NVAPI_OK if the call succeeded
//
///////////////////////////////////////////////////////////////////////////////

//! SUPPORTED OS:  Windows Vista and higher
//!
//! \ingroup dx
NVAPI_INTERFACE NvAPI_D3D9_NVFBC_CaptureBufferToCUDAWithFormat(IDirect3DDevice9 *pDev, void * pNvFBCFrameGrabInfo, IDirect3DVertexBuffer9 *pVertexBuffer, DWORD dwFlags, NVFBC_BUFFER_FORMAT eFormat);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_NVFBC_CaptureBufferToNV12BLVideoSurface
//! \fn NvAPI_D3D9_NVFBC_CaptureBufferToNV12BLVideoSurface(IDirect3DDevice9 *pDev, void * pDataGrabInfo, DWORD dwBufferIndex, DWORD dwFlags, DWORD dwGrabMode, DWORD dwTargetWidth, DWORD dwTargetHeight, DWORD dwStartX, DWORD dwStartY)
//!
//! \return NVAPI_OK if the call succeeded
//
///////////////////////////////////////////////////////////////////////////////

//! SUPPORTED OS:  Windows Vista and higher
//!
//! \ingroup dx
NVAPI_INTERFACE NvAPI_D3D9_NVFBC_CaptureBufferToNV12BLVideoSurface(IDirect3DDevice9 *pDev, void * pDataGrabInfo, DWORD dwBufferIndex, DWORD dwFlags=0, DWORD dwGrabMode=0, DWORD dwTargetWidth=0, DWORD dwTargetHeight=0, DWORD dwStartX=0, DWORD dwStartY=0);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_NVFBC_SetUpToNV12BLVideoSurface
//! \fn NvAPI_D3D9_NVFBC_SetUpToNV12BLVideoSurface(IDirect3DDevice9 *pDev, BOOL bWithHWCursor, DWORD dwNBuffers, HANDLE * ppBuffer, DWORD dwWidth, DWORD dwHeight)
//!
//! \return NVAPI_OK if the call succeeded
//
///////////////////////////////////////////////////////////////////////////////

//! SUPPORTED OS:  Windows Vista and higher
//!
//! \ingroup dx
NVAPI_INTERFACE NvAPI_D3D9_NVFBC_SetUpToNV12BLVideoSurface(IDirect3DDevice9 *pDev, BOOL bWithHWCursor, DWORD dwNBuffers, HANDLE * ppBuffer, DWORD dwWidth, DWORD dwHeight);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_NVFBC_SetUpToNV12BLVideoSurfaceEx
//! \fn NvAPI_D3D9_NVFBC_SetUpToNV12BLVideoSurface(IDirect3DDevice9 *pDev, BOOL bWithHWCursor, DWORD dwNBuffers, HANDLE * ppBuffer, DWORD dwWidth, DWORD dwHeight, BOOL bUseYUV444 = FALSE)
//!
//! \param [in]      pDev      The device that creates/owns the shared surface
//! \param [inout]   pParams   API parameters
//!
//! \retval      NVAPI_OK                       Call succeeded
//! \retval      NVAPI_INVALID_ARGUMENT         One or more arguments are invalid
//! \retval      NVAPI_NO_IMPLEMENTATION        API is not implemented
//! \retval      NVAPI_ERROR                    An unidentified error occurred
//! \retval      NVAPI_INVALID_POINTER          A NULL pointer was passed
//!
//
///////////////////////////////////////////////////////////////////////////////

//! SUPPORTED OS:  Windows Vista and higher
//!
//! \ingroup dx
typedef struct _NVAPI_D3D9_NVFBC_SETUP_Nv12BL_PARAMS_V1
{
    NvU32 version;                                                           //!< [in]  Struct version. Set to NVIFR_CROSSPROC_SHAREDSURFACE_CREATE_PARAMS_VER.
    NvU32 numBuffers;                                                        //!< [in] Number of buffers to allocate
    NvU32 width;                                                             //!< [in] width of buffer
    NvU32 height;                                                            //!< [in] height of buffer
    HANDLE *buffers;                                                         //!< [out] array of handles to allocated buffers
    NvU32 withHWCursor : 1;                                                  //!< [in] set to 1 if HW cursor capture is to be enabled
    NvU32 useYUV444    : 1;                                                  //!< [in] set to true if YUV 4:4:4 format is required
    NvU32 reservedBits : 6;                                                  //!< [in] reserved
} NVAPI_D3D9_NVFBC_SETUP_NV12BL_PARAMS_V1;

typedef NVAPI_D3D9_NVFBC_SETUP_NV12BL_PARAMS_V1 NVAPI_D3D9_NVFBC_SETUP_NV12BL_PARAMS;
#define NVAPI_D3D9_NVFBC_SETUP_NV12BL_PARAMS_VER1  MAKE_NVAPI_VERSION(NVAPI_D3D9_NVFBC_SETUP_NV12BL_PARAMS_V1,1)
#define NVAPI_D3D9_NVFBC_SETUP_NV12BL_PARAMS_VER NVAPI_D3D9_NVFBC_SETUP_NV12BL_PARAMS_VER1

NVAPI_INTERFACE NvAPI_D3D9_NVFBC_SetUpToNV12BLVideoSurfaceEx(__in IDirect3DDevice9 *pDev, __inout NVAPI_D3D9_NVFBC_SETUP_NV12BL_PARAMS *pParams);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_NVFBC_SetHWCursorCapture
//! \fn NvAPI_D3D9_NVFBC_SetHWCursorCapture(IDirect3DDevice9 *pDev, BOOL bWithHWCursor)
//!
//! \return NVAPI_OK if the call succeeded
//
///////////////////////////////////////////////////////////////////////////////

//! SUPPORTED OS:  Windows Vista and higher
//!
//! \ingroup dx
NVAPI_INTERFACE NvAPI_D3D9_NVFBC_SetHWCursorCapture(IDirect3DDevice9 *pDev, BOOL bWithHWCursor);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_NVFBC_SetUpToSys
//! \fn NvAPI_D3D9_NVFBC_SetUpToSys(IDirect3DDevice9 *pDev, BOOL bWithHWCursor, NVFBC_BUFFER_FORMAT eFormat, DWORD dwNBuffers, unsigned char ** ppBuffer, unsigned char ** ppDiffMap)
//!
//! \return NVAPI_OK if the call succeeded
//
///////////////////////////////////////////////////////////////////////////////

//! SUPPORTED OS:  Windows Vista and higher
//!
//! \ingroup dx
NVAPI_INTERFACE NvAPI_D3D9_NVFBC_SetUpToSys(IDirect3DDevice9 *pDev, BOOL bWithHWCursor, NVFBC_BUFFER_FORMAT eFormat, DWORD dwNBuffers, unsigned char ** ppBuffer, unsigned char ** ppDiffMap);

#endif //defined(_D3D9_H_) && defined(__cplusplus)

#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_NVFBC_SetUpToDx9Vid
//! \fn NvAPI_D3D9_NVFBC_SetUpToDX9Vid(IDirect3DDevice9 *pDev, BOOL bWithHWCursor, NVFBC_BUFFER_FORMAT eFormat, DWORD dwNBuffers, HANDLE * aHandles, DWORD dwWidth, DWORD dwHeight)
//!
//! \param [in] pDev           The device for which to get the primary surface 
//! \param [inout] pParam      Parameter Struct.
//!
//! \return NVAPI_OK if the call succeeded
//
///////////////////////////////////////////////////////////////////////////////

//! SUPPORTED OS:  Windows Vista and higher
//!
//! \ingroup dx
typedef struct 
{
    NvU32                   version;                            // in Struct version
    NVFBC_BUFFER_FORMAT     format;                             // in Buffer Format
    HANDLE                 *handles;                            // out array of handles to hold buffer handles allocated by NvFBC
    NvU32                   numBuffers;                         // in Number of buffers to be allocated
    NvU32                   width;                              // in buffer width
    NvU32                   height;                             // in buffer height
    NvU32                   withHWCursor: 1;                    // in HW cursor blending enabled\disabled
    NvU32                   reservedBits : 31;                  // Reserved
} NVFBC_SETUP_DX9_VID_PARAM;

#define NVFBC_SETUP_DX9_VID_PARAM_VER    MAKE_NVAPI_VERSION(NVFBC_SETUP_DX9_VID_PARAM, 1)

NVAPI_INTERFACE NvAPI_D3D9_NVFBC_SetUpToDX9Vid(__in IDirect3DDevice9 *pDev, __inout NVFBC_SETUP_DX9_VID_PARAM *pParam);

#endif //defined(_D3D9_H_) && defined(__cplusplus)

#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_NVFBC_CaptureBufferToSys
//! \fn NvAPI_D3D9_NVFBC_CaptureBufferToSys(IDirect3DDevice9 *pDev, void * pNvFBCFrameGrabInfo, DWORD dwFlags=0, DWORD dwGrabMode=0, DWORD dwTargetWidth=0, DWORD dwTargetHeight=0, DWORD dwStartX=0, DWORD dwStartY=0)
//!
//! \return NVAPI_OK if the call succeeded
//
///////////////////////////////////////////////////////////////////////////////

//! SUPPORTED OS:  Windows Vista and higher
//!
//! \ingroup dx
NVAPI_INTERFACE NvAPI_D3D9_NVFBC_CaptureBufferToSys(IDirect3DDevice9 *pDev, void * pNvFBCFrameGrabInfo, DWORD dwFlags=0, DWORD dwGrabMode=0, DWORD dwTargetWidth=0, DWORD dwTargetHeight=0, DWORD dwStartX=0, DWORD dwStartY=0);

#endif // defined(_D3D9_H_) && defined(__cplusplus)

#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_NVFBC_CaptureBufferToDX9Vid
//! \fn NvAPI_D3D9_NVFBC_CaptureBufferToDX9Vid(IDirect3DDevice9 *pDev, void * pNvFBCFrameGrabInfo, DWORD dwBufferIndex, DWORD dwFlags=0, DWORD dwGrabMode=0, DWORD dwTargetWidth=0, DWORD dwTargetHeight=0, DWORD dwStartX=0, DWORD dwStartY=0)
//!
//! \param [in] pDev   The Direct3D9 device for which to get the primary surface
//! \param [in] pParam Pointer to struct containing API parameters
//! \return NVAPI_OK if the call succeeded
//
///////////////////////////////////////////////////////////////////////////////

//! SUPPORTED OS:  Windows Vista and higher
//!
//! \ingroup dx
typedef struct 
{
    NvU32                   version;                            // in Struct version
    NvU32                   bufferIndex;                        // in Index of the buffer to be written to
    NvU32                   flags;                              // in Frame grab flags
    NvU32                   grabMode;                           // in Frame grab mode
    NvU32                   targetWidth;                        // in Target width of output image
    NvU32                   targetHeight;                       // in Target height of output image
    NvU32                   startX;                             // in X-coordinate on screen of first pixel in output image 
    NvU32                   startY;                             // in Y-coordinate on screen of first pixel in output image
    void *                  nvFBCFrameGrabInfoPtr;              // out Frame grab statistics
} NVFBC_CAPTURE_DX9_VID_PARAM;

#define NVFBC_CAPTURE_DX9_VID_PARAM_VER    MAKE_NVAPI_VERSION(NVFBC_CAPTURE_DX9_VID_PARAM, 1)
NVAPI_INTERFACE NvAPI_D3D9_NVFBC_CaptureBufferToDX9Vid(__in IDirect3DDevice9 *pDev, __inout NVFBC_CAPTURE_DX9_VID_PARAM *pParam);

#endif // defined(_D3D9_H_) && defined(__cplusplus)



#if defined(_D3D9_H_) && defined(__cplusplus)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_NVFBC_GetStatus
//
//! \fn NvAPI_D3D9_NVFBC_GetStatus(void * pNvFBCStatus)
//!   DESCRIPTION: This API returns the current status with regard to the NVFBC subsystem.  
//!
//! \param [in] pNvFBCStatus Pointer to a structure for the status of the NVFBC subsystem.
//!
//! \retval ::NVAPI_OK if the call succeeded
//
/////////////////////////////////////////////////////////////////////////////


//! SUPPORTED OS:  Windows Vista and higher
//!
//! \ingroup dx
NVAPI_INTERFACE NvAPI_D3D9_NVFBC_GetStatus(void * pNvFBCStatus);

#endif //defined(_D3D9_H_) && defined(__cplusplus)


#if defined(_D3D9_H_) && defined(__cplusplus)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_NVFBC_GetStatusEx
//
//! \fn NvAPI_D3D9_NVFBC_GetStatusEx(__inout NVFBC_NVAPI_GET_STATUS_EX_PARAM *nvFBCStatusParam)
//!   DESCRIPTION: This API returns the current status with regard to the NVFBC subsystem.  
//!
//! \param [in] d3d9dev  D3D9 device for which NVFBC status is to be checked
//! \param [inout] nvFBCStatusParam Pointer to a structure for the status of the NVFBC subsystem.
//!
//! \retval ::NVAPI_OK if the call succeeded
//! \retval ::NVAPI_NO_IMPLEMENTATION Not implemented on Win XP and older OS
//! \retval ::NVAPI_INVALID_ARGUMENT  If a NULL parameter pointer was passed
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION If a parameter struct with an incompatible version was passed
//
/////////////////////////////////////////////////////////////////////////////


//! SUPPORTED OS:  Windows Vista and higher
//!
//! \ingroup dx
typedef struct
{
    NvU32 version;                                                  // in struct version
    NvU32 isCapturePossible : 1;                                    // out tells if driver supports it the NvFBC feature
    NvU32 isCurrentlyCapturing : 1;                                 // out tells is NvFBC is already in use
    NvU32 reservedFlags : 30;                                       // out reserved
    NvU32 nvfbcDriverVersion;                                       // out version of the UMD framework for NvFBC
    NvU32 vidPnSrcId;                                               // in what display adapter we are querying the status for?
    NvDisplayHandle displayHandle;                                  // in what display are we querying the status for?
} NVFBC_NVAPI_GET_STATUS_EX_PARAM;

#define NVFBC_NVAPI_GET_STATUS_EX_PARAM_VER    MAKE_NVAPI_VERSION(NVFBC_NVAPI_GET_STATUS_EX_PARAM, 1)
#define NVFBC_NVAPI_GET_STATUS_EX_PARAM_VER1   NVFBC_NVAPI_GET_STATUS_EX_PARAM_VER
NVAPI_INTERFACE NvAPI_D3D9_NVFBC_GetStatusEx(__inout NVFBC_NVAPI_GET_STATUS_EX_PARAM *nvFBCStatusParam);

#endif //defined(_D3D9_H_) && defined(__cplusplus)

#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_IFR_SetUpTargetBufferToSys
//
//!   DESCRIPTION: This API requests the driver to allocate n buffers (up to a maximum of 3). 
//!                Additional calls to NvAPI_D3D9_IFR_SetUpTargetBufferToSys() will free the buffers that were allocated previously with the same call on the d3d device. 
//!
//!
//! \param [in]   pDev       The device to get primary surface on
//! \param [in]   eFormat    The format of the blit
//! \param [in]   dwNBuffers The number of buffers in ppBuffer (max 6).
//! \param [in]   ppBuffer   A pointer to an array of dwNBuffers (max 6) pointers. Virtual memory buffers will be allocated by the driver.
//!
//! \return ::NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////

//! SUPPORTED OS:  Windows Vista and higher
//!
//! \ingroup dx
__nvapi_deprecated_function("Deprecated from r331, GRID SDK 2.2")
NVAPI_INTERFACE NvAPI_D3D9_IFR_SetUpTargetBufferToSys(IDirect3DDevice9 *pDev, NVFBC_BUFFER_FORMAT eFormat, DWORD dwNBuffers, unsigned char ** ppBuffer);
 

#endif //defined(_D3D9_H_) && defined(__cplusplus)

#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_GPUBasedCPUSleep
//
//! \fn NvAPI_D3D9_GPUBasedCPUSleep(IDirect3DDevice9 *pDev, NvU64 qwMicroSeconds)
//!   DESCRIPTION: This API provides sub-quantum (usually 16 ms) sleep that does not burn CPU cycles. 
//!
//! \param [in] pDev           The device for which to get the primary surface 
//! \param [in] qwMicroSeconds The number of micro-seconds to block the CPU thread
//!
//! \return ::NVAPI_OK if the call succeeded
//
///////////////////////////////////////////////////////////////////////////////

//! SUPPORTED OS:  Windows Vista and higher
//!
//! \ingroup dx
NVAPI_INTERFACE NvAPI_D3D9_GPUBasedCPUSleep(IDirect3DDevice9 *pDev, NvU64 qwMicroSeconds);

#endif //defined(_D3D9_H_) && defined(__cplusplus)

#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_NVFBC_NextGen_Entry
//! \fn NvAPI_D3D9_NVFBC_NextGen_Entry(IDirect3DDevice9 *dev, void *nvfbc, NvU32 api, PNVFBCPARAMS params)
//!
//! \param [in]      dev		Directx9 device
//! \param [in]      nvfbc		NVFBC object handle
//! \param [in]      api		NVFBC Next Gen API identifier
//! \param [in]      inparams   API input parameters
//! \param [out]     outparams  API output parameters
//!
//! \retval      NVAPI_OK                       Call succeeded
//! \retval      NVAPI_INVALID_ARGUMENT         One or more arguments are invalid
//! \retval      NVAPI_NO_IMPLEMENTATION        API is not implemented
//! \retval      NVAPI_ERROR                    An unidentified error occurred
//! \retval      NVAPI_INVALID_POINTER          A NULL pointer was passed
//!
//
///////////////////////////////////////////////////////////////////////////////

//! SUPPORTED OS:  Windows Vista and higher
//!
//! \ingroup dx
typedef void* PNVFBCPARAMS;

NVAPI_INTERFACE NvAPI_D3D9_NVFBC_NextGen_Entry(__in IDirect3DDevice9 *dev, __in void *nvfbc, __in NvU32 api, __in PNVFBCPARAMS inparams, __out PNVFBCPARAMS outparams);

#endif //defined(_D3D9_H_) && defined(__cplusplus)


#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_IFR_TransferRenderTarget
//
//!  DESCRIPTION: This API copies the current rendertarget into the provided system memory buffer.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDev      The device to get primary surface on
//! \param [in]      pEvent    When not NULL, will receive a handle to an event that the driver will signal 
//!                            upon completion of NvAPI_D3D9_IFR_TransferRenderTarget().
//! \param [in]      dwBufferIndex  The index of the buffer that will receive a copy of the rendertarget. 
//!                                 This ordinal is between 0 and the number of buffer created by NvAPI_D3D9_IFR_SetUpTargetBufferToSys().
//! \param [in]      dwTargetWidth  When dwTargetWidth and dwTargetHeight are not 0, a bilinear filtered scaling 
//!                                 will be done before the blit to system memory.
//! \param [in]      dwTargetHeight When dwTargetWidth and dwTargetHeight are not 0, a bilinear filtered scaling 
//!                                 will be done before the blit to system memory.
//!
//! \return ::NVAPI_OK 
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Deprecated from r331, GRID SDK 2.2")
NVAPI_INTERFACE NvAPI_D3D9_IFR_TransferRenderTarget(IDirect3DDevice9 *pDev, HANDLE * pEvent, DWORD dwBufferIndex, DWORD dwTargetWidth, DWORD dwTargetHeight);

#endif //defined(_D3D9_H_) && defined(__cplusplus)

#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_IFR_SetUpTargetBufferToNV12BLVideoSurface
//
//!   DESCRIPTION: This API requests the driver to allocate n buffers (up to a maximum of 3). 
//!                Additional calls to NvAPI_D3D9_IFR_SetUpTargetBufferToSys() will free the buffers that were allocated previously with the same call on the d3d device. 
//!
//!
//! \since Release: 295
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]   pDev       The device to get primary surface on
//! \param [in]   dwNBuffers The number of buffers in ppBuffer (max 3).
//! \param [in]   aHandles   A pointer to an array of videolibrary surfaces.
//!
//! \return ::NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////

__nvapi_deprecated_function("Deprecated from r331, GRID SDK 2.2")
NVAPI_INTERFACE NvAPI_D3D9_IFR_SetUpTargetBufferToNV12BLVideoSurface(IDirect3DDevice9 *pDev, DWORD dwNBuffers, HANDLE * aHandles, DWORD dwTargetWidth, DWORD dwTargetHeight);

#endif //defined(_D3D9_H_) && defined(__cplusplus)

#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_IFR_TransferRenderTargetToNV12BLVideoSurface
//
//!  DESCRIPTION: This API copies the current rendertarget into the provided system memory buffer.
//!
//! \since Release: 295
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDev      The device to get primary surface on
//! \param [in]      dwBufferIndex  The index of the buffer that will receive a copy of the rendertarget. 
//!                                 This ordinal is between 0 and the number of buffer created by NvAPI_D3D9_IFR_SetUpTargetBufferToNV12BLVideoSurface().
//! \param [in]      dwTargetWidth  When dwTargetWidth and dwTargetHeight are not 0, a bilinear filtered scaling 
//!                                 will be done before the blit to system memory.
//! \param [in]      dwTargetHeight When dwTargetWidth and dwTargetHeight are not 0, a bilinear filtered scaling 
//!                                 will be done before the blit to system memory.
//!
//! \return ::NVAPI_OK 
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Deprecated from r331, GRID SDK 2.2")
NVAPI_INTERFACE NvAPI_D3D9_IFR_TransferRenderTargetToNV12BLVideoSurface(IDirect3DDevice9 *pDev, DWORD dwBufferIndex, DWORD dwTargetWidth, DWORD dwTargetHeight);

#endif // defined(_D3D9_H_) && defined(__cplusplus)

#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_IFR_CreateSharedSurface
//
//!
//! \since Release: 304
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDev      The device that creates/owns the shared surface
//! \param [in]      dwWidth  
//! \param [in]      dwHeight 
//!
//! \return ::NVAPI_OK 
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////

typedef void * IFRSharedSurfaceHandle;

__nvapi_deprecated_function("Deprecated from r331, GRID SDK 2.2")
NVAPI_INTERFACE NvAPI_D3D9_IFR_CreateSharedSurface(IDirect3DDevice9 *pDev, DWORD dwWidth, DWORD dwHeight, IFRSharedSurfaceHandle * phNvIFRSharedSurface);

#endif // defined(_D3D9_H_) && defined(__cplusplus)

#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_IFR_DestroySharedSurface
//
//!
//! \since Release: 304
//! 
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDev      The device that created the shared surface
//!
//! \return ::NVAPI_OK 
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////

__nvapi_deprecated_function("Deprecated from r331, GRID SDK 2.2")

NVAPI_INTERFACE NvAPI_D3D9_IFR_DestroySharedSurface(IDirect3DDevice9 *pDev, IFRSharedSurfaceHandle hNvIFRSharedSurface);

#endif // defined(_D3D9_H_) && defined(__cplusplus)


#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_IFR_CopyToSharedSurface
//
//!
//! \since Release: 304
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDev      The device that will do the blit
//!
//! \return ::NVAPI_OK 
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////

__nvapi_deprecated_function("Deprecated from r331, GRID SDK 2.2")

NVAPI_INTERFACE NvAPI_D3D9_IFR_CopyToSharedSurface(IDirect3DDevice9 *pDev, IFRSharedSurfaceHandle hNvIFRSharedSurface, IDirect3DSurface9 * pSurface);

#endif // defined(_D3D9_H_) && defined(__cplusplus)


#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_IFR_CopyFromSharedSurface
//
//!
//! \since Release: 304
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDev      The device that will do the blit
//!
//! \return ::NVAPI_OK 
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////

__nvapi_deprecated_function("Deprecated from r331, GRID SDK 2.2")

NVAPI_INTERFACE NvAPI_D3D9_IFR_CopyFromSharedSurface(IDirect3DDevice9 *pDev, IFRSharedSurfaceHandle hNvIFRSharedSurface, IDirect3DSurface9 * pSurface);

#endif // defined(_D3D9_H_) && defined(__cplusplus)

#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_IFR_CreateCrossProcessSharedSurface
//! \fn NvAPI_D3D9_IFR_CreateCrossProcessSharedSurface(__in IDirect3DDevice9 * pDev,
//!                                                    __inout NVIFR_CROSSPROC_SHAREDSURFACE_CREATE_PARAMS * pParams)
//!
//! \since Release: 340
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDev      The device that creates/owns the shared surface
//! \param [inout]   pParams   Shared surface creation parameters 
//!
//! \retval      NVAPI_OK                       Call succeeded
//! \retval      NVAPI_INVALID_ARGUMENT         One or more arguments are invalid
//! \retval      NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found
//! \retval      NVAPI_NOT_SUPPORTED            Mosaic is not supported with GPUs on this system.
//! \retval      NVAPI_ERROR                    An unidentified error occurred
//! \retval      NVAPI_INVALID_POINTER          A NULL pointer was passed
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
typedef struct _NVIFR_CROSSPROC_SHAREDSURFACE_CREATE_PARAMS_V1
{
    NvU32 version;                                                           //!< [in]  Struct version. Set to NVIFR_CROSSPROC_SHAREDSURFACE_CREATE_PARAMS_VER.
    NvU32 width;                                                             //!< [in]  Width of shared surface
    NvU32 height;                                                            //!< [in]  Height of shared surface
    NvU32 pitch;                                                             //!< [out] Pitch of allocated shared surface
    NvU32 linearSize;                                                        //!< [out] Size of allocation in bytes
    NvU32 driverAllocationSize;                                              //!< [out] Size of driver data structure
    NvU64 framebufOffset;                                                    //!< [out] Frame Buffer offset of shared surface allocation
    NvU64 masterMemAllocPtr;                                                 //!< [out] Allocation info
    NvU32 pageSize;                                                          //!< [out] pageSize of shared surface allocation
} NVIFR_CROSSPROC_SHAREDSURFACE_CREATE_PARAMS_V1;

typedef NVIFR_CROSSPROC_SHAREDSURFACE_CREATE_PARAMS_V1 NVIFR_CROSSPROC_SHAREDSURFACE_CREATE_PARAMS;
#define NVIFR_CROSSPROC_SHAREDSURFACE_CREATE_PARAMS_VER1  MAKE_NVAPI_VERSION(NVIFR_CROSSPROC_SHAREDSURFACE_CREATE_PARAMS_V1,1)
#define NVIFR_CROSSPROC_SHAREDSURFACE_CREATE_PARAMS_VER NVIFR_CROSSPROC_SHAREDSURFACE_CREATE_PARAMS_VER1


NVAPI_INTERFACE NvAPI_D3D9_IFR_CreateCrossProcessSharedSurface(__in IDirect3DDevice9 * pDev, __inout NVIFR_CROSSPROC_SHAREDSURFACE_CREATE_PARAMS * pParams);

#endif // defined(_D3D9_H_) && defined(__cplusplus)


#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_IFR_CopyFromCrossProcessSharedSurface
//! \fn NvAPI_D3D9_IFR_CopyFromCrossProcessSharedSurface (__in IDirect3DDevice9 * pDevice, __in NVIFR_CROSSPROC_COPY_PARAMS * pParams)
//!
//! \since Release: 340
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDevice      The device that creates/owns the shared surface
//! \param [in]      pParams      Copy parameters
//!
//! \retval      NVAPI_OK                       Call succeeded
//! \retval      NVAPI_INVALID_ARGUMENT         One or more arguments are invalid
//! \retval      NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found
//! \retval      NVAPI_NOT_SUPPORTED            Mosaic is not supported with GPUs on this system.
//! \retval      NVAPI_ERROR                    An unidentified error occurred
//! \retval      NVAPI_INVALID_POINTER          A NULL pointer was passed
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////

typedef struct _NVIFR_CROSSPROC_COPY_PARAMS
{
    NvU32 version;                                                           //!< [in] Struct version. Set to NVIFR_CROSSPROC_COPY_PARAMS_VER.
    NvU32 width;                                                             //!< [in] Width of shared surface
    NvU32 height;                                                            //!< [in] Height of shared surface
    NvU32 pitch;                                                             //!< [in] Pitch of shraed surface
    NvU64 sharedAlloc;                                                        //!< [in] Shared memory allocation
    NvU64 surface;                                                            //!< [in] directx9 surface
} NVIFR_CROSSPROC_COPY_PARAMS_V1;
typedef NVIFR_CROSSPROC_COPY_PARAMS_V1 NVIFR_CROSSPROC_COPY_PARAMS;
#define NVIFR_CROSSPROC_COPY_PARAMS_VER1  MAKE_NVAPI_VERSION(NVIFR_CROSSPROC_COPY_PARAMS_V1,1)
#define NVIFR_CROSSPROC_COPY_PARAMS_VER NVIFR_CROSSPROC_COPY_PARAMS_VER1

NVAPI_INTERFACE NvAPI_D3D9_IFR_CopyFromCrossProcessSharedSurface(__in IDirect3DDevice9 * pDevice, __in NVIFR_CROSSPROC_COPY_PARAMS * pParams);

#endif // defined(_D3D9_H_) && defined(__cplusplus)


#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_IFR_ConnectToCrossProcessSharedSurface
//! \fn NvAPI_D3D9_IFR_ConnectToCrossProcessSharedSurface(__in IDirect3DDevice9 * pDevice,
//!                                                       __inout NVIFR_CONNECT_TO_CROSSPROC_SHAREDSURFACE_PARAMS * pParams)
//!
//! \since Release: 340
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDevice      The device that creates/owns the shared surface
//! \param [inout]   pParams      Shared surface client connection parameters
//!
//! \retval      NVAPI_OK                       Call succeeded
//! \retval      NVAPI_INVALID_ARGUMENT         One or more arguments are invalid
//! \retval      NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found
//! \retval      NVAPI_NOT_SUPPORTED            Mosaic is not supported with GPUs on this system.
//! \retval      NVAPI_ERROR                    An unidentified error occurred
//! \retval      NVAPI_INVALID_POINTER          A NULL pointer was passed
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////

typedef struct _NVIFR_CONNECT_TO_CROSSPROC_SHAREDSURFACE_PARAMS_V1
{
    NvU32 version;                                                           //!< [in] Struct version. Set to NVIFR_CONNECT_TO_CROSSPROC_SHAREDSURFACE_PARAMS_VER.
    NvU32 linearSize;                                                        //!< [in] Size of shared memory allocation in bytes
    NvU64 framebufOffset;                                                    //!< [in] Frame Buffer Offset of shared allocation
    NvU64 clientMasterMirrorMemAllocPtr;                                     //!< [in] Master handle for shared surface allocation
    NvU64 clientMemAllocPtr;                                                 //!< [out] Client handle for shared surface allocation
    NvU32 pageSize;                                                          //!< [in] pagesize of shared allocation
} NVIFR_CONNECT_TO_CROSSPROC_SHAREDSURFACE_PARAMS_V1;
typedef NVIFR_CONNECT_TO_CROSSPROC_SHAREDSURFACE_PARAMS_V1 NVIFR_CONNECT_TO_CROSSPROC_SHAREDSURFACE_PARAMS;
#define NVIFR_CONNECT_TO_CROSSPROC_SHAREDSURFACE_PARAMS_VER1  MAKE_NVAPI_VERSION(NVIFR_CONNECT_TO_CROSSPROC_SHAREDSURFACE_PARAMS_V1,1)
#define NVIFR_CONNECT_TO_CROSSPROC_SHAREDSURFACE_PARAMS_VER NVIFR_CONNECT_TO_CROSSPROC_SHAREDSURFACE_PARAMS_VER1

NVAPI_INTERFACE NvAPI_D3D9_IFR_ConnectToCrossProcessSharedSurface(__in IDirect3DDevice9 * pDevice, __inout NVIFR_CONNECT_TO_CROSSPROC_SHAREDSURFACE_PARAMS * pParams);

#endif // defined(_D3D9_H_) && defined(__cplusplus)


#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_IFR_CopyToCrossProcessSharedSurface
//
//!
//! \since Release: 340
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDevice      The device that creates/owns the shared surface
//! \param [in]      pParams      Shared surface copy parameters
//!
//! \retval      NVAPI_OK                       Call succeeded
//! \retval      NVAPI_INVALID_ARGUMENT         One or more arguments are invalid
//! \retval      NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found
//! \retval      NVAPI_NOT_SUPPORTED            Mosaic is not supported with GPUs on this system.
//! \retval      NVAPI_ERROR                    An unidentified error occurred
//! \retval      NVAPI_INVALID_POINTER          A NULL pointer was passed
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_D3D9_IFR_CopyToCrossProcessSharedSurface(__in IDirect3DDevice9 * pDevice, __in NVIFR_CROSSPROC_COPY_PARAMS * pParams);

#endif // defined(_D3D9_H_) && defined(__cplusplus)



#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_IFR_DisconnectCrossProcessSharedSurface

//!
//! \since Release: 340
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDevice      The device that creates/owns the shared surface
//! \param [in]      pSharedAlloc Shared surface allocation handle
//!
//! \retval      NVAPI_OK                       Call succeeded
//! \retval      NVAPI_INVALID_ARGUMENT         One or more arguments are invalid
//! \retval      NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found
//! \retval      NVAPI_NOT_SUPPORTED            Mosaic is not supported with GPUs on this system.
//! \retval      NVAPI_ERROR                    An unidentified error occurred
//! \retval      NVAPI_INVALID_POINTER          A NULL pointer was passed
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_D3D9_IFR_DisconnectCrossProcessSharedSurface(__in IDirect3DDevice9 * pDevice, __in void * pSharedAlloc);

#endif // defined(_D3D9_H_) && defined(__cplusplus)


#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_IFR_DestroyCrossProcessSharedSurface
//
//!
//! \since Release: 340
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDevice      The device that creates/owns the shared surface
//! \param [in]      pSharedAlloc Shared surface allocation handle
//!
//! \retval      NVAPI_OK                       Call succeeded
//! \retval      NVAPI_INVALID_ARGUMENT         One or more arguments are invalid
//! \retval      NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA GPU driving a display was found
//! \retval      NVAPI_NOT_SUPPORTED            Mosaic is not supported with GPUs on this system.
//! \retval      NVAPI_ERROR                    An unidentified error occurred
//! \retval      NVAPI_INVALID_POINTER          A NULL pointer was passed
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_D3D9_IFR_DestroyCrossProcessSharedSurface(__in IDirect3DDevice9 * pDevice, __in void * pSharedAlloc);

#endif // defined(_D3D9_H_) && defined(__cplusplus)


#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_FBC_CheckSupport
//
//!
//! \since Release: 304
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDev      The device that will do the blit
//! \param [in]      pParam    The vesion check params
//!
//! \return ::NVAPI_OK 
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////

typedef struct 
{
    DWORD dwVersion;
    DWORD dwType;
    DWORD bSupported   : 1;
    DWORD bNvEncLogoNeeded : 1;
    DWORD bNonQualifiedHW : 1;
    DWORD bCustomerApp : 1;
    DWORD bReservedBits : 28;
    DWORD dwPrivateDataSize;
    void* pPrivateData;
    DWORD dwReserved[60];
    void* pReserved[31];
} NvFBCCheckSupportParams;

NVAPI_INTERFACE NvAPI_D3D9_FBC_CheckSupport(IDirect3DDevice9 *pDev, void * pParam);

#endif // defined(_D3D9_H_) && defined(__cplusplus)

#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
//! \fn NvAPI_D3D9_NVFBC_FORCE_GRAB_FULL_FRAME(__inout NVFBC_FORCE_GRAB_FULL_FRAME * pParam);
//!
//!
//! DESCRIPTION: Forces NvFBC to grab full screen surface irrespective of subrect dimensions inside Present call
//!
//! \since Release: 319
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]            version
//! \param [in]            bForceGrabFullFrame             Bool variable forces KMD to grab full screen in win7-aero off if set to 1
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!          (None)
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////

typedef struct 
{
    NvU32                   version;                             // in Struct version
    NvU64                   forceGrabFullFrame: 1;                     // in In case of NvFBC + win7 + aero off, for first screen capture whole desktop
    NvU64                   ReservedBits      : 63;                    // Reserved
    NvU64                   Reserved[5];                               // Reserved
} NVFBC_FORCE_GRAB_FULL_FRAME;

#define NVFBC_FORCE_GRAB_FULL_FRAME_VER    MAKE_NVAPI_VERSION(NVFBC_FORCE_GRAB_FULL_FRAME, 1)

NVAPI_INTERFACE NvAPI_D3D9_NVFBC_FORCE_GRAB_FULL_FRAME(__inout NVFBC_FORCE_GRAB_FULL_FRAME * pParam);

#endif // defined(_D3D9_H_) && defined(__cplusplus)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D_IFR_UpdateSessionCount
//! \fn NvAPI_D3D9_IFR_UpdateSessionCount(__inout NVIFR_CROSSPROC_SHAREDSURFACE_CREATE_PARAMS * pParams)
//!
//! \since Release: 340
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDev      The device that creates/owns the shared surface
//! \param [inout]   pParams   API parameters 
//!
//! \retval      NVAPI_OK                       Call succeeded
//! \retval      NVAPI_INVALID_ARGUMENT         One or more arguments are invalid
//! \retval      NVAPI_NO_IMPLEMENTATION        API is not implemented
//! \retval      NVAPI_ERROR                    An unidentified error occurred
//! \retval      NVAPI_INVALID_POINTER          A NULL pointer was passed
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
typedef enum
{
    DECREMENT_COUNT   = -1,
    FETCH_COUNT       = 0,
    INCREMENT_COUNT   = 1,
} NVAPI_D3D_IFR_UPDATE_SESSION_COUNT_ACTION;

typedef struct _NVAPI_D3D_IFR_UPDATE_SESSION_COUNT_PARAMS_V1
{
    NvU32 version;                                                           //!< [in] Struct version. Set to NVIFR_CROSSPROC_SHAREDSURFACE_CREATE_PARAMS_VER.
    NvU32 processID;                                                         //!< [in] Current Process ID
    NVAPI_D3D_IFR_UPDATE_SESSION_COUNT_ACTION action;                        //!< [in] API Operation
    NvU32 currentSessionCount;                                               //!< [out]  Current Active NvIFR session count
} NVAPI_D3D_IFR_UPDATE_SESSION_COUNT_PARAMS_V1;

typedef NVAPI_D3D_IFR_UPDATE_SESSION_COUNT_PARAMS_V1 NVAPI_D3D_IFR_UPDATE_SESSION_COUNT_PARAMS;
#define NVAPI_D3D_IFR_UPDATE_SESSION_COUNT_PARAMS_VER1  MAKE_NVAPI_VERSION(NVAPI_D3D_IFR_UPDATE_SESSION_COUNT_PARAMS_V1,1)
#define NVAPI_D3D_IFR_UPDATE_SESSION_COUNT_PARAMS_VER NVAPI_D3D_IFR_UPDATE_SESSION_COUNT_PARAMS_VER1

NVAPI_INTERFACE NvAPI_D3D_IFR_UpdateSessionCount(__inout NVAPI_D3D_IFR_UPDATE_SESSION_COUNT_PARAMS * pParams);

#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
//! FUNCTION NAME: NvAPI_D3D9_NVFBC_GetCaps(__in IDirect3DDevice9 *pDev, __in DWORD dwCaptype , __out unsigned int * pResult);
//!
//!
//! DESCRIPTION: Get caps from NvFBC
//!
//! \since Release: 331
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]            NVFBC_CAPS_TYPE
//! \param [out]           pResult
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!          (None)
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////


NVAPI_INTERFACE NvAPI_D3D9_NVFBC_GetCaps(IDirect3DDevice9 *pDev, __in NVFBC_CAPS_TYPE dwCaptype , __out int * pResult);

#endif // defined(_D3D9_H_) && defined(__cplusplus)

#if defined (__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) )
///////////////////////////////////////////////////////////////////////////////
//
//! FUNCTION NAME: NvAPI_D3D1X_NVIFR_GetCaps(__in IUnknown *pDev, __in NVFBC_CAPS_TYPE dwCaptype , __out unsigned int * pResult);
//!
//!
//! DESCRIPTION: Get caps from NVIFR
//!
//! \since Release: 346
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]            NVFBC_CAPS_TYPE
//! \param [out]           pResult
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!          (None)
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////


NVAPI_INTERFACE NvAPI_D3D1X_NVIFR_GetCaps(__in IUnknown *pDev, __in NVFBC_CAPS_TYPE dwCaptype , __out int * pResult);

#endif //defined(__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) )


#if defined(_D3D9_H_) && defined(__cplusplus)

typedef struct _NVFBC_MOUSE_CAPTURE_SETUP
{
	NvU32							dwVersion;				// Struct Version
    HANDLE							handle; 				// Event handle created by nvfbc, store it in KMD through escape call
	DWORD						  	vidPnSourceId;			// vidPnSource associated with nvfbc
} NVFBC_MOUSE_CAPTURE_SETUP;

///////////////////////////////////////////////////////////////////////////////
//
//!FUNCTION NAME: NvAPI_D3D9_NVFBC_MOUSE_CAPTURE_SETUP
//!
//!  DESCRIPTION: This API is called one time to pass event handle in KMD through escape call
//!
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]            pParam								contains event handle
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////

#define NVFBC_MOUSE_CAPTURE_SETUP_VER    MAKE_NVAPI_VERSION(NVFBC_MOUSE_CAPTURE_SETUP, 1)

NVAPI_INTERFACE NvAPI_D3D9_NVFBC_MOUSE_CAPTURE_SETUP(__in NVFBC_MOUSE_CAPTURE_SETUP * pParam);

#endif // defined(_D3D9_H_) && defined(__cplusplus)

#if defined(_D3D9_H_) && defined(__cplusplus)

typedef struct _NVFBC_MOUSE_CAPTURE_V1
{
    NvU32   dwVersion;           // [in] Struct version
    NvU32   bIsHwCursor;         // [out] Indicates if HW cursor is in use
    NvU32   width;               // [out] Cursor glyph width
    NvU32   height;              // [out] Cursor glyph height
    NvU32   pitch;               // [out] Cursor glyph stride
    BYTE*   pPixels;             // [inout] Cursor image
} NVFBC_MOUSE_CAPTURE_V1;
#define NVFBC_MOUSE_CAPTURE_VER_1    MAKE_NVAPI_VERSION(NVFBC_MOUSE_CAPTURE, 1)

typedef struct _NVFBC_MOUSE_CAPTURE_V2
{
    NvU32   version;             // [in] Struct version
    NvU32   isHwCursor;          // [out] Indicates if HW cursor is in use
    NvU32   width;               // [out] Cursor glyph width
    NvU32   height;              // [out] Cursor glyph height
    NvU32   pitch;               // [out] Cursor glyph stride
    NvU8*   pixels;             // [inout] Cursor image
    NvU32   hotSpotX;            // [out] Cursor hotspot x-coordinate
    NvU32   hotSpotY;            // [out] Cursor hotspot y-coordinate
    NvU32   flags;               // [out] Cursor Flags
} NVFBC_MOUSE_CAPTURE_V2;
#define NVFBC_MOUSE_CAPTURE_VER_2    MAKE_NVAPI_VERSION(NVFBC_MOUSE_CAPTURE, 2)

typedef struct _NVFBC_MOUSE_CAPTURE_V3
{
    NvU32   version;             // [in] Struct version
    NvU32   isHwCursor;          // [out] Indicates if HW cursor is in use
    NvU32   width;               // [out] Cursor glyph width
    NvU32   height;              // [out] Cursor glyph height
    NvU32   pitch;               // [out] Cursor glyph stride
    NvU8*   pixels;              // [inout] Cursor image
    NvU32   hotSpotX;            // [out] Cursor hotspot x-coordinate
    NvU32   hotSpotY;            // [out] Cursor hotspot y-coordinate
    NvU32   flags;               // [out] Cursor Flags
    NvU32   mouseCounter;        // [out] Mouse Counter
} NVFBC_MOUSE_CAPTURE_V3;
#define NVFBC_MOUSE_CAPTURE_VER_3    MAKE_NVAPI_VERSION(NVFBC_MOUSE_CAPTURE, 3)
#define NVFBC_MOUSE_CAPTURE_VER NVFBC_MOUSE_CAPTURE_VER_3
typedef NVFBC_MOUSE_CAPTURE_V3  NVFBC_MOUSE_CAPTURE;

///////////////////////////////////////////////////////////////////////////////
//
//!FUNCTION NAME: NvAPI_D3D9_NVFBC_MOUSE_CAPTURE
//!
//!  DESCRIPTION: This API is called every time shape of mouse changes
//!
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! \pDev  [in]               pDev
//! \param [inout]            pParam
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////


NVAPI_INTERFACE NvAPI_D3D9_NVFBC_MOUSE_CAPTURE(__in IDirect3DDevice9 *pDev, __inout NVFBC_MOUSE_CAPTURE * pParam);

#endif // defined(_D3D9_H_) && defined(__cplusplus)


//-----------------------------------------------------------------------------
// Direct3D9 Sharing surface API
//-----------------------------------------------------------------------------

#if defined(_D3D9_H_) && defined(__cplusplus)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_BeginShareResource
//! \fn API_D3D9_BeginShareResource(IDirect3DDevice9 *pDev,
//!                                              IDirect3DResource9 *pResource,
//!                                              UINT32 flags,
//!                                              HANDLE *pHandle)
//! \code
//!   DESCRIPTION:   Starts sharing the given resource, and increases the refcount of it.  Barring Optimus platforms, if the resource is already shared using Dx9 API via a share handle than this call will fail.
//!                  This is a backdoor to force the sharing of a resource
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! INPUT:           pDev          (IN)     The device which created the resource.
//!                  pResource     (IN)     The resource to be shared.
//!                  flags         (IN)     Flags
//!                  pHandle       (OUT)    The shared handle of the given resource 
//!                  pLocation     (OUT)    Return the location where the shared resource is allocated.
//!
//! RETURN STATUS: 
//!                  NVAPI_OK - completed request
//!                  NVAPI_INVALID_ARGUMENT - invalid argument.  The resource may already shared via Dx9 API using a share handle.
//!                  NVAPI_NO_IMPLEMENTATION
//!                  NVAPI_ERROR - generic error
//!                  NVAPI_SHARE_RESOURCE_RELOCATED - the surface is relocated away from vidmem
//! \endcode
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup dx
enum NVAPI_SHARE_RESOURCE_FLAGS
{
    NVAPI_SHARE_RESOURCE_FLAGS_NONE                = 0x0,
    NVAPI_SHARE_RESOURCE_FLAGS_DISCARD             = 0x1,   //!< Discard the current content
    NVAPI_SHARE_RESOURCE_FLAGS_FAIL_IF_RELOCATED   = 0x2,   //!< Fail if the surface is relocated away from vidmem.
    NVAPI_SHARE_RESOURCE_FLAGS_DISABLE_CPU_ACCESS  = 0x4,   //!< Disable CPU access to the resource. For Dx1x, this allows keeping the shared resources in vidmem
                                                            //!< For Dx9, this flag is used for a vertex buffer only for now.
};

//! \ingroup dx
enum NVAPI_SHARE_RESOURCE_LOCATION
{
    NVAPI_SHARE_RESOURCE_LOCATION_UNKNOWN    = 0,
    NVAPI_SHARE_RESOURCE_LOCATION_VIDMEM     = 1,
    NVAPI_SHARE_RESOURCE_LOCATION_SYSMEM     = 2
};

//! \ingroup dx                                             
NVAPI_INTERFACE NvAPI_D3D9_BeginShareResource(IDirect3DDevice9 *pDev,
                                              IDirect3DResource9 *pResource,
                                              UINT32 flags,
                                              HANDLE *pHandle);

#endif //defined(_D3D9_H_) && defined(__cplusplus)
#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_D3D9_EndShareResource
//
//! \code 
//!   DESCRIPTION:   Ends sharing the given resource.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! INPUT:           pDev          (IN)     The device which created the resource.
//!                  pResource     (IN)     The shared resource.
//!
//! RETURN STATUS: 
//!                  NVAPI_OK - completed request
//!                  NVAPI_INVALID_ARGUMENT - invalid argument
//!                  NVAPI_ERROR - generic error
//! \endcode
//! \ingroup dx
/////////////////////////////////////////////////////////////////////////////////                       
NVAPI_INTERFACE NvAPI_D3D9_EndShareResource(IDirect3DDevice9 *pDev, IDirect3DResource9 *pResource);
  
#endif // defined(_D3D9_H_) && defined(__cplusplus)


//-----------------------------------------------------------------------------
// Direct3D10 APIs
//-----------------------------------------------------------------------------

#if defined(__cplusplus) && defined(__d3d10_h__)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_AliasPrimaryAsTexture
//
//!   DESCRIPTION: This function creates a texture that is an alias of the current device's
//!                primary surface
//!
//!  \note The texture returned is created without any CPU access flags. Locking
//!        to read from the texture should be done by creating a second
//!        application. Otherwise, this texture can be used as any normal
//!        Direct3D texture (it can be blitted from, used as a texture in a
//!        pixel shader, etc.)
//!
//!        This texture is not a render target and cannot be rendered to.
//!
//!        Before this texture is used, the application must call
//!        NvAPI_D3D10_ProcessFlipChainCallbacks() to properly update any internal
//!        driver state.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 173
//!
//!   \param [in]  pDev        The device to get the primary surface from
//!   \param [in]  dwHeadIndex The index to the head to alias
//!   \param [out] ppTexture   Filled with the texture created
//!
//!   \retval      NVAPI_OK    The texture was successfully created.
//!   \retval      NVAPI_ERROR The texture could not be created.
//!
//!   \ingroup dx
/////////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_AliasPrimaryAsTexture(ID3D10Device *pDev,
                                             NvU32 headIndex,
                                             ID3D10Texture2D **ppTexture);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
//! \ingroup dx
typedef void (*NVAPI_PRIMARY_FLIP_CHAIN_CALLBACK)(NvU32);

//! \ingroup dx
//! Used by NVAPI_PRIMARY_FLIP_CHAIN_CALLBACK.
typedef struct
{
    NvU32                     version;              //!< structure version (IN)

    NVAPI_PRIMARY_FLIP_CHAIN_CALLBACK pPrimaryFlipped; //!< A callback function to be notified
                                                       //!  when the primary flip occurred.

    NVAPI_PRIMARY_FLIP_CHAIN_CALLBACK pPrimaryFlipChainModified; //!< A callback function to be notified
                                                                 //!  when the primary flip chain has
                                                                 //!  been modified, either due to a new
                                                                 //!  surface being added, an existing
                                                                 //!  surface being removed, or the resolution
                                                                 //!  being changed. In response to this
                                                                 //!  an application MUST recreate any
                                                                 //!  aliased primary surfaces with
                                                                 //!  NvAPI_D3D10_AliasPrimaryAsTexture()
                                                                 //!  as the existing texture will be invalid.

    NVAPI_PRIMARY_FLIP_CHAIN_CALLBACK pPrimaryAliasInvalid; //!< An error occured while using a texture
                                                            //!  created with NvAPI_D3D10_AliasPrimaryAsTexture().
                                                            //!  The texture needs to be re-created.

    NVAPI_PRIMARY_FLIP_CHAIN_CALLBACK pPrimaryAliasOperationDropped; //!< An operation using the primary alias
                                                                     //!  was not completed because a flip
                                                                     //!  happened while the operation
                                                                     //!  was in progress. The last operation
                                                                     //!  may have operated on an incomplete
                                                                     //!  primary, and should be retried.

    NVAPI_PRIMARY_FLIP_CHAIN_CALLBACK pCursorVisibleUpdated;  //!< A callback function to be notified
                                                              //!  when the cursor visibility has been toggled

    NVAPI_PRIMARY_FLIP_CHAIN_CALLBACK pCursorShapeUpdated; //!< A callback function to be notified
                                                           //!  when the cursor shape has been updated

} NVAPI_FLIP_CHAIN_CALLBACK_PARAMS;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_SetPrimaryFlipChainCallbacks
//
//!   DESCRIPTION: Defines callback functions to receive notification about
//!                certain events relating to the primary flip chain.
//!
//!   \note The events will only be registered at this time. To receive the events
//!         an application must call NvAPI_D3D10_ProcessFlipChainCallbacks().
//!
//!         An application may change it's callback functions at any time, and may
//!         unregister from any function by passing NULL in as a function pointer.
//! 
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 173
//!
//!   \param [in]  pDev             The device to receive events on
//!   \param [in]  pCallbackParams  A structure containing function
//!                                 pointers that will receive the events.
//!                                 A pointer may be set to NULL if
//!                                 an application does not wish to receive
//!                                 the notification.
//!
//!  \return NVAPI_OK if the events were registered successfully
//!
//!  \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_SetPrimaryFlipChainCallbacks(ID3D10Device *pDev,
                                             const NVAPI_FLIP_CHAIN_CALLBACK_PARAMS* pCallbackParams);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_ProcessCallbacks
//
//!   DESCRIPTION: This function processes pending events. 
//!
//! \note All callback functions are passed the head index for the event.
//!
//!       This will call the registered callbacks for any events pending. With
//!       the exeception of the primary flipped callback, an application cannot
//!       "miss" an event if the event were to be notified while the
//!       application was not calling ProcessCallbacks. The application
//!       will receive this event the first time it calls ProcessCallbacks
//!       after the event happened.
//!
//!       The flipped event is an exception to this rule. This callback will
//!       only be fired for flips that occur after the application calls
//!       ProcessCallbacks.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 173
//!
//!   \param [in]  pDev            The device to process events on
//!   \param [in]  dwMilliseconds  The number of milliseconds to sleep while
//!                                waiting for events before returning. This
//!                                can be zero to only process any outstanding
//!                                events, or INFINITE if the application
//!                                wishes to wait forever.
//!
//!   \return  NVAPI_OK if events were properly processed
//!
//!   \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_ProcessCallbacks(ID3D10Device *pDev,
                                             NvU32 dwMilliseconds);


 
#endif //defined(__cplusplus) && defined(__d3d10_h__)



#if defined(__cplusplus) && defined(__d3d10_h__)
//! \ingroup dx
//! Used in 
typedef enum
{
    NV_HW_CURSOR_COLOR_FORMAT_MONOCHROME     = 0,
    NV_HW_CURSOR_COLOR_FORMAT_COLOR          = 1,
    NV_HW_CURSOR_COLOR_FORMAT_MASKED_COLOR   = 2
} NV_HW_CURSOR_COLOR_FORMAT_FLAGS;

//! \ingroup dx
//! Used in NvAPI_D3D10_GetRenderedCursorAsBitmap().
typedef struct _NVAPI_RENDERED_CURSOR_BITMAP_DATA
{
    NvU32 version;     //!< (in) version info
    NvU32 headIndex;   //!< (in) head index to get cursor on
    NvU32 bufferSize;  //!< (in) size of raw bitmap data buffer
    PBITMAP pBitmap;   //!< (in/out) bitmap data for rendered cursor
    NvU32 xHot;        //!< (out) x value for Hotspot
    NvU32 yHot;        //!< (out) y value for Hotspot
    NV_HW_CURSOR_COLOR_FORMAT_FLAGS formatFlag; //!, (out) cursor color format
    NvU32 bVisible;    //!< (out) cursor visibility (0 = not visible, 1 = visible)
} NVAPI_RENDERED_CURSOR_BITMAP_DATA;


//! \ingroup dx
//! Macro for constructing theversion field of _NVAPI_RENDERED_CURSOR_BITMAP_DATA
#define NVAPI_RENDERED_CURSOR_BITMAP_DATA_VER  MAKE_NVAPI_VERSION(NVAPI_RENDERED_CURSOR_BITMAP_DATA,1)


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_GetRenderedCursorAsBitmap
//
//!   DESCRIPTION:  This function provides a bitmap of the hardware cursor and the visible
//!                 state of the cursor at the time the bitmap is captured.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 173
//!
//!   \param [in]     pDev                       The device from which to get the rendered cursor
//!   \param [in,out] pRenderedCursorBitmapData  Structure for input/output with fields as follows:
//!                                              - headIndex:  [input] The display head from which to get the cursor  
//!                                              - bufferSize: [input] The size of the buffer for storing raw bitmap data
//!                                              - pBitmap:    [output] Bitmap data for the rendered cursor.  
//!                                                                     Note that this result data is undefined in the
//!                                                                     case where NVAPI_OK is not the return status
//!                                              - xHot: [output] Location of the X hot spot in the bitmap
//!                                              - yHot: [output] Location of the Y hot spot in the bitmap
//!                                              - formatFlag: [output] Cursor format (monochrome, color, or masked color)
//!                                                                     For monochrome or masked color formats, the corresponding bitmap
//!                                                                     format is ROP1R5G5B5.  For color format, the bitmap format is A8R8G8B8.   //!   
//!                                              - pVisible: [output]  Boolean:  zero=not visible, one=visible
//!
//!   \return NVAPI_OK if the cursor bitmap is successfully returned
//!
//!  \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_GetRenderedCursorAsBitmap(ID3D10Device *pDev,
                                                      NVAPI_RENDERED_CURSOR_BITMAP_DATA *pRenderedCursorBitmapData);

#endif //defined(__cplusplus) && defined(__d3d10_h__)




#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_BeginShareResource
//
//!   DESCRIPTION:  This API recreates the resource as a shared resource.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]   pResource   The resource to recreate as shared
//! \param [out]  pHandle     The shared resource handle
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!                 If there are return error codes with specific meaning for this API, they are listed below.
//!                 (None)
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_BeginShareResource(ID3D10Resource *pResource,
                                               HANDLE         *pHandle);


#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_BeginShareResourceEx
//
//!   DESCRIPTION:  This API is similar to NvAPI_D3D10_BeginShareResource(), except it takes an additional flag parameter.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]  pResource   The resource to recreate as shared
//! \param [in]  flags       Should be one of NVAPI_SHARE_RESOURCE_FLAGS
//! \param [out] pHandle     The shared resource handle
//!
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. 
//!                 If there are return error codes with specific meaning for this API, they are listed below.
//!                 (None)
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_BeginShareResourceEx(ID3D10Resource *pResource,
                                                 UINT32          flags,
                                                 HANDLE         *pHandle);



#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_EndShareResource
//
//!   DESCRIPTION:  This API restores the original resource.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in] pResource    The resource that was shared using NvAPI_D3D10_BeginShareResource
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!                 If there are return error codes with specific meaning for this API, they are listed below.
//!                 (None)
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_EndShareResource(ID3D10Resource *pResource);



#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_SetDepthBoundsTest
//
//!   DESCRIPTION: This function enables/disables the depth bounds test.
//!
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]  pDev         The device to set the depth bounds test
//!   \param [in]  bEnable      Enable(non-zero)/disable(zero) the depth bounds test
//!   \param [in]  fMinDepth    The minimum depth for the depth bounds test
//!   \param [in]  fMaxDepth    The maximum depth for the depth bounds test \n
//!                             The valid values for fMinDepth and fMaxDepth
//!                             are such that 0 <= fMinDepth <= fMaxDepth <= 1
//!
//!   \return NVAPI_OK if the depth bounds test was correctly enabled or disabled 
//!
//!   \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_SetDepthBoundsTest(ID3D10Device *pDev,
                                               NvU32 bEnable,
                                               float fMinDepth,
                                               float fMaxDepth);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_GetResourceHandle
//
//!   DESCRIPTION: This function retrieves a driver handle to a DirectX 10 resource.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//!  \param [in]   pDev         The device on which the resource was created.
//!  \param [in]   pResource    The resource for which we want to retrieve a
//!                             driver handle.
//!  \param [out]  phObject     Pointer to an NvAPI handle to be populated
//!                             on success
//!
//!  \return NVAPI_OK if and only if phObject was populated with a valid
//!            driver handle
//!  \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_GetResourceHandle(ID3D10Device *pDev,
                                              ID3D10Resource* pResource,
                                              NVDX_ObjectHandle* phObject);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_GetVertexShaderHandle
//! \code
//!   DESCRIPTION:  Note: call NvAPI_D3D10_RegisterDevice once before using with this function!!!
//!                This function returns a shader's handle as used inside of the UMD
//!
//!         INPUT:  pD3D10VertexShader  The runtime shader handle
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!        OUTPUT:  phShader     The UMD's shader handle
//!
//! RETURN STATUS: NVAPI_OK if pD3D10VertexShader is valid and the OUT pointers are non-null
//! \endcode
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_GetVertexShaderHandle(ID3D10Device *pDev,
                                                  ID3D10VertexShader *pD3D10VertexShader,
                                                  NVDX_ObjectHandle* phShader);
#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_GetGeometryShaderHandle
//! \code
//!                 This function returns a shader's handle as used inside of the UMD
//!
//!         INPUT:  pD3D10GeometryShader  The runtime shader handle
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!        OUTPUT:  phShader     The UMD's shader handle
//!
//! RETURN STATUS: NVAPI_OK if pD3D10GeometryShader is valid and the OUT pointers are non-null
//! \endcode
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_GetGeometryShaderHandle(ID3D10Device *pDev,
                                                    ID3D10GeometryShader *pD3D10GeometryShader,
                                                    NVDX_ObjectHandle* phShader);
#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_GetPixelShaderHandle
//! \code
//!                 This function returns a shader's handle as used inside of the UMD
//!
//!        INPUT:  pD3D10PixelShader  The runtime pixel shader handle
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!        OUTPUT:  phShader     The UMD's shader handle
//!
//! RETURN STATUS: NVAPI_OK if pD3D10PixelShader is valid and the OUT pointers are non-null
//! \endcode
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_GetPixelShaderHandle(ID3D10Device *pDev,
                                                 ID3D10PixelShader *pD3D10PixelShader,
                                                 NVDX_ObjectHandle* phShader);
#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_GetShaderUCodeAllocationInfo
//! \code
//!                 This function returns a shader's address in video memory, and
//!                 its memory allocation handle.
//!
//!         INPUT:  pDev         The device on which the resource was created
//!                 hShader      Handle to the internal shader data struction of the UMD
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!        OUTPUT:  phAllocation   The shader's allocation handle
//!                 pBlockOffset   The shader's offset into its allocation
//!                 pProgramOffset The offset to shader's debug instance (w.r.t. pBlockOffset)
//!                 pLength        The shader block's length.
//!
//! RETURN STATUS: NVAPI_OK if the OUT pointers are non-null, and there exists
//!                at least (index+1) shaders of the given type in memory.
//! \endcode
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_GetShaderUCodeAllocationInfo(ID3D10Device *pDev,
                                                         NVDX_ObjectHandle hShader,
                                                         NvU32* phAllocation,
                                                         NvU32* pBlockOffset,
                                                         NvU32* pProgramOffset,
                                                         NvU32* pLength);
#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_GetShaderLocalMemoryAllocationInfo
//
//!   This function returns the device's local memory allocation info.
//!   It does not take a shader handle because the local memory allocation
//!   is made per device and not per-shader.
//!
//!   \warning Note, this info represents the current state of the UMD and
//!   does not necessarily reflect the values used by the GPU. Enable warp
//!   semaphore reports (see NvAPI_D3D10_EnableWarpSemaphoreReports) if you
//!   need current data. 
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!    \param [in]   pDev                  The device on which the resource was created
//!    \param [out]  phAllocation          The D3DKMT local memory allocation handle
//!    \param [out]  pBlockOffset          The offset into the local memory allocation
//!    \param [out]  pLength               The length of the allocation
//!    \param [out]  pMaxWarpsPerSm;       Deprecated, returns zero
//!    \param [out]  pLmemBytesPerThread   Deprecated, returns zero
//!
//!    \return   NVAPI_OK if the OUT pointers are non-null.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_GetShaderLocalMemoryAllocationInfo(__in ID3D10Device *pDev,
                                                               __out NvU32* phAllocation,
                                                               __out NvU32* pBlockOffset,
                                                               __out NvU32* pLength,
                                                               __out NvU32* pMaxWarpsPerSm,
                                                               __out NvU32* pLmemBytesPerThread);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_GetResourceAllocationInfoSize
//
//!   This function should be called before GetResourceAllocationInfo, to get the size of pResourceAttributes.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]   pDev    The device on which the resource was created
//!   \param [out]  pSize   The size of the memory needed for pResourceAttributes in NvAPI_D3D10_GetResourceAllocationInfo.
//!
//!   \return   NVAPI_OK if pDev is valid and pSize not NULL.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_GetResourceAllocationInfoSize(__in ID3D10Device *pDev,
                                                          __out NvU32 *pSize);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)

//! \ingroup nsightapi
//! Prototype structure version, check common/inc/ShaderDebuggerStruct.h for versions
//! currently supported by the driver!
typedef struct _sdResourceAttributes
{
    NvU32 structVersion;
} sdResourceAttributes;

//! \ingroup nsightapi
#define SD_RESOURCE_ATTRIBUTES_STRUCT_VERSION_V0 MAKE_NVAPI_VERSION(sdResourceAttributes, 0)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_GetResourceAllocationInfo
//
//!   This function returns the allocation info of a resource.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]   pDev                  The device on which the resource was created
//!   \param [in]   hResource             Handle to the internal resource data struction of the UMD
//!   \param [out]  phAllocation          The D3DKMT local memory allocation handle
//!   \param [out]  pBlockOffset          The offset into the local memory allocation
//!   \param [out]  pLength               The length of the allocation
//!   \param [out]  pResourceAttributes   The attributes of the resource- driver private.  Should be allocated by the caller using
//!                                       information from NvAPI_D3D10_GetResourceAllocationInfoSize.
//!                                       for the structure declaration.
//!
//!   \return   NVAPI_OK if the inputs are valid and the out pointers are non-null.
//!
//! \endcode
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_GetResourceAllocationInfo(__in ID3D10Device *pDev,
                                                      __in NVDX_ObjectHandle hResource,
                                                      __out NvU32* phAllocation,
                                                      __out NvU32* pBlockOffset,
                                                      __out NvU32* pLength,
                                                      __inout sdResourceAttributes* pResourceAttributes);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_GetResourceAllocationInfo2
//
//!   This function returns the allocation info of a resource.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]      pDev                  The device on which the resource was created
//!   \param [in]      hResource             Handle to the internal resource data struction of the UMD
//!   \param [out]     phAllocation          The D3DKMT local memory allocation handle
//!   \param [out]     pBlockOffset          The 64-bit offset into the local memory allocation
//!   \param [out]     pLength               The 64-bit length of the allocation
//!   \param [in,out]  pResourceAttributes   The attributes of the resource- driver private.  Should be allocated by the caller using
//!                                          information from NvAPI_D3D10_GetResourceAllocationInfoSize.
//!
//! \return  NVAPI_OK if the OUT pointers are non-null.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_GetResourceAllocationInfo2(__in ID3D10Device *pDev,
                                                       __in NVDX_ObjectHandle hResource,
                                                       __out NvU32* phAllocation,
                                                       __out NvU64* pBlockOffset,
                                                       __out NvU64* pLength,
                                                       __inout sdResourceAttributes* pResourceAttributes);

#endif //defined(__cplusplus) && defined(__d3d10_h__)



#if defined(__cplusplus) && defined(__d3d10_h__)

//! Prototype structure version, check common/inc/ShaderDebuggerStruct.h for versions
//! currently supported by the driver!
//! \ingroup nsightapi
typedef struct _sdBuildDebugShaderInstanceParamsIn
{
    NvU32 structVersion;
} sdBuildDebugShaderInstanceParamsIn;

//! \ingroup nsightapi
#define SD_BUILD_DEBUG_SHADER_INSTANCE_PARAMS_IN_VERSION_V0 MAKE_NVAPI_VERSION(sdBuildDebugShaderInstanceParamsIn, 0)

//! Prototype structure version, check common/inc/ShaderDebuggerStruct.h for versions
//! currently supported by the driver!
//! \ingroup nsightapi
typedef struct _sdBuildDebugShaderInstanceParamsOut
{
    NvU32 structVersion;
} sdBuildDebugShaderInstanceParamsOut;

//! \ingroup nsightapi
#define SD_BUILD_DEBUG_SHADER_INSTANCE_PARAMS_OUT_VERSION_V0 MAKE_NVAPI_VERSION(sdBuildDebugShaderInstanceParamsOut, 0)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_BuildDebugShaderInstance2
//
//!   This function creates and builds a debug instance of a shader.
//!   If the shader already has a debug instance then it returns
//!   immediately with the instructions unless the rebuild param is true.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]      pDev         The device to which the shader belongs to.
//!   \param [in]      pParamsIn    Pointer to extendable input structure.
//!   \param [in,out]  pParamsOut   Pointer to extendable output structure.
//!
//!   \return NVAPI_OK if pDev is valid and pParamsIn and pParamsOut are non-null
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_BuildDebugShaderInstance2(__in ID3D10Device *pDev,
                                                      __in sdBuildDebugShaderInstanceParamsIn  *pParamsIn,
                                                      __inout sdBuildDebugShaderInstanceParamsOut *pParamsOut);

#endif //defined(__cplusplus) && defined(__d3d10_h__)



#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D1x_NsightEnableDebugMode
//
//!   Notify the D3D driver to use debug shader instances instead of
//!   release/optimized shaders from now until it gets this call with
//!   enable flag set to false. 
//!   EnableFlag is true, when a user sets his first BreakPoint
//!   EnableFlag is false, when the user removes his last BreakPoint
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]   pDev      The device pointer on which we want to set the flag. 
//!                           pDev can be either ID3D10Device or ID3D10Device1 or ID3D11Device ptr.
//!   \param [in]   bEnable   Boolean flag to denote either to enable/disable.
//!
//!   \return NVAPI_OK if the device was valid and we successfully completed the operation.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D1x_NsightEnableDebugMode(__in IUnknown *pDev,
                                                  __in bool bEnable);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D1x_NsightCommunication
//
//!   Uber call that handles all Nsight instrumentation in the DX driver
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!   \note <b> When pInternalDev is valid, pDev (device pointer) is just a mule device to carry our instructions.
//!              All the changes are really done on the pInternalDev (driver internal device pointer). </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]      pDev          The device pointer on which we want to instrument. 
//!                                  pDev can be either ID3D10Device or ID3D10Device1 or ID3D11Device ptr.
//!   \param [in]      pInternalDev  Driver internal device pointer on which we want to make changes. 
//!   \param [in, out] pPayload      All the data needed by the instrumentation.
//!                                  check common/inc/ShaderDebuggerStruct.h for PayLoad defines.
//!   \return NVAPI_OK if the device was valid and we successfully completed the operation.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D1x_NsightCommunication(__in IUnknown *pDev,
                                                __in void     *pInternalDev,
                                                __inout void  *pPayload);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)

//! Prototype structure version, check common/inc/ShaderDebuggerStruct.h for versions
//! currently supported by the driver!
//! \ingroup nsightapi
typedef struct _sdPushMethodIntoPushBufferArguments
{
    NvU32 structVersion;
} sdPushMethodIntoPushBufferArguments;

//! \ingroup nsightapi
#define SD_PUSH_METHOD_INTO_PUSH_BUFFER_ARGUMENTS_VERSION_V0 MAKE_NVAPI_VERSION(sdPushMethodIntoPushBufferArguments, 0)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D1x_NsightPushMethodIntoPushBuffer
//
//!   Allows the tools to add a method into the PB.
//!   We will not allow any arbitrary PB methods to be inserted into the PB stream.
//!   The legal ones are defined in sdPushBufferMethod (see wgf2um\inc\ShaderDebuggerStruct.h).
//!   Right now we only have support for this in Kepler because the only supported PB method
//!   (SD_PUSHBUFFERMETHOD_TRAPHANDLERADDRESS) is a Kepler-only method.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]   pDev   The device pointer into which we want to push the PB method. 
//!                         pDev can be either ID3D10Device or ID3D10Device1 or ID3D11Device ptr
//!   \param [in]  pArgs   Identifies the method to push and its parameters.
//!
//!   \return NVAPI_OK if the device is valid and the operation completed successfully.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D1x_NsightPushMethodIntoPushBuffer(__in IUnknown *pDev,
                                                           __in sdPushMethodIntoPushBufferArguments* pArgs);
#endif //defined(__cplusplus) && defined(__d3d10_h__)



#if defined(__cplusplus) && defined(__d3d10_h__)

//! Prototype for callback functions used by the Nsight debugger
//! \ingroup nsightapi
typedef HRESULT (__cdecl *SHADERDEBUGGER_CALLBACK) (__in void* pCallbackData, __in_opt void* pParam);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_SetShaderDebuggerCallback
//
//!   This function is used to register callbacks for various debug events.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]  pDev               The device on which the callback is valid.
//!   \param [in]  cbType             The type of the callback to be set, see common/inc/ShaderDebuggerCallbacks.h
//!   \param [in]  pCallbackFunction  Pointer to the callback function. Pass NULL to disable the callback.
//!   \param [in]  pParam             Application data that will be passed back to this callback.
//!
//!   \return  NVAPI_OK if the callback was successfully set.
//!
//!   \note  An application may change its callback functions at any time, and may
//!          unregister from any function by passing NULL in as a function pointer.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_SetShaderDebuggerCallback(__in ID3D10Device *pDev,
                                                      __in NvU32 cbType,
                                                      __in_opt SHADERDEBUGGER_CALLBACK pCallbackFunction,
                                                      __in_opt void* pParam);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D1x_MoveShaderCacheBetweenVidAndSys
//
//!   This function will be used mainly by ShaderDebugger and will move shader cache and shader lmem
//!   from Video memory to System memory or the other way round. When the app starts up,
//!   we usually store shader cache and lmem in Video memory. To facilitate shader debugging (to
//!   set breakpoints, replace shaders at a breakpoint, and read/write lmem), we need these in system memory.
//!   Usual way of running things: When the user sets his first breakpoint in the shader, we
//!   get this call to move shader cache and lmem from VID to SYS. From then on, the driver maintains
//!   the cache and lmem in SYS memory. Once the user removes his last breakpoint, we will get this call
//!   to move cache and lmem from SYS to VID memory & continue normal operations after that.
//!   The shaderTypeFlags parameter allows us to move a single shaderType cache or multiple caches, as well as the 
//!   lmem at the same time.
//!
//!   \note Only moves the lmem to sys on Fermi architectures, Tesla lmem remains in vid.  Needs to be updated for Kepler.
//! 
//!   \note Compute Shader Manager is created, only when we have a compute channel. Hence this call would
//!         return NVAPI_INVALID_ARGUMENT, If you use this call to move compute shader cache, without
//!         a compute channel.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]  pDev            The device for which we need to move shader cache and lmem. pDev can be either
//!                                ID3D10Device or ID3D10Device1 or ID3D11Device ptr
//!   \param [in]  cacheLocation   Specifies location to move the shadercache and lmem (SD_STORAGE_VID/SD_STORAGE_SYS).
//!                                Check the sdShaderHeapStorage enums in common/inc/ShaderDebuggerStruct.h for valid
//!                                values. Don't use SD_STORAGE_COUNT.
//!   \param [out] shaderTypeFlags Specifies what all shader caches need to be moved.
//!                                Check the sdShaderType enums in common/inc/ShaderDebuggerStruct.h for valid values.
//!                                You can use multiple of these, depending on the types of ShaderCaches you want to move.
//!                                NOTE: Trying to use SD_SHADER_TYPE_HULL & SD_SHADER_TYPE_DOMAIN flags on D3D10 devices
//!                                will return an NVAPI_INVALID_ARGUMENT error.
//!
//!
//!   \return  This will be a synchronous call i.e. would be executed immediately. Hence will return NVAPI_OK if the call was successfull.
//!            This call will return NVAPI_OK, without doing anything, if shaderCache already exists in the requested location
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D1x_MoveShaderCacheBetweenVidAndSys(__in IUnknown *pDev,
                                                            __in NvU32 cacheLocation,
                                                            __in NvU32 shaderTypeFlags);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)

//! \ingroup nsightapi
typedef enum
{
    D3D_SHADER_TYPE_VERTEX   = 0,
    D3D_SHADER_TYPE_GEOMETRY = 1,
    D3D_SHADER_TYPE_PIXEL    = 2,
    D3D_SHADER_TYPE_COMPUTE  = 3,
    D3D_SHADER_TYPE_HULL     = 4,
    D3D_SHADER_TYPE_DOMAIN   = 5,
} D3D_SHADER_TYPE;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_SetShaderDebuggerHeapSize
//
//!   Sets the private heap available for use by the shader debugger.
//!   By default this heap has a size of zero.  The debugger should
//!   set this to zero if it wants to the destroy an existing heap.
//!   After the heap is resized, any previous contents of the heap
//!   are invalid and should be reinitialized by the debugger.
//!   However, the contents of this heap will be preserved between
//!   migrations between sysmem and vidmem for the applicable shader
//!   cache (see NvAPI_D3D1x_MoveShaderCacheBetweenVidAndSys)
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]  pDev         The device on which the callback is valid.
//!   \param [in]  newSize      The new requested size for the heap, in bytes
//!   \param [in]  shaderType   The shader type (using enum)
//!   \param [out] pNewOffset   The offset in bytes from the start of the shader heap. Can be NULL if newSize == 0.
//!
//!   \return NVAPI_OK if the heap was successfully resized.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_SetShaderDebuggerHeapSize(__in ID3D10Device *pDev,
                                                      __in NvU32 newSize,
                                                      __in D3D_SHADER_TYPE shaderType,
                                                      __out_opt NvU32 *pNewOffset);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_SetDeviceStateSaveBuffer
//
//!   Creates a region in Vidmem where the trap handler will dump
//!   the SM states. This will be used in Fermi and Kepler by the debugger.
//!   Set the size to zero to destroy the existing allocation.
//!   Resize operation is not supported -- destroy the allocation and recreate
//!   a new one.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]   pDev         The device on which the callback is valid.
//!   \param [in]   newSize      The new requested size for the heap, in bytes
//!   \param [in]   shaderType   The shader type (using enum)
//!   \param [out]  pNewOffset   The offset in bytes from the start of the shader heap. Can be NULL if newSize == 0.
//!
//!   \return NVAPI_OK if the heap was successfully resized.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_SetDeviceStateSaveBuffer(__in ID3D10Device *pDev,
                                                     __in NvU32 newSize,
                                                     __in D3D_SHADER_TYPE shaderType,
                                                     __out_opt NvU64 *phAllocation);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_LockCb
//! \code
//!   DESCRIPTION: This function is an accessor for the UMD's surface locking function.
//!
//!         INPUT:  pDev         The device on which the resource was created
//!                 hMemory      The memory handle to use.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!        OUTPUT:  ppBuffer     The mapped buffer.
//!
//! RETURN STATUS: NVAPI_OK if the buffer is non_null, and the lock succeeds.
//! \endcode
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_LockCb(ID3D10Device *pDev,
                                   NvU32 hMemory,
                                   NvU32** ppBuffer);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_UnlockCb
//! \code
//!   DESCRIPTION: This function is an accessor for the UMD's surface unlocking function.
//!
//!         INPUT:  pDev         The device on which the resource was created
//!                 hMemory      The memory handle to use.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! RETURN STATUS: NVAPI_OK if the buffer is non_null, and the lock succeeds.
//! \endcode
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_UnlockCb(ID3D10Device *pDev,
                                     NvU32 hMemory);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_GetAllContextRmHandles
//
//!   This function retrieves the RM handles for the device
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]      pDev                  The device whose handle we want
//!   \param [in,out]  pRmHandlesCollection  The device's RM handles of every channel/GPU combination that is active.
//!
//!   \return NVAPI_OK if and only if pDev was populated with valid RM handles
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_GetAllContextRmHandles(__in ID3D10Device *pDev,
                                                   __inout sdRmHandlesCollection* pRmHandlesCollection);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_GetAllocDebugInfo
//
//!   Internal function used by shader debugger, used for getting
//!   addressing info about resident shaders
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]   pDev                    D3D handle of client
//!   \param [in]   hKmtAlloc               KMT allocation object handle
//!   \param [in]   hAllocType              1 for resource, 2 for primary surface
//!   \param [in]   hAllocIsDeviceSpecific  Flag for allocation
//!   \param [out]  phClient                Matching RM client
//!   \param [out]  phDevice                Matching RM device
//!   \param [out]  pAllocPAddr             Allocation offset from FB
//!   \param [out]  pAllocSize              Size of allocation
//!
//!   \return NVAPI_OK if and only if the hKmtAlloc was known by the KMD
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_GetAllocDebugInfo(__in ID3D10Device *pDev,
                                              __in NvU32 hKmtAlloc,
                                              __in NvU32 hAllocType,
                                              __in NvU32 hAllocIsDeviceSpecific,
                                              __out NvU32* phClient,
                                              __out NvU32* phDevice,
                                              __out NvU64* pAllocPAddr,
                                              __out NvU32* pAllocSize);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_GetPixelShaderInstructions
//
//!   This function retrieves the SASS instructions of a DX10 pixel shader
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]   pDev           The device on which the resource was created.
//!   \param [in]   pShader        The pixel shader for which we want to retrieve the instructions.
//!   \param [out]  ppInstructions  Pointer to the SASS instructions of the shader.
//!   \param [out]  pBufferSize     The byte size of the instruction buffer.
//!
//!   \return NVAPI_OK if and only if pInstructions was populated with a valid
//!           set of instruction
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_GetPixelShaderInstructions(__in ID3D10Device *pDev,
                                                       __in ID3D10PixelShader* pShader,
                                                       __out_bcount(*pBufferSize) NvU32** ppInstructions,
                                                       __out NvU32* pBufferSize);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_SetPixelShaderInstructions
//
//!   This function sets the SASS instructions of a DX10 pixel shader
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]  pDev           The device on which the resource was created.
//!   \param [in]  pShader        The pixel shader for which we want to set the instructions.
//!   \param [in]  pInstructions  Pointer to the SASS instructions of the shader.
//!   \param [in]  bufferSize     The byte size of the instruction buffer.
//!
//!   \return NVAPI_OK if device and shader handle are valid and the instructions could be successfully set.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_SetPixelShaderInstructions(__in ID3D10Device *pDev,
                                                       __in ID3D10PixelShader* pShader,
                                                       __in_bcount(bufferSize) NvU32* pInstructions,
                                                       __in NvU32 bufferSize);
#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_NsightEnableReporting
//
//!   Notify the D3D driver that Nsight is attaching to the process,
//!   enable reporting, register a callback with the driver. This
//!   callback function is called when a report data is available.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]  pDev                       The device pointer on which we will tag on.
//!   \param [in]  bEnable                    boolean flag to denote either to enable/disable.
//!   \param [in]  completedReportsCallback   Callback function.
//!   \param [in]  pCallbackData              Data associated with the callback function 
//!                                           that is passed back through the callback.
//!
//!   \return  NVAPI_OK if we have successfully completed the operation.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_NsightEnableReporting(__in ID3D10Device *pDev,
                                                  __in bool bEnable,
                                                  __in fdStatsReportsCompletedCallback completedReportsCallback, 
                                                  __in_opt void *pCallbackData);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_NsightFlushReporting
//
//!   Flushes reporting output for nsight.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//
//!   \param [in]  pDev    The device pointer on which we will flush on.
//!
//!   \return  NVAPI_OK if we have successfully completed the operation.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_NsightFlushReporting(__in ID3D10Device *pDev);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_NsightSetCustomReportData
//
//!   Specifies the current custom report data for Nsight reports
//!   in the driver.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]  pDev    The device pointer on which we will tag on.
//!                        customData Custom report data.
//!
//!   \return  NVAPI_OK if we have successfully completed the operation.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_NsightSetCustomReportData(__in ID3D10Device *pDev,
                                                      __in NvU32 customData);





//! \ingroup nsightapi
// Increment version when call are added
typedef enum
{
    NVAPI_D3D_DRAW     = 0,
    NVAPI_D3D_DISPATCH = 1,
    NVAPI_D3D_PRESENT  = 2,
    NVAPI_D3D_COPY     = 3,
} NVAPI_NSIGHT_D3DCALLTYPE;

#define NVAPI_NSIGHT_CALLTYPE_VERSION 1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_NsightSetCurrentContextAndD3DCallCount
//
//!   Sets context handle for the device & sets counter for the specified
//!   NsightD3DCallType. 
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]   pDev          The device pointer on which we need to set the above.
//!   \param [in]   contextHandle API handle
//!   \param [in]   d3dCallType   Type of d3d call
//!   \param [in]   count         count-value to be set for corresponding d3d call.
//!
//!   \return  NVAPI_OK if we have successfully completed the operation.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_NsightSetCurrentContextAndD3DCallCount(__in ID3D10Device *pDev, 
                                                                   __in NvU64 contextHandle, 
                                                                   __in NVAPI_NSIGHT_D3DCALLTYPE d3dCallIdType,
                                                                   __in NvU64 count);

#endif //defined(__cplusplus) && defined(__d3d10_h__)

#if defined(__d3d10_h__)

//////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D_GetIDXGIAdapter
//
//!   DESCRIPTION: This function returns the IDXGIAdapter* of the input GPU handle.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 340
//!
//!   \param [in]     hPhysicalGpu
//!   \param [out]    ppAdapter
//!
//! \return      This API can return any of the error codes enumerated in #NvAPI_Status.
//!              If there are return error codes with specific meaning for this API, they are listed below.
//!
//!   \ingroup dx
//////////////////////////////////////////////////////////////////////////

//!   \ingroup dx
NVAPI_INTERFACE NvAPI_D3D_GetIDXGIAdapter(__in NvPhysicalGpuHandle hPhysicalGpu, __out IDXGIAdapter** ppAdapter);
#endif // defined(__d3d10_h__)


#if defined(__cplusplus) && defined(__d3d10_h__)

#ifdef __d3d10_1_h__


//////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_CreateDevice
//
//!   DESCRIPTION: This function creates a d3d10 device. The function call is the 
//!                same as D3D10CreateDevice1(), but with an extra argument 
//!                (#D3D10_FEATURE_LEVEL supported by the device) that the function fills in.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//!   \param [in]     pAdapter
//!   \param [in]     DriverType
//!   \param [in]     Software
//!   \param [in]     Flags
//!   \param [in]     HardwareLevel
//!   \param [in]     SDKVersion
//!   \param [in]     ppDevice
//!   \param [in]     *pLevel  D3D10_FEATURE_LEVEL supported - see #NVAPI_DEVICE_FEATURE_LEVEL
//!
//!   \return  NVAPI_OK if the createDevice call succeeded.
//
//////////////////////////////////////////////////////////////////////////

//!   \ingroup dx
NVAPI_INTERFACE NvAPI_D3D10_CreateDevice(IDXGIAdapter* pAdapter,
                                         D3D10_DRIVER_TYPE DriverType,
                                         HMODULE Software,
                                         UINT32 Flags,
                                         D3D10_FEATURE_LEVEL1 HardwareLevel,
                                         UINT SDKVersion,
                                         ID3D10Device1** ppDevice,
                                         NVAPI_DEVICE_FEATURE_LEVEL *pLevel);
#endif //defined(__d3d10_1_h__)
#endif //defined(__cplusplus) && defined(__d3d10_h__)



#if defined(__cplusplus) && defined(__d3d10_h__)
#ifdef __d3d10_1_h__
////////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_CreateDeviceAndSwapChain
//
//!   DESCRIPTION: This function creates a d3d10 device and swap chain. The function call is the 
//!                same as D3D10CreateDeviceAndSwapChain1(), but with an extra argument 
//!                (D3D10_FEATURE_LEVEL supported by the device) that the function fills in .
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//!   \param [in]   pAdapter
//!   \param [in]   DriverType
//!   \param [in]   Software
//!   \param [in]   Flags
//!   \param [in]   HardwareLevel
//!   \param [in]   SDKVersion
//!   \param [in]   pSwapChainDesc
//!   \param [in]   ppSwapChain
//!   \param [in]   ppDevice
//!   \param [in]   pLevel       D3D10_FEATURE_LEVEL supported - see see #NVAPI_DEVICE_FEATURE_LEVEL
//!
//!   \return  NVAPI_OK if the createDevice with swap chain call succeeded.
//!
//!   \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_CreateDeviceAndSwapChain(IDXGIAdapter* pAdapter,
                                                     D3D10_DRIVER_TYPE DriverType,
                                                     HMODULE Software,
                                                     UINT32 Flags,
                                                     D3D10_FEATURE_LEVEL1 HardwareLevel,
                                                     UINT SDKVersion,
                                                     DXGI_SWAP_CHAIN_DESC* pSwapChainDesc,
                                                     IDXGISwapChain** ppSwapChain,
                                                     ID3D10Device1** ppDevice,
                                                     NVAPI_DEVICE_FEATURE_LEVEL *pLevel);


#endif //defined(__d3d10_1_h__)
#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)



//-----------------------------------------------------------------------------
// Private Direct3D10 APIs
//-----------------------------------------------------------------------------

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_GetBufferStreamOutBytesWritten
//
//!   DESCRIPTION: This API gets the number of bytes written during stream out for the
//!                specified buffer.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!  
//!  \param [in]  pDev
//!  \param [in]  Buffer
//!  \param [out] pCount
//!
//!  \return NVAPI_OK if the operation succeeded
//!
//!  \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_GetBufferStreamOutBytesWritten(ID3D10Device* pDev, ID3D10Buffer* pBuffer, NvU32* pCount);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_SetBufferStreamOutBytesWritten
//
//!   DESCRIPTION: This API sets the number of bytes written during stream out for the
//!                specified buffer.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!  
//!  \param [in]  pDev
//!  \param [in]  Buffer
//!  \param [in] pCount
//!
//!  \return NVAPI_OK if the operation succeeded
//!
//!  \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_SetBufferStreamOutBytesWritten(ID3D10Device* pDev, ID3D10Buffer* pBuffer, NvU32 Count);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_1_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_CreateDevice_McCompat
//! \code
//!   DESCRIPTION: This function creates a d3d10 device. The function call is the
//!                same as D3D10CreateDevice1, but 3 extra arguments:
//!                (D3D10_FEATURE_LEVEL supported by the device), mccompat bits to
//!                control SLI optimizations and mccompatHybrid bits to control
//!                Hybrid SLI.  The bits are the same ones exported by d3dreg.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!         INPUT:  IDXGIAdapter* pAdapter,
//!                 D3D10_DRIVER_TYPE DriverType,
//!                 HMODULE Software,
//!                 UINT32 Flags,
//!                 D3D10_FEATURE_LEVEL1 HardwareLevel,
//!                 UINT SDKVersion,
//!                 ID3D10Device1** ppDevice,
//!                 NVAPI_DEVICE_FEATURE_LEVEL *pLevel,  // D3D10_FEATURE_LEVEL supported
//!                 UINT32 mccompat,                     // SLI mccompat bits, default to 0
//!                 UINT32 mccompatHybrid,               // Hybrid SLI mccompat bits, default to 0
//!
//! RETURN STATUS: NVAPI_OK if the createDevice call succeeded.
//! \endcode
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_CreateDevice_McCompat(  IDXGIAdapter* pAdapter,
                                                    D3D10_DRIVER_TYPE DriverType,
                                                    HMODULE Software,
                                                    UINT32 Flags,
                                                    D3D10_FEATURE_LEVEL1 HardwareLevel,
                                                    UINT SDKVersion,
                                                    ID3D10Device1** ppDevice,
                                                    NVAPI_DEVICE_FEATURE_LEVEL *pLevel,
                                                    UINT32 mccompat,
                                                    UINT32 mccompatHybrid);




#endif //defined(__cplusplus) && defined(__d3d10_1_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_RegisterDevice
//
//!   DESCRIPTION: DEPRECATED- all functions should now auto-register the device. 
//!
//!                Register device with NvAPI before using it in specified funtions  This allows for
//!                more efficient high-frequency nvapi calls, as setting up the device for NvAPI use
//!                is an expensive operation.  When finished with the handle, clients should call 
//!                NvAPI_D3D10_ReleaseDeviceHandle.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in] ID3D10Device* pDev
//!
//! \return  NVAPI_OK if the call succeeded.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_RegisterDevice(ID3D10Device *pDev);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_UnregisterDevice
//
//!   DESCRIPTION: Unregister a device after NvAPI_D3D10_RegisterDevice
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in] ID3D10Device* pDev
//!
//! \return  NVAPI_OK if the call succeeded.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_UnregisterDevice(ID3D10Device* pDev);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_SetPrivateConstData
//
//!   Sets data in the private UMD constant buffer.
//!   Slots are defined by the NvAPIPrivateConstDataSlot enumeration.
//!   Consumers of this constant buffer data must take care to call
//!   NvAPI_D3D10_GetPrivateConstDataSlotAndOffset for the same instance
//!   of the shader which will consume the data.  Producers of this data
//!   should call NvAPI_D3D10_SetPrivateConstData any time before drawing.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//
//!   \param [in]  pDev       The device pointer
//!   \param [in]  dataslot   The data slot to update
//!   \param [in]  data       The data value
//!
//!   \return  NVAPI_OK if the call succeeded.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_SetPrivateConstData(__in ID3D10Device* pDev,
                                                __in NvAPIPrivateConstDataSlot dataslot,
                                                __in NvU32 data);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_GetPrivateConstDataSlotAndOffset
//
//!   This function retrieves the constant slot and offset corresponding
//!   to the private UMD constant buffer for the specified shader.  See
//!   comments for NvAPI_D3D10_SetPrivateConstData.  hShader should be
//!   acquired using one of the NvAPI_D3D10_GetXXXShaderHandle functions.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]  pDev               The device pointer
//!   \param [in]  hShader            The shader for which to query the data
//!   \param [in]  dataslot           The data slot to query
//!
//!   \param [out] pOutConstSlot      The buffer id (bank#)
//!   \param [out] pOutScalarOffset   The offset within the buffer
//!
//!   \return  NVAPI_OK if the call succeeded.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_GetPrivateConstDataSlotAndOffset(__in ID3D10Device* pDev,
                                                             __in NVDX_ObjectHandle* phShader,
                                                             __in NvAPIPrivateConstDataSlot dataslot,
                                                             __out NvU32 *pOutConstSlot,
                                                             __out NvU32 *pOutScalarOffset);

#endif //defined(__cplusplus) && defined(__d3d10_h__)



#if defined(__cplusplus) && defined(__d3d10_h__)

//! \ingroup nsightapi
typedef struct _NvAPI_D3DResourceSubresourceInfo
{
    NvU32 ArraySlice;
    NvU32 MipLevel;
    NvU32 OffsetInBytes;
} NvAPI_D3DResourceSubresourceInfo;

//! \ingroup nsightapi
#define NVAPI_GET_RESOURCE_SUBRESOURCE_INFO_VERSION 1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_GetResourceSubresourceInfo
//
//!   Returns information about the internal layout of subresources in a driver resource.
//!   To obtain the subresource count, callers should call this with ppInfoBuffer=NULL.
//!   Then, the caller should allocate an array of NvAPI_D3DResourceSubresourceInfo* and
//!   initialize each member of the array with a valid pointer.
//!   When ppInfoBuffer is non-null, the caller must provide its array length in pSubresourceCount.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//!   \deprecated Use NvAPI_D3D10_GetResourceSubresourceInfo2 instead.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]   pDev               The device pointer.
//!   \param [in]   hResource          The resource handle.
//!   \param [in]   Version            The version of the output structure used to allocate the buffer.
//!   \param [out]  pSubresourceCount  Available subresource count or size of ppInfoBuffer. See comments above.
//!   \param [out]  ppInfoBuffer       Result buffer allocated by caller. See comments above.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_GetResourceSubresourceInfo(__in ID3D10Device* pDev,
                                                       __in NVDX_ObjectHandle hResource,
                                                       __in NvU32 Version,
                                                       __inout NvU32* pSubresourceCount,
                                                       __out_ecount_part_opt(*pSubresourceCount, *pSubresourceCount) NvAPI_D3DResourceSubresourceInfo** ppInfoBuffer);

#endif //defined(__cplusplus) && defined(__d3d10_h__)
#if defined(__cplusplus) && defined(__d3d10_h__)

//! Prototype structure version, check common/inc/ShaderDebuggerStruct.h for versions
//! currently supported by the driver!
//! \ingroup nsightapi
typedef struct _sdD3DResourceSubresourceInfo
{
    NvU32 structVersion;
} sdD3DResourceSubresourceInfo;

//! \ingroup nsightapi
#define SD_D3D_RESOURCE_SUBRESOURCE_INFO_STRUCT_VERSION_V0 MAKE_NVAPI_VERSION(sdD3DResourceSubresourceInfo, 0)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_GetResourceSubresourceInfo2
//
//!   Returns information about the internal layout of subresources in a driver resource.
//!   To obtain the subresource count, callers should call this with ppInfoBuffer=NULL.
//!   Then, the caller should allocate an array of sdD3DResourceSubresourceInfo_vX* (see
//!   common/inc/ShaderDebuggerStruct.h) and initialize each member of the array with a valid pointer.
//!   When ppInfoBuffer is non-null, the caller must provide its array length in pSubresourceCount.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//
//!   \param [in]   pDev               The device pointer.
//!   \param [in]   hResource          The resource handle.
//!   \param [in]   Version            The version of the output structure used to allocate the buffer.
//!   \param [out]  pSubresourceCount  Available subresource count or size of ppInfoBuffer. See comments above.
//!   \param [out]  ppInfoBuffer       Result buffer allocated by caller. See comments above.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_GetResourceSubresourceInfo2(__in ID3D10Device* pDev,
                                                       __in NVDX_ObjectHandle hResource,
                                                       __in NvU32 Version,
                                                       __inout NvU32* pSubresourceCount,
                                                       __out_ecount_part_opt(*pSubresourceCount, *pSubresourceCount) sdD3DResourceSubresourceInfo** ppInfoBuffer);

#endif //defined(__cplusplus) && defined(__d3d10_h__)


#if defined(__cplusplus) && defined(__d3d10_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D10_EnableWarpSemaphoreReports
//
//!   Returns a pointer to a volatile block of memory, which contains lmem, crs,
//!   and warp parameters, circa when the debugger is servicing a breakpoint.
//!   In SLI mode, these pertain to GPU 0 only.
//!   The mapped memory is a an array of structures, which should be indexed
//!   with the correct sdWarpSemaphoreReportType enum as defined in common/inc/ShaderDebuggerStruct.h
//!   When this feature is enabled, extra WFIs can occur when driver state changes,
//!   and semaphores will be issued to the HW.  Thus this feature should be disabled
//!   when not in use.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//
//!   \param [in]   pDev                The device pointer
//!   \param [in]   enable              Enable or disable reporting
//!   \param [in]   requestedVersion    Since the driver allocates the memory, the user needs to
//!                                     let the driver know which version of the structure to create.
//!   \param [out]  ppOutMappedMemory   Pointer to the semaphore data block.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D10_EnableWarpSemaphoreReports(__in ID3D10Device* pDev,
                                                       __in bool enable,
                                                       __in NvU32 requestedVersion,
                                                       __out volatile sdWarpSemaphoreReport** ppOutMappedMemory);


#endif // defined(__cplusplus) && defined(__d3d10_h__)



//-----------------------------------------------------------------------------
// Direct3D11 APIs
//-----------------------------------------------------------------------------

#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_CreateDevice
//
//!   DESCRIPTION: This function tries to create a DirectX 11 device. If the call fails (if we are running
//!                on pre-DirectX 11 hardware), depending on the type of hardware it will try to create a DirectX 10.1 OR DirectX 10.0+
//!                OR DirectX 10.0 device. The function call is the same as D3D11CreateDevice(), but with an extra 
//!                argument (D3D_FEATURE_LEVEL supported by the device) that the function fills in. This argument
//!                can contain -1 (NVAPI_DEVICE_FEATURE_LEVEL_NULL), if the requested featureLevel is less than DirecX 10.0.
//!
//!            NOTE: When NvAPI_D3D11_CreateDevice is called with 10+ feature level we have an issue on few set of
//!                  tesla hardware (G80/G84/G86/G92/G94/G96) which does not support all feature level 10+ functionality
//!                  e.g. calling driver with mismatch between RenderTarget and Depth Buffer. App developers should
//!                  take into consideration such limitation when using NVAPI on such tesla hardwares.
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]   pAdapter
//! \param [in]   DriverType
//! \param [in]   Software
//! \param [in]   Flags
//! \param [in]   *pFeatureLevels
//! \param [in]   FeatureLevels
//! \param [in]   SDKVersion
//! \param [in]   **ppDevice
//! \param [in]   *pFeatureLevel
//! \param [in]   **ppImmediateContext
//! \param [in]   *pSupportedLevel  D3D_FEATURE_LEVEL supported
//!
//! \return NVAPI_OK if the createDevice call succeeded.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_CreateDevice(IDXGIAdapter* pAdapter,
                                         D3D_DRIVER_TYPE DriverType,
                                         HMODULE Software,
                                         UINT Flags,
                                         CONST D3D_FEATURE_LEVEL *pFeatureLevels,
                                         UINT FeatureLevels,
                                         UINT SDKVersion,
                                         ID3D11Device **ppDevice,
                                         D3D_FEATURE_LEVEL *pFeatureLevel,
                                         ID3D11DeviceContext **ppImmediateContext,
                                         NVAPI_DEVICE_FEATURE_LEVEL *pSupportedLevel);


#endif //defined(__cplusplus) && defined(__d3d11_h__)

#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_CreateDeviceAndSwapChain
//
//!   DESCRIPTION: This function tries to create a DirectX 11 device and swap chain. If the call fails (if we are 
//!                running on pre=DirectX 11 hardware), depending on the type of hardware it will try to create a DirectX 10.1 OR 
//!                DirectX 10.0+ OR DirectX 10.0 device. The function call is the same as D3D11CreateDeviceAndSwapChain,  
//!                but with an extra argument (D3D_FEATURE_LEVEL supported by the device) that the function fills
//!                in. This argument can contain -1 (NVAPI_DEVICE_FEATURE_LEVEL_NULL), if the requested featureLevel
//!                is less than DirectX 10.0.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]     pAdapter
//! \param [in]     DriverType
//! \param [in]     Software
//! \param [in]     Flags
//! \param [in]     *pFeatureLevels
//! \param [in]     FeatureLevels
//! \param [in]     SDKVersion
//! \param [in]     *pSwapChainDesc
//! \param [in]     **ppSwapChain
//! \param [in]     **ppDevice
//! \param [in]     *pFeatureLevel
//! \param [in]     **ppImmediateContext
//! \param [in]     *pSupportedLevel  D3D_FEATURE_LEVEL supported
//!
//!return  NVAPI_OK if the createDevice with swap chain call succeeded.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_CreateDeviceAndSwapChain(IDXGIAdapter* pAdapter,
                                         D3D_DRIVER_TYPE DriverType,
                                         HMODULE Software,
                                         UINT Flags,
                                         CONST D3D_FEATURE_LEVEL *pFeatureLevels,
                                         UINT FeatureLevels,
                                         UINT SDKVersion,
                                         CONST DXGI_SWAP_CHAIN_DESC *pSwapChainDesc,
                                         IDXGISwapChain **ppSwapChain,
                                         ID3D11Device **ppDevice,
                                         D3D_FEATURE_LEVEL *pFeatureLevel,
                                         ID3D11DeviceContext **ppImmediateContext,
                                         NVAPI_DEVICE_FEATURE_LEVEL *pSupportedLevel);



#endif //defined(__cplusplus) && defined(__d3d11_h__)


// under development. API will be nda or public after implementation is completed
//! SUPPORTED OS:  Windows Vista and higher
//!
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_CreateComputeOnlyDevice
//
//!   DESCRIPTION: This function creates a restricted type of a D3D11 device for compute-only work.
//!                It is a companion device for the main fully-capable 3D device. It has its own 
//!                pipe-line state and can run asynchronously w.r.t. the main device.
//!                Therefore compute work, submitted  to the compute-only device, can run in parallel 
//!                with graphics/compute work of the main device. The compute-only device is fully
//!                free-threaded w.r.t the main device.
//!                
//!                Restrictions:
//!                1. The compute-only device holds a reference to the main device, so the two share lifetime.
//!                In case of device lost of either device, the recovery sequence is to release the compute-only
//!                device first, then recover the main device, and then use this call to create a new
//!                compute-only device.
//!                2. All graphics related "set" functions are silently ignored on this device. All draw calls
//!                cause device lost.
//!                3. Only non-stretching, non-format converting blits are supported on this device. More copy restrictions
//!                may apply.
//!                4. No DXGI services (like present calls) are supported on this device.
//!                5. Predicated rendering is not supported on this device.
//!                6. While calling this create function, no other calls can be made on the main device on any other thread.
//!
//!                Creation call takes a pointer to the main device and few of the parameters of the standard device creation call.
//!                The remaining parameters have to match those of the main device and are derived from the main device pointer.
//!
//!
//! \param [in]     *pBase3DDevice        - a pointer the main device
//! \param [in]     Flags                 - creation flags (see documentaion for the D3D11CreateDevice() call) 
//! \param [in]     SDKVersion            - SDK version used by the caller  (see documentaion for the D3D11CreateDevice() call) 
//! \param [out]    **ppDevice            - a pointer to return created device
//! \param [out]    *pFeatureLevel        - a pointer to return the feature level of the device
//! \param [out]    **ppImmediateContext  - a pointer to return an immediate context of this device
//!
//! \return  NVAPI_OK if the create compute-only device call succeeded.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_CreateComputeOnlyDevice(__in ID3D11Device *pBase3DDevice,
    __in  UINT Flags,
    __in  UINT SDKVersion,
    __out ID3D11Device **ppDevice,
    __out D3D_FEATURE_LEVEL *pFeatureLevel,
    __out ID3D11DeviceContext **ppImmediateContext);

#endif //defined(__cplusplus) && defined(__d3d11_h__)

#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_BeginShareResource
//
//!   DESCRIPTION:  This API recreates the resource as a shared resource.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!  \param [in]  pResource   The resource to recreate as shared
//!  \param [in]  flags       Should be one of NVAPI_SHARE_RESOURCE_FLAGS
//!  \param [out] pHandle     The shared resource handle
//!
//!
//!  \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!                 If there are return error codes with specific meaning for this API, they are listed below.
//!                 (None)
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_BeginShareResource(ID3D11Resource *pResource,
                                               UINT32          flags,
                                               HANDLE         *pHandle);

#endif //defined(__cplusplus) && defined(__d3d11_h__)

#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_EndShareResource
//
//!   DESCRIPTION:  This API restores the original resource.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in] pResource    The resource that was shared using NvAPI_D3D11_BeginShareResource
//!
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!                 If there are return error codes with specific meaning for this API, they are listed below.
//!                 (None)
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_EndShareResource(ID3D11Resource *pResource);

#endif //defined(__cplusplus) && defined(__d3d11_h__)

#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_SetDepthBoundsTest
//
//!   DESCRIPTION: This function enables/disables the depth bounds test
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]        pDeviceOrContext   The device or device context to set depth bounds test
//! \param [in]        bEnable            Enable(non-zero)/disable(zero) the depth bounds test
//! \param [in]        fMinDepth          The minimum depth for depth bounds test
//! \param [in]        fMaxDepth          The maximum depth for depth bounds test
//!                                       The valid values for fMinDepth and fMaxDepth
//!                                       are such that 0 <= fMinDepth <= fMaxDepth <= 1
//!
//! \return  ::NVAPI_OK if the depth bounds test was correcly enabled or disabled
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_SetDepthBoundsTest(IUnknown* pDeviceOrContext,
                                               NvU32 bEnable,
                                               float fMinDepth,
                                               float fMaxDepth);

#endif //defined(__cplusplus) && defined(__d3d11_h__)

#if defined (__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_IsNvShaderExtnOpCodeSupported
//
//!   DESCRIPTION: This function checks if a nv HLSL shader extension opcode is 
//!                supported on current hardware. List of opcodes is in nvShaderExtnEnums.h
//!                To use Nvidia HLSL extensions the application must include nvHLSLExtns.h 
//!                in the hlsl shader code. See nvHLSLExtns.h for more details on supported opcodes.
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]        pDev         The device on which to query for support,
//!                                 should be a ID3D11Device+ device
//! \param [in]        opCode       the opcode to check
//! \param [out]       pSupported   true if supported, false otherwise
//!
//! RETURN STATUS:     This API can return any of the error codes enumerated in #NvAPI_Status. 
//!                    If there are return error codes with specific meaning for this API, they are listed below.
//! \retval ::         NVAPI_OK if the call succeeded
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_IsNvShaderExtnOpCodeSupported(__in  IUnknown *pDev,
                                                          __in  NvU32 opCode,
													      __out bool *pSupported);

#endif //defined (__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))

#if defined (__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_SetNvShaderExtnSlot
//
//!   DESCRIPTION: This function sets the fake UAV slot that is used by Nvidia HLSL
//!                shader extensions. All createShader calls made to the driver after
//!                setting this slot would treat writes/reads to this UAV in a 
//!                different way. Applications are expected to bind null UAV to this slot.
//!                The same slot is used for all shader stages.
//!                To disable shader extensions the app may set this uav slot
//!                to some value that is bigger than the max allowed slot index
//!                e.g, 128 or 0xFFFFFFFF.
//!                To use Nvidia HLSL extensions the application must include nvHLSLExtns.h 
//!                in the hlsl shader code. See nvHLSLExtns.h for more details.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]        pDev         The device for which to set the extension slot
//!                                 should be a ID3D11Device+ device
//! \param [in]        uavSlot      the uav slot to use
//!
//! RETURN STATUS:     This API can return any of the error codes enumerated in #NvAPI_Status. 
//!                    If there are return error codes with specific meaning for this API, they are listed below.
//! \retval ::         NVAPI_OK    : success, the uavSlot was set sucessfully
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_SetNvShaderExtnSlot(__in IUnknown *pDev,
                                                __in NvU32 uavSlot);

#endif //defined (__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))


#if defined (__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D_ForcePerSampleInterlock
//
//!   DESCRIPTION: Pixel shader interlock happens at shader frequency by default. This 
//!                function forces the interlock to happen at sample frequency (even if the shader
//!                is running at per-pixel frequency). Note that this function has no effect
//!                if the shader is already running at per-sample frequency (supersampling).
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]        *pDeviceOrContext     pointer to D3D11 device, or D3D11 device context
//! \param [in]        bForcePerSample   	 set this to true to force per sample interlock
//!
//! RETURN STATUS:     This API can return any of the error codes enumerated in #NvAPI_Status. 
//!                    If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_ForcePerSampleInterlock(__in  IUnknown *pDeviceOrContext,
                                                  __in  bool bForcePerSample);

#endif //defined (__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))

#if defined (__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_BeginUAVOverlapEx
//
//!   DESCRIPTION: Causes the driver to skip synchronization that is normally needed when accessing UAVs.
//!                Applications must use this with caution otherwise this might cause data hazards when
//!                multiple draw calls/compute shader launches are accessing same memory locations
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]        *pDeviceOrContext     pointer to D3D11 device, or D3D11 device context
//! \param [in]        insertWFIFlags        bit fields to indicate which WFI would be inserted (gfx / compute / both).
//!
//! RETURN STATUS:     This API can return any of the error codes enumerated in #NvAPI_Status. 
//!                    If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
typedef enum _NVAPI_D3D11_INSERTWFI_FLAG
{
    NVAPI_D3D_BEGIN_UAV_OVERLAP_NO_WFI      = 0x00000000,   //!< no WFI
    NVAPI_D3D_BEGIN_UAV_OVERLAP_GFX_WFI     = 0x00000001,   //!< (bit 0) force graphics WFI
    NVAPI_D3D_BEGIN_UAV_OVERLAP_COMP_WFI    = 0x00000002,   //!< (bit 1) force compute WFI
} NVAPI_D3D11_INSERTWFI_FLAG;

NVAPI_INTERFACE NvAPI_D3D11_BeginUAVOverlapEx(__in  IUnknown *pDeviceOrContext, __in NvU32 insertWFIFlags);

#endif //defined (__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))

#if defined (__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_BeginUAVOverlap
//
//!   DESCRIPTION: Causes the driver to skip synchronization that is normally needed when accessing UAVs.
//!                Applications must use this with caution otherwise this might cause data hazards when
//!                multiple draw calls/compute shader launches are accessing same memory locations
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]        *pDeviceOrContext     pointer to D3D11 device, or D3D11 device context
//!
//! RETURN STATUS:     This API can return any of the error codes enumerated in #NvAPI_Status. 
//!                    If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_BeginUAVOverlap(__in  IUnknown *pDeviceOrContext);

#endif //defined (__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))

#if defined (__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_EndUAVOverlap
//
//!   DESCRIPTION: Re-enables driver synchronization between calls that access same UAVs
//!                See NvAPI_D3D_BeginUAVOverlap for more details.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]        *pDeviceOrContext     pointer to D3D11 device, or D3D11 device context
//!
//! RETURN STATUS:     This API can return any of the error codes enumerated in #NvAPI_Status. 
//!                    If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_EndUAVOverlap(__in  IUnknown *pDeviceOrContext);

#endif //defined (__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))


#if defined (__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_CreatePixelShaderEx
//
//!   DESCRIPTION: Extension of ID3D11Device::CreatePixelShader method with additional flags to allow shader attribute evaluation at
//!                correct sampling locations for 1X AA case - which can be used with Maxwell programmable sample positions.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]        *pDevice              pointer to D3D11 device
//! \param [in]        *pShaderBytecode      pointer to the compiled shader
//! \param [in]         BytecodeLength       Size of the compiled pixel shader
//! \param [in]        *pClassLinkage        A pointer to a class linkage interface; the value can be NULL.
//! \param [in]        flags                 Extra flags to support additional functionality.
//! \param [out]       *ppPixelShader        Address of a pointer to a ID3D11PixelShader interface.
//!
//! RETURN STATUS:     This API can return any of the error codes enumerated in #NvAPI_Status. 
//!                    If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////

typedef enum {
    NVAPI_SHADER_ATTRIB_EVAL_AT_SAMPLE_LOCATION    = 0x00000001,  //!< Change shader attribute evaluation locations to match rasterizer sample positions. 
	                                                              //!< Applicable only when shader is used without MSAA. Has no effect if shader is used with MSAA.
} NVAPI_CREATE_PIXEL_SHADER_FLAGS;

NVAPI_INTERFACE NvAPI_D3D11_CreatePixelShaderEx(__in ID3D11Device *pDevice,
                                                __in const void *pShaderBytecode,
                                                __in SIZE_T BytecodeLength,
                                                __in ID3D11ClassLinkage *pClassLinkage,
                                                __in NVAPI_CREATE_PIXEL_SHADER_FLAGS flags,
                                                __out ID3D11PixelShader **ppPixelShader);

#endif //defined (__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))


//-----------------------------------------------------------------------------
// Private Direct3D11 APIs
//-----------------------------------------------------------------------------

#if defined(__cplusplus) && defined(__d3d11_h__)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_GetBufferStreamOutBytesWritten
//! \code
//!   DESCRIPTION: Gets the number of bytes written during stream out for the
//!                specified buffer.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!         INPUT:  ID3D11Device*
//!                 ID3D11Buffer*
//!                 NvU32*
//!
//! RETURN STATUS: NVAPI_OK if the operation succeeded
//! \endcode
//! \ingroup nsightapi
/////////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_GetBufferStreamOutBytesWritten(ID3D11Device* pDev, ID3D11Buffer* pBuffer, NvU32* pCount);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_SetBufferStreamOutBytesWritten
//! \code
//!   DESCRIPTION: Sets the number of bytes written during stream out for the
//!                specified buffer.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!         INPUT:  ID3D11Device*
//!                 ID3D11Buffer*
//!                 NvU32
//!
//! RETURN STATUS: NVAPI_OK if the operation succeeded
//! \endcode
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_SetBufferStreamOutBytesWritten(ID3D11Device* pDev, ID3D11Buffer* pBuffer, NvU32 Count);

#endif //defined(__cplusplus) && defined(__d3d11_h__)

#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_GetResourceHandle
//
//! \code
//!   DESCRIPTION: This function retrieves a driver handle to a DX10 resource
//!
//!         INPUT:  pDev         The device on which the resource was created
//!                 pResource    The resource for which we want to retrieve a
//!                              driver handle.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!        OUTPUT:  phObject     Pointer to an NvAPI handle to be populated
//!                              on success
//!
//! RETURN STATUS: NVAPI_OK if and only if phObject was populated with a valid
//!                driver handle
//! \endcode
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_GetResourceHandle(ID3D11Device *pDev,
                                              ID3D11Resource* pResource,
                                              NVDX_ObjectHandle* phObject);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_SetPrivateConstData
//
//!   Sets data in the private UMD constant buffer.
//!   Slots are defined by the NvAPIPrivateConstDataSlot enumeration.
//!   Consumers of this constant buffer data must take care to call
//!   NvAPI_D3D11_GetPrivateConstDataSlotAndOffset for the same instance
//!   of the shader which will consume the data.  Producers of this data
//!   should call NvAPI_D3D11_SetPrivateConstData any time before drawing.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//
//!   \param [in]  pDev       The device pointer
//!   \param [in]  dataslot   The data slot to update
//!   \param [in]  data       The data value
//!
//!   \return  NVAPI_OK if the call succeeded.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_SetPrivateConstData(__in ID3D11DeviceContext* pContext,
                                                __in NvAPIPrivateConstDataSlot dataslot,
                                                __in NvU32 data);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_GetPrivateConstDataSlotAndOffset
//
//!   This function retrieves the constant slot and offset corresponding
//!   to the private UMD constant buffer for the specified shader.  See
//!   comments for NvAPI_D3D11_SetPrivateConstData.  hShader should be
//!   acquired using one of the NvAPI_D3D11_GetXXXShaderHandle functions.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]  pDev               The device pointer
//!   \param [in]  hShader            The shader for which to query the data
//!   \param [in]  dataslot           The data slot to query
//!
//!   \param [out] pOutConstSlot      The buffer id (bank#)
//!   \param [out] pOutScalarOffset   The offset within the buffer
//!
//!   \return  NVAPI_OK if the call succeeded.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_GetPrivateConstDataSlotAndOffset(__in ID3D11DeviceContext* pContext,
                                                             __in NVDX_ObjectHandle* phShader,
                                                             __in NvAPIPrivateConstDataSlot dataslot,
                                                             __out NvU32 *pOutConstSlot,
                                                             __out NvU32 *pOutScalarOffset);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_GetResourceAllocationInfoSize
//
//!   This function should be called before GetResourceAllocationInfo, to get the size of pResourceAttributes.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]   pDev    The device on which the resource was created
//!   \param [out]  pSize   The size of the memory needed for pResourceAttributes in NvAPI_D3D11_GetResourceAllocationInfo.
//!
//!   \return   NVAPI_OK if pDev is valid and pSize not NULL.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_GetResourceAllocationInfoSize(__in ID3D11DeviceContext *pContext,
                                                          __out NvU32 *pSize);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_GetResourceAllocationInfo
//
//!   This function returns the allocation info of a resource.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]   pDev                  The device on which the resource was created
//!   \param [in]i  hResource             Handle to the internal resource data struction of the UMD
//!   \param [out]  phAllocation          The D3DKMT local memory allocation handle
//!   \param [out]  pBlockOffset          The offset into the local memory allocation
//!   \param [out]  pLength               The length of the allocation
//!   \param [out]  pResourceAttributes   The attributes of the resource- driver private.  Should be allocated by the caller using
//!                                       information from NvAPI_D3D11_GetResourceAllocationInfoSize.
//!                                       for the structure declaration.
//!
//!   \return   NVAPI_OK if the inputs are valid and the out pointers are non-null.
//!
//! \endcode
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_GetResourceAllocationInfo(__in ID3D11DeviceContext *pContext,
                                                      __in NVDX_ObjectHandle hResource,
                                                      __out NvU32* phAllocation,
                                                      __out NvU32* pBlockOffset,
                                                      __out NvU32* pLength,
                                                      __inout sdResourceAttributes* pResourceAttributes);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_GetResourceAllocationInfo2
//
//!   This function returns the allocation info of a resource.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]      pDev                  The device on which the resource was created
//!   \param [in]      hResource             Handle to the internal resource data struction of the UMD
//!   \param [out]     phAllocation          The D3DKMT local memory allocation handle
//!   \param [out]     pBlockOffset          The 64-bit offset into the local memory allocation
//!   \param [out]     pLength               The 64-bit length of the allocation
//!   \param [in,out]  pResourceAttributes   The attributes of the resource- driver private.  Should be allocated by the caller using
//!                                          information from NvAPI_D3D11_GetResourceAllocationInfoSize.
//!
//! RETURN STATUS: NVAPI_OK if the OUT pointers are non-null.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_GetResourceAllocationInfo2(__in ID3D11Device *pDev,
                                                       __in NVDX_ObjectHandle hResource,
                                                       __out NvU32* phAllocation,
                                                       __out NvU64* pBlockOffset,
                                                       __out NvU64* pLength,
                                                       __inout sdResourceAttributes* pResourceAttributes);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_GetAllContextRmHandles
//
//!   This function retrieves the RM handles for the device
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]      pDev                  The device whose handle we want
//!   \param [in,out]  pRmHandlesCollection  The device's RM handles of every channel/GPU combination that is active.
//!
//!   \return NVAPI_OK if and only if pDev was populated with valid RM handles
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_GetAllContextRmHandles(__in ID3D11DeviceContext *pContext,
                                                   __inout sdRmHandlesCollection* pRmHandlesCollection);
 
#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_GetAllocDebugInfo
//
//!   Internal function used by shader debugger, used for getting
//!   addressing info about resident shaders
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]   pDev                    D3D handle of client
//!   \param [in]   hKmtAlloc               KMT allocation object handle
//!   \param [in]   hAllocType              1 for resource, 2 for primary surface
//!   \param [in]   hAllocIsDeviceSpecific  Flag for allocation
//!   \param [out]  phClient                Matching RM client
//!   \param [out]  phDevice                Matching RM device
//!   \param [out]  pAllocPAddr             Allocation offset from FB
//!   \param [out]  pAllocSize              Size of allocation
//!
//!   \return NVAPI_OK if and only if the hKmtAlloc was known by the KMD
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_GetAllocDebugInfo(__in ID3D11DeviceContext *pContext,
                                              __in NvU32 hKmtAlloc,
                                              __in NvU32 hAllocType,
                                              __in NvU32 hAllocIsDeviceSpecific,
                                              __out NvU32* phClient,
                                              __out NvU32* phDevice,
                                              __out NvU64* pAllocPAddr,
                                              __out NvU32* pAllocSize);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_GetVertexShaderHandle
//
//! \code
//!   DESCRIPTION:  This function returns a shader's handle as used inside of the UMD
//!
//!         INPUT:  pD3D11VertexShader   The runtime vertex shader handle
//!                 ppD3D11ClassInstance Pointer to an array of class-instance interfaces
//!                 NumClassInstances    Number of class-instance interfaces in the array
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!        OUTPUT:  phShader     The UMD's shader handle
//!
//! RETURN STATUS: NVAPI_OK if pD3D11VertexShader is valid and the OUT pointers are non-null
//! \endcode
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_GetVertexShaderHandle(ID3D11DeviceContext *pContext,
                                                  ID3D11VertexShader  *pD3D11VertexShader,
                                                  ID3D11ClassInstance *const *ppD3D11ClassInstance,
                                                  UINT NumClassInstances,
                                                  NVDX_ObjectHandle* phShader);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_GetGeometryShaderHandle
//
//! \code
//!   DESCRIPTION:  This function returns a shader's handle as used inside of the UMD
//!
//!         INPUT:  pD3D11GeometryShader  The runtime geometry shader handle
//!                 ppD3D11ClassInstance Pointer to an array of class-instance interfaces
//!                 NumClassInstances    Number of class-instance interfaces in the array
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!        OUTPUT:  phShader     The UMD's shader handle
//!
//! RETURN STATUS: NVAPI_OK if pD3D11GeometryShader is valid and the OUT pointers are non-null
//! \endcode
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_GetGeometryShaderHandle(ID3D11DeviceContext *pContext,
                                                    ID3D11GeometryShader *pD3D11GeometryShader,
                                                    ID3D11ClassInstance *const *ppD3D11ClassInstance,
                                                    UINT NumClassInstances,
                                                    NVDX_ObjectHandle* phShader);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_GetPixelShaderHandle
//
//! \code
//!   DESCRIPTION:  This function returns a shader's handle as used inside of the UMD
//!
//!         INPUT:  pD3D11PixelShader  The runtime pixel shader handle
//!                 ppD3D11ClassInstance Pointer to an array of class-instance interfaces
//!                 NumClassInstances    Number of class-instance interfaces in the array
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!        OUTPUT:  phShader     The UMD's shader handle
//!
//! RETURN STATUS: NVAPI_OK if pD3D11PixelShader is valid and the OUT pointers are non-null
//! \endcode
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_GetPixelShaderHandle(ID3D11DeviceContext *pContext,
                                                 ID3D11PixelShader *pD3D11PixelShader,
                                                 ID3D11ClassInstance *const *ppD3D11ClassInstance,
                                                 UINT NumClassInstances,
                                                 NVDX_ObjectHandle* phShader);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_GetComputeShaderHandle
//
//! \code
//!   DESCRIPTION:  This function returns a shader's handle as used inside of the UMD
//!
//!         INPUT:  pD3D11ComputeShader  The runtime shader handle
//!                 ppD3D11ClassInstance Pointer to an array of class-instance interfaces
//!                 NumClassInstances    Number of class-instance interfaces in the array
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!        OUTPUT:  phShader     The UMD's shader handle
//!
//! RETURN STATUS: NVAPI_OK if pD3D11ComputeShader is valid and the OUT pointers are non-null
//! \endcode
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_GetComputeShaderHandle(ID3D11DeviceContext *pContext,
                                                   ID3D11ComputeShader *pD3D11ComputeShader,
                                                   ID3D11ClassInstance *const *ppD3D11ClassInstance,
                                                   UINT NumClassInstances,
                                                   NVDX_ObjectHandle* phShader);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_GetHullShaderHandle
//
//! \code
//!   DESCRIPTION:  This function returns a shader's handle as used inside of the UMD
//!
//!         INPUT:  pD3D11HullShader  The runtime shader handle
//!                 ppD3D11ClassInstance Pointer to an array of class-instance interfaces
//!                 NumClassInstances    Number of class-instance interfaces in the array
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!        OUTPUT:  phShader     The UMD's shader handle
//!
//! RETURN STATUS: NVAPI_OK if pD3D11HullShader is valid and the OUT pointers are non-null
//! \endcode
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_GetHullShaderHandle(ID3D11DeviceContext *pContext,
                                                ID3D11HullShader *pD3D11HullShader,
                                                ID3D11ClassInstance *const *ppD3D11ClassInstance,
                                                UINT NumClassInstances,
                                                NVDX_ObjectHandle* phShader);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_GetDomainShaderHandle
//
//! \code
//!   DESCRIPTION:  This function returns a shader's handle as used inside of the UMD
//!
//!         INPUT:  pD3D11DomainShader  The runtime shader handle
//!                 ppD3D11ClassInstance Pointer to an array of class-instance interfaces
//!                 NumClassInstances    Number of class-instance interfaces in the array
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!        OUTPUT:  phShader     The UMD's shader handle
//!
//! RETURN STATUS: NVAPI_OK if pD3D11DomainShader is valid and the OUT pointers are non-null
//! \endcode
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_GetDomainShaderHandle(ID3D11DeviceContext *pContext,
                                                  ID3D11DomainShader *pD3D11DomainShader,
                                                  ID3D11ClassInstance *const *ppD3D11ClassInstance,
                                                  UINT NumClassInstances,
                                                  NVDX_ObjectHandle* phShader);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_SetShaderDebuggerHeapSize
//
//!   Sets the private heap available for use by the shader debugger.
//!   By default this heap has a size of zero.  The debugger should
//!   set this to zero if it wants to the destroy an existing heap.
//!   After the heap is resized, any previous contents of the heap
//!   are invalid and should be reinitialized by the debugger.
//!   However, the contents of this heap will be preserved between
//!   migrations between sysmem and vidmem for the applicable shader
//!   cache (see NvAPI_D3D1x_MoveShaderCacheBetweenVidAndSys)
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]  pDev         The device on which the callback is valid.
//!   \param [in]  newSize      The new requested size for the heap, in bytes
//!   \param [in]  shaderType   The shader type (using enum)
//!   \param [out] pNewOffset   The offset in bytes from the start of the shader heap. Can be NULL if newSize == 0.
//!
//!   \return NVAPI_OK if the heap was successfully resized.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_SetShaderDebuggerHeapSize(__in ID3D11Device *pDev,
                                                      __in NvU32 newSize,
                                                      __in D3D_SHADER_TYPE shaderType,
                                                      __out_opt NvU32 *pNewOffset);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_SetDeviceStateSaveBuffer
//
//!   Creates a region in Vidmem where the trap handler will dump
//!   the SM states. This will be used in Fermi and Kepler by the debugger.
//!   Set the size to zero to destroy the existing allocation.
//!   Resize operation is not supported -- destroy the allocation and recreate
//!   a new one.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!    \param [in]   pDev         The device on which the callback is valid.
//!    \param [in]   newSize      The new requested size for the heap, in bytes
//!    \param [in]   shaderType   The shader type (using enum)
//!    \param [out]  pNewOffset   The offset in bytes from the start of the shader heap. Can be NULL if newSize == 0.
//!
//!    \return NVAPI_OK if the heap was successfully resized.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_SetDeviceStateSaveBuffer(__in ID3D11Device *pDev,
                                                     __in NvU32 newSize,
                                                     __in D3D_SHADER_TYPE shaderType,
                                                     __out_opt NvU64 *phAllocation);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_GetShaderUCodeAllocationInfo
//
//! \code
//!   DESCRIPTION:  This function returns a shader's address in video memory, and
//!                 its memory allocation handle.
//!
//!         INPUT:  pContext     The Context on which the resource was created
//!                 hShader      Handle to the internal shader data struction of the UMD
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!        OUTPUT:  phAllocation   The shader's allocation handle
//!                 pBlockOffset   The shader's offset into its allocation
//!                 pProgramOffset The offset to shader's debug instance (w.r.t. pBlockOffset)
//!                 pLength        The shader block's length.
//!
//! RETURN STATUS: NVAPI_OK if the OUT pointers are non-null
//! \endcode
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_GetShaderUCodeAllocationInfo(ID3D11DeviceContext *pContext,
                                                         NVDX_ObjectHandle hShader,
                                                         NvU32* phAllocation,
                                                         NvU32* pBlockOffset,
                                                         NvU32* pProgramOffset,
                                                         NvU32* pLength);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__d3d11_h__)

//! Versioned parameter structure for NvAPI_D3D11_GetComputeShaderInfo.  Please add new
//! parameters to the _end_ of the struct and increment the version info in NV_COMPUTE_SHADER_INFO_VER.
//! \ingroup nsightapi
typedef struct 
{
    NvU32 version;                    //!< [IN]  The struct version used by the client.  Set this to NV_COMPUTE_SHADER_INFO_VER
    NvU32 smemSize;                   //!< [OUT] Size of shared memory in bytes
    NvU32 tmpRegCount;                //!< [OUT] The number of temporary registers used
} NV_COMPUTE_SHADER_INFO;

//! \ingroup nsightapi
#define NV_COMPUTE_SHADER_INFO_VER MAKE_NVAPI_VERSION(NV_COMPUTE_SHADER_INFO, 1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_GetComputeShaderInfo
//
//!   This function returns various info about a compute shader 
//!   including smem size, register usage, etc.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//
//!   \param [in]      pContext            The Context on which the resource was created
//!   \param [in]      hShader             Handle to the internal shader data struction of the UMD
//!   \param [in,out]  pComputeShaderInfo  Results of the query
//!
//!   \return NVAPI_OK if the OUT pointers are non-null
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_GetComputeShaderInfo(__in ID3D11DeviceContext *pContext,
                                                 __in NVDX_ObjectHandle hShader,
                                                 __inout NV_COMPUTE_SHADER_INFO* pComputeShaderInfo);

#endif //if defined(__d3d11_h__)
#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_GetShaderLocalMemoryAllocationInfo
//
//!    This function returns the device's local memory allocation info.
//!    It does not take a shader handle because the local memory allocation
//!    is made per device and not per-shader.
//!  
//!    \warning Note, this info represents the current state of the UMD and
//!    does not necessarily reflect the values used by the GPU. Enable warp
//!    semaphore reports (see NvAPI_D3D11_EnableWarpSemaphoreReports) if you
//!    need current data. 
//!  
//!    \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!    \param [in]   pDev                  The device on which the resource was created
//!    \param [out]  phAllocation          The D3DKMT local memory allocation handle
//!    \param [out]  pBlockOffset          The offset into the local memory allocation
//!    \param [out]  pLength               The length of the allocation
//!    \param [out]  pMaxWarpsPerSm;       Deprecated, returns zero
//!    \param [out]  pLmemBytesPerThread   Deprecated, returns zero
//!
//!    \return   NVAPI_OK if the OUT pointers are non-null.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_GetShaderLocalMemoryAllocationInfo(__in ID3D11DeviceContext *pContext,
                                                               __out NvU32* phAllocation,
                                                               __out NvU32* pBlockOffset,
                                                               __out NvU32* pLength,
                                                               __out NvU32* pMaxWarpsPerSm,
                                                               __out NvU32* pLmemBytesPerThread);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_BuildDebugShaderInstance2
//
//!   This function creates and builds a debug instance of a shader.
//!   If the shader already has a debug instance then it returns
//!   immediately with the instructions unless the rebuild param is true.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]      pDev         The device to which the shader belongs to.
//!   \param [in]      pParamsIn    Pointer to extendable input structure.
//!   \param [in,out]  pParamsOut   Pointer to extendable output structure.
//!
//!   \return NVAPI_OK if pDev is valid and pParamsIn and pParamsOut are non-null
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_BuildDebugShaderInstance2(__in ID3D11Device *pDev,
                                                      __in sdBuildDebugShaderInstanceParamsIn  *pParamsIn,
                                                      __inout sdBuildDebugShaderInstanceParamsOut *pParamsOut);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_SetShaderDebuggerCallback
//
//!   This function is used to register callbacks for various debug events.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]  pDev               The device on which the callback is valid.
//!   \param [in]  cbType             The type of the callback to be set, see common/inc/ShaderDebuggerCallbacks.h
//!   \param [in]  pCallbackFunction  Pointer to the callback function. Pass NULL to disable the callback.
//!   \param [in]  pParam             Application data that will be passed back to this callback.
//!
//!   \return  NVAPI_OK if the callback was successfully set.
//!
//!   \note  An application may change it's callback functions at any time, and may
//!          unregister from any function by passing NULL in as a function pointer.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_SetShaderDebuggerCallback(__in ID3D11DeviceContext *pContext,
                                                      __in NvU32 cbType,
                                                      __in_opt SHADERDEBUGGER_CALLBACK pCallbackFunction,
                                                      __in_opt void* pParam);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_GetResourceSubresourceInfo
//
//!   Returns information about the internal layout of subresources in a driver resource.
//!   To obtain the subresource count, callers should call this with ppInfoBuffer=NULL.
//!   Then, the caller should allocate an array of NvAPI_D3DResourceSubresourceInfo* and
//!   initialize each member of the array with a valid pointer.
//!   When ppInfoBuffer is non-null, the caller must provide its array length in pSubresourceCount.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//!   \deprecated Use NvAPI_D3D11_GetResourceSubresourceInfo2 instead.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]   pDev               The device pointer.
//!   \param [in]   hResource          The resource handle.
//!   \param [in]   Version            The version of the output structure used to allocate the buffer.
//!   \param [out]  pSubresourceCount  Available subresource count or size of ppInfoBuffer. See comments above.
//!   \param [out]  ppInfoBuffer       Result buffer allocated by caller. See comments above.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_GetResourceSubresourceInfo(__in ID3D11Device* pDev,
                                                       __in NVDX_ObjectHandle hResource,
                                                       __in NvU32 Version,
                                                       __inout NvU32* pSubresourceCount,
                                                       __out_ecount_part_opt(*pSubresourceCount, *pSubresourceCount) NvAPI_D3DResourceSubresourceInfo** ppInfoBuffer);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_GetResourceSubresourceInfo2
//
//!   Returns information about the internal layout of subresources in a driver resource.
//!   To obtain the subresource count, callers should call this with ppInfoBuffer=NULL.
//!   Then, the caller should allocate an array of sdD3DResourceSubresourceInfo_vX* (see
//!   common/inc/ShaderDebuggerStruct.h) and initialize each member of the array with a valid pointer.
//!   When ppInfoBuffer is non-null, the caller must provide its array length in pSubresourceCount.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//
//!   \param [in]   pDev               The device pointer.
//!   \param [in]   hResource          The resource handle.
//!   \param [in]   Version            The version of the output structure used to allocate the buffer.
//!   \param [out]  pSubresourceCount  Available subresource count or size of ppInfoBuffer. See comments above.
//!   \param [out]  ppInfoBuffer       Result buffer allocated by caller. See comments above.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_GetResourceSubresourceInfo2(__in ID3D11Device* pDev,
                                                       __in NVDX_ObjectHandle hResource,
                                                       __in NvU32 Version,
                                                       __inout NvU32* pSubresourceCount,
                                                       __out_ecount_part_opt(*pSubresourceCount, *pSubresourceCount) sdD3DResourceSubresourceInfo** ppInfoBuffer);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_EnableWarpSemaphoreReports
//
//!   Returns a pointer to a volatile block of memory, which contains lmem, crs,
//!   and warp parameters, circa when the debugger is servicing a breakpoint.
//!   In SLI mode, these pertain to GPU 0 only.
//!   The mapped memory is a an array of structures, which should be indexed
//!   with the correct sdWarpSemaphoreReportType enum as defined in common/inc/ShaderDebuggerStruct.h
//!   When this feature is enabled, extra WFIs can occur when driver state changes,
//!   and semaphores will be issued to the HW.  Thus this feature should be disabled
//!   when not in use.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//
//!   \param [in]   pDev                The device pointer
//!   \param [in]   enable              Enable or disable reporting
//!   \param [in]   requestedVersion    Since the driver allocates the memory, the user needs to
//!                                     let the driver know which version of the structure to create.
//!   \param [out]  ppOutMappedMemory   Pointer to the semaphore data block.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_EnableWarpSemaphoreReports(__in ID3D11Device* pDev,
                                                       __in bool enable,
                                                       __in NvU32 requestedVersion,
                                                       __out volatile sdWarpSemaphoreReport** ppOutMappedMemory);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_NsightEnableReporting
//
//!   Notify the D3D driver that Nsight is attaching to the process,
//!   enable reporting, register a callback with the driver. This
//!   callback function is called when a report data is available.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]  pDev                       The device pointer on which we will tag on.
//!   \param [in]  bEnable                    boolean flag to denote either to enable/disable.
//!   \param [in]  completedReportsCallback   Callback function.
//!   \param [in]  pCallbackData              Data associated with the callback function 
//!                                           that is passed back through the callback.
//!
//!   \return  NVAPI_OK if we have successfully completed the operation.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_NsightEnableReporting(__in ID3D11Device *pDev,
                                                  __in bool bEnable,
                                                  __in fdStatsReportsCompletedCallback completedReportsCallback, 
                                                  __in_opt void *pCallbackData);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_NsightCommunication
//
//!   Uber call that handles all Nsight instrumentation in the DX driver
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!   \note <b> When pInternalDev is valid, pContext (device context pointer) is just a mule device to carry our instructions.
//!              All the changes are really done on the pInternalDev (driver/deviceContext internal device pointer). </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]      pContext      The device context on which we want to instrument. 
//!   \param [in]      pInternalDev  Driver internal device pointer on which we want to make changes. 
//!   \param [in, out] pPayload      All the data needed by the instrumentation.
//!                                  check common/inc/ShaderDebuggerStruct.h for PayLoad defines.
//!   \return NVAPI_OK if the device was valid and we successfully completed the operation.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_NsightCommunication(__in ID3D11DeviceContext *pContext,
                                                __in void     *pInternalDev,
                                                __inout void  *pPayload);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_NsightFlushReporting
//
//!   Flushes reporting output for nsight.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//
//!   \param [in]  pDev    The device pointer on which we will flush on.
//!
//!   \return  NVAPI_OK if we have successfully completed the operation.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_NsightFlushReporting(__in ID3D11Device *pDev);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_NsightSetCustomReportData
//
//!   Specifies the current custom report data for Nsight reports
//!   in the driver.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]  pDev    The device pointer on which we will tag on.
//!                        customData Custom report data.
//!
//!   \return  NVAPI_OK if we have successfully completed the operation.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_NsightSetCustomReportData(__in ID3D11DeviceContext *pContext,
                                                      __in NvU32 customData);

#endif //defined(__cplusplus) && defined(__d3d11_h__)
#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_NsightSetCurrentContextAndD3DCallCount
//
//!   Sets context handle for the device & sets counter for the specified
//!   NsightD3DCallType. 
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]   pDev          The device pointer on which we need to set the above.
//!   \param [in]   contextHandle API handle
//!   \param [in]   d3dCallType   Type of d3d call
//!   \param [in]   count         count-value to be set for corresponding d3d call.
//!
//!   \return  NVAPI_OK if we have successfully completed the operation.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_NsightSetCurrentContextAndD3DCallCount(__in ID3D11DeviceContext *pContext, 
                                                                   __in NvU64 contextHandle, 
                                                                   __in NVAPI_NSIGHT_D3DCALLTYPE d3dCallIdType,
                                                                   __in NvU64 count);

#endif // defined(__cplusplus) && defined(__d3d11_h__)



#if defined(__cplusplus) && defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_DevtoolsInvokeFunctor
//
//!   Calls the equivalent of devtools_context.h :: InvokeFunctor() but through
//!   an ID3D11DeviceContext.
//!
//!   \note This is an NVIDIA-private bootstrapping function for Devtools API.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in]   pDeviceContext  DX context
//!   \param [in]   userdata        really a DTA_FunctorUserData*
//!   \param [in]   userdataSize    sizeof *userdata
//!
//!   \return  NVAPI_OK if we have successfully completed the operation.
//!
//! \ingroup devtools
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_DevtoolsInvokeFunctor(__in ID3D11DeviceContext *pDeviceContext,
                                                  __in void* userdata,
                                                  __in size_t userdataSize);
#endif // defined(__cplusplus) && defined(__d3d11_h__)



#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D_SetFPSIndicatorState
//
//!   DESCRIPTION: Display an overlay that tracks the number of times the app presents per second, or,   
//!      the number of frames-per-second (FPS)
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in] bool    Whether or not to enable the fps indicator.
//!                
//! \return ::NVAPI_OK, 
//!         ::NVAPI_ERROR
//!
//! \ingroup dx 
/////////////////////////////////////////////////////////////////////////////// 
NVAPI_INTERFACE NvAPI_D3D_SetFPSIndicatorState(IUnknown *pDev, NvU8 doEnable);

#endif //if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)


#if defined(_D3D9_H_)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_Present
//
//! DESCRIPTION: This API presents the contents of the next buffer in the sequence of back buffers 
//!              owned by a IDirect3DDevice9 device.
//!              This Present operation supports using a SwapGroup and SwapBarrier on the SwapChain
//!              that owns the back buffer to be presented.
//!
//!          NOTE: NvAPI_D3D9_Present is a wrapper of the method IDirect3DDevice9::Present which
//!                additionally notifies the D3D driver of the SwapChain used by the runtime for
//!                presentation, thus allowing the D3D driver to apply SwapGroup and SwapBarrier
//!                functionality to that SwapChain.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]    pDevice     The IDirect3DDevice9 interface that is used to issue the Present, 
//!                using the following IDirect3DDevice9::Present input parameters
//! \param [in]    pSwapChain   Optional pointer to a IDirect3DSwapChain9 interface. If provided, the presentation is executed
//!                             using this interface (i.e. pSwapChain->Present()) for the given swapchain only.
//!                             If NULL, the presentation is executed on the device for all swapchains as in pDevice->Present()
//! \param [in]    pSourceRect  A pointer to a RECT structure containing the source rectangle. 
//!                             If NULL, the entire source surface is presented.
//! \param [in]    pDestRect      A pointer to a RECT structure containing the destination rectangle, in window client coordinates. 
//!                   If NULL, the entire client area is filled. 
//! \param [in]    hDestWindowOverride  A pointer to a destination window whose client area is taken as the target for this presentation. 
//!                                     If this value is NULL, then the hWndDeviceWindow member of D3DPRESENT_PARAMTERS is taken. 
//! \param [in]    pDirtyRegion (IN)   A pointer to a region to be presented. It must be NULL unless the swap chain was reated with 
//!                                    D3DSWAPEFFECT_COPY. If this value is non-NULL, the contained region is expressed in back buffer coordinates.
//!
//! \retval ::NVAPI_OK                 the Present operation was successfully executed
//! \retval ::NVAPI_D3D_DEVICE_LOST    D3D device status is D3DERR_DEVICELOST or D3DERR_DEVICENOTRESET, the caller has to reset device   
//! \retval ::NVAPI_DEVICE_BUSY        the Present operation failed with an error other than D3DERR_DEVICELOST or D3DERR_DEVICENOTRESET
//! \retval ::NVAPI_ERROR              the communication with the D3D driver failed, SwapGroup/SwapBarrier may not be possible.
//! \retval ::NVAPI_API_NOT_INITIALIZED NvAPI was not yet initialized.
//!
//!\ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_Present(IDirect3DDevice9 *pDevice,
                                   IDirect3DSwapChain9 *pSwapChain,
                                   const RECT *pSourceRect,
                                   const RECT *pDestRect,
                                   HWND hDestWindowOverride,
                                   const RGNDATA *pDirtyRegion);
#endif //if defined(_D3D9_H_)

#if defined(_D3D9_H_)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_QueryFrameCount
//
//!   DESCRIPTION: This API queries the universal framecounter of the G-Sync master device.
//!
//! \param [in]   pDevice            The caller provides the DX9 device that has access to the GSync device
//! \param [out]  pFrameCount        The caller provides the storage space where the framecount is stored.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \retval ::NVAPI_OK                  *pFrameCount populated with framecount value.
//! \retval ::NVAPI_ERROR               The operation failed.
//! \retval ::NVAPI_INVALID_ARGUMENT    One or more args passed in are invalid.
//! \retval ::NVAPI_API_NOT_INITIALIZED NvAPI was not yet initialized.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_QueryFrameCount(IDirect3DDevice9 *pDevice,
                                           NvU32 *pFrameCount);
#endif //if defined(_D3D9_H_)

#if defined(_D3D9_H_)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_ResetFrameCount
//
//!   DESCRIPTION: This API resets the universal framecounter on the G-Sync master device.
//!
//! \param [in]   pDevice            The caller provides the DX9 device that has access to the GSync device
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \retval ::NVAPI_OK                   framecounter has been reset
//! \retval ::NVAPI_ERROR                The operation failed.
//! \retval ::NVAPI_INVALID_ARGUMENT     One or more args passed in are invalid.
//! \retval ::NVAPI_API_NOT_INITIALIZED  NvAPI was not yet initialized.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_ResetFrameCount(IDirect3DDevice9 *pDevice);
#endif //if defined(_D3D9_H_)

#if defined(_D3D9_H_)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_QueryMaxSwapGroup
//
//!   DESCRIPTION: This API queries the number of supported SwapGroups and SwapBarriers in the graphics system.
//!
//! \param [in]   pDevice              The caller provides the DirectX 9 device that is used as a swapgroup client
//! \param [out]  pMaxGroups           The caller provides the storage space where the number of available SwapGroups is stored.
//! \param [out]  pMaxBarriers         The caller provides the storage space where the number of available SwapBarriers is stored.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \retval ::NVAPI_OK                   the number of SwapGroups and SwapBarriers has been stored
//! \retval ::NVAPI_ERROR                The operation failed.
//! \retval ::NVAPI_INVALID_ARGUMENT     One or more args passed in are invalid.
//! \retval ::NVAPI_API_NOT_INITIALIZED  NvAPI was not yet initialized.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_QueryMaxSwapGroup(IDirect3DDevice9 *pDevice, 
                                             NvU32 *pMaxGroups, 
                                             NvU32 *pMaxBarriers); 
#endif //if defined(_D3D9_H_)

#if defined(_D3D9_H_)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_QuerySwapGroup
//
//!   DESCRIPTION: This API queries the current SwapGroup and SwapBarrier that a SwapChain of a specific client device is bound to.
//!
//! \param [in]   pDevice            The caller provides the DirectX 9 device that is used as a swapgroup client
//! \param [in]   pSwapChain         The caller provides the IDirect3DSwapChain9 interface as a handle to the SwapChain  
//!                                  that belongs to the swapgroup client device
//! \param [out]  pSwapGroup         The caller provides the storage space where the current SwapGroup is stored.
//! \param [out]  pSwapBarrier       The caller provides the storage space where the current SwapBarrier is stored.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \retval ::NVAPI_OK                   the current SwapGroup and SwapBarrier has been stored
//! \retval ::NVAPI_ERROR                The operation failed.
//! \retval ::NVAPI_INVALID_ARGUMENT     One or more args passed in are invalid.
//! \retval ::NVAPI_API_NOT_INITIALIZED  NvAPI was not yet initialized.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_QuerySwapGroup(IDirect3DDevice9 *pDevice, 
                                          IDirect3DSwapChain9 *pSwapChain, 
                                          NvU32 *pSwapGroup, 
                                          NvU32 *pSwapBarrier); 
#endif //if defined(_D3D9_H_)

#if defined(_D3D9_H_)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_JoinSwapGroup
//
//!   DESCRIPTION: This API causes the SwapChain of a SwapGroup client to join or leave the specified SwapGroup.
//!
//! \param [in]    pDevice               The caller provides the DirectX 9 device that is used as a swapgroup client
//! \param [in]    pSwapChain            The caller provides the IDirect3DSwapChain9 interface as a handle to the SwapChain  
//!                                      that belongs to the swapgroup client device
//! \param [in]    group                 The caller specifies the SwapGroup which the SwapChain should join.
//!                                      - If the value of group is zero, the SwapChain leaves the SwapGroup.
//!                                      - The SwapChain joins a SwapGroup if the SwapGroup number is a positive integer less than or
//!                                        equal to the maximum number of SwapGroups queried by NvAPI_SwapGroup_QueryMaxSwapGroup.
//! \param [in]    blocking              The caller specifies that a presentation of this SwapChain should return immediately or block
//!                                      until all members of the SwapGroup are ready and the presentation was actually executed.
//!                                      A boolean value of false means the Present operation returns immediately and a value of true
//!                                      means the Present operation is blocking.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \retval ::NVAPI_OK                   the SwapChain joined/left the SwapGroup accordingly
//! \retval ::NVAPI_ERROR                The operation failed.
//! \retval ::NVAPI_INVALID_ARGUMENT     One or more args passed in are invalid.
//! \retval ::NVAPI_API_NOT_INITIALIZED  NvAPI was not yet initialized.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_JoinSwapGroup(IDirect3DDevice9 *pDevice, 
                                         IDirect3DSwapChain9 *pSwapChain, 
                                         NvU32 group,
                                         BOOL blocking); 
#endif //if defined(_D3D9_H_)

#if defined(_D3D9_H_)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_BindSwapBarrier
//
//!   DESCRIPTION: This API causes a SwapGroup to be bound to or released from the specified SwapBarrier.
//!
//! \param [in]    pDevice    The caller provides the DirectX 9 device that is used as a swapgroup client
//! \param [in]    group      The caller specifies the SwapGroup to be bound to the SwapBarrier.
//! \param [in]    barrier    The caller specifies the SwapBarrier that the SwapGroup should be bound to.
//!                              - If the value of barrier is zero, the SwapGroup will be released from the SwapBarrier.
//!                              - The SwapGroup will be bound to the SwapBarrier if the value of barrier is a positive 
//!                                integer less than or equal to the maximum number of SwapBarriers queried by NvAPI_SwapGroup_QueryMaxSwapGroup.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \retval ::NVAPI_OK                  the SwapGroup is bound to or released from the specified SwapBarrier
//! \retval ::NVAPI_ERROR               The operation failed.
//! \retval ::NVAPI_INVALID_ARGUMENT    One or more args passed in are invalid.
//! \retval ::NVAPI_API_NOT_INITIALIZED NvAPI was not yet initialized.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_BindSwapBarrier(IDirect3DDevice9 *pDevice, 
                                           NvU32 group, 
                                           NvU32 barrier); 
#endif //if defined(_D3D9_H_)


//! \ingroup dx
typedef enum
{
    NVAPI_VSYNC_DEFAULT,                    //!< Fall back to the default settings
    NVAPI_VSYNC_OFF,                        //!< Force vertical sync off when performance is more important than image quality and for benchmarking" 
    NVAPI_VSYNC_ON,                         //!< Force vertical sync on when image quality is more important than performance
    NVAPI_VSYNC_ADAPTIVE,                   //!< Select adaptive to turn vertical sync on or off based on the frame rate. 
                                            //!  Vertical sync will only be on for frame rates above the monitor refresh rate.
    NVAPI_VSYNC_ADAPTIVE_HALF_REFRESH_RATE  //!<

} NVAPI_VSYNC_MODE;

#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D_SetVerticalSyncMode
//
//!   DESCRIPTION: This API set the vertical sync mode for the given device context.
//!
//! \param [in]    pDevice    The caller provides the device and can be either IDirect3DDevice9 or ID3D10Device or ID3D10Device1 or ID3D11Device.
//! \param [in]    vsyncMode  The caller specifies the NVAPI_VSYNC_MODE to be set.
//!
//! SUPPORTED OS:  Windows Vista
//!
//!
//! RETURN STATUS: This API can return any of the error codes enumerated in #NvAPI_Status. 
//!                If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_SetVerticalSyncMode(__in IUnknown *pDevice, __in NVAPI_VSYNC_MODE vsyncMode); 

#endif //if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)

#if defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D1x_Present
//
//! DESCRIPTION: Presents the contents of the next buffer in the sequence of back buffers 
//!              owned by a D3D device.
//!              This Present operation supports using a SwapGroup and SwapBarrier on the SwapChain
//!              that owns the back buffer to be presented.
//!
//!          NOTE: NvAPI_D3D1x_Present is a wrapper of the method IDXGISwapChain::Present which
//!                additionally notifies the D3D driver of the SwapChain used by the runtime for
//!                presentation, thus allowing the D3D driver to apply SwapGroup and SwapBarrier
//!                functionality to that SwapChain.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]     pDevice          The D3D device interface that is used to issue the Present operation, 
//!                                 using the following IDirect3DDevice9::Present input parameters.
//!                                  pDevice can be either ID3D10Device or ID3D10Device1 or ID3D11Device.
//! \param [in]     pSwapChain       The IDXGISwapChain interface that is intended to present
//! \param [in]     SyncInterval     An integer that specifies the how to synchronize presentation of a frame with the vertical blank.
//!                                          Values are: 
//!                                          - 0:  The presentation occurs immediately, there is no synchronization.
//!                                          - 1,2,3,4 : Synchronize presentation after the n'th vertical blank.
//! \param [in]     Flags            An integer value that contains swap-chain presentation options as defined in DXGI_PRESENT.
//!
//! \retval ::NVAPI_OK                 the Present operation was successfully executed
//! \retval ::NVAPI_DEVICE_BUSY        the Present operation failed with an error DXGI_ERROR_DEVICE_RESET or DXGI_ERROR_DEVICE_REMOVED, 
//                                     DXGI_STATUS_OCCLUDED, or D3DDDIERR_DEVICEREMOVED. 
//! \retval ::NVAPI_ERROR              the communication with the D3D driver failed, SwapGroup/SwapBarrier may not be possible.
//! \retval ::NVAPI_API_NOT_INITIALIZED NvAPI was not yet initialized.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D1x_Present(IUnknown *pDevice,
                                    IDXGISwapChain *pSwapChain,
                                    UINT SyncInterval,
                                    UINT Flags);

#endif //if defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)

#if defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D1x_QueryFrameCount
//
//!   DESCRIPTION: This API queries the universal framecounter of the G-Sync master device.
//!
//! \param [in]    pDevice           The caller provides the D3D device that has access to the G-Sync device,
//!                                  pDevice can be either ID3D10Device or ID3D10Device1 or ID3D11Device.
//! \param [out]   pFrameCount       The caller provides the storage space where the framecount is stored.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \retval ::NVAPI_OK                   *pFrameCount populated with framecount value.
//! \retval ::NVAPI_ERROR                The operation failed.
//! \retval ::NVAPI_INVALID_ARGUMENT     One or more args passed in are invalid.
//! \retval ::NVAPI_API_NOT_INITIALIZED  NvAPI was not yet initialized.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D1x_QueryFrameCount(IUnknown *pDevice,
                                            NvU32 *pFrameCount);
#endif //if defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)

#if defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D1x_ResetFrameCount
//
//!   DESCRIPTION: This API resets the universal framecounter on the G-Sync master device.
//!
//! \param [in]    pDevice         The caller provides the D3D device that has access to the GSync device,
//!                                pDevice can be either ID3D10Device or ID3D10Device1 or ID3D11Device.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \retval ::NVAPI_OK                   framecounter has been reset
//! \retval ::NVAPI_ERROR                The operation failed.
//! \retval ::NVAPI_INVALID_ARGUMENT     pDevice arg passed in is invalid.
//! \retval ::NVAPI_API_NOT_INITIALIZED  NvAPI was not yet initialized.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D1x_ResetFrameCount(IUnknown *pDevice);
#endif //if defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)

#if defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D1x_QueryMaxSwapGroup
//
//!   DESCRIPTION: This API queries the number of supported SwapGroups and SwapBarriers in the graphics system.
//!
//! \param [in]    pDevice        The caller provides the D3D device that is intended to use SwapGroup functionality.
//!                               pDevice can be either ID3D10Device or ID3D10Device1 or ID3D11Device.
//! \param [out]   pMaxGroups     The caller provides the storage space where the number of available SwapGroups is stored.
//! \param [out]   pMaxBarriers   The caller provides the storage space where the number of available SwapBarriers is stored.
//! 
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \retval ::NVAPI_OK                  the number of SwapGroups and SwapBarriers has been stored
//! \retval ::NVAPI_ERROR               The operation failed.
//! \retval ::NVAPI_INVALID_ARGUMENT    One or more args passed in are invalid.
//! \retval ::NVAPI_API_NOT_INITIALIZED NvAPI was not yet initialized.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D1x_QueryMaxSwapGroup(IUnknown *pDevice, 
                                              NvU32 *pMaxGroups, 
                                              NvU32 *pMaxBarriers); 
#endif //if defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)

#if defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D1x_QuerySwapGroup
//
//!   DESCRIPTION: This API queries the current SwapGroup and SwapBarrier that a SwapChain of a specific client device is bound to.
//!
//! \param [in]    pDevice            The caller provides the D3D device that owns the SwapChain used as a SwapGroup client.
//!                                   pDevice can be either ID3D10Device or ID3D10Device1 or ID3D11Device.
//! \param [in]    pSwapChain         The IDXGISwapChain interface that is used as the SwapGroup client.
//!
//! \param [out]   pSwapGroup         The caller provides the storage space where the current SwapGroup is stored.
//! \param [out]   pSwapBarrier       The caller provides the storage space where the current SwapBarrier is stored.
//! 
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \retval ::NVAPI_OK                   the current SwapGroup and SwapBarrier has been stored
//! \retval ::NVAPI_ERROR                The operation failed.
//! \retval ::NVAPI_INVALID_ARGUMENT     One or more args passed in are invalid.
//! \retval ::NVAPI_API_NOT_INITIALIZED  NvAPI was not yet initialized.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D1x_QuerySwapGroup(IUnknown *pDevice, 
                                           IDXGISwapChain  *pSwapChain, 
                                           NvU32 *pSwapGroup, 
                                           NvU32 *pSwapBarrier); 
#endif //if defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)

#if defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D1x_JoinSwapGroup
//
//!   DESCRIPTION: This API causes the SwapChain of a SwapGroup client to join or leave the specified SwapGroup.
//!
//! \param [in]   pDevice            The caller provides the D3D device that owns the SwapChain used as a SwapGroup client.
//!                                  pDevice can be either ID3D10Device or ID3D10Device1 or ID3D11Device.
//! \param [in]   pSwapChain         The IDXGISwapChain interface that is used as the SwapGroup client.
//! \param [in]   group              The caller specifies the SwapGroup which the SwapChain should join.
//!                                      - If the value of group is zero, the SwapChain leaves the SwapGroup.
//!                                      - The SwapChain joins a SwapGroup if the SwapGroup number is a positive integer less than or
//!                                        equal to the maximum number of SwapGroups queried by NvAPI_SwapGroup_QueryMaxSwapGroup.
//! \param [in]   blocking           The caller specifies that a presentation of this SwapChain should return immediately or block
//!                                  until all members of the SwapGroup are ready and the presentation was actually executed.
//!                                  A boolean value of false means the Present operation returns immediately and a value of true
//!                                  means the Present operation is blocking.
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \retval ::NVAPI_OK                   the SwapChain joined/left the SwapGroup accordingly
//! \retval ::NVAPI_ERROR                The operation failed.
//! \retval ::NVAPI_INVALID_ARGUMENT     One or more args passed in are invalid.
//! \retval ::NVAPI_API_NOT_INITIALIZED  NvAPI was not yet initialized.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D1x_JoinSwapGroup(IUnknown *pDevice, 
                                          IDXGISwapChain  *pSwapChain, 
                                          NvU32 group,
                                          BOOL blocking);
#endif //if defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)

#if defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D1x_BindSwapBarrier
//
//!   DESCRIPTION: This API causes a SwapGroup to be bound to or released from the specified SwapBarrier.
//!
//! \param [in]   pDevice            The caller provides the D3D device that owns the SwapChain used as a SwapGroup client.
//!                                  pDevice can be either ID3D10Device or ID3D10Device1 or ID3D11Device.
//! \param [in]   group              The caller specifies the SwapGroup to be bound to the SwapBarrier.
//! \param [in]   barrier            The caller specifies the SwapBarrier that the SwapGroup should be bound to.
//!                                      - If the value of barrier is zero, the SwapGroup releases the SwapBarrier.
//!                                      - The SwapGroup will be bound to the SwapBarrier if the value of barrier is a positive 
//!                                        integer less than or equal to the maximum number of SwapBarriers queried by NvAPI_D3D1x_QueryMaxSwapGroup.
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \retval ::NVAPI_OK                  the SwapGroup is bound to the specified SwapBarrier
//! \retval ::NVAPI_ERROR                The operation failed.
//! \retval ::NVAPI_INVALID_ARGUMENT     One or more args passed in are invalid.
//! \retval ::NVAPI_API_NOT_INITIALIZED  NvAPI was not yet initialized.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D1x_BindSwapBarrier(IUnknown *pDevice, 
                                            NvU32 group, 
                                            NvU32 barrier); 
#endif //if defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)

#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D_SetCurrentSwapChain
//
//!   DESCRIPTION:  This function notifies the D3D driver of the DX runtime swapchain used for presentation.
//!
//! \param [in]  pDev                  The device on which the current DX SwapChain was created.
//!                                    We track resources being created by this SwapChain in the D3D driver as a SwapChain object.
//!                                    pDev can be either IDirect3DDevice9 or ID3D10Device or ID3D10Device1 or ID3D11Device.
//! \param [in]  hSwapChain            A handle that specifies the current SwapChain and which is used in the interface between
//!                                    NvAPI and the D3D driver to identify a SwapChain object.
//!                                          
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \return   This call will return NVAPI_OK if the SwapChain handle could be successfully identify an object in the D3D driver, 
//!           otherwise it returns NVAPI_ERROR.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_SetCurrentSwapChain(IUnknown *pDevice,
                                              void     *params);

#endif // defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)





//! SUPPORTED OS:  Windows Vista and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_OGL_NsightAttach
//
//!   DESCRIPTION: This API notifies the OpenGL driver that Nsight is attaching to the process.
//!
//!    PARAMETERS: None.
//!
//! \retval ::NVAPI_API_NOT_INTIALIZED         : NVAPI not initialized
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND    : no NVIDIA GPU found
//! \retval ::NVAPI_ERROR : OpenGL driver failed to load properly
//! \retval ::NVAPI_OK    : success
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_OGL_NsightAttach(void);

//! SUPPORTED OS:  Windows Vista and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_OGL_NsightAttachEx
//
//!   DESCRIPTION: This API notifies the OpenGL driver that Nsight is attaching to the process.
//!                componentMask will mention with specific components of Nsight are being enabled.
//!
//!    PARAMETERS: None.
//!
//! \param [in]  componentMask  mask of nsight components to be enabled.
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval ::NVAPI_API_NOT_INTIALIZED         : NVAPI not initialized
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND    : no NVIDIA GPU found
//! \retval ::NVAPI_ERROR : OpenGL driver failed to load properly
//! \retval ::NVAPI_OK    : success
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_OGL_NsightAttachEx(__in NvU32 componentMask);

//! SUPPORTED OS:  Windows Vista and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_OGL_NsightDetach
//
//!   DESCRIPTION: This API notifies the OpenGL driver that Nsight is detaching from the process.
//!
//!    PARAMETERS: None.
//!
//! \retval ::NVAPI_API_NOT_INTIALIZED         : NVAPI not initialized
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND    : no NVIDIA GPU found
//! \retval ::NVAPI_ERROR : OpenGL driver failed to load properly
//! \retval ::NVAPI_OK    : success
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_OGL_NsightDetach(void);

//! SUPPORTED OS:  Windows Vista and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_OGL_NsightEnableReporting
//
//!   DESCRIPTION: This API enables reporting of Nsight statistics in the OpenGL driver.
//!
//!    PARAMETERS: None.
//!
//! \retval ::NVAPI_API_NOT_INTIALIZED         : NVAPI not initialized
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND    : no NVIDIA GPU found
//! \retval ::NVAPI_OPENGL_CONTEXT_NOT_CURRENT : no current NVIDIA OpenGL 
//!                                                  context
//! \retval ::NVAPI_ERROR : OpenGL driver failed to load properly
//! \retval ::NVAPI_OK    : success
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_OGL_NsightEnableReporting(__in fdStatsReportsCompletedCallback completedReportsCallback, 
                                                __in_opt void *pCallbackData);

//! SUPPORTED OS:  Windows Vista and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_OGL_NsightDisableReporting
//
//!   DESCRIPTION: This API disables reporting of Nsight statistics in the OpenGL driver.
//!
//!    PARAMETERS: None.
//!
//! \retval ::NVAPI_API_NOT_INTIALIZED         : NVAPI not initialized
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND    : no NVIDIA GPU found
//! \retval ::NVAPI_OPENGL_CONTEXT_NOT_CURRENT : no current NVIDIA OpenGL 
//!                                                  context
//! \retval ::NVAPI_ERROR : OpenGL driver failed to load properly
//! \retval ::NVAPI_OK    : success
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_OGL_NsightDisableReporting(void);

//! SUPPORTED OS:  Windows Vista and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_OGL_NsightFlushReporting
//
//!   DESCRIPTION: This API enables flush reporting of Nsight statistics in the OpenGL driver.
//!
//!    PARAMETERS: None.
//!
//! \retval ::NVAPI_API_NOT_INTIALIZED         : NVAPI not initialized
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND    : no NVIDIA GPU found
//! \retval ::NVAPI_OPENGL_CONTEXT_NOT_CURRENT : no current NVIDIA OpenGL 
//!                                                  context
//! \retval ::NVAPI_ERROR : OpenGL driver failed to load properly
//! \retval ::NVAPI_OK    : success
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_OGL_NsightFlushReporting(void);

//! SUPPORTED OS:  Windows Vista and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_OGL_NsightSetGlobalCustomReportData
//
//!   DESCRIPTION: This API specifies the current global custom report data for Nsight 
//!                reports in the OpenGL driver. The global custom report data
//!                is process global data.
//!
//! \param [in]  customData  Custom report data.
//!
//! \retval ::NVAPI_API_NOT_INTIALIZED         : NVAPI not initialized
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND    : no NVIDIA GPU found
//! \retval ::NVAPI_OPENGL_CONTEXT_NOT_CURRENT : no current NVIDIA OpenGL 
//!                                                  context
//! \retval ::NVAPI_ERROR : OpenGL driver failed to load properly
//! \retval ::NVAPI_OK    : success
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_OGL_NsightSetGlobalCustomReportData(__in NvU32 customData);

//! SUPPORTED OS:  Windows Vista and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_OGL_NsightSetCustomReportData
//
//!   DESCRIPTION: This API specifies the current custom report data for Nsight reports
//!                in the OpenGL driver. The custom report data is associated
//!                with the current context.
//!
//! \param [in]  customData  Custom report data.
//!
//! \retval ::NVAPI_API_NOT_INTIALIZED         : NVAPI not initialized
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND    : no NVIDIA GPU found
//! \retval ::NVAPI_OPENGL_CONTEXT_NOT_CURRENT : no current NVIDIA OpenGL 
//!                                                  context
//! \retval ::NVAPI_ERROR : OpenGL driver failed to load properly
//! \retval ::NVAPI_OK    : success
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_OGL_NsightSetCustomReportData(__in NvU32 customData);

//! SUPPORTED OS:  Windows Vista and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_OGL_NsightSetDrawCallId
//
//!   DESCRIPTION: This API specifies the ID of the current (next) draw call. This ID is
//!                used in NvapiNsightStatsReport() (stored in the count field)
//!                for draw calls, and it is also used by the OpenGL shader 
//!                debugger. The ID is associated with the current context.
//!
//! \param [in] id   ID of the current (next) draw call.
//!
//! \retval ::NVAPI_API_NOT_INTIALIZED         : NVAPI not initialized
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND    : no NVIDIA GPU found
//! \retval ::NVAPI_OPENGL_CONTEXT_NOT_CURRENT : no current NVIDIA OpenGL 
//!                                                  context
//! \retval ::NVAPI_ERROR : OpenGL driver failed to load properly
//! \retval ::NVAPI_OK    : success
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_OGL_NsightSetDrawCallId(__in NvU64 id);

//! SUPPORTED OS:  Windows Vista and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_OGL_NsightPushTag
//
//!   DESCRIPTION: This API inserts the specified tag into the push buffer associated with
//!                the current context.
//!
//! \param [in]   tag   Tag to insert into the push buffer
//! \param [in]   id    An Nsight supplied ID to associate with the event
//
//! \retval ::NVAPI_API_NOT_INTIALIZED         : NVAPI not initialized
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND    : no NVIDIA GPU found
//! \retval ::NVAPI_OPENGL_CONTEXT_NOT_CURRENT : no current NVIDIA OpenGL 
//!                                                  context
//! \retval ::NVAPI_ERROR : OpenGL driver failed to load properly
//! \retval ::NVAPI_OK    : success
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_OGL_NsightPushTag(__in NvU32 tag, 
                                        __in NvU64 id);

//! SUPPORTED OS:  Windows Vista and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_OGL_NsightPop
//
//!   DESCRIPTION: This API pops the tag most recently pushed with NvAPI_OGL_NsightPopTag().
//!
//!    PARAMETERS: None.
//!
//! \retval ::NVAPI_API_NOT_INTIALIZED         : NVAPI not initialized
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND    : no NVIDIA GPU found
//! \retval ::NVAPI_OPENGL_CONTEXT_NOT_CURRENT : no current NVIDIA OpenGL 
//!                                                  context
//! \retval ::NVAPI_ERROR : OpenGL driver failed to load properly
//! \retval ::NVAPI_OK    : success
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_OGL_NsightPop();

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_OGL_NsightGetDeviceHandles
//
//!   This API gets the device handles associated with the current context / thread.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista
//!
//!
//!   \param [out]  adapterHandle   Populated with the adapter handle
//!   \param [out]  deviceHandle    Populated with the device handle
//!   \param [out]  contextHandle   Populated with the context handle
//!
//!   \retval  NVAPI_API_NOT_INTIALIZED if NVAPI not initialized
//!   \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND if no NVIDIA GPU found
//!   \retval  NVAPI_OPENGL_CONTEXT_NOT_CURRENT if no current NVIDIA OpenGL context
//!   \retval  NVAPI_ERROR if OpenGL driver failed to load properly
//!   \retval  NVAPI_OK if success
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_OGL_NsightGetDeviceHandles(__out NvU32 *adapterHandle,
                                                 __out NvU32 *deviceHandle,
                                                 __out NvU32 *contextHandle);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_OGL_NsightGetPrivateHandle
//
//!   This API gets the os-private handle associated with the current context.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista
//!
//!
//!   \param [out]  handle   Populated with the driver's os-private handle for the current context
//!
//!   \retval  NVAPI_API_NOT_INTIALIZED if NVAPI not initialized
//!   \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND if no NVIDIA GPU found
//!   \retval  NVAPI_OPENGL_CONTEXT_NOT_CURRENT if no current NVIDIA OpenGL context
//!   \retval  NVAPI_ERROR if OpenGL driver failed to load properly
//!   \retval  NVAPI_OK if success
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_OGL_NsightGetPrivateHandle(__out NvU64 *handle);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_OGL_NsightGetContextRmHandles
//
//!   This function retrieves the RM handles for the current context
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista
//!
//!
//!   \param [in,out]  pRmHandlesCollection  The device's RM handles of every channel/GPU combination that is active
//!
//!   \retval NVAPI_OK if and only if phClient and phDevice were populated with valid RM handles
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_OGL_NsightGetContextRmHandles(__inout sdRmHandlesCollection* pRmHandlesCollection);


#ifndef _HRESULT_DEFINED
#define HRESULT long
#endif

typedef HRESULT (__cdecl *SHADERDEBUGGER_CALLBACK) (__in void* pCallbackData,
                                                    __in_opt void* pParam);

#ifndef _HRESULT_DEFINED
#undef HRESULT
#endif

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_OGL_NsightSetShaderDebuggerCallback
//
//!   This function is used to register callbacks for various debug events.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista
//!
//!
//!   \param [in]   cbType             The SHADERDEBUGGER_CALLBACK_TYPE.
//!   \param [in]   pCallbackFunction  Pointer to the callback function.
//!   \param [in]   pParam             Application data that will be passed back to this callback.
//!
//!
//!   \retval NVAPI_OK if the callback was successfully set.
//!
//!   \note An application may change it's callback functions at any time, and may
//!         unregister from any function by passing NULL in as a function pointer.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_OGL_NsightSetShaderDebuggerCallback(__in NvU32 callbackType,
                                                          __in SHADERDEBUGGER_CALLBACK pCallbackFunction,
                                                          __in_opt void* pParam);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_OGL_NsightGetPrivateConstDataSlotAndOffset
//
//!   Sets data in the private UMD constant buffer.
//!   Slots are defined by the NvAPIPrivateConstDataSlot enumeration.
//!   Consumers of this constant buffer data must take care to call
//!   NvAPI_OGL_NsightGetPrivateConstDataSlotAndOffset for the same instance
//!   of the shader which will consume the data.  Producers of this data
//!   should call NvAPI_OGL_NsightSetPrivateConstDataSlotAndOffset any time
//!   before drawing.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista
//!
//!
//!   \param [in]   dataslot
//!
//!   \param [out]  pOutConstSlot
//!   \param [out]  pOutScalarOffset
//!
//!   \retval NVAPI_OK if the call succeeded.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_OGL_NsightGetPrivateConstDataSlotAndOffset(__in NvAPIPrivateConstDataSlot dataslot,
                                                                 __out NvU32 *pOutConstSlot,
                                                                 __out NvU32 *pOutScalarOffset);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_OGL_NsightSetPrivateConstData
//
//!   Sets data in the private UMD constant buffer.
//!   Slots are defined by the NvAPIPrivateConstDataSlot enumeration.
//!   Consumers of this constant buffer data must take care to call
//!   NvAPI_OGL_NsightGetPrivateConstDataSlotAndOffset for the same instance
//!   of the shader which will consume the data.  Producers of this data
//!   should call NvAPI_OGL_NsightSetPrivateConstData any time before drawing.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista
//!
//!
//!   \param [in]  dataslot
//!   \param [in]  data
//!
//!   \retval NVAPI_OK if the call succeeded.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_OGL_NsightSetPrivateConstData(__in NvAPIPrivateConstDataSlot dataslot,
                                                    __in NvU32 data);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_OGL_NsightEnableWarpSemaphoreReports
//
//!    Returns a pointer to a volatile block of memory, which contains lmem, crs,
//!    and warp parameters, circa when the debugger is servicing a breakpoint.
//!    In SLI mode, these pertain to GPU 0 only.
//!    The mapped memory is a an array of structures, which should be indexed
//!    with the correct WarpSemaphoreReportType enum.
//!    When this feature is enabled, extra WFIs can occur when driver state changes,
//!    and semaphores will be issued to the HW.  Thus this feature should be disabled
//!    when not in use.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista
//!
//!
//!   \param [in]   bEnable             boolean 0/1 flag to denote enable or disable reporting
//!   \param [in]   requestedVersion    Since the driver allocates the memory, the user needs to
//!                                     let the driver know which version of the structure to create.
//!   \param [out]  ppOutMappedMemory   Pointer to the semaphore data block.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_OGL_NsightEnableWarpSemaphoreReports(__in NvU32 bEnable,
                                                           __in NvU32 requestedVersion,
                                                           __out volatile sdWarpSemaphoreReport** ppOutMappedMemory);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_OGL_NsightSetShaderDebuggerHeapSize
//
//!   Sets the private heap available for use by the shader debugger.
//!   By default this heap has a size of zero.  The debugger should
//!   set this to zero if it wants to the destroy an existing heap.
//!   After the heap is resized, any previous contents of the heap
//!   are invalid and should be reinitialized by the debugger.
//!   However, the contents of this heap will be preserved between
//!   migrations between sysmem and vidmem for the applicable shader
//!   cache (see NvAPI_OGL_NsightMoveShaderCacheBetweenVidAndSys)
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista
//!
//!
//!   \param [in]   newSize      The new requested size for the heap, in bytes
//!   \param [in]   shaderType   The shader type (using enum)
//!   \param [out]  pNewOffset   The offset in bytes from the start of the shader heap. Can be NULL if newSize == 0.
//!
//!   \retval NVAPI_OK if the heap was successfully resized.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_OGL_NsightSetShaderDebuggerHeapSize(__in NvU32 newSize,
                                                          __in NvU32 shaderType,
                                                          __out NvU32 *pNewOffset);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_OGL_NsightSetDeviceStateSaveBuffer
//
//!   Creates a region in Vidmem where the trap handler will dump
//!   the SM states. This will be used in Fermi and Kepler by the debugger.
//!   Set the size to zero to destroy the existing allocation.
//!   Resize operation is not supported -- destroy the allocation and recreate
//!   a new one.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista
//!
//!
//!   \param [in]   newSize      The new requested size for the heap, in bytes
//!   \param [in]   shaderType   The shader type (using enum)
//!
//!   \param [out]  pNewOffset   The offset in bytes from the start of the shader heap. Can be NULL if newSize == 0.
//!
//!
//! RETURN STATUS: NVAPI_OK if the heap was successfully resized.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_OGL_NsightSetDeviceStateSaveBuffer(__in NvU32 newSize,
                                                         __in NvU32 shaderType,
                                                         __out NvU64 *phAllocation);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_OGL_NsightMoveShaderCacheBetweenVidAndSys
//
//!   This function will be used by the ShaderDebugger and will move shader cache and shader lmem
//!   from Video memory to System memory or the other way round. When the app starts up,
//!   we usually store shader cache and lmem in Video memory. To facilitate shader debugging (to
//!   set breakpoints, replace shaders at a breakpoint, and read/write lmem), we need these in system memory.
//!   Usual way of running things: When the user sets his first breakpoint in the shader, we
//!   get this call to move shader cache and lmem from VID to SYS. From then on, the driver maintains
//!   the cache and lmem in SYS memory. Once the user removes his last breakpoint, we will get this call
//!   to move cache and lmem from SYS to VID memory & continue normal operations after that.
//!   The shaderTypeFlags parameter allows us to move a single shaderType cache or multiple caches, as well as the 
//!   lmem at the same time.
//!
//!   \note Only moves the lmem to sys on Fermi and Kepler architectures, Tesla lmem remains in vid.
//! 
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista
//!
//!
//!   \param [in]  cacheLocation   Specifies location to move the shadercache and lmem (SD_STORAGE_VID/SD_STORAGE_SYS).
//!                                Check the sdShaderHeapStorage enums in common/inc/ShaderDebuggerStruct.h for valid
//!                                values. Don't use SD_STORAGE_COUNT.
//!   \param [in]  shaderTypeFlags Specifies what all shader caches need to be moved.
//!                                Check the sdShaderType enums in common/inc/ShaderDebuggerStruct.h for valid values.
//!                                You can use multiple of these, depending on the types of ShaderCaches you want to move.
//!                                NOTE: Trying to use SD_SHADER_TYPE_HULL & SD_SHADER_TYPE_DOMAIN flags on D3D10 devices
//!                                will return an NVAPI_INVALID_ARGUMENT error.
//!
//!
//!   \retval  This will be a synchronous call i.e. would be executed immediately. Hence will return NVAPI_OK if the call was successfull.
//!            This call will return NVAPI_OK, without doing anything, if shaderCache already exists in the requested location
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_OGL_NsightMoveShaderCacheBetweenVidAndSys(__in NvU32 cacheLocation,
                                                                __in NvU32 shaderTypeFlags);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_OGL_NsightGetDeviceKmtHandle
//
//!   This function retrieves the KMT handle for the current context
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista
//!
//!
//!   \param [out]  phDevice  The current context's KMT handle
//!
//!   \retval NVAPI_OK if and only if phDevice was populated with a valid KMT handle.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_OGL_NsightGetDeviceKmtHandle(__out NvU64* phDevice);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION TYPE: NvAPI_OGL_NsightEnableDebugMode
//
//!   Notify the OGL driver to use debug shader instances instead of
//!   release/optimized shaders from now until it gets this call with
//!   enable flag set to false. 
//!   EnableFlag is true, when a user sets his first BreakPoint
//!   EnableFlag is false, when the user removes his last BreakPoint
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista
//!
//!
//!   \param [in]  bEnable  boolean 0/1 flag to denote either to enable/disable.
//!
//!   \retval NVAPI_OK if we have successfully completed the operation.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_OGL_NsightEnableDebugMode(__in NvU32 bEnable);


//! Prototype structure version, check common/inc/ShaderDebuggerStruct.h for versions
//! currently supported by the driver!
//! \ingroup nsightapi
typedef struct _sdGlBuildDebugShaderInstanceParamsIn
{
    NvU32 structVersion;
} sdGlBuildDebugShaderInstanceParamsIn;

//! \ingroup nsightapi
#define SD_GL_BUILD_DEBUG_SHADER_INSTANCE_PARAMS_IN_VERSION_V0 MAKE_SD_VERSION(sdGlBuildDebugShaderInstanceParamsIn, 0)

//! Prototype structure version, check common/inc/ShaderDebuggerStruct.h for versions
//! currently supported by the driver!
//! \ingroup nsightapi
typedef struct _sdGlBuildDebugShaderInstanceParamsOut
{
    NvU32 structVersion;
} sdGlBuildDebugShaderInstanceParamsOut;

//! \ingroup nsightapi
#define SD_GL_BUILD_DEBUG_SHADER_INSTANCE_PARAMS_OUT_VERSION_V0 MAKE_SD_VERSION(sdGlBuildDebugShaderInstanceParamsOut_v0, 0)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION TYPE: NvAPI_OGL_NsightBuildDebugShaderInstance
//
//!   This function creates and builds a debug instance of a shader.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista
//!
//!
//!   \param [in]      pParamsIn   Pointer to extendable input structure.
//!   \param [in,out]  pParamsOut  Pointer to extendable output structure.
//!
//!   \retval NVAPI_OK if we have successfully completed the operation.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_OGL_NsightBuildDebugShaderInstance(__in sdGlBuildDebugShaderInstanceParamsIn  *pParamsIn,
                                                         __inout sdGlBuildDebugShaderInstanceParamsOut *pParamsOut);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_OGL_NsightGetProgramiv
//
//!   This API notifies acts like glGetProgramiv, but accesses Nsight specific data.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista
//!
//!
//!   \param [in]   id      Name of the program to query.
//!   \param [in]   pname   Name of the parameter to query.
//!   \param [out]  params  Pointer to memory where the query result will be stored
//!
//! /return   NVAPI_API_NOT_INTIALIZED if NVAPI not initialized
//! /return   NVAPI_NVIDIA_DEVICE_NOT_FOUND if no NVIDIA GPU found
//! /return   NVAPI_ERROR if OpenGL driver failed to load properly
//! /return   NVAPI_OK if success
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_OGL_NsightGetProgramiv(__in NvU32 id,
                                             __in NvU32 pname,
                                             __out NvU32 *params);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_OGL_NsightGetDriverResourceInfoSize
//
//!   This API allows the caller to query the size required to 
//!   store all of the driver resource info.  The caller is
//!   responsible for allocating and freeing the memory necessary
//!   to query the resource info.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista
//!
//!
//!   \param [in]   version   Version of the data structures to use.
//!   \param [out]  size      Pointer to an integer where the required size for the resource info
//!                           will be stored.
//!
//!   \retval  NVAPI_API_NOT_INTIALIZED if NVAPI not initialized
//!   \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND if no NVIDIA GPU found
//!   \retval  NVAPI_ERROR if OpenGL driver failed to load properly
//!   \retval  NVAPI_OK if success
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_OGL_NsightGetDriverResourceInfoSize(__in NvU32 version,
                                                          __out NvU32 *size);


//! Prototype structure version, check common/inc/ShaderDebuggerStruct.h for versions
//! currently supported by the driver!
//! \ingroup nsightapi
typedef struct _sdOpenGLDriverResourceInfo
{
    NvU32 structVersion;
} sdOpenGLDriverResourceInfo;

//! \ingroup nsightapi
#define SD_OPENGL_DRIVER_RESOURCE_INFO_VERSION_V0 MAKE_SD_VERSION(sdOpenGLDriverResourceInfo_v0, 0)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_OGL_NsightGetDriverResourceInfo
//
//!   This API allows the caller to query the driver resources
//!   that are in use on the GPU.  The resourceInfo parameter needs
//!   to be allocated/freed by the caller using the size obtained by calling
//!   NvAPI_OGL_NsightGetDriverResourceInfoSize() with the same struct version
//!   that will be passed as parameter to this call.
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista
//!
//!
//!   \param [in]  version       Version of the data structures to use.
//!   \param [out] resourceInfo  Pointer a memory allocation where the resource
//!                              info will be stored.
//!
//!   \retval  NVAPI_API_NOT_INTIALIZED if NVAPI not initialized
//!   \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND if no NVIDIA GPU found
//!   \retval  NVAPI_ERROR if OpenGL driver failed to load properly
//!   \retval  NVAPI_OK if success
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_OGL_NsightGetDriverResourceInfo(__in NvU32 version,
                                                      __out sdOpenGLDriverResourceInfo *resourceInfo);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_OGL_NsightCommunication
//
//!   Uber call that handles all Nsight instrumentation in the GL driver
//!
//!   \note <b> This is a strictly private function only to be used by the Nsight debugger! </b>
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!   \param [in, out] pPayload      All the data needed by the instrumentation.
//!                                  check common/inc/NvDevToolsNvApiThunk.h for PayLoad defines.
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval ::NVAPI_API_NOT_INTIALIZED         : NVAPI not initialized
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND    : no NVIDIA GPU found
//! \retval ::NVAPI_ERROR : OpenGL driver failed to load properly
//! \retval ::NVAPI_OK    : success, if the device was valid and we successfully completed the operation.
//!
//! \ingroup nsightapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_OGL_NsightCommunication(__inout void  *pPayload);




//! SUPPORTED OS:  Windows Vista and higher
//!
//-----------------------------------------------------------------------------
// DirectX1x IFR API
//-----------------------------------------------------------------------------

#if defined (__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) ) 

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D1x_IFR_SetUpTargetBufferToSys
//
//!   DESCRIPTION: This API allocates n buffers (up to a maximum of 6). 
//!                Additional calls to NvAPI_D3D10_IFR_SetUpTargetBufferToSys() will free the buffers that were allocated previously with the same call on the d3d device. 
//!
//! \param [in]    pDev       The device to get primary surface on. pDevice can be either ID3D10Device or ID3D10Device1 or ID3D11Device.
//! \param [in]    eFormat    The format of the blit
//! \param [in]    dwNBuffers The number of buffers in ppBuffer (max 6).
//! \param [in]    ppBuffer   A pointer to an array of dwNBuffers (max 6) pointers. Virtual memory buffers will be allocated by the driver.
//!
//! \return ::NVAPI_OK if the call succeeded
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Deprecated from r331, GRID SDK 2.2")
NVAPI_INTERFACE NvAPI_D3D1x_IFR_SetUpTargetBufferToSys(IUnknown *pDevice, NVFBC_BUFFER_FORMAT eFormat, DWORD dwNBuffers, void** ppBuffers);

#endif //defined(__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) )

//! SUPPORTED OS:  Windows Vista and higher
//!
#if defined (__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) ) 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D1x_IFR_TransferRenderTarget
//
//!   DESCRIPTION: This API copies the current rendertarget into the provided system memory buffer.
//!
//! \param [in]   pDev                      The device to get primary surface on. pDevice can be either ID3D10Device or ID3D10Device1 or ID3D11Device.
//! \param [in]   pEvent                    When not NULL, will receive a handle to an event that the driver will signal upon completion of NvAPI_D3D10_IFR_TransferRenderTarget
//! \param [in]   dwBufferIndex             The index of the buffer that will receive a copy of the rendertarget. 
//!!                                        This ordinal is between 0 and the number of buffer created by NvAPI_D3D10_IFR_SetUpTargetBufferToSys.
//! \param [in]   dwTargetWidth             When dwTargetWidth and dwTargetHeight are not 0, a bilinear filtered scaling will be done before the blit to system memory.
//! \param [in]   dwTargetHeight            When dwTargetWidth and dwTargetHeight are not 0, a bilinear filtered scaling will be done before the blit to system memory.
//! \param [in]   dwRenderTargetIndex       The index of the rendertarget that will be copied.
//! \param [in]   dwRenderTargetArraySlice  The array slice we want copied
//!
//! \return ::NVAPI_OK if the call succeeded
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Deprecated from r331, GRID SDK 2.2")
NVAPI_INTERFACE NvAPI_D3D1x_IFR_TransferRenderTarget(IUnknown *pDevice, HANDLE * pEvent, DWORD dwBufferIndex, 
                                                        DWORD dwTargetWidth, DWORD dwTargetHeight,
                                                        DWORD dwRenderTargetIndex, DWORD dwRenderTargetArraySlice);

#endif //defined(__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) )

//! SUPPORTED OS:  Windows Vista and higher
//!
#if defined (__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) ) 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D1x_IFR_CheckDeviceSupport
//
//!   DESCRIPTION: This API requests the driver to check if NvIFR context can be created. 
//!
//!
//! \since Release: 304
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]   pDevice      The device to get primary surface on
//! \param [out]  pdwSupported The NvIFR support status on this device
//!
//! \return ::NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////

typedef struct
{
    DWORD bSupported :1;
    DWORD bNvEncLogoNeeded : 1;
    DWORD bNonQualifiedHW : 1;
    DWORD bCustomerApp : 1;
    DWORD bReservedBits : 28;
    DWORD dwPrivateDataSize;
    void* pPrivateData;
    IUnknown* pDevice;
    DWORD dwVersion;
    DWORD dwReserved[29];
    void* pReserved[30];
} NvIFRCheckDeviceSupportParams;

NVAPI_INTERFACE NvAPI_D3D1x_IFR_CheckDeviceSupport(NvIFRCheckDeviceSupportParams *pParams);

#endif //defined(__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) )

//! SUPPORTED OS:  Windows Vista and higher
//!
#if defined (__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) ) 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D1x_IFR_SetUpTargetBufferToNV12BLVideoSurface
//
//!   DESCRIPTION: This API requests the driver to allocate n buffers (up to a maximum of 3). 
//!                Additional calls to NvAPI_DxD1x_IFR_SetUpTargetBufferToNV12BLVideoSurface() will free the buffers that were allocated previously with the same call on the d3d device. 
//!
//!
//! \since Release: 304
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]   pDevice    The device to get primary surface on
//! \param [in]   dwNBuffers The number of buffers in ppBuffer (max 3).
//! \param [in]   aHandles   A pointer to an array of videolibrary surfaces.
//!
//! \return ::NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Deprecated from r331, GRID SDK 2.2")

NVAPI_INTERFACE NvAPI_D3D1x_IFR_SetUpTargetBufferToNV12BLVideoSurface(IUnknown *pDevice, DWORD dwNBuffers, HANDLE * aHandles, DWORD dwTargetWidth, DWORD dwTargetHeight);

#endif //defined(__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) )

//! SUPPORTED OS:  Windows Vista and higher
//!
#if defined (__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) ) 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D1x_IFR_TransferRenderTargetToNV12BLVideoSurface
//
//!  DESCRIPTION: This API copies the current rendertarget into the provided system memory buffer.
//!
//! \since Release: 304
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDevice      The device to get primary surface on
//! \param [in]      dwBufferIndex  The index of the buffer that will receive a copy of the rendertarget. 
//!                                 This ordinal is between 0 and the number of buffer created by NvAPI_D3D1x_IFR_SetUpTargetBufferToNV12BLVideoSurface().
//! \param [in]      dwTargetWidth  When dwTargetWidth and dwTargetHeight are not 0, a bilinear filtered scaling 
//!                                 will be done before the blit to system memory.
//! \param [in]      dwTargetHeight When dwTargetWidth and dwTargetHeight are not 0, a bilinear filtered scaling 
//!                                 will be done before the blit to system memory.
//! \param [in]   dwRenderTargetIndex       The index of the rendertarget that will be copied.
//! \param [in]   dwRenderTargetArraySlice  The array slice we want copied
//!
//! \return ::NVAPI_OK 
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Deprecated from r331, GRID SDK 2.2")
NVAPI_INTERFACE NvAPI_D3D1x_IFR_TransferRenderTargetToNV12BLVideoSurface(IUnknown *pDevice, DWORD dwBufferIndex, DWORD dwTargetWidth, DWORD dwTargetHeight, DWORD dwRenderTargetIndex, DWORD dwRenderTargetArraySlice);

#endif //defined(__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) )

//! SUPPORTED OS:  Windows Vista and higher
//!

#if defined (__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))

enum NVAPI_QUAD_FILLMODE
{
    NVAPI_QUAD_FILLMODE_DISABLED = 0,
    NVAPI_QUAD_FILLMODE_BBOX = 1,
    NVAPI_QUAD_FILLMODE_FULL_VIEWPORT = 2,
};

typedef struct NvAPI_D3D11_RASTERIZER_DESC_EX
{
    // D3D11_RASTERIZER_DESC member variables
    D3D11_FILL_MODE FillMode;
    D3D11_CULL_MODE CullMode;
    BOOL FrontCounterClockwise;
    INT DepthBias;
    FLOAT DepthBiasClamp;
    FLOAT SlopeScaledDepthBias;
    BOOL DepthClipEnable;
    BOOL ScissorEnable;
    BOOL MultisampleEnable;
    BOOL AntialiasedLineEnable;

    // NvAPI_D3D11_RASTERIZER_DESC_EX specific member variables
    NvU32 ForcedSampleCount;                 //<! Added DX 11.1, part of _DESC1 version of this struct.
    bool ProgrammableSamplePositionsEnable;  //<! enable Programmable Samples feature
    bool InterleavedSamplingEnable;          //<! when jitter is enabled, an app need to fill the whole arrays below, otherwise only as much entries as samples
    NvU8 SampleCount;                        //<! number of samples. In TIR N->1 it needs to match N, in non-TIR it needs to match RT sample count. Ignored if ForcePerSampleInterlock is set
    NvU8 SamplePositionsX[16];               //<! x positions in API sample order
    NvU8 SamplePositionsY[16];               //<! y positions in API sample order
    bool ConservativeRasterEnable;           //<! rasterize all pixels a primitive touches in any way instead of just those with the centroid covered. 
    NVAPI_QUAD_FILLMODE QuadFillMode;        //<! Fill a triangle outside its bounds as a screen-aligned quad, matching the tri's bounding-box or filling the full viewport.
    bool PostZCoverageEnable;                //<! Enable pixel-shader input SV_COVERAGE to account for z-test in early-z mode.
    bool CoverageToColorEnable;              //<! Enable output of coverage to a color render-target.
    NvU8 CoverageToColorRTIndex;             //<! Index of RT for coverage-to-color.
    NvU32 reserved[16];                      //<! reserved for expansion, set to zero.
} NvAPI_D3D11_RASTERIZER_DESC_EX;
 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_CreateRasterizerState
//
//! \code
//!   DESCRIPTION: This function is an extension of ID3D11Device::CreateRasterizerState with additional raster states
//!
//!         \param [in]        pDevice             current d3d device
//!         \param [in]        pRasterizerDesc     Rasterizer state description of type NVAPI_D3D11_RASTERIZER_DESC_EX
//!         \param [out]       ppRasterizerState   ID3D11RasterizerState 
//!
//!
//! \return ::NVAPI_OK     if the call succeeds.
//! \endcode
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_CreateRasterizerState(__in ID3D11Device *pDevice,
                                                  __in const NvAPI_D3D11_RASTERIZER_DESC_EX *pRasterizerDesc,
                                                  __out ID3D11RasterizerState **ppRasterizerState);

#endif //defined(__cplusplus) && defined(__d3d11_h__)

//! SUPPORTED OS:  Windows Vista and higher
//!

#if defined (__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D_PerformPostProcessOps
//
//! \code
//!   DESCRIPTION: This function tells the driver to perform any post process operations (like FXAA/MFAA TSF) 
//!                on the given resource (and also don't do it again at the time of present)
//!                This is used by the app side shim to get FXAA/TSF filters applied on the original surface before scaling
//!
//!         \param [in]        pDevice             current d3d device (should be either ID3D11Device or ID3D10Device, DX9 TODO!)
//!         \param [in]        pTex                The Texture2D resource on which post process operations have to be performed 
//!                                                (should be either ID3D11Texture2D or ID3D10Texture2D)
//!
//!
//! \return ::NVAPI_OK     if the call succeeds.
//! \endcode
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_PerformPostProcessOps(__in IUnknown *pDevice,
                                                __in IUnknown *pTex);

#endif //defined (__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))


//! SUPPORTED OS:  Windows Vista and higher
//!

#if defined (__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_CreateMultiSampledUAV
//
//! \code
//!   DESCRIPTION: This function is an extension of ID3D11Device::CreateUnorderedAccessView that allows creating UAV of multisampled Texture2D resources
//!                The Texture2D resource doesn't need to have D3D11_BIND_UNORDERED_ACCESS bind flag as d3d11 runtime won't allow creating multisampled
//!                Texture2D resource with D3D11_BIND_UNORDERED_ACCESS bind flag. Use NvLoadFromMultiSampledUav() and NvStoreToMultiSampledUav() Nvidia 
//!                HLSL extension functions in HLSL shader code to access UAVs created using this call.
//!
//!         \param [in]        pDevice             current d3d device
//!         \param [in]        pTex                The MultiSampled Texture2D resource for which the UAV is to be created
//!         \param [in]        pDesc   	           The UAV descriptor. pDesc->ViewDimension must be D3D11_UAV_DIMENSION_TEXTURE2D

//!
//!
//! \return ::NVAPI_OK     if the call succeeds.
//! \endcode
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_CreateMultiSampledUAV(__in ID3D11Device *pDevice,
                                                  __in ID3D11Texture2D *pTex,
                                                  __in const D3D11_UNORDERED_ACCESS_VIEW_DESC *pDesc,
                                                  __out ID3D11UnorderedAccessView **ppUAV);

#endif //defined(__cplusplus) && defined(__d3d11_h__)

//! SUPPORTED OS:  Windows Vista and higher
//!

#if defined (__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_AliasMSAATexture2DAsNonMSAA
//
//! \code
//!   DESCRIPTION: This function allows creating (aliasing) a non-MSAA Texture2D object using the same memory as the given multi-sampled
//!                texture (pInputTex). The surface created would be bloated in width and height but it will have SampleCount = 1
//!                For 2X MSAA: OutTex.Width = InputTex.Width * 2, outTex.Height = InputTex.Height
//!                For 4X MSAA: OutTex.Width = InputTex.Width * 2, outTex.Height = InputTex.Height * 2
//!                For 8X MSAA: OutTex.Width = InputTex.Width * 4, outTex.Height = InputTex.Height * 2
//!                Only textures SampleQuality = 0 can be aliased as Non MSAA
//!                The app should ensure that original texture is released only after the aliased copy is released.
//!
//!         \param [in]        pDevice             current d3d device
//!         \param [in]        pInputTex           The MultiSampled Texture2D resource that is being aliased
//!         \param [out]       ppOutTex            The aliased non AA copy MultiSampled Texture2D resource
//!
//!
//! \return :: NVAPI_OK                   if the call succeeds.
//! \endcode
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_AliasMSAATexture2DAsNonMSAA(__in ID3D11Device *pDevice,
														__in ID3D11Texture2D *pInputTex,
														__out ID3D11Texture2D **ppOutTex);

#endif //defined(__cplusplus) && defined(__d3d11_h__)

//! SUPPORTED OS:  Windows Vista and higher
//!

#if defined (__cplusplus) && defined(__d3d11_h__) && (!defined(CINTERFACE) ) 

typedef UINT NvAPI_D3D11_SWIZZLE_MODE;

typedef struct NvAPI_D3D11_CREATE_GEOMETRY_SHADER_EX
{
    UINT version; // ALWAYS == NVAPI_D3D11_CREATEGEOMETRYSHADEREX_2_VERSION

    BOOL UseViewportMask;
    BOOL OffsetRtIndexByVpIndex;
    BOOL ForceFastGS;
    BOOL UseViewportOrder;
    BOOL UseAttributeSkipMask;
    BOOL UseCoordinateSwizzle;
    NvAPI_D3D11_SWIZZLE_MODE *pCoordinateSwizzling;
} NvAPI_D3D11_CREATE_GEOMETRY_SHADER_EX;

#define NVAPI_D3D11_CREATEGEOMETRYSHADEREX_2_VERSION MAKE_NVAPI_VERSION(NvAPI_D3D11_CREATE_GEOMETRY_SHADER_EX, 1)

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_CreateGeometryShaderEx
//
//! \fn NvAPI_D3D11_CreateGeometryShaderEx
//!                                                
//!   DESCRIPTION: This function allows us to extend the creation of geometry shaders with extra bits
//!                of functionality.
//!                
//!                The first parameters are identical to ID3D11Device::CreateGeometryShader() 
//!                so please refer to its documentation for their usage.
//!                
//!                The new parameter is UseViewportMask which is to tell the driver to create a shader
//!                that outputs a viewport mask instead when a viewport index is indicated.
//!                Outputting a viewport mask allows a single primitive to land on many different viewports
//!                as specified by the bits set in the mask, rather than to rely on a single number that tells it
//!                which unique viewport it would be drawn on.
//!                This can be used for example in conjunction with the setting of coordinates swizzling (see XXX_NVAPI function)
//!                to generates multiple adjacent views of the same primitive in a more efficient fashion 
//!                (outputting the primitive only once).
//!                ! Warning these functions are NOT free-threaded create compatible. 
//!                So Don't call them from a different thread than the one calling immediate device setstate functions
//!                And make sure no other thread is calling into another (even unrelated) free threaded function !
//!                
//! \since Release: 
//!                
//!   \param [in]  pDevice               The device pointer
//!   \param [in]  pShaderBytecode       A pointer to the compiled shader.
//!   \param [in]  BytecodeLength        Size of the compiled geometry shader.
//!   \param [in]  pClassLinkage         A pointer to a class linkage interface. Can be NULL.
//!   \param [in]  UseViewportMask       Tell the driver to create a shader that outputs the viewport mask in lieu of the viewport index. See above description.
//!   \param [in]  OffsetRtIndexByVpIndex       The Rendertarget index is offset by the viewport index
//!   \param [in]  ForceFastGS           DEBUG/Internal testing only.
//!   \param [in]  UseViewportOrder      DEBUG/Internal testing only.
//!   \param [in]  UseAttributeSkipMask  DEBUG/Internal testing only.
//!   \param [in]  UseCoordinateSwizzle  DEBUG/Internal testing only.
//!   \param [in]  pCoordinateSwizzling  DEBUG/Internal testing only.
//!   \param [out] ppGeometryShader      Address of a pointer to a ID3D11GeometryShader interface. 
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_D3D11_CreateGeometryShaderEx_2(__in ID3D11Device *pDevice, __in const void *pShaderBytecode, 
                                                     __in SIZE_T BytecodeLength, __in_opt ID3D11ClassLinkage *pClassLinkage, 
                                                     __in const NvAPI_D3D11_CREATE_GEOMETRY_SHADER_EX *pCreateGeometryShaderExArgs,
                                                    __out ID3D11GeometryShader **ppGeometryShader);

#endif //defined(__cplusplus) && defined(__d3d11_h__) && (!defined(CINTERFACE))

//! SUPPORTED OS:  Windows Vista and higher
//!

#if defined (__cplusplus) && defined(__d3d11_h__) && (!defined(CINTERFACE) ) 
////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_CreateFastGeometryShader
//
//! \fn NvAPI_D3D11_CreateFastGeometryShader
//!                                                
//!   DESCRIPTION: This function will convert a regular geometry shader into a fast GS variant if possible.
//!                It will not do any validation regarding the compatibility of the resulting fast GS with any 
//!                Pixel shader. The validation has to be done by the application manually.
//!                
//!                The parameters are identical to ID3D11Device::CreateGeometryShader() 
//!                so please refer to its documentation for their usage.
//!                
//!                If the shader is too complex or is not in adequate form to be converted to fast GS
//!                this function will simply fail. You should then call ID3D11Device::CreateGeometryShader() 
//!                to create the regular geometry shader.
//!                
//! \since Release: 
//!                
//!   \param [in]  pDevice               The device pointer
//!   \param [in]  pShaderBytecode       A pointer to the compiled shader.
//!   \param [in]  BytecodeLength        Size of the compiled geometry shader.
//!   \param [in]  pClassLinkage         A pointer to a class linkage interface. Can be NULL.
//!   \param [out] ppGeometryShader      Address of a pointer to a ID3D11GeometryShader interface. 
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_D3D11_CreateFastGeometryShader(__in ID3D11Device *pDevice, __in const void *pShaderBytecode, 
                                                     __in SIZE_T BytecodeLength, __in_opt ID3D11ClassLinkage *pClassLinkage,
                                                     __out ID3D11GeometryShader **ppGeometryShader);

#endif //defined(__cplusplus) && defined(__d3d11_h__) && (!defined(CINTERFACE))

//! SUPPORTED OS:  Windows Vista and higher
//!

#if defined (__cplusplus) && defined(__d3d11_h__)

typedef struct NvAPI_D3D11_VIEWPORT_EX
{
    // D3D11_VIEWPORT member variables
    FLOAT TopLeftX;
    FLOAT TopLeftY;
    FLOAT Width;
    FLOAT Height;
    FLOAT MinDepth;
    FLOAT MaxDepth;

    // NvAPI_D3D11_VIEWPORT_EX specific member variables
    bool bUseSubpixelBits;  // Define the number of bits used for sub-pixel snap. 8 is standard. 
                            // The rest is integer pixel coordinate. Leaving fewer bits than necessary to represent 
                            // entire range of int(width) or int(height) produces in undefined results.
    UINT NumSubpixelBits;   
}NvAPI_D3D11_VIEWPORT_PER_VIEWPORT_EX;

typedef struct NvAPI_D3D11_VIEWPORTS_EX
{
    UINT version; // ALWAYS == NVAPI_D3D11_RSSETVIEWPORTS_EX_VERSION

    UINT NumViewports;
    const NvAPI_D3D11_VIEWPORT_EX *pViewports;
}NvAPI_D3D11_VIEWPORTS_EX;

#define NVAPI_D3D11_RSSETVIEWPORTS_EX_VERSION     MAKE_NVAPI_VERSION(NvAPI_D3D11_VIEWPORTS_EX, 1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_RSSetViewports
//
//! \code
//!   DESCRIPTION: This function is an extension of ID3D11DeviceContext::RSSetViewports with additional per viewport properties
//!
//!         \param [in]        pDeviceOrContext   The device or device context to set the viewport
//!         \param [in]        NumViewports        Number of viewports to bind
//!         \param [in]        pViewports          Viewport declaration of type NVAPI_D3D11_VIEWPORT_EX 
//!
//!
//! \return ::NVAPI_OK     if the call succeeds.
//! \endcode
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_RSSetViewportsEx(__in IUnknown *pDevice, __in const NvAPI_D3D11_VIEWPORTS_EX *pViewportsExArgs);

#endif //defined(__cplusplus) && defined(__d3d11_h__)

//! SUPPORTED OS:  Windows Vista and higher
//!

#if defined (__cplusplus) && defined(__d3d11_h__)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_DecompressView
//
//! \code
//!   DESCRIPTION: This function is used to decompress a surface using the currently bound programmable sample positions.
//!
//!                This is needed:
//!                  - When writing to a surface in a region previously rendered by different sample positions and no clear was done.
//!                  - When reading a surface in a shader that was rendered using non-standard sample positions.
//!                  - When copying from a surface that was rendered using non-standard sample positions.
//!
//!         \param [in]        pDevice             Current d3d11 device
//!         \param [in]        pDeviceContext      Current d3d11 device context
//!         \param [in]        pView               Current view to decompress
//!
//!
//! \return ::NVAPI_OK     if the call succeeds.
//! \endcode
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_DecompressView(__in ID3D11Device* pDevice, __in ID3D11DeviceContext *pDeviceContext, __in ID3D11View* pView);

#endif //defined(__cplusplus) && defined(__d3d11_h__)

//! SUPPORTED OS:  Windows Vista and higher
//!
#if defined(_D3D9_H_) && defined(__cplusplus)

typedef struct _NV_FBC_CAPTURE_PARAMS_V1
{
    NvU32                     version;          //!<Version of structure. Must always be first member
    NvU32                     dwBufferIndex;    //!<Index of the target.
    NvU32                     dwFlags;          //!<Capture flags.
    NvU32                     dwGrabMode;       //!<GrabMode for converting current res to supplied resolution.
    NvU32                     dwTargetWidth;    //!<Supplied resolution Width.
    NvU32                     dwTargetHeight;   //!<Supplied resolution Height.
    NvU32                     dwBlend;          //!<Prefilter Blend Ratio.
    NvU32                     dwStartX;         //!<Supplied scaled resolution Widht.
    NvU32                     dwStartY;         //!<Supplied scaled resolution Height.
} NV_FBC_CAPTURE_PARAMS_V1;

#define NV_FBC_CAPTURE_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_FBC_CAPTURE_PARAMS_V1, 1)

typedef struct _NV_FBC_CAPTURE_PARAMS_V2
{
    NvU32                     version;          //!<Version of structure. Must always be first member
    NvU32                     dwBufferIndex;    //!<Index of the target.
    NvU32                     dwFlags;          //!<Capture flags.
    NvU32                     dwGrabMode;       //!<GrabMode for converting current res to supplied resolution.
    NvU32                     dwTargetWidth;    //!<Supplied resolution Width.
    NvU32                     dwTargetHeight;   //!<Supplied resolution Height.
    NvU32                     dwBlend;          //!<Prefilter Blend Ratio.
    NvU32                     dwStartX;         //!<Supplied scaled resolution Widht.
    NvU32                     dwStartY;         //!<Supplied scaled resolution Height.
    NvU32                     isSrcFromSysMem;  //!<Whether the client supplies the source surface from system memory
    NvU64                     qwSysMemPointer;  //!<Pointer to the client supplied source surface in system memory
    NvU32                     dwSourceWidth;    //!<Supplied source surface width
    NvU32                     dwSourceHeight;   //!<Supplied source surface height
} NV_FBC_CAPTURE_PARAMS_V2;

#define NV_FBC_CAPTURE_PARAMS_VER_2 MAKE_NVAPI_VERSION(NV_FBC_CAPTURE_PARAMS_V2, 2)

typedef struct _NV_FBC_CAPTURE_PARAMS_V3
{
    NvU32                     version;          //!<Version of structure. Must always be first member
    NvU32                     dwBufferIndex;    //!<Index of the target.
    NvU32                     dwFlags;          //!<Capture flags.
    NvU32                     dwGrabMode;       //!<GrabMode for converting current res to supplied resolution.
    NvU32                     dwTargetWidth;    //!<Supplied resolution Width.
    NvU32                     dwTargetHeight;   //!<Supplied resolution Height.
    NvU32                     dwBlend;          //!<Prefilter Blend Ratio.
    NvU32                     dwStartX;         //!<Supplied scaled resolution Widht.
    NvU32                     dwStartY;         //!<Supplied scaled resolution Height.
    NvU32                     isSrcFromSysMem;  //!<Whether the client supplies the source surface from system memory
    NvU64                     qwSysMemPointer;  //!<Pointer to the client supplied source surface in system memory
    NvU32                     dwSourceWidth;    //!<Supplied source surface width
    NvU32                     dwSourceHeight;   //!<Supplied source surface height
    NvU32                     bIsYUV444;        //!<Captured image should be converted YUV444 for encode
} NV_FBC_CAPTURE_PARAMS_V3;

#define NV_FBC_CAPTURE_PARAMS_VER_3 MAKE_NVAPI_VERSION(NV_FBC_CAPTURE_PARAMS_V3, 3)

#define NV_FBC_CAPTURE_PARAMS_VER   NV_FBC_CAPTURE_PARAMS_VER_3
typedef NV_FBC_CAPTURE_PARAMS_V3    NV_FBC_CAPTURE_PARAMS;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_NVFBC_Prefilter_CaptureBufferToNV12BLVideoSurface
//!
//!  DESCRIPTION: This API applies prefilter on captured backBuffer and blits into NV12 Surface
//!
//! \param [in]      pDev                     The device to get primary surface on
//! \param [out]     pDataGrabInfo            The Grabbed Frame information structure
//! \param [in]      pNvfbcCaptureParams      The Parameters of Capturing Frame 
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_NVFBC_Prefilter_CaptureBufferToNV12BLVideoSurface(__in IDirect3DDevice9 *pDev, __in NV_FBC_CAPTURE_PARAMS *pNvfbcCaptureParams, __out void * pDataGrabInfo);

#endif //defined(_D3D9_H_) && defined(__cplusplus)

//! SUPPORTED OS:  Windows Vista and higher
//!
#if defined(_D3D9_H_) && defined(__cplusplus)

typedef struct _NV_FBC_CAPTURE_TO_CUDA_PARAMS_V1
{
    NvU32                   version;            //!<Version of structure. Must always be first member
    NvU64                   qwVertexBuffer;     //!<Output buffer for captured content
    NvU32                   dwFlags;            //!<Capture flags
    NvU32                   dwFormat;           //!<Capture surface format
    NvU32                   isSrcFromSysMem;    //!<Whether the source surface is supplied by client in the system memory
    NvU64                   qwSysMemPointer;    //!<Pointer to the source surface in system memory
    NvU32                   dwSourceWidth;      //!<Width of source surface if content supplied by client
    NvU32                   dwSourceHeight;     //!<Height of source surface if content supplied by client 
} NV_FBC_CAPTURE_TO_CUDA_PARAMS_V1;

#define NV_FBC_CAPTURE_TO_CUDA_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_FBC_CAPTURE_TO_CUDA_PARAMS_V1, 1)
#define NV_FBC_CAPTURE_TO_CUDA_PARAMS_VER NV_FBC_CAPTURE_TO_CUDA_PARAMS_VER_1
typedef NV_FBC_CAPTURE_TO_CUDA_PARAMS_V1 NV_FBC_CAPTURE_TO_CUDA_PARAMS;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_NVFBC_SysmemToCUDAWithFormat
//!
//!  DESCRIPTION: This API applies takes an ARGB surface captured in system memory and convert it to the target format, used when doing NvFBCToCuda desktop capture on Coproc systems
//!
//! \param [in]      pDev                       The device to get primary surface on
//! \param [out]     pNvFBCFrameGrabInfo        The Grabbed Frame information structure
//! \param [in]      pNvFbcCaptureToCudaParams  The Parameters of Capturing Frame 
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup dx
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_NVFBC_SysmemToCUDAWithFormat(__in IDirect3DDevice9 *pDev, __in NV_FBC_CAPTURE_TO_CUDA_PARAMS *pNvFbcCaptureToCudaParams, __out void * pNvFBCFrameGrabInfo);

#endif //defined(_D3D9_H_) && defined(__cplusplus)

#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_NVFBC_SysmemToNV12BLVideoSurface
//!
//!  DESCRIPTION: This API takes a frame buffer in system memory and blits it into NV12 Surface
//!
//! \param [in]      pDev                     The device to get frame surface on
//! \param [out]     pDataGrabInfo            The Grabbed Frame information structure
//! \param [in]      pNvfbcCaptureParams      The Parameters of Capturing Frame 
//!
//! \return  This API can return any of the error codes enumerated in
//!          #NvAPI_Status.  If there are return error codes with specific
//!          meaning for this API, they are listed below.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////

//! SUPPORTED OS:  Windows Vista and higher
//!
//! \ingroup dx
NVAPI_INTERFACE NvAPI_D3D9_NVFBC_SysmemToNV12BLVideoSurface(__in IDirect3DDevice9 *pDev, __in NV_FBC_CAPTURE_PARAMS *pNvfbcCaptureParams, __out void * pDataGrabInfo);

#endif //defined(_D3D9_H_) && defined(__cplusplus)


#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)

///////////////////////////////////////////////////////////////////////////////
//!
//! FUNCTION NAME: NvAPI_D3D_GetVRRState
//!   DESCRIPTION: This API get the VRR state for the given device context.
//!
//! \param [in]    pDeviceOrContext    The D3D9, D3D10, D3D11 device, or D3D11 device context
//! \param [in]    NVDX_ObjectHandle   The handle of primary surface
//! \param [out]   pisVrrEnabled       true if VRR is enabled
//! \param [out]   pisVrrRequested     true if VRR is requested
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! RETURN STATUS: This API can return any of the error codes enumerated in #NvAPI_Status. 
//!                If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_GetVRRState(__in IUnknown *pDeviceOrContext, __in NVDX_ObjectHandle primarySurface, __out_opt BOOL *pisVrrEnabled, __out_opt BOOL *pisVrrRequested);
#endif //if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)



#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)

///////////////////////////////////////////////////////////////////////////////
//!
//! FUNCTION NAME: NvAPI_D3D_IsGSyncCapable
//!   DESCRIPTION: This API gets G-Sync capability for the given device context.
//!                This is only reliable after the first present call has completed.
//! \param [in]    pDeviceOrContext    The D3D9, D3D10, D3D11 device, or D3D11 device context
//! \param [in]    NVDX_ObjectHandle   The handle of primary surface
//! \param [out]   pIsGsyncCapable     if G-Sync can be enabled, *pIsGsyncCapable is true.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! RETURN STATUS: This API can return any of the error codes enumerated in #NvAPI_Status. 
//!                If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_IsGSyncCapable(__in IUnknown *pDeviceOrContext, __in NVDX_ObjectHandle primarySurface, __out BOOL *pIsGsyncCapable);
#endif //if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)



#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)

///////////////////////////////////////////////////////////////////////////////
//!
//! FUNCTION NAME: NvAPI_D3D_IsGSyncActive
//!   DESCRIPTION: This API get the G-Sync state for the given device context.
//!                This is only reliable after the first present call has completed.
//!                As it is a bit time consuming, It should not be called per frame. 
//! \param [in]    pDeviceOrContext    The D3D9, D3D10, D3D11 device, or D3D11 device context
//! \param [in]    NVDX_ObjectHandle   The handle of primary surface
//! \param [out]   pIsGsyncActive      if G-Sync is active, *pisGsyncActive is true.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! RETURN STATUS: This API can return any of the error codes enumerated in #NvAPI_Status. 
//!                If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_IsGSyncActive(__in IUnknown *pDeviceOrContext, __in NVDX_ObjectHandle primarySurface, __out BOOL *pIsGsyncActive);
#endif //if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)




#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)

///////////////////////////////////////////////////////////////////////////////
//!
//! FUNCTION NAME: NvAPI_D3D_SetVRRState
//!   DESCRIPTION: This API enable/disable VRR state for the given device context.
//!
//! \param [in]    pDeviceOrContext    The D3D9, D3D10, D3D11 device, or D3D11 device context
//! \param [in]    NVDX_ObjectHandle   The handle of primary surface
//! \param [in]    enable              true to enable VRR and false to disable VRR
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! RETURN STATUS: This API can return any of the error codes enumerated in #NvAPI_Status. 
//!                If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_SetVRRState(__in IUnknown *pDeviceOrContext, __in NVDX_ObjectHandle primarySurface, __in BOOL enable);
#endif //if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)

//! \ingroup dx

#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
#define NV_FLIP_PATTERNS_BUFFER_SIZE 7
typedef struct _NV_FLIP_PATTERN_DATA_V1
{
    NvU32   version;                    //!< Structure version
    NvU8    isLastCall;                 //!< [IN] set to stop data collection for this device
    NvU32   lastQueriedFlip;            //!< [IN/OUT] [IN]: a counter of last previously queried flip, [OUT]: a counter of last returned flip.
    NvU64   currentTimestamp;           //!< [OUT]timestamp of the call
    NvU64   timestampFrequency;         //!< [OUT]frequency factor
    NvU64   flipTimestamps[NV_FLIP_PATTERNS_BUFFER_SIZE]; //!<  timestamps of flips
    NvU32   numFlipsReturned;              //!< [OUT]how many flip entries were filled
    NvU8    hasMoreData;                   //!< [OUT]are there more data pending
} NV_FLIP_PATTERN_DATA_V1;

#define NV_FLIP_PATTERN_DATA_VER1    MAKE_NVAPI_VERSION(NV_FLIP_PATTERN_DATA_V1, 1)

typedef struct _NV_FLIP_PATTERN_DATA_V2
{
    NvU32   version;                    //!< Structure version
    NvU8    isLastCall;                 //!< [IN] set to stop data collection for this device
    NvU32   lastQueriedFlip;            //!< [IN/OUT] [IN]: a counter of last previously queried flip, [OUT]: a counter of last returned flip.
    NvU64   currentTimestamp;           //!< [OUT]timestamp of the call
    NvU64   timestampFrequency;         //!< [OUT]frequency factor
    NvU64   flipTimestamps[NV_FLIP_PATTERNS_BUFFER_SIZE]; //!<  timestamps of flips
    NvU32   numFlipsReturned;              //!< [OUT]how many flip entries were filled
    NvU8    hasMoreData;                   //!< [OUT]are there more data pending
    NvU8    writeData;                     //!< [IN] to enable FlipDataDump hotkey via FCAT
} NV_FLIP_PATTERN_DATA_V2;

#define NV_FLIP_PATTERN_DATA_VER2    MAKE_NVAPI_VERSION(NV_FLIP_PATTERN_DATA_V2, 2)
#define NV_FLIP_PATTERN_DATA_VER     NV_FLIP_PATTERN_DATA_VER2
typedef NV_FLIP_PATTERN_DATA_V2      NV_FLIP_PATTERN_DATA;

///////////////////////////////////////////////////////////////////////////////
//!
//! FUNCTION NAME: NvAPI_D3D_GetFlipPattern
//!   DESCRIPTION: This API returns flip pattern with timestamp.
//!
//! \param [in]    pDeviceOrContext    The D3D9, D3D10, D3D11 device, or D3D11 device context
//! \param [in]    NVDX_ObjectHandle   The handle of primary surface
//! \param [out]   pFlipData           pointer to struct NV_FLIP_PATTERN_DATA.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! RETURN STATUS: This API can return any of the error codes enumerated in #NvAPI_Status. 
//!                If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_GetFlipPattern(__in IUnknown *pDeviceOrContext, __in NVDX_ObjectHandle primarySurface, __inout NV_FLIP_PATTERN_DATA *pFlipData);
#endif //if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)

#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_IFR_SetUpTargetBufferToSys_Pvt
//
//!   DESCRIPTION: This API requests the driver to allocate n buffers (up to a maximum of 3). 
//!                Additional calls to NvAPI_D3D9_IFR_SetUpTargetBufferToSys() will free the buffers that were allocated previously with the same call on the d3d device. 
//!
//! \since Release: 331
//!
//! \param [in]   pDev       The device to get primary surface on
//! \param [in]   eFormat    The format of the blit
//! \param [in]   dwNBuffers The number of buffers in ppBuffer (max 6).
//! \param [in]   ppBuffer   A pointer to an array of dwNBuffers (max 6) pointers. Virtual memory buffers will be allocated by the driver.
//!
//! \return ::NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////

//! SUPPORTED OS:  Windows Vista and higher
//!
//! \ingroup dx
NVAPI_INTERFACE NvAPI_D3D9_IFR_SetUpTargetBufferToSys_Pvt(IDirect3DDevice9 *pDev, NVFBC_BUFFER_FORMAT eFormat, DWORD dwNBuffers, unsigned char ** ppBuffer);
#endif //#if defined(_D3D9_H_) && defined(__cplusplus)

#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_IFR_TransferRenderTarget_Pvt
//
//!  DESCRIPTION: This API copies the current rendertarget into the provided system memory buffer.
//!
//! \since Release: 331
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDev      The device to get primary surface on
//! \param [in]      pEvent    When not NULL, will receive a handle to an event that the driver will signal 
//!                            upon completion of NvAPI_D3D9_IFR_TransferRenderTarget().
//! \param [in]      dwBufferIndex  The index of the buffer that will receive a copy of the rendertarget. 
//!                                 This ordinal is between 0 and the number of buffer created by NvAPI_D3D9_IFR_SetUpTargetBufferToSys().
//! \param [in]      dwTargetWidth  When dwTargetWidth and dwTargetHeight are not 0, a bilinear filtered scaling 
//!                                 will be done before the blit to system memory.
//! \param [in]      dwTargetHeight When dwTargetWidth and dwTargetHeight are not 0, a bilinear filtered scaling 
//!                                 will be done before the blit to system memory.
//!
//! \return ::NVAPI_OK 
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_IFR_TransferRenderTarget_Pvt(IDirect3DDevice9 *pDev, HANDLE * pEvent, DWORD dwBufferIndex, DWORD dwTargetWidth, DWORD dwTargetHeight);

#endif //defined(_D3D9_H_) && defined(__cplusplus)

#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_IFR_SetUpTargetBufferToNV12BLVideoSurface_Pvt
//
//!   DESCRIPTION: This API requests the driver to allocate n buffers (up to a maximum of 3). 
//!                Additional calls to NvAPI_D3D9_IFR_SetUpTargetBufferToSys() will free the buffers that were allocated previously with the same call on the d3d device. 
//!
//!
//! \since Release: 331
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]   pDev       The device to get primary surface on
//! \param [in]   dwNBuffers The number of buffers in ppBuffer (max 3).
//! \param [in]   aHandles   A pointer to an array of videolibrary surfaces.
//!
//! \return ::NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_D3D9_IFR_SetUpTargetBufferToNV12BLVideoSurface_Pvt(IDirect3DDevice9 *pDev, DWORD dwNBuffers, HANDLE * aHandles, DWORD dwTargetWidth, DWORD dwTargetHeight, BOOL bUseYUV444  = 0);

#endif //defined(_D3D9_H_) && defined(__cplusplus)

#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_IFR_TransferRenderTargetToNV12BLVideoSurface_Pvt
//
//!  DESCRIPTION: This API copies the current rendertarget into the provided system memory buffer.
//!
//! \since Release: 331
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDev      The device to get primary surface on
//! \param [in]      dwBufferIndex  The index of the buffer that will receive a copy of the rendertarget. 
//!                                 This ordinal is between 0 and the number of buffer created by NvAPI_D3D9_IFR_SetUpTargetBufferToNV12BLVideoSurface().
//! \param [in]      dwTargetWidth  When dwTargetWidth and dwTargetHeight are not 0, a bilinear filtered scaling 
//!                                 will be done before the blit to system memory.
//! \param [in]      dwTargetHeight When dwTargetWidth and dwTargetHeight are not 0, a bilinear filtered scaling 
//!                                 will be done before the blit to system memory.
//!
//! \return ::NVAPI_OK 
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_IFR_TransferRenderTargetToNV12BLVideoSurface_Pvt(IDirect3DDevice9 *pDev, DWORD dwBufferIndex, DWORD dwTargetWidth, DWORD dwTargetHeight, BOOL bUseYUV444 = 0);

#endif // defined(_D3D9_H_) && defined(__cplusplus)

#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_IFR_CreateSharedSurface_Pvt
//
//!
//! \since Release: 331
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDev      The device that creates/owns the shared surface
//! \param [in]      dwWidth  
//! \param [in]      dwHeight 
//!
//! \return ::NVAPI_OK 
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////

typedef void * IFRSharedSurfaceHandle;

NVAPI_INTERFACE NvAPI_D3D9_IFR_CreateSharedSurface_Pvt(IDirect3DDevice9 *pDev, DWORD dwWidth, DWORD dwHeight, IFRSharedSurfaceHandle * phNvIFRSharedSurface);

#endif // defined(_D3D9_H_) && defined(__cplusplus)

#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_IFR_DestroySharedSurface_Pvt
//
//!
//! \since Release: 331
//! 
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDev      The device that created the shared surface
//!
//! \return ::NVAPI_OK 
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////


NVAPI_INTERFACE NvAPI_D3D9_IFR_DestroySharedSurface_Pvt(IDirect3DDevice9 *pDev, IFRSharedSurfaceHandle hNvIFRSharedSurface);

#endif // defined(_D3D9_H_) && defined(__cplusplus)

#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_IFR_CopyToSharedSurface_Pvt
//
//!
//! \since Release: 331
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDev      The device that will do the blit
//!
//! \return ::NVAPI_OK 
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////


NVAPI_INTERFACE NvAPI_D3D9_IFR_CopyToSharedSurface_Pvt(IDirect3DDevice9 *pDev, IFRSharedSurfaceHandle hNvIFRSharedSurface, IDirect3DSurface9 * pSurface);

#endif // defined(_D3D9_H_) && defined(__cplusplus)

#if defined(_D3D9_H_) && defined(__cplusplus)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_IFR_CopyFromSharedSurface_Pvt
//
//!
//! \since Release: 331
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDev      The device that will do the blit
//!
//! \return ::NVAPI_OK 
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////


NVAPI_INTERFACE NvAPI_D3D9_IFR_CopyFromSharedSurface_Pvt(IDirect3DDevice9 *pDev, IFRSharedSurfaceHandle hNvIFRSharedSurface, IDirect3DSurface9 * pSurface);

#endif // defined(_D3D9_H_) && defined(__cplusplus)


//! SUPPORTED OS:  Windows Vista and higher
//!
//-----------------------------------------------------------------------------
// DirectX1x IFR API
//-----------------------------------------------------------------------------

#if defined (__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) ) 

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D1x_IFR_SetUpTargetBufferToSys_Pvt
//
//!   DESCRIPTION: This API allocates n buffers (up to a maximum of 6). 
//!                Additional calls to NvAPI_D3D10_IFR_SetUpTargetBufferToSys() will free the buffers that were allocated previously with the same call on the d3d device. 
//!
//! \since Release: 331
//!
//! \param [in]    pDev       The device to get primary surface on. pDevice can be either ID3D10Device or ID3D10Device1 or ID3D11Device.
//! \param [in]    eFormat    The format of the blit
//! \param [in]    dwNBuffers The number of buffers in ppBuffer (max 6).
//! \param [in]    ppBuffer   A pointer to an array of dwNBuffers (max 6) pointers. Virtual memory buffers will be allocated by the driver.
//!
//! \return ::NVAPI_OK if the call succeeded
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D1x_IFR_SetUpTargetBufferToSys_Pvt(IUnknown *pDevice, NVFBC_BUFFER_FORMAT eFormat, DWORD dwNBuffers, void** ppBuffers);

#endif //defined(__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) )

//! SUPPORTED OS:  Windows Vista and higher
//!
#if defined (__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) ) 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D1x_IFR_TransferRenderTarget_Pvt
//
//!   DESCRIPTION: This API copies the current rendertarget into the provided system memory buffer.
//! \since Release: 331
//!
//! \param [in]   pDev                      The device to get primary surface on. pDevice can be either ID3D10Device or ID3D10Device1 or ID3D11Device.
//! \param [in]   pEvent                    When not NULL, will receive a handle to an event that the driver will signal upon completion of NvAPI_D3D10_IFR_TransferRenderTarget
//! \param [in]   dwBufferIndex             The index of the buffer that will receive a copy of the rendertarget. 
//!!                                        This ordinal is between 0 and the number of buffer created by NvAPI_D3D10_IFR_SetUpTargetBufferToSys.
//! \param [in]   dwTargetWidth             When dwTargetWidth and dwTargetHeight are not 0, a bilinear filtered scaling will be done before the blit to system memory.
//! \param [in]   dwTargetHeight            When dwTargetWidth and dwTargetHeight are not 0, a bilinear filtered scaling will be done before the blit to system memory.
//! \param [in]   dwRenderTargetIndex       The index of the rendertarget that will be copied.
//! \param [in]   dwRenderTargetArraySlice  The array slice we want copied
//!
//! \return ::NVAPI_OK if the call succeeded
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D1x_IFR_TransferRenderTarget_Pvt(IUnknown *pDevice, HANDLE * pEvent, DWORD dwBufferIndex, 
                                                        DWORD dwTargetWidth, DWORD dwTargetHeight,
                                                        DWORD dwRenderTargetIndex, DWORD dwRenderTargetArraySlice);

#endif //defined(__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) )


//! SUPPORTED OS:  Windows Vista and higher
//!
#if defined (__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) ) 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D1x_IFR_SetUpTargetBufferToNV12BLVideoSurface_Pvt
//
//!   DESCRIPTION: This API requests the driver to allocate n buffers (up to a maximum of 3). 
//!                Additional calls to NvAPI_DxD1x_IFR_SetUpTargetBufferToNV12BLVideoSurface() will free the buffers that were allocated previously with the same call on the d3d device. 
//!
//!
//! \since Release: 331
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]   pDevice    The device to get primary surface on
//! \param [in]   dwNBuffers The number of buffers in ppBuffer (max 3).
//! \param [in]   aHandles   A pointer to an array of videolibrary surfaces.
//!
//! \return ::NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_D3D1x_IFR_SetUpTargetBufferToNV12BLVideoSurface_Pvt(IUnknown *pDevice, DWORD dwNBuffers, HANDLE * aHandles, DWORD dwTargetWidth, DWORD dwTargetHeight);

#endif //defined(__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) )

//! SUPPORTED OS:  Windows Vista and higher
//!
#if defined (__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) ) 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D1x_IFR_SetUpVideoTargetBuffer_Pvt
//
//!   DESCRIPTION: This API requests the driver to allocate n buffers (up to a maximum of 3). 
//!                Additional calls to NvAPI_D3D1x_IFR_SetUpVideoTargetBuffer_Pvt() will free the buffers that were allocated previously with the same call on the d3d device. 
//!                This API replaces NvAPI_D3D1x_IFR_SetUpTargetBufferToNV12BLVideoSurface_Pvt
//!
//!
//! \since Release: 349
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]   Param struct of type NVIFR_SETUP_VIDEO_TARGET_BUFFER_PARAMS
//!
//! \return ::NVAPI_OK
//! \return ::NVAPI_INVALID_POINTER
//! \return ::NVAPI_INVALID_ARGUMENT
//! \return ::NVAPI_INVALID_HANDLE
//
///////////////////////////////////////////////////////////////////////////////
typedef struct _NVIFR_SETUP_VIDEO_TARGET_BUFFER_PARAMS_V1
{
    NvU32 version;
    NvU32 numBuffers;       // [in] The number of buffers in aHandles
    IUnknown *device;       // [in] The device to get primary surface on
    HANDLE *handles;        // [in] A pointer to an array of videolibrary surfaces
    NvU32  format;          // [in] Video buffer format
    NvU32  width;           // [in] Buffer width
    NvU32  height;          // [in] Buffer Height
}NVIFR_SETUP_VIDEO_TARGET_BUFFER_PARAMS_V1;

typedef NVIFR_SETUP_VIDEO_TARGET_BUFFER_PARAMS_V1      NVIFR_SETUP_VIDEO_TARGET_BUFFER_PARAMS;
#define NVIFR_SETUP_VIDEO_TARGET_BUFFER_PARAMS_VER1    MAKE_NVAPI_VERSION(NVIFR_SETUP_VIDEO_TARGET_BUFFER_PARAMS_V1, 1)
#define NVIFR_SETUP_VIDEO_TARGET_BUFFER_PARAMS_VER     NVIFR_SETUP_VIDEO_TARGET_BUFFER_PARAMS_VER1

NVAPI_INTERFACE NvAPI_D3D1x_IFR_SetUpVideoTargetBuffer_Pvt(NVIFR_SETUP_VIDEO_TARGET_BUFFER_PARAMS params);

#endif //defined(__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) )

//! SUPPORTED OS:  Windows Vista and higher
//!
#if defined (__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) ) 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D1x_IFR_TransferRenderTargetToNV12BLVideoSurface_Pvt
//
//!  DESCRIPTION: This API copies the current rendertarget into the provided system memory buffer.
//!
//! \since Release: 331
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]      pDevice      The device to get primary surface on
//! \param [in]      dwBufferIndex  The index of the buffer that will receive a copy of the rendertarget. 
//!                                 This ordinal is between 0 and the number of buffer created by NvAPI_D3D1x_IFR_SetUpTargetBufferToNV12BLVideoSurface().
//! \param [in]      dwTargetWidth  When dwTargetWidth and dwTargetHeight are not 0, a bilinear filtered scaling 
//!                                 will be done before the blit to system memory.
//! \param [in]      dwTargetHeight When dwTargetWidth and dwTargetHeight are not 0, a bilinear filtered scaling 
//!                                 will be done before the blit to system memory.
//! \param [in]   dwRenderTargetIndex       The index of the rendertarget that will be copied.
//! \param [in]   dwRenderTargetArraySlice  The array slice we want copied
//!
//! \return ::NVAPI_OK 
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D1x_IFR_TransferRenderTargetToNV12BLVideoSurface_Pvt(IUnknown *pDevice, DWORD dwBufferIndex, DWORD dwTargetWidth, DWORD dwTargetHeight, DWORD dwRenderTargetIndex, DWORD dwRenderTargetArraySlice);

#endif //defined(__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) )

//! SUPPORTED OS:  Windows Vista and higher
//!
#if defined (__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) ) 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D1x_DisableShaderDiskCache
//
//! DESCRIPTION: Disables driver managed caching of shader compilations to disk
//!
//! \param [in]    pDevice               Device to disabled the shader disk cache on
//!
//!
//! \retval ::NVAPI_OK                   Shader disk cache was disabled
//! \retval ::NVAPI_ERROR                The operation failed.
//! \retval ::NVAPI_INVALID_ARGUMENT     Argument passed in is invalid.
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D1x_DisableShaderDiskCache(IUnknown *pDevice);

#endif //defined(__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) )

//! SUPPORTED OS:  Windows Vista and higher
//!
#if defined (__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) ) 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D1x_HintCreateLowLatencyDevice
//
//! DESCRIPTION: Hint driver what type of D3D1x device has to be created
//!
//! \param [in]    bool                  true  - Next CreateDevice call has to create low latency device.
//!										 false - Next CreateDevice call has to create normal device.
//!												 Caller has explicitely change state of the hint from true to false     
//!												 after low latency device is created.
//!												 Default hint state is false.
//! \retval ::NVAPI_OK                   Hint is set.
//! \retval ::NVAPI_ERROR                Hint was not set.
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D1x_HintCreateLowLatencyDevice(bool bCreateLowLatencyDevice);


#endif //defined(__cplusplus) && ( defined(__d3d10_h__) || defined(__d3d10_1_h__) ||defined(__d3d11_h__) )

//! SUPPORTED OS:  Windows Vista and higher
//!
#if defined (__cplusplus) && defined(__d3d11_h__) 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_SetDirectVRMode
//
//! DESCRIPTION: Request to enable direct VR extension. Also automatically disables auto stereo.
//!
//! \retval ::NVAPI_OK                   Direct VR mode is set.
//! \retval ::NVAPI_ERROR                Request to enable direct VR mode failed.
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_SetDirectVRMode();


#endif //defined(__cplusplus) && defined(__d3d11_h__)

//! SUPPORTED OS:  Windows Vista and higher
//!
#if defined (__cplusplus) && defined(__d3d11_h__) 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_Multiview_CreateRenderTargets
//
//! DESCRIPTION: Creates additional multi view render targets and link them together
//!
//! \param [in]    pResource             Pointer to original render target for which extra render targets are being created.
//! \param [inout] pNViews               Pointer to number of views being created. Returns number of extra render target created.
//! \param [in]    pViewports            Pointer to viewports for all views if original render target is bloated.
//! \param [out]   pOutResources         Pointer to array of created extra render targets.
//! \retval ::NVAPI_OK                   Call successful.
//! \retval ::NVAPI_ERROR                Call failed.
///////////////////////////////////////////////////////////////////////////////

//! \ingroup dx
NVAPI_INTERFACE NvAPI_D3D11_Multiview_CreateRenderTargets(__in ID3D11Resource *pResource, __inout DWORD *pNViews, __in D3D11_VIEWPORT *pViewports, __out ID3D11Resource **pOutResources);

#endif //defined(__cplusplus) && defined(__d3d11_h__)

//! SUPPORTED OS:  Windows Vista and higher
//!
#if defined (__cplusplus) && defined(__d3d11_h__) 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_Multiview_GetSetConstantBuffersInterface
//
//! DESCRIPTION: Returns structure of addresses of all NvAPI SetConstantBuffers interface
//!
//! \param [in]	                         pSetConstantBuffersInterface pointer to a SetConstantBuffers interface structure.
//!                                      Each SetConstantBuffers function independent of type takes the same set of parameters.
//!                                      Its syntax is as follows:
//!                                      XXSetConstantBuffers(__in ID3D11DeviceContext *pContext, __in UINT StartSlot, __in UINT NumBuffers, __in ID3D11Buffer *const *ppConstantBuffers);
//!                                      where:
//!     \param [in]	   pContext				 Device context. Only immidiate context	is allowed.
//!     \param [in]    StartSlot             Index into the device's zero-based array to begin setting constant buffers to. 
//!     \param [in]    NumBuffers            Number of buffers to set. The total expected number of buffers pointed by ppConstantBuffers is 
//                                           NumBuffers * (number of previously defined views). This call is similar to GSSetConstantBuffers() 
//                                           except that it expects a set of constant buffers for each view in the current configuration.
//!     \param [in]    ppConstantBuffers     Pointer to array of constant buffers being given to the device.
//! 										 If ppConstantBuffers == NULL then all referenced slots will be unbinded from constant buffers.
//!     \retval ::NVAPI_OK                   Call successful.
//!     \retval ::NVAPI_ERROR                Call failed.
//! \retval ::NVAPI_OK                   Call successful.
///////////////////////////////////////////////////////////////////////////////

//! \ingroup dx
typedef NvAPI_Status(__cdecl *NvAPI_D3D11_Multiview_SetConstantBuffersFn)(__in ID3D11DeviceContext *pContext, __in UINT StartSlot, __in UINT NumBuffers, __in ID3D11Buffer *const *ppConstantBuffers);

//! \ingroup dx
//! Used in NvAPI_D3D11_Multiview_GetSetConstantBuffersInterface().
typedef struct 
{
    NvAPI_D3D11_Multiview_SetConstantBuffersFn VSSetConstantBuffers;
    NvAPI_D3D11_Multiview_SetConstantBuffersFn PSSetConstantBuffers;
    NvAPI_D3D11_Multiview_SetConstantBuffersFn GSSetConstantBuffers;
    NvAPI_D3D11_Multiview_SetConstantBuffersFn DSSetConstantBuffers;
    NvAPI_D3D11_Multiview_SetConstantBuffersFn HSSetConstantBuffers;
    NvAPI_D3D11_Multiview_SetConstantBuffersFn CSSetConstantBuffers;
} NV_SET_CONSTANT_BUFFERS_INTERFACE, *PNV_SET_CONSTANT_BUFFERS_INTERFACE;

//! \ingroup dx
NVAPI_INTERFACE NvAPI_D3D11_Multiview_GetSetConstantBuffersInterface(__out PNV_SET_CONSTANT_BUFFERS_INTERFACE  pSetConstantBuffersInterface);

#endif //defined(__cplusplus) && defined(__d3d11_h__)

//! SUPPORTED OS:  Windows Vista and higher
//!
#if defined (__cplusplus) && defined(__d3d11_h__) 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_Multiview_Sync
//
//! DESCRIPTION: Resolves given resource content on main GPU for broadcast SLI.
//!
//! \param [in]    pResource             Pointer to a resource that needs to be synched.
//! \retval ::NVAPI_OK                   Call successful.
//! \retval ::NVAPI_ERROR                Call failed.
///////////////////////////////////////////////////////////////////////////////

//! \ingroup dx
NVAPI_INTERFACE NvAPI_D3D11_Multiview_Sync(__in ID3D11Resource *pResource);

#endif //defined(__cplusplus) && defined(__d3d11_h__)

//! SUPPORTED OS:  Windows Vista and higher
//!
#if defined (__cplusplus) && defined(__d3d11_h__) 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_SetVRSLI
//
//! DESCRIPTION: Creates additional multi view render targets and link them together
//!
//! \param [in]    pDevice               Pointer to device. 
//! \retval ::NVAPI_OK                   Call successful.
//! \retval ::NVAPI_ERROR                Call failed.
///////////////////////////////////////////////////////////////////////////////

//! \ingroup dx
NVAPI_INTERFACE NvAPI_D3D11_SetVRSLI(__in ID3D11Device *pDevice);

#endif //defined(__cplusplus) && defined(__d3d11_h__)

//! SUPPORTED OS:  Windows Vista and higher
//!
#if defined (__cplusplus) && defined(__d3d11_h__) 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_MultiGPU_GetCaps
//
//! DESCRIPTION: Request to get multi GPU extension caps.
//!
//! \param [out]    pMultiGPUCaps        Pointer to a structure returning multi GPU caps
//! \retval ::NVAPI_OK                   Call succeeded.
//! \retval ::NVAPI_ERROR                Call failed.
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
//! \ingroup dx
typedef struct 
{
    NvU32 multiGPUVersion;
    NvU32 reserved;
    NvU32 nTotalGPUs;
    NvU32 nSLIGPUs;
    NvU32 videoBridgePresent;
} NV_MULTIGPU_CAPS, *PNV_MULTIGPU_CAPS;

//! \ingroup dx
NVAPI_INTERFACE NvAPI_D3D11_MultiGPU_GetCaps(__out PNV_MULTIGPU_CAPS pMultiGPUCaps);

#endif //defined(__cplusplus) && defined(__d3d11_h__)

//! SUPPORTED OS:  Windows Vista and higher
//!
#if defined (__cplusplus) && defined(__d3d11_h__) 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_MultiGPU_Init
//
//! DESCRIPTION: Request to enable/disable multi GPU extension. Also if enabled automatically disables auto stereo.
//!
//! \param [in]    bEnable               if true enables the extension for all subsequently created devices. Otherwise disables it
//! \retval ::NVAPI_OK                   Call succeeded.
//! \retval ::NVAPI_ERROR                Call failed.
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D11_MultiGPU_Init(__in bool bEnable);

#endif //defined(__cplusplus) && defined(__d3d11_h__)

//! SUPPORTED OS:  Windows Vista and higher
//!
#if defined (__cplusplus) && defined(__d3d11_h__) 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D11_CreateMultiGPUDevice
//! \code
//!   DESCRIPTION: This function returns ID3D11MultiGPUDevice used for multi GPU VR support
//!
//!         \param [in]        pDevice                  current d3d device
//!         \param [in]        version                  version of requested ID3D11MultiGPUDevice. 
//!         \param [out]       currentVersion           pointer to returned current version of ID3D11MultiGPUDevice. 
//!         \param [out]       ppD3D11MultiGPUDevice    pointer to returned ID3D11MultiGPUDevice. 
//!
//!
//! \return ::NVAPI_OK     if the call succeeds.
//! \endcode
///////////////////////////////////////////////////////////////////////////////

#if !defined(__d3d11_2_h__)
typedef void* ID3D11DeviceContext2;
typedef void*  D3D11_TILED_RESOURCE_COORDINATE;
typedef void*  D3D11_TILE_REGION_SIZE;
#endif

#if !defined(__d3d11_1_h__)
typedef void* ID3D11DeviceContext1;
#endif

//! \ingroup dx

#define NVAPI_COPY_ASYNCHRONOUSLY					 1
#define NVAPI_CPU_RESOURCE					0xffffffff 

DECLARE_INTERFACE(ID3D11MultiGPUDevice_V1)
{
    STDMETHOD_(void,Destroy)(THIS) PURE;
    STDMETHOD_(UINT,SetGPUMask)(THIS_ __in UINT GPUMask) PURE;
    STDMETHOD_(NvAPI_Status,CopySubresourceRegion)(THIS_ __in ID3D11DeviceContext *pContext, __in ID3D11Resource *pDstResource, __in UINT DstSubresource, 
                                                   __in UINT DstGPUIndex, __in UINT DstX, __in UINT DstY, __in UINT DstZ, 
                                                   __in ID3D11Resource *pSrcResource, __in UINT SrcSubresource, __in UINT SrcGPUIndex, 
                                                   __in const D3D11_BOX *pSrcBox, __in UINT ExtendedFlags = 0) PURE;
    STDMETHOD_(NvAPI_Status,CopySubresourceRegion1)(THIS_ __in ID3D11DeviceContext1 *pContext1, __in ID3D11Resource *pDstResource, __in UINT DstSubresource, 
                                                   __in UINT DstGPUIndex, __in UINT DstX, __in UINT DstY, __in UINT DstZ, 
                                                   __in ID3D11Resource *pSrcResource, __in UINT SrcSubresource, __in UINT SrcGPUIndex, 
                                                   __in const D3D11_BOX *pSrcBox, __in UINT CopyFlags, __in UINT ExtendedFlags = 0 ) PURE;
    STDMETHOD_(NvAPI_Status,UpdateSubresource)(THIS_ __in ID3D11DeviceContext *pContext,__in ID3D11Resource *pDstResource, __in UINT DstSubresource, __in UINT DstGPUIndex, 
                                               __in const D3D11_BOX *pDstBox, __in const void *pSrcData, __in UINT SrcRowPitch, __in UINT SrcDepthPitch) PURE;
    STDMETHOD_(NvAPI_Status,VSSetConstantBuffers)(THIS_ __in ID3D11DeviceContext *pContext, __in UINT GPUMask, __in UINT StartSlot, 
                                                 __in UINT NumBuffers, __in ID3D11Buffer *const *ppConstantBuffers,
                                                 __in UINT *const pFirstConstant = NULL, __in UINT *const pNumConstants = NULL) PURE;
    STDMETHOD_(NvAPI_Status,PSSetConstantBuffers)(THIS_ __in ID3D11DeviceContext *pContext, __in UINT GPUMask, __in UINT StartSlot, 
                                                 __in UINT NumBuffers, __in ID3D11Buffer *const *ppConstantBuffers,
                                                 __in UINT *const pFirstConstant = NULL, __in UINT *const pNumConstants = NULL) PURE;
    STDMETHOD_(NvAPI_Status,GSSetConstantBuffers)(THIS_ __in ID3D11DeviceContext *pContext, __in UINT GPUMask, __in UINT StartSlot, 
                                                 __in UINT NumBuffers, __in ID3D11Buffer *const *ppConstantBuffers,
                                                 __in UINT *const pFirstConstant = NULL, __in UINT *const pNumConstants = NULL) PURE;
    STDMETHOD_(NvAPI_Status,DSSetConstantBuffers)(THIS_ __in ID3D11DeviceContext *pContext, __in UINT GPUMask, __in UINT StartSlot, 
                                                 __in UINT NumBuffers, __in ID3D11Buffer *const *ppConstantBuffers,
                                                 __in UINT *const pFirstConstant = NULL, __in UINT *const pNumConstants = NULL) PURE;
    STDMETHOD_(NvAPI_Status,HSSetConstantBuffers)(THIS_ __in ID3D11DeviceContext *pContext, __in UINT GPUMask, __in UINT StartSlot, 
                                                 __in UINT NumBuffers, __in ID3D11Buffer *const *ppConstantBuffers,
                                                 __in UINT *const pFirstConstant = NULL, __in UINT *const pNumConstants = NULL) PURE;
    STDMETHOD_(NvAPI_Status,CSSetConstantBuffers)(THIS_ __in ID3D11DeviceContext *pContext, __in UINT GPUMask, __in UINT StartSlot, 
                                                 __in UINT NumBuffers, __in ID3D11Buffer *const *ppConstantBuffers,
                                                 __in UINT *const pFirstConstant = NULL, __in UINT *const pNumConstants = NULL) PURE;
    STDMETHOD_(NvAPI_Status,SetViewports)(THIS_ __in ID3D11DeviceContext *pContext, __in UINT GPUMask, __in UINT NumViewports, 
                                          __in const D3D11_VIEWPORT *pViewports) PURE;
    STDMETHOD_(NvAPI_Status,SetScissorRects)(THIS_ __in ID3D11DeviceContext *pContext, __in UINT GPUMask, __in UINT NumRects, 
                                            __in const D3D11_RECT *pRects) PURE;
    STDMETHOD_(HRESULT,GetData)(THIS_ __in ID3D11DeviceContext *pContext, __in ID3D11Asynchronous *pAsync, __in UINT GPUIndex, 
                                    __out void *pData, __in UINT DataSize, __in UINT GetDataFlags) PURE;
    STDMETHOD_(NvAPI_Status,UpdateTiles)(THIS_ __in ID3D11DeviceContext2 *pContext2, __in ID3D11Resource *pDestTiledResource, 
                                        __in UINT GPUMask, __in const D3D11_TILED_RESOURCE_COORDINATE *pDestTileRegionStartCoordinate, 
                                        __in const D3D11_TILE_REGION_SIZE *pDestTileRegionSize, __in const void *pSourceTileData, 
                                        __in UINT Flags) PURE;
    STDMETHOD_(NvAPI_Status,CreateFences)(THIS_ __in UINT count, __out void **ppFences) PURE;
    STDMETHOD_(NvAPI_Status,SetFence)(THIS_ __in UINT GPUIndex, __in void *hFence, __in UINT64 value) PURE;
    STDMETHOD_(NvAPI_Status,WaitForFence)(THIS_ __in UINT GPUIMask, __in void *hFence, __in UINT64 value) PURE;
    STDMETHOD_(NvAPI_Status,FreeFences)(THIS_ __in UINT count, __in void **ppFences) PURE;
    STDMETHOD_(NvAPI_Status,PresentCompositingConfig )(THIS_ __in IDXGISwapChain *pSwapChain, __in UINT GPUMask, 
                                         __in const D3D11_RECT *pRects, __in UINT flags) PURE;
};

//! PresentCompositingConfig method flags.
#define NVAPI_PRESENT_COMPOSITING_CONFIG_FLAG_USE_VIDEO_BRIDGE    1
#define NVAPI_PRESENT_COMPOSITING_CONFIG_FLAG_CLEAR_OUTBANDS      2

#define NVAPI_ALL_GPUS				0
typedef ID3D11MultiGPUDevice_V1     ID3D11MultiGPUDevice;
#define ID3D11MultiGPUDevice_VER1   MAKE_NVAPI_VERSION(ID3D11MultiGPUDevice_V1, 1)
#define ID3D11MultiGPUDevice_VER    ID3D11MultiGPUDevice_VER1

//! \ingroup dx
NVAPI_INTERFACE NvAPI_D3D11_CreateMultiGPUDevice(__in ID3D11Device *pDevice, __in ULONG version, __out ULONG *currentVersion, __out ID3D11MultiGPUDevice **ppD3D11MultiGPUDevice);

#endif //defined(__cplusplus) && defined(__d3d11_h__)


#if defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))

typedef NvU32 NV_DIRECT_MODE_SURFACE_HANDLE;

typedef struct _NV_DIRECT_MODE_INFO_V1
{
    NvU32                       version;          //!< The version of the structure
    NvU32                       width;
    NvU32                       height;
    NV_DISPLAY_REFRESH_RATE     refresh;
    NV_FORMAT                   format;
    NvU32                       ScanlineOrdering; //!< 0 - Unspecified; 1 - Progressive; 2 - Interlaced
    NV_SCALING                  scaling;
} NV_DIRECT_MODE_INFO_V1;

#define NV_DIRECT_MODE_INFO_VER1   MAKE_NVAPI_VERSION(NV_DIRECT_MODE_INFO_V1, 1)

#define NV_DIRECT_MODE_INFO_VER    NV_DIRECT_MODE_INFO_VER1
typedef NV_DIRECT_MODE_INFO_V1     NV_DIRECT_MODE_INFO;

#endif // defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))

#if defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_D3D_AcquireDirectModeDisplay
//
//!   DESCRIPTION:  This API acquires exclusive access to the specified Direct mode display
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! 
//! \param [in]     vendorId        Vendor Id of the target VR solution
//! \param [in]     pDevice         The device created by the vendor's implementation
//! \param [in,out] phDisplay       A pointer to NV_DIRECT_MODE_DISPLAY_HANDLE structure. 
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval  NVAPI_OK         Completed request
//!
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_AcquireDirectModeDisplay(__in NvU32 vendorId, __in IDXGIDevice *pDevice, __inout NV_DIRECT_MODE_DISPLAY_HANDLE *phDisplay);

#endif // defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))

#if defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_D3D_ReleaseDirectModeDisplay
//
//!   DESCRIPTION:  This API releases the exclusive access to the specified Direct mode display
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! 
//! \param [in]     vendorId        Vendor Id of the target VR solution              
//! \param [in/out] phDisplay       A pointer to NV_DIRECT_MODE_DISPLAY_HANDLE structure. 
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval  NVAPI_OK         Completed request
//!
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_ReleaseDirectModeDisplay(__in NvU32 vendorId, __inout NV_DIRECT_MODE_DISPLAY_HANDLE *phDisplay);

#endif //defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))

#if defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D_DirectModeCreateSurface
//
//! DESCRIPTION: Request to allocate a presentable render target on specified display out.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in/out] hDisplay        A pointer to NV_DIRECT_MODE_DISPLAY_HANDLE structure. 
//! \param [in]     pModeInfo       Mode info that surface needs to match.
//! \param [out]    phSurface       A pointer to NV_DIRECT_MODE_SURFACE_HANDLE.
//! \param [out]    phSharedHandle  A pointer to returned DX surface
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_DirectModeCreateSurface(__inout NV_DIRECT_MODE_DISPLAY_HANDLE* phDisplay, 
                                                  __in NV_DIRECT_MODE_INFO *pModeInfo, 
                                                  __out NV_DIRECT_MODE_SURFACE_HANDLE *phSurface, 
                                                  __out HANDLE *phSharedHandle);

#endif //defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))

#if defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D_DirectModeDestroySurface
//
//! DESCRIPTION: Request to destroy the presentable render target earlier created using NvAPI_D3D_DirectModeCreateSurface.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in/out] hDisplay       A pointer to NV_DIRECT_MODE_DISPLAY_HANDLE structure. 
//! \param [in]    hSurface        A NV_DIRECT_MODE_SURFACE_HANDLE that was previously obtained using NvAPI_D3D_DirectModeCreateSurface
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_DirectModeDestroySurface(__inout NV_DIRECT_MODE_DISPLAY_HANDLE* phDisplay, __in NV_DIRECT_MODE_SURFACE_HANDLE hSurface);

#endif //defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))

#if defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))

//! \ingroup dx
//! See NvAPI_D3D11_DirectModePresent
typedef enum _NVAPI_DIRECTMODE_PRESENT_FLAG
{
    NV_DIRECTMODE_PRESENT_FLAG_NONE  = 0,
    NV_DIRECTMODE_PRESENT_FLAG_VSYNC,               //!< Present according to vsync interval
} NVAPI_DIRECTMODE_PRESENT_FLAG;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D_DirectModePresent
//
//! DESCRIPTION: Request to present a DirectMode surface.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]    hDisplay      A pointer to NV_DIRECT_MODE_DISPLAY_HANDLE structure. 
//! \param [in]    hSurface      A NV_DIRECT_MODE_SURFACE_HANDLE that was previously obtained using NvAPI_D3D_DirectModeCreateSurface
//! \param [in]    flag          Option for controlling presentation
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_DirectModePresent(__in NV_DIRECT_MODE_DISPLAY_HANDLE* phDisplay, __in NV_DIRECT_MODE_SURFACE_HANDLE hSurface, __in NVAPI_DIRECTMODE_PRESENT_FLAG flag);

#endif //defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))

#if defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
typedef struct _NV_DIRECT_MODE_PRESENT_STATS_V1
{
    NvU32                       version;            //!< The version of the structure
    NV_DISPLAY_REFRESH_RATE     refresh;            //!< Current refresh rate
    NvU32                       frameIndex;         //!< A monotonically incrementing frame index (incremented on vsync)
    NvU64                       timeOfLastVSync;    //!< QPC time of last vsync
}NV_DIRECT_MODE_PRESENT_STATS_V1;

#define NV_DIRECT_MODE_PRESENT_STATS_VER1   MAKE_NVAPI_VERSION(NV_DIRECT_MODE_PRESENT_STATS_V1, 1)

#define NV_DIRECT_MODE_PRESENT_STATS_VER    NV_DIRECT_MODE_PRESENT_STATS_VER1
typedef NV_DIRECT_MODE_PRESENT_STATS_V1     NV_DIRECT_MODE_PRESENT_STATS;

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_D3D_GetDirectModePresentStats
//
//!   DESCRIPTION:  This API gets Present statistics
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! 
//! \param [in]     hDisplay     A pointer to NV_DIRECT_MODE_DISPLAY_HANDLE structure. 
//! \param [IN,out] pStatsInfo   Pointer to a NV_DIRECT_MODE_PRESENT_STATS structure which will be filled in by the API.
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_GetDirectModePresentStats(__in NV_DIRECT_MODE_DISPLAY_HANDLE* phDisplay, __inout NV_DIRECT_MODE_PRESENT_STATS* pStatsInfo);

#endif //defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))

#if defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_D3D_DirectModeSetDisplayMode
//
//!   DESCRIPTION:  This API sets the source mode for the specified direct mode display.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]    hDisplay     A pointer to NV_DIRECT_MODE_DISPLAY_HANDLE structure. 
//! \param [in]    pModeInfo    The mode info that needs to be applied
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_DirectModeSetDisplayMode(__in NV_DIRECT_MODE_DISPLAY_HANDLE* phDisplay, __in NV_DIRECT_MODE_INFO* pModeInfo);
#endif //defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))

#if defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))

typedef enum _NV_DIRECTMODE_GETMODES_FLAG
{
    NV_DIRECTMODE_GETMODES_FLAG_SUPPORTED = 0,  //!< Used to fetch all the supported modes
    NV_DIRECTMODE_GETMODES_FLAG_CURRENT         //!< Used to fetch the currently applied mode
}NV_DIRECTMODE_GETMODES_FLAG;

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_D3D_DirectModeGetDisplayModes
//
//!   DESCRIPTION:  This API gets all the supported source modes or the currently applied mode
//!                 for the direct mode display. 
//!                 To get a count of the supported modes, the user can call with pModeInfo set to NULL. 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]     phDisplay    A pointer to NV_DIRECT_MODE_DISPLAY_HANDLE structure. 
//! \param [in/out] modeCount    When flag is NV_GET_DIRECTMODE_FLAG_CURRENT, 
//!                                  - *modeCount should be set to 1 and a single NV_DIRECT_MODE_INFO should be allocated for pModeInfo.
//!                              When flag is NV_GET_DIRECTMODE_FLAG_SUPPORTED,
//!                                  -  during input, *modeCount is the number of entries allocated in pModeInfo.
//!                                  -  during output, *modeCount is the number of actual supported modes.
//! \param [out]    pModeInfo    Pointer to a NV_DIRECT_MODE_INFO structure which will be filled in by the API.
//! \param [in]     flag         A NV_GET_DIRECTMODE_FLAG type to control which modes to be returned.
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval  NVAPI_INSUFFICIENT_BUFFER  When the input buffer(pModeInfo)'s size(*modeCount) is less than the supported modes. 
//!                                     The *modeCount will return the actual supported modeInfo count.
//!
//! \retval  NVAPI_INVALID_ARGUMENT     When NV_GET_MODE_CURRENT is passed in flag and *modeCount != 1, then this error is returned.
//!
//! \ingroup dx
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D_DirectModeGetDisplayModes(
                            __in NV_DIRECT_MODE_DISPLAY_HANDLE* phDisplay,
                            __inout NvU32 *modeCount,
                            __inout_opt NV_DIRECT_MODE_INFO* pModeInfo,
                            __in NV_DIRECTMODE_GETMODES_FLAG flag);

#endif //defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))


/////////////////////////////////////////////////////////////////////////
// Video Input Output (VIO) API
/////////////////////////////////////////////////////////////////////////



//! \ingroup vidio
//! Unique identifier for VIO owner (process identifier or NVVIOOWNERID_NONE)
typedef NvU32   NVVIOOWNERID;                               


//! \addtogroup vidio
//! @{


#define NVVIOOWNERID_NONE                   0      //!< Unregistered ownerId        


//! Owner type for device
typedef enum _NVVIOOWNERTYPE                               
{
    NVVIOOWNERTYPE_NONE                             ,       //!<  No owner for the device
    NVVIOOWNERTYPE_APPLICATION                      ,       //!<  Application owns the device
    NVVIOOWNERTYPE_DESKTOP                          ,       //!<  Desktop transparent mode owns the device (not applicable for video input)
}NVVIOOWNERTYPE;

// Access rights for NvAPI_VIO_Open()

//! Read access             (not applicable for video output)
#define NVVIO_O_READ                        0x00000000      

//! Write exclusive access  (not applicable for video input)
#define NVVIO_O_WRITE_EXCLUSIVE             0x00010001      

//! 
#define NVVIO_VALID_ACCESSRIGHTS            (NVVIO_O_READ              | \
                                             NVVIO_O_WRITE_EXCLUSIVE   )

              
//! VIO_DATA.ulOwnerID high-bit is set only if device has been initialized by VIOAPI
//! examined at NvAPI_GetCapabilities|NvAPI_VIO_Open to determine if settings need to be applied from registry or POR state read
#define NVVIO_OWNERID_INITIALIZED  0x80000000

//! VIO_DATA.ulOwnerID next-bit is set only if device is currently in exclusive write access mode from NvAPI_VIO_Open()
#define NVVIO_OWNERID_EXCLUSIVE    0x40000000
                                              
//! VIO_DATA.ulOwnerID lower bits are:
//!  NVGVOOWNERTYPE_xxx enumerations indicating use context
#define NVVIO_OWNERID_TYPEMASK     0x0FFFFFFF //!< mask for NVVIOOWNERTYPE_xxx


//! @}
              
//---------------------------------------------------------------------
// Enumerations
//---------------------------------------------------------------------


//! \addtogroup vidio
//! @{

//! Video signal format and resolution
typedef enum _NVVIOSIGNALFORMAT
{
    NVVIOSIGNALFORMAT_NONE,                //!< Invalid signal format 
    NVVIOSIGNALFORMAT_487I_59_94_SMPTE259_NTSC,     //!< 01  487i    59.94Hz  (SMPTE259) NTSC
    NVVIOSIGNALFORMAT_576I_50_00_SMPTE259_PAL,      //!< 02  576i    50.00Hz  (SMPTE259) PAL
    NVVIOSIGNALFORMAT_1035I_60_00_SMPTE260,         //!< 03  1035i   60.00Hz  (SMPTE260)
    NVVIOSIGNALFORMAT_1035I_59_94_SMPTE260,         //!< 04  1035i   59.94Hz  (SMPTE260)
    NVVIOSIGNALFORMAT_1080I_50_00_SMPTE295,         //!< 05  1080i   50.00Hz  (SMPTE295)
    NVVIOSIGNALFORMAT_1080I_60_00_SMPTE274,         //!< 06  1080i   60.00Hz  (SMPTE274)
    NVVIOSIGNALFORMAT_1080I_59_94_SMPTE274,         //!< 07  1080i   59.94Hz  (SMPTE274)
    NVVIOSIGNALFORMAT_1080I_50_00_SMPTE274,         //!< 08  1080i   50.00Hz  (SMPTE274)
    NVVIOSIGNALFORMAT_1080P_30_00_SMPTE274,         //!< 09  1080p   30.00Hz  (SMPTE274)
    NVVIOSIGNALFORMAT_1080P_29_97_SMPTE274,         //!< 10  1080p   29.97Hz  (SMPTE274)
    NVVIOSIGNALFORMAT_1080P_25_00_SMPTE274,         //!< 11  1080p   25.00Hz  (SMPTE274)
    NVVIOSIGNALFORMAT_1080P_24_00_SMPTE274,         //!< 12  1080p   24.00Hz  (SMPTE274)
    NVVIOSIGNALFORMAT_1080P_23_976_SMPTE274,        //!< 13  1080p   23.976Hz (SMPTE274)
    NVVIOSIGNALFORMAT_720P_60_00_SMPTE296,          //!< 14  720p    60.00Hz  (SMPTE296)
    NVVIOSIGNALFORMAT_720P_59_94_SMPTE296,          //!< 15  720p    59.94Hz  (SMPTE296)
    NVVIOSIGNALFORMAT_720P_50_00_SMPTE296,          //!< 16  720p    50.00Hz  (SMPTE296)
    NVVIOSIGNALFORMAT_1080I_48_00_SMPTE274,         //!< 17  1080I   48.00Hz  (SMPTE274)
    NVVIOSIGNALFORMAT_1080I_47_96_SMPTE274,         //!< 18  1080I   47.96Hz  (SMPTE274)
    NVVIOSIGNALFORMAT_720P_30_00_SMPTE296,          //!< 19  720p    30.00Hz  (SMPTE296)
    NVVIOSIGNALFORMAT_720P_29_97_SMPTE296,          //!< 20  720p    29.97Hz  (SMPTE296)
    NVVIOSIGNALFORMAT_720P_25_00_SMPTE296,          //!< 21  720p    25.00Hz  (SMPTE296)
    NVVIOSIGNALFORMAT_720P_24_00_SMPTE296,          //!< 22  720p    24.00Hz  (SMPTE296)
    NVVIOSIGNALFORMAT_720P_23_98_SMPTE296,          //!< 23  720p    23.98Hz  (SMPTE296)
    NVVIOSIGNALFORMAT_2048P_30_00_SMPTE372,         //!< 24  2048p   30.00Hz  (SMPTE372)
    NVVIOSIGNALFORMAT_2048P_29_97_SMPTE372,         //!< 25  2048p   29.97Hz  (SMPTE372)
    NVVIOSIGNALFORMAT_2048I_60_00_SMPTE372,         //!< 26  2048i   60.00Hz  (SMPTE372)
    NVVIOSIGNALFORMAT_2048I_59_94_SMPTE372,         //!< 27  2048i   59.94Hz  (SMPTE372)
    NVVIOSIGNALFORMAT_2048P_25_00_SMPTE372,         //!< 28  2048p   25.00Hz  (SMPTE372)
    NVVIOSIGNALFORMAT_2048I_50_00_SMPTE372,         //!< 29  2048i   50.00Hz  (SMPTE372)
    NVVIOSIGNALFORMAT_2048P_24_00_SMPTE372,         //!< 30  2048p   24.00Hz  (SMPTE372)
    NVVIOSIGNALFORMAT_2048P_23_98_SMPTE372,         //!< 31  2048p   23.98Hz  (SMPTE372)
    NVVIOSIGNALFORMAT_2048I_48_00_SMPTE372,         //!< 32  2048i   48.00Hz  (SMPTE372)
    NVVIOSIGNALFORMAT_2048I_47_96_SMPTE372,         //!< 33  2048i   47.96Hz  (SMPTE372)
    
    NVVIOSIGNALFORMAT_1080PSF_25_00_SMPTE274,       //!< 34  1080PsF 25.00Hz  (SMPTE274)
    NVVIOSIGNALFORMAT_1080PSF_29_97_SMPTE274,       //!< 35  1080PsF 29.97Hz  (SMPTE274)
    NVVIOSIGNALFORMAT_1080PSF_30_00_SMPTE274,       //!< 36  1080PsF 30.00Hz  (SMPTE274)
    NVVIOSIGNALFORMAT_1080PSF_24_00_SMPTE274,       //!< 37  1080PsF 24.00Hz  (SMPTE274)
    NVVIOSIGNALFORMAT_1080PSF_23_98_SMPTE274,       //!< 38  1080PsF 23.98Hz  (SMPTE274)

    NVVIOSIGNALFORMAT_1080P_50_00_SMPTE274_3G_LEVEL_A, //!< 39  1080P   50.00Hz  (SMPTE274) 3G Level A
    NVVIOSIGNALFORMAT_1080P_59_94_SMPTE274_3G_LEVEL_A, //!< 40  1080P   59.94Hz  (SMPTE274) 3G Level A
    NVVIOSIGNALFORMAT_1080P_60_00_SMPTE274_3G_LEVEL_A, //!< 41  1080P   60.00Hz  (SMPTE274) 3G Level A
    
    NVVIOSIGNALFORMAT_1080P_60_00_SMPTE274_3G_LEVEL_B, //!< 42  1080p   60.00Hz  (SMPTE274) 3G Level B
    NVVIOSIGNALFORMAT_1080I_60_00_SMPTE274_3G_LEVEL_B, //!< 43  1080i   60.00Hz  (SMPTE274) 3G Level B
    NVVIOSIGNALFORMAT_2048I_60_00_SMPTE372_3G_LEVEL_B, //!< 44  2048i   60.00Hz  (SMPTE372) 3G Level B
    NVVIOSIGNALFORMAT_1080P_50_00_SMPTE274_3G_LEVEL_B, //!< 45  1080p   50.00Hz  (SMPTE274) 3G Level B
    NVVIOSIGNALFORMAT_1080I_50_00_SMPTE274_3G_LEVEL_B, //!< 46  1080i   50.00Hz  (SMPTE274) 3G Level B
    NVVIOSIGNALFORMAT_2048I_50_00_SMPTE372_3G_LEVEL_B, //!< 47  2048i   50.00Hz  (SMPTE372) 3G Level B
    NVVIOSIGNALFORMAT_1080P_30_00_SMPTE274_3G_LEVEL_B, //!< 48  1080p   30.00Hz  (SMPTE274) 3G Level B
    NVVIOSIGNALFORMAT_2048P_30_00_SMPTE372_3G_LEVEL_B, //!< 49  2048p   30.00Hz  (SMPTE372) 3G Level B
    NVVIOSIGNALFORMAT_1080P_25_00_SMPTE274_3G_LEVEL_B, //!< 50  1080p   25.00Hz  (SMPTE274) 3G Level B
    NVVIOSIGNALFORMAT_2048P_25_00_SMPTE372_3G_LEVEL_B, //!< 51  2048p   25.00Hz  (SMPTE372) 3G Level B
    NVVIOSIGNALFORMAT_1080P_24_00_SMPTE274_3G_LEVEL_B, //!< 52  1080p   24.00Hz  (SMPTE274) 3G Level B
    NVVIOSIGNALFORMAT_2048P_24_00_SMPTE372_3G_LEVEL_B, //!< 53  2048p   24.00Hz  (SMPTE372) 3G Level B
    NVVIOSIGNALFORMAT_1080I_48_00_SMPTE274_3G_LEVEL_B, //!< 54  1080i   48.00Hz  (SMPTE274) 3G Level B
    NVVIOSIGNALFORMAT_2048I_48_00_SMPTE372_3G_LEVEL_B, //!< 55  2048i   48.00Hz  (SMPTE372) 3G Level B
    NVVIOSIGNALFORMAT_1080P_59_94_SMPTE274_3G_LEVEL_B, //!< 56  1080p   59.94Hz  (SMPTE274) 3G Level B
    NVVIOSIGNALFORMAT_1080I_59_94_SMPTE274_3G_LEVEL_B, //!< 57  1080i   59.94Hz  (SMPTE274) 3G Level B
    NVVIOSIGNALFORMAT_2048I_59_94_SMPTE372_3G_LEVEL_B, //!< 58  2048i   59.94Hz  (SMPTE372) 3G Level B
    NVVIOSIGNALFORMAT_1080P_29_97_SMPTE274_3G_LEVEL_B, //!< 59  1080p   29.97Hz  (SMPTE274) 3G Level B
    NVVIOSIGNALFORMAT_2048P_29_97_SMPTE372_3G_LEVEL_B, //!< 60  2048p   29.97Hz  (SMPTE372) 3G Level B
    NVVIOSIGNALFORMAT_1080P_23_98_SMPTE274_3G_LEVEL_B, //!< 61  1080p   29.98Hz  (SMPTE274) 3G Level B
    NVVIOSIGNALFORMAT_2048P_23_98_SMPTE372_3G_LEVEL_B, //!< 62  2048p   29.98Hz  (SMPTE372) 3G Level B
    NVVIOSIGNALFORMAT_1080I_47_96_SMPTE274_3G_LEVEL_B, //!< 63  1080i   47.96Hz  (SMPTE274) 3G Level B
    NVVIOSIGNALFORMAT_2048I_47_96_SMPTE372_3G_LEVEL_B, //!< 64  2048i   47.96Hz  (SMPTE372) 3G Level B
    
    NVVIOSIGNALFORMAT_END                              //!< 65  To indicate end of signal format list

}NVVIOSIGNALFORMAT;

//! SMPTE standards format
typedef enum _NVVIOVIDEOSTANDARD
{
    NVVIOVIDEOSTANDARD_SMPTE259                        ,       //!< SMPTE259
    NVVIOVIDEOSTANDARD_SMPTE260                        ,       //!< SMPTE260
    NVVIOVIDEOSTANDARD_SMPTE274                        ,       //!< SMPTE274
    NVVIOVIDEOSTANDARD_SMPTE295                        ,       //!< SMPTE295
    NVVIOVIDEOSTANDARD_SMPTE296                        ,       //!< SMPTE296
    NVVIOVIDEOSTANDARD_SMPTE372                        ,       //!< SMPTE372
}NVVIOVIDEOSTANDARD;

//! HD or SD video type
typedef enum _NVVIOVIDEOTYPE
{
    NVVIOVIDEOTYPE_SD                                  ,       //!< Standard-definition (SD)
    NVVIOVIDEOTYPE_HD                                  ,       //!< High-definition     (HD)
}NVVIOVIDEOTYPE;

//! Interlace mode
typedef enum _NVVIOINTERLACEMODE 
{
    NVVIOINTERLACEMODE_PROGRESSIVE                     ,       //!< Progressive               (p)
    NVVIOINTERLACEMODE_INTERLACE                       ,       //!< Interlace                 (i)
    NVVIOINTERLACEMODE_PSF                             ,       //!< Progressive Segment Frame (psf)
}NVVIOINTERLACEMODE;

//! Video data format
typedef enum _NVVIODATAFORMAT
{
    NVVIODATAFORMAT_UNKNOWN   = -1                     ,       //!< Invalid DataFormat
    NVVIODATAFORMAT_R8G8B8_TO_YCRCB444                 ,       //!< R8:G8:B8                => YCrCb  (4:4:4)
    NVVIODATAFORMAT_R8G8B8A8_TO_YCRCBA4444             ,       //!< R8:G8:B8:A8             => YCrCbA (4:4:4:4)
    NVVIODATAFORMAT_R8G8B8Z10_TO_YCRCBZ4444            ,       //!< R8:G8:B8:Z10            => YCrCbZ (4:4:4:4)
    NVVIODATAFORMAT_R8G8B8_TO_YCRCB422                 ,       //!< R8:G8:B8                => YCrCb  (4:2:2)
    NVVIODATAFORMAT_R8G8B8A8_TO_YCRCBA4224             ,       //!< R8:G8:B8:A8             => YCrCbA (4:2:2:4)
    NVVIODATAFORMAT_R8G8B8Z10_TO_YCRCBZ4224            ,       //!< R8:G8:B8:Z10            => YCrCbZ (4:2:2:4)
    NVVIODATAFORMAT_X8X8X8_444_PASSTHRU                ,       //!< R8:G8:B8                => RGB    (4:4:4)
    NVVIODATAFORMAT_X8X8X8A8_4444_PASSTHRU             ,       //!< R8:G8:B8:A8             => RGBA   (4:4:4:4)
    NVVIODATAFORMAT_X8X8X8Z10_4444_PASSTHRU            ,       //!< R8:G8:B8:Z10            => RGBZ   (4:4:4:4)
    NVVIODATAFORMAT_X10X10X10_444_PASSTHRU             ,       //!< Y10:CR10:CB10           => YCrCb  (4:4:4)
    NVVIODATAFORMAT_X10X8X8_444_PASSTHRU               ,       //!< Y10:CR8:CB8             => YCrCb  (4:4:4)
    NVVIODATAFORMAT_X10X8X8A10_4444_PASSTHRU           ,       //!< Y10:CR8:CB8:A10         => YCrCbA (4:4:4:4)
    NVVIODATAFORMAT_X10X8X8Z10_4444_PASSTHRU           ,       //!< Y10:CR8:CB8:Z10         => YCrCbZ (4:4:4:4)
    NVVIODATAFORMAT_DUAL_R8G8B8_TO_DUAL_YCRCB422       ,       //!< R8:G8:B8 + R8:G8:B8     => YCrCb  (4:2:2 + 4:2:2)
    NVVIODATAFORMAT_DUAL_X8X8X8_TO_DUAL_422_PASSTHRU   ,       //!< Y8:CR8:CB8 + Y8:CR8:CB8 => YCrCb  (4:2:2 + 4:2:2)
    NVVIODATAFORMAT_R10G10B10_TO_YCRCB422              ,       //!< R10:G10:B10             => YCrCb  (4:2:2)
    NVVIODATAFORMAT_R10G10B10_TO_YCRCB444              ,       //!< R10:G10:B10             => YCrCb  (4:4:4)
    NVVIODATAFORMAT_X12X12X12_444_PASSTHRU             ,       //!< X12:X12:X12             => XXX    (4:4:4)
    NVVIODATAFORMAT_X12X12X12_422_PASSTHRU             ,       //!< X12:X12:X12             => XXX    (4:2:2)
    NVVIODATAFORMAT_Y10CR10CB10_TO_YCRCB422            ,       //!< Y10:CR10:CB10           => YCrCb  (4:2:2)
    NVVIODATAFORMAT_Y8CR8CB8_TO_YCRCB422               ,       //!< Y8:CR8:CB8              => YCrCb  (4:2:2)
    NVVIODATAFORMAT_Y10CR8CB8A10_TO_YCRCBA4224         ,       //!< Y10:CR8:CB8:A10         => YCrCbA (4:2:2:4)
    NVVIODATAFORMAT_R10G10B10_TO_RGB444                ,       //!< R10:G10:B10             => RGB    (4:4:4)
    NVVIODATAFORMAT_R12G12B12_TO_YCRCB444              ,       //!< R12:G12:B12             => YCrCb  (4:4:4)
    NVVIODATAFORMAT_R12G12B12_TO_YCRCB422              ,       //!< R12:G12:B12             => YCrCb  (4:2:2)
}NVVIODATAFORMAT;

//! Video output area
typedef enum _NVVIOOUTPUTAREA
{
    NVVIOOUTPUTAREA_FULLSIZE                           ,       //!< Output to entire video resolution (full size)
    NVVIOOUTPUTAREA_SAFEACTION                         ,       //!< Output to centered 90% of video resolution (safe action)
    NVVIOOUTPUTAREA_SAFETITLE                          ,       //!< Output to centered 80% of video resolution (safe title)
}NVVIOOUTPUTAREA;

//! Synchronization source
typedef enum _NVVIOSYNCSOURCE
{
    NVVIOSYNCSOURCE_SDISYNC                            ,       //!< SDI Sync  (Digital input)
    NVVIOSYNCSOURCE_COMPSYNC                           ,       //!< COMP Sync (Composite input)
}NVVIOSYNCSOURCE;

//! Composite synchronization type
typedef enum _NVVIOCOMPSYNCTYPE
{
    NVVIOCOMPSYNCTYPE_AUTO                             ,       //!< Auto-detect
    NVVIOCOMPSYNCTYPE_BILEVEL                          ,       //!< Bi-level signal
    NVVIOCOMPSYNCTYPE_TRILEVEL                         ,       //!< Tri-level signal
}NVVIOCOMPSYNCTYPE;

//! Video input output status
typedef enum _NVVIOINPUTOUTPUTSTATUS
{
    NVINPUTOUTPUTSTATUS_OFF                            ,       //!< Not in use
    NVINPUTOUTPUTSTATUS_ERROR                          ,       //!< Error detected
    NVINPUTOUTPUTSTATUS_SDI_SD                         ,       //!< SDI (standard-definition)
    NVINPUTOUTPUTSTATUS_SDI_HD                         ,       //!< SDI (high-definition)
}NVVIOINPUTOUTPUTSTATUS;

//! Synchronization input status
typedef enum _NVVIOSYNCSTATUS
{
    NVVIOSYNCSTATUS_OFF                                ,       //!< Sync not detected
    NVVIOSYNCSTATUS_ERROR                              ,       //!< Error detected
    NVVIOSYNCSTATUS_SYNCLOSS                           ,       //!< Genlock in use, format mismatch with output
    NVVIOSYNCSTATUS_COMPOSITE                          ,       //!< Composite sync
    NVVIOSYNCSTATUS_SDI_SD                             ,       //!< SDI sync (standard-definition)
    NVVIOSYNCSTATUS_SDI_HD                             ,       //!< SDI sync (high-definition)
}NVVIOSYNCSTATUS;

//! Video Capture Status
typedef enum _NVVIOCAPTURESTATUS
{
    NVVIOSTATUS_STOPPED                                ,       //!< Sync not detected
    NVVIOSTATUS_RUNNING                                ,       //!< Error detected
    NVVIOSTATUS_ERROR                                  ,       //!< Genlock in use, format mismatch with output
}NVVIOCAPTURESTATUS;

//! Video Capture Status
typedef enum _NVVIOSTATUSTYPE
{
    NVVIOSTATUSTYPE_IN                                 ,       //!< Input Status
    NVVIOSTATUSTYPE_OUT                                ,       //!< Output Status
}NVVIOSTATUSTYPE;


//! Assumption, maximum 4 SDI input and 4 SDI output cards supported on a system
#define NVAPI_MAX_VIO_DEVICES                 8   

//! 4 physical jacks supported on each SDI input card.
#define NVAPI_MAX_VIO_JACKS                   4   


//! Each physical jack an on SDI input card can have
//! two "channels" in the case of "3G" VideoFormats, as specified
//! by SMPTE 425; for non-3G VideoFormats, only the first channel within
//! a physical jack is valid.
#define NVAPI_MAX_VIO_CHANNELS_PER_JACK       2   

//! 4 Streams, 1 per physical jack
#define NVAPI_MAX_VIO_STREAMS                 4   

#define NVAPI_MIN_VIO_STREAMS                 1   

//! SDI input supports a max of 2 links per stream
#define NVAPI_MAX_VIO_LINKS_PER_STREAM        2   


#define NVAPI_MAX_FRAMELOCK_MAPPING_MODES     20

//! Min number of capture images 
#define NVAPI_GVI_MIN_RAW_CAPTURE_IMAGES      1   

//! Max number of capture images        
#define NVAPI_GVI_MAX_RAW_CAPTURE_IMAGES      32  

//! Default number of capture images
#define NVAPI_GVI_DEFAULT_RAW_CAPTURE_IMAGES  5   



// Data Signal notification events. These need a event handler in RM.
// Register/Unregister and PopEvent NVAPI's are already available.

//! Device configuration
typedef enum _NVVIOCONFIGTYPE
{
    NVVIOCONFIGTYPE_IN                                 ,       //!< Input Status
    NVVIOCONFIGTYPE_OUT                                ,       //!< Output Status
}NVVIOCONFIGTYPE;

typedef enum _NVVIOCOLORSPACE
{
    NVVIOCOLORSPACE_UNKNOWN,
    NVVIOCOLORSPACE_YCBCR,
    NVVIOCOLORSPACE_YCBCRA,
    NVVIOCOLORSPACE_YCBCRD,
    NVVIOCOLORSPACE_GBR,
    NVVIOCOLORSPACE_GBRA,
    NVVIOCOLORSPACE_GBRD,
} NVVIOCOLORSPACE;

//! Component sampling
typedef enum _NVVIOCOMPONENTSAMPLING
{
    NVVIOCOMPONENTSAMPLING_UNKNOWN,
    NVVIOCOMPONENTSAMPLING_4444,
    NVVIOCOMPONENTSAMPLING_4224,
    NVVIOCOMPONENTSAMPLING_444,
    NVVIOCOMPONENTSAMPLING_422
} NVVIOCOMPONENTSAMPLING;

typedef enum _NVVIOBITSPERCOMPONENT
{
    NVVIOBITSPERCOMPONENT_UNKNOWN,
    NVVIOBITSPERCOMPONENT_8,
    NVVIOBITSPERCOMPONENT_10,
    NVVIOBITSPERCOMPONENT_12,
} NVVIOBITSPERCOMPONENT;

typedef enum _NVVIOLINKID 
{
    NVVIOLINKID_UNKNOWN,
    NVVIOLINKID_A,
    NVVIOLINKID_B,
    NVVIOLINKID_C,
    NVVIOLINKID_D
} NVVIOLINKID;


typedef enum _NVVIOANCPARITYCOMPUTATION
{
    NVVIOANCPARITYCOMPUTATION_AUTO,
    NVVIOANCPARITYCOMPUTATION_ON,
    NVVIOANCPARITYCOMPUTATION_OFF
} NVVIOANCPARITYCOMPUTATION;



//! @}


//---------------------------------------------------------------------
// Structures
//---------------------------------------------------------------------

//! \addtogroup vidio
//! @{


//! Supports Serial Digital Interface (SDI) output
#define NVVIOCAPS_VIDOUT_SDI                0x00000001      

//! Supports Internal timing source
#define NVVIOCAPS_SYNC_INTERNAL             0x00000100      

//! Supports Genlock timing source
#define NVVIOCAPS_SYNC_GENLOCK              0x00000200      

//! Supports Serial Digital Interface (SDI) synchronization input
#define NVVIOCAPS_SYNCSRC_SDI               0x00001000      

//! Supports Composite synchronization input
#define NVVIOCAPS_SYNCSRC_COMP              0x00002000      

//! Supports Desktop transparent mode
#define NVVIOCAPS_OUTPUTMODE_DESKTOP        0x00010000      

//! Supports OpenGL application mode
#define NVVIOCAPS_OUTPUTMODE_OPENGL         0x00020000      

//! Supports Serial Digital Interface (SDI) input
#define NVVIOCAPS_VIDIN_SDI                 0x00100000  

//! Supports Packed ANC
#define NVVIOCAPS_PACKED_ANC_SUPPORTED      0x00200000     

//! Supports ANC audio blanking
#define NVVIOCAPS_AUDIO_BLANKING_SUPPORTED  0x00400000  

//! SDI-class interface: SDI output with two genlock inputs
#define NVVIOCLASS_SDI                      0x00000001      

//! Device capabilities
typedef struct _NVVIOCAPS
{
    NvU32             version;                              //!< Structure version
    NvAPI_String      adapterName;                          //!< Graphics adapter name
    NvU32             adapterClass;                         //!< Graphics adapter classes (NVVIOCLASS_SDI mask)
    NvU32             adapterCaps;                          //!< Graphics adapter capabilities (NVVIOCAPS_* mask)
    NvU32             dipSwitch;                            //!< On-board DIP switch settings bits
    NvU32             dipSwitchReserved;                    //!< On-board DIP switch settings reserved bits
    NvU32             boardID;                              //!< Board ID
    //! Driver version
    struct                                                  //
    {                                                      
        NvU32          majorVersion;                        //!< Major version. For GVI, majorVersion contains MajorVersion(HIWORD) And MinorVersion(LOWORD)
        NvU32          minorVersion;                        //!< Minor version. For GVI, minorVersion contains Revison(HIWORD) And Build(LOWORD)
    } driver;                                               //
    //! Firmware version 
    struct                                                  
    {                                                       
        NvU32          majorVersion;                        //!< Major version. In version 2, for both GVI and GVO, majorVersion contains MajorVersion(HIWORD) And MinorVersion(LOWORD)
        NvU32          minorVersion;                        //!< Minor version. In version 2, for both GVI and GVO, minorVersion contains Revison(HIWORD) And Build(LOWORD)
    } firmWare;                                             //
    NVVIOOWNERID      ownerId;                              //!< Unique identifier for owner of video output (NVVIOOWNERID_INVALID if free running)
    NVVIOOWNERTYPE    ownerType;                            //!< Owner type (OpenGL application or Desktop mode)
} NVVIOCAPS;

//! Macro for constructing the version field of NVVIOCAPS
#define NVVIOCAPS_VER1  MAKE_NVAPI_VERSION(NVVIOCAPS,1)
#define NVVIOCAPS_VER2  MAKE_NVAPI_VERSION(NVVIOCAPS,2)
#define NVVIOCAPS_VER   NVVIOCAPS_VER2

//! Input channel status
typedef struct _NVVIOCHANNELSTATUS
{
    NvU32                  smpte352;                         //!< 4-byte SMPTE 352 video payload identifier
    NVVIOSIGNALFORMAT      signalFormat;                     //!< Signal format
    NVVIOBITSPERCOMPONENT  bitsPerComponent;                 //!< Bits per component
    NVVIOCOMPONENTSAMPLING samplingFormat;                   //!< Sampling format
    NVVIOCOLORSPACE        colorSpace;                       //!< Color space
    NVVIOLINKID            linkID;                           //!< Link ID
} NVVIOCHANNELSTATUS;

//! Input device status
typedef struct _NVVIOINPUTSTATUS
{
    NVVIOCHANNELSTATUS     vidIn[NVAPI_MAX_VIO_JACKS][NVAPI_MAX_VIO_CHANNELS_PER_JACK];     //!< Video input status per channel within a jack
    NVVIOCAPTURESTATUS     captureStatus;                  //!< status of video capture
} NVVIOINPUTSTATUS;

//! Output device status
typedef struct _NVVIOOUTPUTSTATUS
{
    NVVIOINPUTOUTPUTSTATUS    vid1Out;                        //!< Video 1 output status
    NVVIOINPUTOUTPUTSTATUS    vid2Out;                        //!< Video 2 output status
    NVVIOSYNCSTATUS        sdiSyncIn;                      //!< SDI sync input status
    NVVIOSYNCSTATUS        compSyncIn;                     //!< Composite sync input status
    NvU32            syncEnable;                     //!< Sync enable (TRUE if using syncSource)
    NVVIOSYNCSOURCE        syncSource;                     //!< Sync source
    NVVIOSIGNALFORMAT        syncFormat;                     //!< Sync format
    NvU32            frameLockEnable;                //!< Framelock enable flag
    NvU32            outputVideoLocked;              //!< Output locked status
    NvU32            dataIntegrityCheckErrorCount;   //!< Data integrity check error count
    NvU32            dataIntegrityCheckEnabled;      //!< Data integrity check status enabled 
    NvU32            dataIntegrityCheckFailed;       //!< Data integrity check status failed 
    NvU32                       uSyncSourceLocked;              //!< genlocked to framelocked to ref signal
    NvU32                       uPowerOn;                       //!< TRUE: indicates there is sufficient power
} NVVIOOUTPUTSTATUS;

//! Video device status.
typedef struct _NVVIOSTATUS
{
    NvU32                 version;                        //!< Structure version
    NVVIOSTATUSTYPE       nvvioStatusType;                //!< Input or Output status
    union                                                   
    {
        NVVIOINPUTSTATUS  inStatus;                       //!<  Input device status
        NVVIOOUTPUTSTATUS outStatus;                      //!<  Output device status
    }vioStatus;      
} NVVIOSTATUS;

//! Macro for constructingthe version field of NVVIOSTATUS
#define NVVIOSTATUS_VER   MAKE_NVAPI_VERSION(NVVIOSTATUS,1)

//! Output region
typedef struct _NVVIOOUTPUTREGION
{
    NvU32              x;                                    //!< Horizontal origin in pixels
    NvU32              y;                                    //!< Vertical origin in pixels
    NvU32              width;                                //!< Width of region in pixels
    NvU32              height;                               //!< Height of region in pixels
} NVVIOOUTPUTREGION;

//! Gamma ramp (8-bit index)
typedef struct _NVVIOGAMMARAMP8
{
    NvU16              uRed[256];                            //!< Red channel gamma ramp (8-bit index, 16-bit values)
    NvU16              uGreen[256];                          //!< Green channel gamma ramp (8-bit index, 16-bit values)
    NvU16              uBlue[256];                           //!< Blue channel gamma ramp (8-bit index, 16-bit values)
} NVVIOGAMMARAMP8;

//! Gamma ramp (10-bit index)
typedef struct _NVVIOGAMMARAMP10
{
    NvU16              uRed[1024];                           //!< Red channel gamma ramp (10-bit index, 16-bit values)
    NvU16              uGreen[1024];                         //!< Green channel gamma ramp (10-bit index, 16-bit values)
    NvU16              uBlue[1024];                          //!< Blue channel gamma ramp (10-bit index, 16-bit values)
} NVVIOGAMMARAMP10;


//! Sync delay
typedef struct _NVVIOSYNCDELAY
{
    NvU32              version;                              //!< Structure version
    NvU32              horizontalDelay;                      //!< Horizontal delay in pixels
    NvU32              verticalDelay;                        //!< Vertical delay in lines
} NVVIOSYNCDELAY;

//! Macro for constructing the version field of NVVIOSYNCDELAY
#define NVVIOSYNCDELAY_VER   MAKE_NVAPI_VERSION(NVVIOSYNCDELAY,1)


//! Video mode information
typedef struct _NVVIOVIDEOMODE
{
    NvU32                horizontalPixels;                   //!< Horizontal resolution (in pixels)
    NvU32                verticalLines;                      //!< Vertical resolution for frame (in lines)
    float                fFrameRate;                         //!< Frame rate
    NVVIOINTERLACEMODE   interlaceMode;                      //!< Interlace mode 
    NVVIOVIDEOSTANDARD   videoStandard;                      //!< SMPTE standards format
    NVVIOVIDEOTYPE       videoType;                          //!< HD or SD signal classification
} NVVIOVIDEOMODE;

//! Signal format details
typedef struct _NVVIOSIGNALFORMATDETAIL
{   
    NVVIOSIGNALFORMAT    signalFormat;                       //!< Signal format enumerated value
    NVVIOVIDEOMODE       videoMode;                          //!< Video mode for signal format
}NVVIOSIGNALFORMATDETAIL;


//! R8:G8:B8
#define NVVIOBUFFERFORMAT_R8G8B8                  0x00000001
 
//! R8:G8:B8:Z24  
#define NVVIOBUFFERFORMAT_R8G8B8Z24               0x00000002
   
//! R8:G8:B8:A8
#define NVVIOBUFFERFORMAT_R8G8B8A8                0x00000004   

//! R8:G8:B8:A8:Z24       
#define NVVIOBUFFERFORMAT_R8G8B8A8Z24             0x00000008   

//! R16FP:G16FP:B16FP
#define NVVIOBUFFERFORMAT_R16FPG16FPB16FP         0x00000010   

//! R16FP:G16FP:B16FP:Z24
#define NVVIOBUFFERFORMAT_R16FPG16FPB16FPZ24      0x00000020   

//! R16FP:G16FP:B16FP:A16FP
#define NVVIOBUFFERFORMAT_R16FPG16FPB16FPA16FP    0x00000040   

//! R16FP:G16FP:B16FP:A16FP:Z24
#define NVVIOBUFFERFORMAT_R16FPG16FPB16FPA16FPZ24 0x00000080   



//! Data format details
typedef struct _NVVIODATAFORMATDETAIL
{
    NVVIODATAFORMAT   dataFormat;                              //!< Data format enumerated value
    NvU32             vioCaps;                                 //!< Data format capabilities (NVVIOCAPS_* mask)
}NVVIODATAFORMATDETAIL;

//! Colorspace conversion
typedef struct _NVVIOCOLORCONVERSION
{
    NvU32       version;                                    //!<  Structure version
    float       colorMatrix[3][3];                          //!<  Output[n] =
    float       colorOffset[3];                             //!<  Input[0] * colorMatrix[n][0] +
    float       colorScale[3];                              //!<  Input[1] * colorMatrix[n][1] +
                                                            //!<  Input[2] * colorMatrix[n][2] +
                                                            //!<  OutputRange * colorOffset[n]
                                                            //!<  where OutputRange is the standard magnitude of
                                                            //!<  Output[n][n] and colorMatrix and colorOffset 
                                                            //!<  values are within the range -1.0 to +1.0
    NvU32      compositeSafe;                               //!<  compositeSafe constrains luminance range when using composite output
} NVVIOCOLORCONVERSION;

//! macro for constructing the version field of _NVVIOCOLORCONVERSION.
#define NVVIOCOLORCONVERSION_VER   MAKE_NVAPI_VERSION(NVVIOCOLORCONVERSION,1)

//! Gamma correction
typedef struct _NVVIOGAMMACORRECTION
{
    NvU32            version;                               //!< Structure version
    NvU32            vioGammaCorrectionType;                //!< Gamma correction type (8-bit or 10-bit)
    //! Gamma correction:
    union                                                   
    {                                                       
        NVVIOGAMMARAMP8  gammaRamp8;                        //!< Gamma ramp (8-bit index, 16-bit values)
        NVVIOGAMMARAMP10 gammaRamp10;                       //!< Gamma ramp (10-bit index, 16-bit values)
    }gammaRamp;                                      
    float            fGammaValueR;            //!< Red Gamma value within gamma ranges. 0.5 - 6.0
    float            fGammaValueG;            //!< Green Gamma value within gamma ranges. 0.5 - 6.0
    float            fGammaValueB;            //!< Blue Gamma value within gamma ranges. 0.5 - 6.0
} NVVIOGAMMACORRECTION;

//! Macro for constructing thevesion field of _NVVIOGAMMACORRECTION
#define NVVIOGAMMACORRECTION_VER   MAKE_NVAPI_VERSION(NVVIOGAMMACORRECTION,1)

//! Maximum number of ranges per channel
#define MAX_NUM_COMPOSITE_RANGE      2                      


typedef struct _NVVIOCOMPOSITERANGE
{
    NvU32   uRange;
    NvU32   uEnabled;
    NvU32   uMin;
    NvU32   uMax;
} NVVIOCOMPOSITERANGE;



// Device configuration (fields masks indicating NVVIOCONFIG fields to use for NvAPI_VIO_GetConfig/NvAPI_VIO_SetConfig() )
//
#define NVVIOCONFIG_SIGNALFORMAT            0x00000001      //!< fields: signalFormat
#define NVVIOCONFIG_DATAFORMAT              0x00000002      //!< fields: dataFormat
#define NVVIOCONFIG_OUTPUTREGION            0x00000004      //!< fields: outputRegion
#define NVVIOCONFIG_OUTPUTAREA              0x00000008      //!< fields: outputArea
#define NVVIOCONFIG_COLORCONVERSION         0x00000010      //!< fields: colorConversion
#define NVVIOCONFIG_GAMMACORRECTION         0x00000020      //!< fields: gammaCorrection
#define NVVIOCONFIG_SYNCSOURCEENABLE        0x00000040      //!< fields: syncSource and syncEnable
#define NVVIOCONFIG_SYNCDELAY               0x00000080      //!< fields: syncDelay
#define NVVIOCONFIG_COMPOSITESYNCTYPE       0x00000100      //!< fields: compositeSyncType
#define NVVIOCONFIG_FRAMELOCKENABLE         0x00000200      //!< fields: EnableFramelock
#define NVVIOCONFIG_422FILTER               0x00000400      //!< fields: bEnable422Filter
#define NVVIOCONFIG_COMPOSITETERMINATE      0x00000800      //!< fields: bCompositeTerminate (Not supported on Quadro FX 4000 SDI)         
#define NVVIOCONFIG_DATAINTEGRITYCHECK      0x00001000      //!< fields: bEnableDataIntegrityCheck (Not supported on Quadro FX 4000 SDI)
#define NVVIOCONFIG_CSCOVERRIDE             0x00002000      //!< fields: colorConversion override
#define NVVIOCONFIG_FLIPQUEUELENGTH         0x00004000      //!< fields: flipqueuelength control
#define NVVIOCONFIG_ANCTIMECODEGENERATION   0x00008000      //!< fields: bEnableANCTimeCodeGeneration
#define NVVIOCONFIG_COMPOSITE               0x00010000      //!< fields: bEnableComposite
#define NVVIOCONFIG_ALPHAKEYCOMPOSITE       0x00020000      //!< fields: bEnableAlphaKeyComposite
#define NVVIOCONFIG_COMPOSITE_Y             0x00040000      //!< fields: compRange
#define NVVIOCONFIG_COMPOSITE_CR            0x00080000      //!< fields: compRange
#define NVVIOCONFIG_COMPOSITE_CB            0x00100000      //!< fields: compRange
#define NVVIOCONFIG_FULL_COLOR_RANGE        0x00200000      //!< fields: bEnableFullColorRange
#define NVVIOCONFIG_RGB_DATA                0x00400000      //!< fields: bEnableRGBData
#define NVVIOCONFIG_RESERVED_SDIOUTPUTENABLE         0x00800000      //!< fields: bEnableSDIOutput
#define NVVIOCONFIG_STREAMS                 0x01000000      //!< fields: streams
#define NVVIOCONFIG_ANC_PARITY_COMPUTATION  0x02000000      //!< fields: ancParityComputation
#define NVVIOCONFIG_ANC_AUDIO_REPEAT		0x04000000      //!< fields: enableAudioBlanking
 

// Don't forget to update NVVIOCONFIG_VALIDFIELDS in nvapi.spec when NVVIOCONFIG_ALLFIELDS changes.
#define NVVIOCONFIG_ALLFIELDS   ( NVVIOCONFIG_SIGNALFORMAT          | \
                                  NVVIOCONFIG_DATAFORMAT            | \
                                  NVVIOCONFIG_OUTPUTREGION          | \
                                  NVVIOCONFIG_OUTPUTAREA            | \
                                  NVVIOCONFIG_COLORCONVERSION       | \
                                  NVVIOCONFIG_GAMMACORRECTION       | \
                                  NVVIOCONFIG_SYNCSOURCEENABLE      | \
                                  NVVIOCONFIG_SYNCDELAY             | \
                                  NVVIOCONFIG_COMPOSITESYNCTYPE     | \
                                  NVVIOCONFIG_FRAMELOCKENABLE       | \
                                  NVVIOCONFIG_422FILTER             | \
                                  NVVIOCONFIG_COMPOSITETERMINATE    | \
                                  NVVIOCONFIG_DATAINTEGRITYCHECK    | \
                                  NVVIOCONFIG_CSCOVERRIDE           | \
                                  NVVIOCONFIG_FLIPQUEUELENGTH       | \
                                  NVVIOCONFIG_ANCTIMECODEGENERATION | \
                                  NVVIOCONFIG_COMPOSITE             | \
                                  NVVIOCONFIG_ALPHAKEYCOMPOSITE     | \
                                  NVVIOCONFIG_COMPOSITE_Y           | \
                                  NVVIOCONFIG_COMPOSITE_CR          | \
                                  NVVIOCONFIG_COMPOSITE_CB          | \
                                  NVVIOCONFIG_FULL_COLOR_RANGE      | \
                                  NVVIOCONFIG_RGB_DATA              | \
                                  NVVIOCONFIG_RESERVED_SDIOUTPUTENABLE | \
                                  NVVIOCONFIG_STREAMS               | \
                                  NVVIOCONFIG_ANC_PARITY_COMPUTATION | \
								  NVVIOCONFIG_ANC_AUDIO_REPEAT )

#define NVVIOCONFIG_VALIDFIELDS  ( NVVIOCONFIG_SIGNALFORMAT          | \
                                   NVVIOCONFIG_DATAFORMAT            | \
                                   NVVIOCONFIG_OUTPUTREGION          | \
                                   NVVIOCONFIG_OUTPUTAREA            | \
                                   NVVIOCONFIG_COLORCONVERSION       | \
                                   NVVIOCONFIG_GAMMACORRECTION       | \
                                   NVVIOCONFIG_SYNCSOURCEENABLE      | \
                                   NVVIOCONFIG_SYNCDELAY             | \
                                   NVVIOCONFIG_COMPOSITESYNCTYPE     | \
                                   NVVIOCONFIG_FRAMELOCKENABLE       | \
                                   NVVIOCONFIG_RESERVED_SDIOUTPUTENABLE | \
                                   NVVIOCONFIG_422FILTER             | \
                                   NVVIOCONFIG_COMPOSITETERMINATE    | \
                                   NVVIOCONFIG_DATAINTEGRITYCHECK    | \
                                   NVVIOCONFIG_CSCOVERRIDE           | \
                                   NVVIOCONFIG_FLIPQUEUELENGTH       | \
                                   NVVIOCONFIG_ANCTIMECODEGENERATION | \
                                   NVVIOCONFIG_COMPOSITE             | \
                                   NVVIOCONFIG_ALPHAKEYCOMPOSITE     | \
                                   NVVIOCONFIG_COMPOSITE_Y           | \
                                   NVVIOCONFIG_COMPOSITE_CR          | \
                                   NVVIOCONFIG_COMPOSITE_CB          | \
                                   NVVIOCONFIG_FULL_COLOR_RANGE      | \
                                   NVVIOCONFIG_RGB_DATA              | \
                                   NVVIOCONFIG_RESERVED_SDIOUTPUTENABLE | \
                                   NVVIOCONFIG_STREAMS               | \
                                   NVVIOCONFIG_ANC_PARITY_COMPUTATION | \
								   NVVIOCONFIG_ANC_AUDIO_REPEAT)

#define NVVIOCONFIG_DRIVERFIELDS ( NVVIOCONFIG_OUTPUTREGION          | \
                                   NVVIOCONFIG_OUTPUTAREA            | \
                                   NVVIOCONFIG_COLORCONVERSION       | \
                                   NVVIOCONFIG_FLIPQUEUELENGTH)

#define NVVIOCONFIG_GAMMAFIELDS  ( NVVIOCONFIG_GAMMACORRECTION       )

#define NVVIOCONFIG_RMCTRLFIELDS ( NVVIOCONFIG_SIGNALFORMAT          | \
                                   NVVIOCONFIG_DATAFORMAT            | \
                                   NVVIOCONFIG_SYNCSOURCEENABLE      | \
                                   NVVIOCONFIG_COMPOSITESYNCTYPE     | \
                                   NVVIOCONFIG_FRAMELOCKENABLE       | \
                                   NVVIOCONFIG_422FILTER             | \
                                   NVVIOCONFIG_COMPOSITETERMINATE    | \
                                   NVVIOCONFIG_DATAINTEGRITYCHECK    | \
                                   NVVIOCONFIG_COMPOSITE             | \
                                   NVVIOCONFIG_ALPHAKEYCOMPOSITE     | \
                                   NVVIOCONFIG_COMPOSITE_Y           | \
                                   NVVIOCONFIG_COMPOSITE_CR          | \
                                   NVVIOCONFIG_COMPOSITE_CB)

#define NVVIOCONFIG_RMSKEWFIELDS ( NVVIOCONFIG_SYNCDELAY             )

#define NVVIOCONFIG_ALLOWSDIRUNNING_FIELDS ( NVVIOCONFIG_DATAINTEGRITYCHECK     | \
                                             NVVIOCONFIG_SYNCDELAY              | \
                                             NVVIOCONFIG_CSCOVERRIDE            | \
                                             NVVIOCONFIG_ANCTIMECODEGENERATION  | \
                                             NVVIOCONFIG_COMPOSITE              | \
                                             NVVIOCONFIG_ALPHAKEYCOMPOSITE      | \
                                             NVVIOCONFIG_COMPOSITE_Y            | \
                                             NVVIOCONFIG_COMPOSITE_CR           | \
                                             NVVIOCONFIG_COMPOSITE_CB           | \
                                             NVVIOCONFIG_ANC_PARITY_COMPUTATION)

                                             
 #define NVVIOCONFIG_RMMODESET_FIELDS ( NVVIOCONFIG_SIGNALFORMAT         | \
                                        NVVIOCONFIG_DATAFORMAT           | \
                                        NVVIOCONFIG_SYNCSOURCEENABLE     | \
                                        NVVIOCONFIG_FRAMELOCKENABLE      | \
                                        NVVIOCONFIG_COMPOSITESYNCTYPE	 | \
										NVVIOCONFIG_ANC_AUDIO_REPEAT)                                            
                                             

//! Output device configuration 
// No members can be deleted from below structure. Only add new members at the 
// end of the structure.
typedef struct _NVVIOOUTPUTCONFIG_V1
{
    NVVIOSIGNALFORMAT    signalFormat;                         //!< Signal format for video output
    NVVIODATAFORMAT      dataFormat;                           //!< Data format for video output
    NVVIOOUTPUTREGION    outputRegion;                         //!< Region for video output (Desktop mode)
    NVVIOOUTPUTAREA      outputArea;                           //!< Usable resolution for video output (safe area)
    NVVIOCOLORCONVERSION colorConversion;                      //!< Color conversion.
    NVVIOGAMMACORRECTION gammaCorrection;
    NvU32                syncEnable;                           //!< Sync enable (TRUE to use syncSource)
    NVVIOSYNCSOURCE      syncSource;                           //!< Sync source
    NVVIOSYNCDELAY       syncDelay;                            //!< Sync delay
    NVVIOCOMPSYNCTYPE    compositeSyncType;                    //!< Composite sync type
    NvU32                frameLockEnable;                      //!< Flag indicating whether framelock was on/off
    NvU32                psfSignalFormat;                      //!< Indicates whether contained format is PSF Signal format
    NvU32                enable422Filter;                      //!< Enables/Disables 4:2:2 filter
    NvU32                compositeTerminate;                   //!< Composite termination
    NvU32                enableDataIntegrityCheck;             //!< Enable data integrity check: true - enable, false - disable
    NvU32                cscOverride;                          //!< Use provided CSC color matrix to overwrite 
    NvU32                flipQueueLength;                      //!< Number of buffers used for the internal flipqueue
    NvU32                enableANCTimeCodeGeneration;          //!< Enable SDI ANC time code generation
    NvU32                enableComposite;                      //!< Enable composite
    NvU32                enableAlphaKeyComposite;              //!< Enable Alpha key composite
    NVVIOCOMPOSITERANGE  compRange;                            //!< Composite ranges
    NvU8                 reservedData[256];                    //!< Inicates last stored SDI output state TRUE-ON / FALSE-OFF
    NvU32                enableFullColorRange;                 //!< Flag indicating Full Color Range
    NvU32                enableRGBData;                        //!< Indicates data is in RGB format
} NVVIOOUTPUTCONFIG_V1;

typedef struct _NVVIOOUTPUTCONFIG_V2
{
    NVVIOSIGNALFORMAT    signalFormat;                         //!< Signal format for video output
    NVVIODATAFORMAT      dataFormat;                           //!< Data format for video output
    NVVIOOUTPUTREGION    outputRegion;                         //!< Region for video output (Desktop mode)
    NVVIOOUTPUTAREA      outputArea;                           //!< Usable resolution for video output (safe area)
    NVVIOCOLORCONVERSION colorConversion;                      //!< Color conversion.
    NVVIOGAMMACORRECTION gammaCorrection;
    NvU32                syncEnable;                           //!< Sync enable (TRUE to use syncSource)
    NVVIOSYNCSOURCE      syncSource;                           //!< Sync source
    NVVIOSYNCDELAY       syncDelay;                            //!< Sync delay
    NVVIOCOMPSYNCTYPE    compositeSyncType;                    //!< Composite sync type
    NvU32                frameLockEnable;                      //!< Flag indicating whether framelock was on/off
    NvU32                psfSignalFormat;                      //!< Indicates whether contained format is PSF Signal format
    NvU32                enable422Filter;                      //!< Enables/Disables 4:2:2 filter
    NvU32                compositeTerminate;                   //!< Composite termination
    NvU32                enableDataIntegrityCheck;             //!< Enable data integrity check: true - enable, false - disable
    NvU32                cscOverride;                          //!< Use provided CSC color matrix to overwrite
    NvU32                flipQueueLength;                      //!< Number of buffers used for the internal flip queue
    NvU32                enableANCTimeCodeGeneration;          //!< Enable SDI ANC time code generation
    NvU32                enableComposite;                      //!< Enable composite
    NvU32                enableAlphaKeyComposite;              //!< Enable Alpha key composite
    NVVIOCOMPOSITERANGE  compRange;                            //!< Composite ranges
    NvU8                 reservedData[256];                    //!< Indicates last stored SDI output state TRUE-ON / FALSE-OFF
    NvU32                enableFullColorRange;                 //!< Flag indicating Full Color Range
    NvU32                enableRGBData;                        //!< Indicates data is in RGB format
    NVVIOANCPARITYCOMPUTATION ancParityComputation;            //!< Enable HW ANC parity bit computation (auto/on/off)
} NVVIOOUTPUTCONFIG_V2;

typedef struct _NVVIOOUTPUTCONFIG_V3
{
    NVVIOSIGNALFORMAT    signalFormat;                         //!< Signal format for video output
    NVVIODATAFORMAT      dataFormat;                           //!< Data format for video output
    NVVIOOUTPUTREGION    outputRegion;                         //!< Region for video output (Desktop mode)
    NVVIOOUTPUTAREA      outputArea;                           //!< Usable resolution for video output (safe area)
    NVVIOCOLORCONVERSION colorConversion;                      //!< Color conversion.
    NVVIOGAMMACORRECTION gammaCorrection;
    NvU32                syncEnable;                           //!< Sync enable (TRUE to use syncSource)
    NVVIOSYNCSOURCE      syncSource;                           //!< Sync source
    NVVIOSYNCDELAY       syncDelay;                            //!< Sync delay
    NVVIOCOMPSYNCTYPE    compositeSyncType;                    //!< Composite sync type
    NvU32                frameLockEnable;                      //!< Flag indicating whether framelock was on/off
    NvU32                psfSignalFormat;                      //!< Indicates whether contained format is PSF Signal format
    NvU32                enable422Filter;                      //!< Enables/Disables 4:2:2 filter
    NvU32                compositeTerminate;                   //!< Composite termination
    NvU32                enableDataIntegrityCheck;             //!< Enable data integrity check: true - enable, false - disable
    NvU32                cscOverride;                          //!< Use provided CSC color matrix to overwrite
    NvU32                flipQueueLength;                      //!< Number of buffers used for the internal flip queue
    NvU32                enableANCTimeCodeGeneration;          //!< Enable SDI ANC time code generation
    NvU32                enableComposite;                      //!< Enable composite
    NvU32                enableAlphaKeyComposite;              //!< Enable Alpha key composite
    NVVIOCOMPOSITERANGE  compRange;                            //!< Composite ranges
    NvU8                 reservedData[256];                    //!< Indicates last stored SDI output state TRUE-ON / FALSE-OFF
    NvU32                enableFullColorRange;                 //!< Flag indicating Full Color Range
    NvU32                enableRGBData;                        //!< Indicates data is in RGB format
    NVVIOANCPARITYCOMPUTATION ancParityComputation;            //!< Enable HW ANC parity bit computation (auto/on/off)
	NvU32				 enableAudioBlanking;				   //!< Enable HANC audio blanking on repeat frames
} NVVIOOUTPUTCONFIG_V3;

//! Stream configuration
typedef struct _NVVIOSTREAM
{
    NvU32                   bitsPerComponent;                     //!< Bits per component
    NVVIOCOMPONENTSAMPLING  sampling;                             //!< Sampling   
    NvU32                   expansionEnable;                      //!< Enable/disable 4:2:2->4:4:4 expansion
    NvU32                   numLinks;                             //!< Number of active links
    struct
    {
        NvU32               jack;                                 //!< This stream's link[i] will use the specified (0-based) channel within the
        NvU32               channel;                              //!< specified (0-based) jack
    } links[NVAPI_MAX_VIO_LINKS_PER_STREAM];
} NVVIOSTREAM;

//! Input device configuration
typedef struct _NVVIOINPUTCONFIG
{
    NvU32                numRawCaptureImages;                  //!< numRawCaptureImages is the number of frames to keep in the capture queue. 
                                                               //!< must be between NVAPI_GVI_MIN_RAW_CAPTURE_IMAGES and NVAPI_GVI_MAX_RAW_CAPTURE_IMAGES, 
    NVVIOSIGNALFORMAT    signalFormat;                         //!< Signal format.
                                                               //!< Please note that both numRawCaptureImages and signalFormat should be set together.
    NvU32                numStreams;                           //!< Number of active streams.
    NVVIOSTREAM          streams[NVAPI_MAX_VIO_STREAMS];       //!< Stream configurations
    NvU32                bTestMode;                            //!< This attribute controls the GVI test mode.
                                                               //!< Possible values 0/1. When testmode enabled, the
                                                               //!< GVI device will generate fake data as quickly as possible.
} NVVIOINPUTCONFIG;

typedef struct _NVVIOCONFIG_V1
{
    NvU32                version;                              //!< Structure version
    NvU32                fields;                               //!< Caller sets to NVVIOCONFIG_* mask for fields to use
    NVVIOCONFIGTYPE      nvvioConfigType;                      //!< Input or Output configuration
    union                                                   
    {
        NVVIOINPUTCONFIG  inConfig;                            //!<  Input device configuration
        NVVIOOUTPUTCONFIG_V1 outConfig;                           //!<  Output device configuration
    }vioConfig; 
} NVVIOCONFIG_V1;


typedef struct _NVVIOCONFIG_V2
{
    NvU32                version;                              //!< Structure version
    NvU32                fields;                               //!< Caller sets to NVVIOCONFIG_* mask for fields to use
    NVVIOCONFIGTYPE      nvvioConfigType;                      //!< Input or Output configuration
    union
    {
        NVVIOINPUTCONFIG     inConfig;                         //!< Input device configuration
        NVVIOOUTPUTCONFIG_V2 outConfig;                        //!< Output device configuration
    }vioConfig;
} NVVIOCONFIG_V2;

typedef struct _NVVIOCONFIG_V3
{
    NvU32                version;                              //!< Structure version
    NvU32                fields;                               //!< Caller sets to NVVIOCONFIG_* mask for fields to use
    NVVIOCONFIGTYPE      nvvioConfigType;                      //!< Input or Output configuration
    union
    {
        NVVIOINPUTCONFIG     inConfig;                         //!< Input device configuration
        NVVIOOUTPUTCONFIG_V3 outConfig;                        //!< Output device configuration
    }vioConfig;
} NVVIOCONFIG_V3;
typedef NVVIOOUTPUTCONFIG_V3 NVVIOOUTPUTCONFIG;
typedef NVVIOCONFIG_V3 NVVIOCONFIG;

#define NVVIOCONFIG_VER1  MAKE_NVAPI_VERSION(NVVIOCONFIG_V1,1)
#define NVVIOCONFIG_VER2  MAKE_NVAPI_VERSION(NVVIOCONFIG_V2,2)
#define NVVIOCONFIG_VER3  MAKE_NVAPI_VERSION(NVVIOCONFIG_V3,3)
#define NVVIOCONFIG_VER   NVVIOCONFIG_VER3


typedef struct
{
    NvPhysicalGpuHandle                    hPhysicalGpu;                    //!< Handle to Physical GPU (This could be NULL for GVI device if its not binded)
    NvVioHandle                         hVioHandle;                     //!<handle to SDI Input/Output device
    NvU32                               vioId;                          //!<device Id of SDI Input/Output device
    NvU32                               outputId;            //!<deviceMask of the SDI display connected to GVO device. 
                                                                        //!<outputId will be 0 for GVI device.
} NVVIOTOPOLOGYTARGET;                                                    

typedef struct _NV_VIO_TOPOLOGY
{
    NvU32                       version;
    NvU32                       vioTotalDeviceCount;                    //!<How many video I/O targets are valid
    NVVIOTOPOLOGYTARGET         vioTarget[NVAPI_MAX_VIO_DEVICES];       //!<Array of video I/O targets
}NV_VIO_TOPOLOGY, NVVIOTOPOLOGY;


//! Macro for constructing the version field of NV_VIO_TOPOLOGY
#define NV_VIO_TOPOLOGY_VER  MAKE_NVAPI_VERSION(NV_VIO_TOPOLOGY,1)

//! Macro for constructing the version field of NVVIOTOPOLOGY
#define NVVIOTOPOLOGY_VER    MAKE_NVAPI_VERSION(NVVIOTOPOLOGY,1)



//! @} 



//! \addtogroup vidio
//! @{
///////////////////////////////////////////////////////////////////////////////
//!   
//!   Function:    NvAPI_VIO_GetCapabilities
//!  
//!   Description: This API determine the graphics adapter video I/O capabilities.
//!  
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 190
//!  
//! \param [in]  NvVioHandle   The caller provides the SDI device handle as input.
//! \param [out] pAdapterCaps  Pointer to receive capabilities
//!  
//! \retval ::NVAPI_OK                           Success
//! \retval ::NVAPI_API_NOT_INTIALIZED           NVAPI Not Initialized
//! \retval ::NVAPI_INVALID_ARGUMENT             Arguments passed to API are not valid
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION  NVVIOCAPS struct version used by the app is not compatible
//! \retval ::NVAPI_NOT_SUPPORTED                Video I/O not supported
//! \retval ::NVAPI_ERROR                        NVAPI Random errors
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_VIO_GetCapabilities(NvVioHandle     hVioHandle,
                                          NVVIOCAPS       *pAdapterCaps);


////////////////////////////////////////////////////////////////////////////////
//!   Function:    NvAPI_VIO_Open
//!  
//!   Description: This API opens the graphics adapter for video I/O operations
//!                using the OpenGL application interface.  Read operations
//!                are permitted in this mode by multiple clients, but Write 
//!                operations are application exclusive.
//!  
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 190
//!  
//! \param [in]  NvVioHandle      The caller provides the SDI output device handle as input.
//! \param [in]  vioClass         Class interface (NVVIOCLASS_* value)
//! \param [in]  ownerType        Specify NVVIOOWNERTYPE_APPLICATION or NVVIOOWNERTYPE_DESKTOP.
//!  
//! \retval ::NVAPI_OK                           Success
//! \retval ::NVAPI_API_NOT_INTIALIZED           NVAPI Not Initialized
//! \retval ::NVAPI_INVALID_ARGUMENT             Arguments passed to API are not valid
//! \retval ::NVAPI_NOT_SUPPORTED                Video I/O not supported
//! \retval ::NVAPI_ERROR                        NVAPI Random errors
//! \retval ::NVAPI_DEVICE_BUSY                  Access denied for requested access
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_VIO_Open(NvVioHandle       hVioHandle,
                               NvU32             vioClass,
                               NVVIOOWNERTYPE    ownerType);

///////////////////////////////////////////////////////////////////////////////
//!   Function:    NvAPI_VIO_Close
//!  
//!   Description: This API closes the graphics adapter for graphics-to-video operations
//!                using the OpenGL application interface.  Closing an 
//!                OpenGL handle releases the device.
//!  
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 190
//!  
//! \param [in]  NvVioHandle   The caller provides the SDI output device handle as input.
//! \param [in]  bRelease      boolean value to either keep or release ownership
//!  
//! \retval ::NVAPI_OK                           Success
//! \retval ::NVAPI_API_NOT_INTIALIZED           NVAPI Not Initialized
//! \retval ::NVAPI_INVALID_ARGUMENT             Arguments passed to API are not valid
//! \retval ::NVAPI_NOT_SUPPORTED                Video I/O not supported
//! \retval ::NVAPI_ERROR                        NVAPI Random errors
//! \retval ::NVAPI_DEVICE_BUSY                  Access denied for requested access
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_VIO_Close(NvVioHandle       hVioHandle,
                                NvU32             bRelease);
///////////////////////////////////////////////////////////////////////////////
//!   Function:    NvAPI_VIO_Status
//!  
//!   Description: This API gets the Video I/O LED status.
//!  
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 190
//!  
//! \param [in]  NvVioHandle   The caller provides the SDI device handle as input.
//! \param [out] pStatus       Return pointer to NVVIOSTATUS
//!  
//! \retval ::NVAPI_OK                           Success
//! \retval ::NVAPI_API_NOT_INTIALIZED           NVAPI Not Initialized
//! \retval ::NVAPI_INVALID_ARGUMENT             Arguments passed to API are not valid
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION  Invalid structure version
//! \retval ::NVAPI_NOT_SUPPORTED                Video I/O not supported
//! \retval ::NVAPI_ERROR                        NVAPI Random errors
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_VIO_Status(NvVioHandle     hVioHandle, 
                                 NVVIOSTATUS     *pStatus);

////////////////////////////////////////////////////////////////////////////////
//!   Function:    NvAPI_VIO_SyncFormatDetect
//!  
//!   Description: This API detects the Video I/O incoming sync video format.
//!  
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 190
//!  
//! \param [in]  NvVioHandle  The caller provides the SDI device handle as input.
//! \param [out] pWait        Pointer to receive how many milliseconds will lapse 
//!                           before VIOStatus returns the detected syncFormat.
//!  
//! \retval ::NVAPI_OK                          Success
//! \retval ::NVAPI_API_NOT_INTIALIZED          NVAPI Not Initialized
//! \retval ::NVAPI_INVALID_ARGUMENT            Arguments passed to API are not valid
//! \retval ::NVAPI_NOT_SUPPORTED               Video I/O not supported
//! \retval ::NVAPI_ERROR                       NVAPI Random errors
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_VIO_SyncFormatDetect(NvVioHandle hVioHandle,
                                           NvU32       *pWait);
///////////////////////////////////////////////////////////////////////////////
//!   Function:    NvAPI_VIO_GetConfig
//!  
//!   Description: This API gets the graphics-to-video configuration.
//!  
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 190
//!  
//! \param [in]  NvVioHandle   The caller provides the SDI device handle as input.
//! \param [out] pConfig       Pointer to the graphics-to-video configuration
//!  
//! \retval ::NVAPI_OK                           Success
//! \retval ::NVAPI_API_NOT_INTIALIZED           NVAPI Not Initialized
//! \retval ::NVAPI_INVALID_ARGUMENT             Arguments passed to API are not valid
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION  Invalid structure version
//! \retval ::NVAPI_NOT_SUPPORTED                Video I/O not supported
//! \retval ::NVAPI_ERROR                        NVAPI Random errors
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_VIO_GetConfig(NvVioHandle        hVioHandle,
                                    NVVIOCONFIG        *pConfig); 

///////////////////////////////////////////////////////////////////////////////
//!   Function:    NvAPI_VIO_SetConfig
//!  
//!   Description: This API sets the graphics-to-video configuration.
//!  
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 190
//!  
//! \param [in]  NvVioHandle      The caller provides the SDI device handle as input.
//! \param [in]  pConfig          Pointer to Graphics-to-Video configuration
//!  
//! \retval ::NVAPI_OK                           Success
//! \retval ::NVAPI_API_NOT_INTIALIZED           NVAPI Not Initialized
//! \retval ::NVAPI_INVALID_ARGUMENT             Arguments passed to API are not valid
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION  Stucture version invalid
//! \retval ::NVAPI_NOT_SUPPORTED                Video I/O not supported
//! \retval ::NVAPI_ERROR                        NVAPI Random errors
//! \retval ::NVAPI_DEVICE_BUSY                  Access denied for requested access
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_VIO_SetConfig(NvVioHandle            hVioHandle,
                                    const NVVIOCONFIG      *pConfig);

///////////////////////////////////////////////////////////////////////////////
//!   Function:    NvAPI_VIO_SetCSC
//!  
//!   Description: This API sets the colorspace conversion parameters.
//!  
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_VIO_SetConfig.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 190
//!
//! \param [in]  NvVioHandle      The caller provides the SDI device handle as input.
//! \param [in]  pCSC             Pointer to CSC parameters
//!  
//! \retval ::NVAPI_OK                           Success
//! \retval ::NVAPI_API_NOT_INTIALIZED           NVAPI Not Initialized
//! \retval ::NVAPI_INVALID_ARGUMENT             Arguments passed to API are not valid
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION  Stucture version invalid
//! \retval ::NVAPI_NOT_SUPPORTED                Video I/O not supported
//! \retval ::NVAPI_ERROR                        NVAPI Random errors
//! \retval ::NVAPI_DEVICE_BUSY                  Access denied for requested access
////////////////////////////////////////////////////////////////////////////////----
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use NvAPI_VIO_SetConfig.")
NVAPI_INTERFACE NvAPI_VIO_SetCSC(NvVioHandle           hVioHandle,
                                 NVVIOCOLORCONVERSION  *pCSC);
////////////////////////////////////////////////////////////////////////////////
//!   Function:    NvAPI_VIO_GetCSC
//! 
//!   Description: This API gets the colorspace conversion parameters.
//!
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_VIO_GetConfig.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 190
//!
//! \param [in]  NvVioHandle      The caller provides the SDI device handle as input.
//! \param [out] pCSC             Pointer to CSC parameters
//! 
//! \retval ::NVAPI_OK                           Success
//! \retval ::NVAPI_API_NOT_INTIALIZED           NVAPI Not Initialized
//! \retval ::NVAPI_INVALID_ARGUMENT             Arguments passed to API are not valid
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION  Stucture version invalid
//! \retval ::NVAPI_NOT_SUPPORTED                Video I/O not supported
//! \retval ::NVAPI_ERROR                        NVAPI Random errors
////////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use NvAPI_VIO_GetConfig.")
NVAPI_INTERFACE NvAPI_VIO_GetCSC(NvVioHandle           hVioHandle,
                                 NVVIOCOLORCONVERSION  *pCSC);
///////////////////////////////////////////////////////////////////////////////
//!   Function:    NvAPI_VIO_SetGamma
//! 
//!   Description: This API sets the gamma conversion parameters.
//! 
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_VIO_SetConfig.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 190
//!
//! \param [in]  NvVioHandle       The caller provides the SDI device handle as input.
//! \param [in]  pGamma            Pointer to gamma parameters
//! 
//! \retval ::NVAPI_OK                           Success
//! \retval ::NVAPI_API_NOT_INTIALIZED           NVAPI Not Initialized
//! \retval ::NVAPI_INVALID_ARGUMENT             Arguments passed to API are not valid
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION  Stucture version invalid
//! \retval ::NVAPI_NOT_SUPPORTED                Video I/O not supported
//! \retval ::NVAPI_ERROR                        NVAPI Random errors
//! \retval ::NVAPI_DEVICE_BUSY                  Access denied for requested access
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use NvAPI_VIO_SetConfig.")
NVAPI_INTERFACE NvAPI_VIO_SetGamma(NvVioHandle           hVioHandle,
                                   NVVIOGAMMACORRECTION  *pGamma);

///////////////////////////////////////////////////////////////////////////////
//!   Function:    NvAPI_VIO_GetGamma
//! 
//!   Description: This API gets the gamma conversion parameters.
//! 
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_VIO_GetConfig.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 190
//!
//! \param [in]  NvVioHandle      The caller provides the SDI device handle as input.
//! \param [out] pGamma           Pointer to gamma parameters
//! 
//! \retval ::NVAPI_OK                           Success
//! \retval ::NVAPI_API_NOT_INTIALIZED           NVAPI Not Initialized
//! \retval ::NVAPI_INVALID_ARGUMENT             Arguments passed to API are not valid
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION  Stucture version invalid
//! \retval ::NVAPI_NOT_SUPPORTED                Video I/O not supported
//! \retval ::NVAPI_ERROR                        NVAPI Random errors
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use NvAPI_VIO_GetConfig.")
NVAPI_INTERFACE NvAPI_VIO_GetGamma(NvVioHandle           hVioHandle,
                                   NVVIOGAMMACORRECTION* pGamma);
////////////////////////////////////////////////////////////////////////////////
//!   Function:    NvAPI_VIO_SetSyncDelay
//! 
//!   Description: This API sets the sync delay parameters.
//! 
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_VIO_SetConfig.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 190
//! 
//! \param [in]  NvVioHandle   The caller provides the SDI device handle as input.
//! \param [in]  pSyncDelay    Pointer to sync delay parameters
//!  
//! \retval ::NVAPI_OK                           Success
//! \retval ::NVAPI_API_NOT_INTIALIZED           NVAPI Not Initialized
//! \retval ::NVAPI_INVALID_ARGUMENT             Arguments passed to API are not valid
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION  Stucture version invalid
//! \retval ::NVAPI_ERROR                        NVAPI Random errors
//! \retval ::NVAPI_DEVICE_BUSY                  Access denied for requested access
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use NvAPI_VIO_SetConfig.")
NVAPI_INTERFACE NvAPI_VIO_SetSyncDelay(NvVioHandle            hVioHandle,
                                       const NVVIOSYNCDELAY   *pSyncDelay);

////////////////////////////////////////////////////////////////////////////////
//!   Function:    NvAPI_VIO_GetSyncDelay
//! 
//!   Description: This API gets the sync delay parameters.
//! 
//! \deprecated  Do not use this function - it is deprecated in release 290. Instead, use NvAPI_VIO_GetConfig.
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 190
//! 
//! \param [in]  NvVioHandle      The caller provides the SDI device handle as input.
//! \param [out] pSyncDelay       Pointer to sync delay parameters
//! 
//! \retval ::NVAPI_OK                           Success
//! \retval ::NVAPI_API_NOT_INTIALIZED           NVAPI Not Initialized
//! \retval ::NVAPI_INVALID_ARGUMENT             Arguments passed to API are not valid
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION  Stucture version invalid
//! \retval ::NVAPI_ERROR                        NVAPI Random errors
///////////////////////////////////////////////////////////////////////////////
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use NvAPI_VIO_GetConfig.")
NVAPI_INTERFACE NvAPI_VIO_GetSyncDelay(NvVioHandle      hVioHandle,
                                       NVVIOSYNCDELAY   *pSyncDelay);

typedef enum _NVVIOPCILINKRATE
{
    NVVIOPCILINKRATE_UNKNOWN          = 0,
    NVVIOPCILINKRATE_GEN1             = 1,                    //<! 2.5 Gbps.
    NVVIOPCILINKRATE_GEN2             = 2,                    //<! 5 Gbps.
    NVVIOPCILINKRATE_GEN3             = 3,                    //<! 8 Gbps.
}NVVIOPCILINKRATE;

typedef enum _NVVIOPCILINKWIDTH
{
    NVVIOPCILINKWIDTH_UNKNOWN         = 0,
    NVVIOPCILINKWIDTH_x1              = 1,
    NVVIOPCILINKWIDTH_x2              = 2,
    NVVIOPCILINKWIDTH_x4              = 4,
    NVVIOPCILINKWIDTH_x8              = 8,
    NVVIOPCILINKWIDTH_x16            = 16,
}NVVIOPCILINKWIDTH;

typedef struct _NVVIOPCIINFO
{
    NvU32                     version;                            //!< Structure version
    
    NvU32                   pciDeviceId;                        //!< specifies the internal PCI device identifier for the GVI.
    NvU32                   pciSubSystemId;                        //!< specifies the internal PCI subsystem identifier for the GVI.
    NvU32                   pciRevisionId;                        //!< specifies the internal PCI device-specific revision identifier for the GVI.
    NvU32                   pciDomain;                            //!< specifies the PCI domain of the GVI device.
    NvU32                   pciBus;                                //!< specifies the PCI bus number of the GVI device.
    NvU32                   pciSlot;                            //!< specifies the PCI slot number of the GVI device.
    NVVIOPCILINKWIDTH       pciLinkWidth;                        //!< specifies the the negotiated PCIE link width.
    NVVIOPCILINKRATE           pciLinkRate;                        //!< specifies the the negotiated PCIE link rate.
} NVVIOPCIINFO_V1;

typedef NVVIOPCIINFO_V1                                         NVVIOPCIINFO;
#define NVVIOPCIINFO_VER1                                          MAKE_NVAPI_VERSION(NVVIOPCIINFO_V1,1)
#define NVVIOPCIINFO_VER                                        NVVIOPCIINFO_VER1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_VIO_GetPCIInfo()
//
// DESCRIPTION:   This API gets PCI information of the attached SDI(input) capture card.
//
// PARAMETERS:      hVioHandle    (IN)    - Handle to SDI capture card.
//                  pVioPCIInfo    (OUT)    - PCI information of the attached SDI capture card.
//
//! SUPPORTED OS:  Windows XP and higher
//!
//
// RETURN STATUS: This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//                specific meaning for this API, they are listed below.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_VIO_GetPCIInfo(__in NvVioHandle hVioHandle, 
                                            __inout NVVIOPCIINFO* pVioPCIInfo);

////////////////////////////////////////////////////////////////////////////////
//!   Function:    NvAPI_VIO_IsRunning
//! 
//!   Description: This API determines if Video I/O is running.
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 190
//! 
//! \param [in]  NvVioHandle[IN]          The caller provides the SDI device handle as input.
//! 
//! \retval ::NVAPI_DRIVER_RUNNING        Video I/O running
//! \retval ::NVAPI_DRIVER_NOTRUNNING     Video I/O not running
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_VIO_IsRunning(NvVioHandle   hVioHandle);

///////////////////////////////////////////////////////////////////////////////
//!   Function:    NvAPI_VIO_Start
//! 
//!   Description: This API starts Video I/O.
//!              This API should be called for NVVIOOWNERTYPE_DESKTOP only and will not work for OGL applications.
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 190
//!
//! \param [in]  NvVioHandle[IN]     The caller provides the SDI device handle as input.
//! 
//! \retval ::NVAPI_OK                           Success
//! \retval ::NVAPI_API_NOT_INTIALIZED           NVAPI Not Initialized
//! \retval ::NVAPI_INVALID_ARGUMENT             Arguments passed to API are not valid
//! \retval ::NVAPI_NOT_SUPPORTED                Video I/O not supported
//! \retval ::NVAPI_ERROR                        NVAPI Random errors
//! \retval ::NVAPI_DEVICE_BUSY                  Access denied for requested access
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_VIO_Start(NvVioHandle     hVioHandle);

///////////////////////////////////////////////////////////////////////////////
//!   Function:    NvAPI_VIO_Stop
//! 
//!   Description: This API stops Video I/O.
//!              This API should be called for NVVIOOWNERTYPE_DESKTOP only and will not work for OGL applications.
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 190
//! 
//! \param [in]  NvVioHandle[IN]     The caller provides the SDI device handle as input.
//! 
//! \retval ::NVAPI_OK                           Success
//! \retval ::NVAPI_API_NOT_INTIALIZED           NVAPI Not Initialized
//! \retval ::NVAPI_INVALID_ARGUMENT             Arguments passed to API are not valid
//! \retval ::NVAPI_NOT_SUPPORTED                Video I/O not supported
//! \retval ::NVAPI_ERROR                        NVAPI Random errors
//! \retval ::NVAPI_DEVICE_BUSY                  Access denied for requested access
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_VIO_Stop(NvVioHandle     hVioHandle);


///////////////////////////////////////////////////////////////////////////////
//!   Function:    NvAPI_VIO_IsFrameLockModeCompatible
//! 
//!   Description: This API checks whether modes are compatible in frame lock mode.
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 190
//! 
//! \param [in]   NvVioHandle          The caller provides the SDI device handle as input.
//! \param [in]   srcEnumIndex         Source Enumeration index
//! \param [in]   destEnumIndex        Destination Enumeration index
//! \param [out]  pbCompatible         Pointer to receive compatibility
//! 
//! \retval ::NVAPI_OK                           Success
//! \retval ::NVAPI_API_NOT_INTIALIZED           NVAPI Not Initialized
//! \retval ::NVAPI_INVALID_ARGUMENT             Arguments passed to API are not valid
//! \retval ::NVAPI_NOT_SUPPORTED                Video I/O not supported
//! \retval ::NVAPI_ERROR                        NVAPI Random errors
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_VIO_IsFrameLockModeCompatible(NvVioHandle              hVioHandle,
                                                    NvU32                    srcEnumIndex,
                                                    NvU32                    destEnumIndex,
                                                    NvU32*                   pbCompatible);


///////////////////////////////////////////////////////////////////////////////
//!   Function:    NvAPI_VIO_EnumDevices
//! 
//!   Description: This API enumerate all VIO devices connected to the system.
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 190
//!
//! \param [out]  NvVioHandle                  User passes the pointer of NvVioHandle[] array to get handles to
//!                                            all the connected video I/O devices.
//! \param [out]  vioDeviceCount               User gets total number of VIO devices connected to the system.
//! 
//! \retval ::NVAPI_OK                         Success
//! \retval ::NVAPI_API_NOT_INTIALIZED         NVAPI Not Initialized
//! \retval ::NVAPI_INVALID_ARGUMENT           Arguments passed to API are not valid
//! \retval ::NVAPI_ERROR                      NVAPI Random errors
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND    No SDI Device found
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_VIO_EnumDevices(NvVioHandle       hVioHandle[NVAPI_MAX_VIO_DEVICES],
                                      NvU32             *vioDeviceCount);
                                                                                          

///////////////////////////////////////////////////////////////////////////////
//!   Function:    NvAPI_VIO_QueryTopology
//! 
//!   Description: This API queries the valid SDI topologies.
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 190
//!
//! \param [out] pNvVIOTopology     User passes the pointer to NVVIOTOPOLOGY to fetch all valid SDI topologies.
//! 
//! \retval ::NVAPI_OK                           Success
//! \retval ::NVAPI_API_NOT_INTIALIZED           NVAPI Not Initialized
//! \retval ::NVAPI_INVALID_ARGUMENT             Arguments passed to API are not valid
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION  Invalid structure version
//! \retval ::NVAPI_ERROR                        NVAPI Random errors
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_VIO_QueryTopology(NV_VIO_TOPOLOGY   *pNvVIOTopology);


///////////////////////////////////////////////////////////////////////////////
//!   Function:    NvAPI_VIO_EnumSignalFormats
//! 
//!   Description: This API enumerates signal formats supported by Video I/O.
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 190
//!
//! \param [in]   NvVioHandle          The caller provides the SDI device handle as input.
//! \param [in]   enumIndex            Enumeration index
//! \param [out]  pSignalFormatDetail  Pointer to receive detail or NULL
//! 
//! \retval ::NVAPI_OK                  Success
//! \retval ::NVAPI_API_NOT_INTIALIZED  NVAPI not initialized
//! \retval ::NVAPI_INVALID_ARGUMENT    Invalid argument passed
//! \retval ::NVAPI_END_ENUMERATION     No more signal formats to enumerate
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_VIO_EnumSignalFormats(NvVioHandle              hVioHandle,
                                            NvU32                    enumIndex,
                                            NVVIOSIGNALFORMATDETAIL  *pSignalFormatDetail);

///////////////////////////////////////////////////////////////////////////////
//!   Function:    NvAPI_VIO_EnumDataFormats
//! 
//!   Description: This API enumerates data formats supported by Video I/O.
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 190
//! 
//! \param [in]  NvVioHandle         The caller provides the SDI device handle as input.
//! \param [in]  enumIndex           Enumeration index
//! \param [out] pDataFormatDetail   Pointer to receive detail or NULL
//! 
//! \retval ::NVAPI_OK                Success
//! \retval ::NVAPI_END_ENUMERATION   No more data formats to enumerate
//! \retval ::NVAPI_NOT_SUPPORTED     Unsupported NVVIODATAFORMAT_ enumeration
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_VIO_EnumDataFormats(NvVioHandle            hVioHandle,
                                          NvU32                  enumIndex,
                                          NVVIODATAFORMATDETAIL  *pDataFormatDetail);
                                                                                      

//! @}




///////////////////////////////////////////////////////////////////////////////////
//  CAMERA TEST API
//  These APIs allows test apps to perform low level camera tests

//! \addtogroup vidio
//! @{
//! SUPPORTED OS:  Windows 8
//!

typedef enum _NVAPI_VIDEO_CAMERA_TEST_RETURN_STATUS
{
	NVAPI_VIDEO_CAMERA_TEST_RETURN_STATUS_SUCCESS,
	NVAPI_VIDEO_CAMERA_TEST_RETURN_STATUS_NA,
	NVAPI_VIDEO_CAMERA_TEST_RETURN_STATUS_INVALID_ARG,
	NVAPI_VIDEO_CAMERA_TEST_RETURN_STATUS_ERROR,
	NVAPI_VIDEO_CAMERA_TEST_RETURN_STATUS_POWER_OFF,
	
} NVAPI_VIDEO_CAMERA_TEST_RETURN_STATUS;
typedef enum _NVAPI_CAMERA_TEST_DEVICE_ID
{
	NVAPI_CAMERA_TEST_DEVICE_CAMERA1_ID,
	NVAPI_CAMERA_TEST_DEVICE_SENSOR1_ID,
	NVAPI_CAMERA_TEST_DEVICE_FOCUSSER1_ID,
	NVAPI_CAMERA_TEST_DEVICE_FLASH1_ID,
	
	NVAPI_CAMERA_TEST_DEVICE_CAMERA2_ID,
	NVAPI_CAMERA_TEST_DEVICE_SENSOR2_ID,
	NVAPI_CAMERA_TEST_DEVICE_FOCUSSER2_ID,
	NVAPI_CAMERA_TEST_DEVICE_FLASH2_ID,
	
	
	NVAPI_CAMERA_TEST_DEVICE_CAMERA3_ID,
	NVAPI_CAMERA_TEST_DEVICE_SENSOR3_ID,
	NVAPI_CAMERA_TEST_DEVICE_FOCUSSER3_ID,
	NVAPI_CAMERA_TEST_DEVICE_FLASH3_ID,
	
}NVAPI_CAMERA_TEST_DEVICE_ID;

typedef enum _NVAPI_CAMERA_TEST_FUNCTION_ID
{
	NVAPI_CAMERA_TEST_FUNCTION_ID_POWERON,
	NVAPI_CAMERA_TEST_FUNCTION_ID_POWEROFF,
	NVAPI_CAMERA_TEST_FUNCTION_ID_GET_TOPOLOGY,
	NVAPI_CAMERA_TEST_FUNCTION_ID_SYSTEMTEST,
	NVAPI_CAMERA_TEST_FUNCTION_ID_REGWRITE,
	NVAPI_CAMERA_TEST_FUNCTION_ID_CAPTURE
}NVAPI_CAMERA_TEST_FUNCTION_ID;

typedef enum _NVAPI_CAMERA_TEST_FUNCTION_ID_POWER_PARAM
{
	NVAPI_CAMERA_TEST_FUNCTION_ID_POWER_PARAM_CAM1,
	NVAPI_CAMERA_TEST_FUNCTION_ID_POWER_PARAM_CAM2,
	NVAPI_CAMERA_TEST_FUNCTION_ID_POWER_PARAM_CAM3,
}NVAPI_CAMERA_TEST_FUNCTION_ID_POWER_PARAM;

typedef enum _NVAPI_CAMERA_TEST_FUNCTION_ID_SYSTEMTEST_PARAM
{
	NVAPI_CAMERA_TEST_FUNCTION_ID_SYSTEMTEST_PARAM_SENSOR,
	NVAPI_CAMERA_TEST_FUNCTION_ID_SYSTEMTEST_PARAM_FOCUSSER,
	NVAPI_CAMERA_TEST_FUNCTION_ID_SYSTEMTEST_PARAM_FLASH,
}NVAPI_CAMERA_TEST_FUNCTION_ID_SYSTEMTEST_PARAM;

typedef struct _NVAPI_CAMERA_TEST_PARAMS_V1
{
    NvU32									version; //!< (IN) version that matches NVAPI_CAMERA_TEST_PARAMS_VER
    NVAPI_VIDEO_CAMERA_TEST_RETURN_STATUS	dwStatus; //!< (OUT) one of the NVAPI_VIDEO_CAMERA_TEST_RETURN_STATUS 
    NVAPI_CAMERA_TEST_FUNCTION_ID			functionId; //!< (IN) one of the NV_CAMERA_TEST_FUNCTION_ID
    NvU32									dwParam; //!< (IN) device ID of the target device
    NvAPI_String							szParam; //!< (IN/OUT) additional params for the test
    NvU32									adwReserved[5]; //!< (IN/OUT) reserved for future expansion
} NVAPI_CAMERA_TEST_PARAMS_V1;

#define NVAPI_CAMERA_TEST_PARAMS_VER_V1 MAKE_NVAPI_VERSION(NVAPI_CAMERA_TEST_PARAMS_V1,1)

typedef NVAPI_CAMERA_TEST_PARAMS_V1 NVAPI_CAMERA_TEST_PARAMS;
#define NVAPI_CAMERA_TEST_PARAMS_VER NVAPI_CAMERA_TEST_PARAMS_VER_V1
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Camera_Test
//
//!   DESCRIPTION: This API executes camera tests in the KMD via escape calls. This is an internal API for usage only by our tools.
//! \param [in]     hNvDisplay(in)	  - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//! \param [in,out] pCameraTestParams - NVAPI_CAMERA_TEST_PARAMS containing a FunctionId.
//!                                          
//! \return ::NVAPI_OK if the call succeeded. 
//!
//! \ingroup vidio

///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_CameraTest( __in NvDisplayHandle hNvDisplay, __inout NVAPI_CAMERA_TEST_PARAMS* pCameraTestParams );

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_Stereo_GetInfo
//
//! \fn NvAPI_Stereo_GetInfo(__in NvDisplayHandle hNvDisplay, __inout NV_STEREO_DIAG_INFO *pStereoInfo)
//! DESCRIPTION:     This API returns requested stereo diagnostic information 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]          hNvDisplay      Display Handle
//! \param [in,out]      pStereoInfo     stereo information
//!
//! \return    This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//!
//! \retval    NVAPI_INVALID_POINTER                -   Invalid input parameter. Following can be the reason for this return value:
//!                                                 -# pStereoInfo is NULL.
//! \retval    NVAPI_INCOMPATIBLE_STRUCT_VERSION    -   NV_STEREO_DIAG_INFO Struct not compatible with this NVAPI driver
//! \retval    NVAPI_INVALID_HANDLE                 -   Invalid Adapter handle
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup stereoapi
//! @{

//! See NvAPI_Stereo_GetInfo().
//! Macro for constructing the version field of NV_STEREO_DIAG_INFO
#define NV_STEREO_DIAG_INFO_VER MAKE_NVAPI_VERSION(NV_STEREO_DIAG_INFO, 2)

//! See NvAPI_Stereo_GetInfo().
#define NV_STEREO_MAX_HEADS           4

//! @}

//! \ingroup stereoapi
//! @{

//! See NvAPI_Stereo_GetInfo().
//! Stereo info query IDs.
typedef enum _NV_STEREO_DIAG_INFO_QUERY_ID
{
    NV_STEREO_DIAG_INFO_QUERY_ID_COMMON,

    // << Append here >> 
    NV_STEREO_DIAG_INFO_QUERY_ID_LAST,
}NV_STEREO_DIAG_INFO_QUERY_ID;

//! See NvAPI_Stereo_GetInfo().
//! Stereo High VBI override status.
typedef enum _NV_STEREO_HIGH_VBI_OVERRIDE
{
    NV_STEREO_HIGH_VBI_OVERRIDE_DONE              = 0x10000,
    NV_STEREO_HIGH_VBI_OVERRIDE_NOT_DONE          = 0x20000,
    NV_STEREO_HIGH_VBI_OVERRIDE_NO_MONITOR        = 0x40000,
    NV_STEREO_HIGH_VBI_OVERRIDE_PENDING_ON_RESUME = 0x80000
}NV_STEREO_HIGH_VBI_OVERRIDE;
//! @}

//! \ingroup stereoapi
//! @{

//! See NvAPI_Stereo_GetInfo().
//! Stereo global(kmd) status info: Used in NV_STEREO_DIAG_COMMON_INFO
typedef struct _NV_STEREO_STATUS_INFO
{
    NvU8         isStereoEnabled;       //!< TRUE if stereo enabled 
    NvU8         isStereoActive;        //!< TRUE if stereo active 
    NvU32        numStereoClients;      //!< Number of clients that have recursively enabled stereo (by calling setStereoConfig)
    NvS32        stereoDeviceCount;     //!< Number of devices which have allocated a stereo renderable 
                                        //!< primary (excluding the shared scanout primary).
    NvU32        pendingStereoConfig[NV_STEREO_MAX_HEADS];           //!< flags reflecting requested stereo configuration
    NvU32        persistentStereoConfig[NV_STEREO_MAX_HEADS];        //!< flags reflecting persistent stereo configuration
    NvU32        stereoConfig[NV_STEREO_MAX_HEADS];                  //!< flags reflecting adapter's stereo configuration
    NvU32        stereoVBIOverride[NV_STEREO_MAX_HEADS];             //!< indicates need to override high VBI on mode set if stereo is enabled.
    NvU32        stereoLastModeSetVBIOverride[NV_STEREO_MAX_HEADS];  //!< Last mode set VBI override status.
    NvU32        stereoDesktopCount[NV_STEREO_MAX_HEADS];            //!< Count of active devices running in windowed stereo.
    NvU32        monitor3DEnableStatus[NV_STEREO_MAX_HEADS];         //!< holds the last status of monitor 3D mode authentication.
    NvU32        stereoVBIOverrideTargetId[NV_STEREO_MAX_HEADS];     //!< target id of overridden monitor controlling the dongle

    NvU32        reserved[5];
}NV_STEREO_STATUS_INFO;

//! See NvAPI_Stereo_GetInfo().
//! Stereo emitter info: Used in NV_STEREO_DIAG_COMMON_INFO
typedef struct _NV_STEREO_EMITTER_INFO
{
    NvU8         isInit;                //!< Emitter initialized
    NvU8         isConnected;           //!< TRUE if stereo enabled 
    NvU8         isActivated;           //!< TRUE if stereo active 
    NvU32        activatedHead;         //!< Stereo activated head
    NvU32        activeHeadRR;          //!< Refresh Rate on active head
    NvU32        activeCount;           //!< Number of apps that have sent activate calls
    NvU8         isActiveStatusUSBDrv;  //!< Activation status in USB Driver
    NvU32        reserved[5];
}NV_STEREO_EMITTER_INFO;

//! See NvAPI_Stereo_GetInfo().
//! Stereo windowed app aero info: Used in NV_STEREO_DIAG_COMMON_INFO
typedef struct _NV_STEREO_AERO_INFO
{
    NvU32       appCount;               //!< Number of windowed mode active apps
    NvU32       appPid;                 //!< Process ID of app that initiated DWM restart
    NvU32       orgRR;                  //!< Original Refresh Rate
    NvU32       reserved[5];
}NV_STEREO_AERO_INFO;

//! See NvAPI_Stereo_GetInfo().
//! Stereo global(kmd) common info
typedef struct  _NV_STEREO_DIAG_COMMON_INFO
{
    NvU32                      reserved1;
    NV_STEREO_STATUS_INFO      status;          //!< (OUT) Stereo global status info
    NV_STEREO_EMITTER_INFO     emitter;         //!< (OUT) Emitter Status info
    NV_STEREO_AERO_INFO        aero;            //!< (OUT) Windowed mode app(AERO ON) info
    NvU32                      reserved2[20];
} NV_STEREO_DIAG_COMMON_INFO;


//! See NvAPI_Stereo_GetInfo().
//! Stereo info
typedef struct  _NV_STEREO_DIAG_INFO
{
    NvU32                      version;         //!< (IN) Stereo get  info version
    NvU32                      queryId;         //!< (IN)     Stereo info query ID
    NvU32                      result;          //!< (OUT)    info retrived successfully?
    NvU32                      reserved1;
    union
    {
        NV_STEREO_DIAG_COMMON_INFO commonInfo;        //!< (IN,OUT) Stereo common info 
        // To retrieve other types of info, please append structs here.
    };
} NV_STEREO_DIAG_INFO;


//! @}

//! \ingroup stereoapi
NVAPI_INTERFACE NvAPI_Stereo_GetInfo(__in NvDisplayHandle hNvDisplay, __inout NV_STEREO_DIAG_INFO *pStereoInfo);






///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_Stereo_GetAppInfo
//
//! \fn NvAPI_Stereo_GetAppInfo(__in NvDisplayHandle hNvDisplay, __inout NV_STEREO_DIAG_APP_INFO *pStereoInfo)
//! DESCRIPTION:     This API returns the application's stereo driver information 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]          hNvDisplay      Display Handle
//! \param [in,out]      pStereoInfo     application's stereo driver diagnostic information
//!
//! \return    This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//!
//! \retval    NVAPI_INVALID_POINTER                -   Invalid input parameter. Following can be the reason for this return value:
//!                                                 -# pStereoInfo is NULL.
//! \retval    NVAPI_INCOMPATIBLE_STRUCT_VERSION    -   NV_STEREO_DIAG_INFO Struct not compatible with this NVAPI driver
//! \retval    NVAPI_INVALID_HANDLE                 -   Invalid Adapter handle
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup stereoapi
//! @{

//! See NvAPI_Stereo_GetAppInfo().
//! Macro for constructing the version field of NV_STEREO_DIAG_APP_INFO
#define NV_STEREO_DIAG_APP_INFO_VER MAKE_NVAPI_VERSION(NV_STEREO_DIAG_APP_INFO, 2)

//! See NvAPI_Stereo_GetAppInfo().
#define NV_STEREO_INFO_MAX_APPS       32
#define NV_STEREO_INFO_DX9_APP        1
#define NV_STEREO_INFO_DX10_APP       2
#define NV_STEREO_APP_INFO_SIZE       1024

//! @}

//! \ingroup stereoapi
//! @{

//! See NvAPI_Stereo_GetAppInfo().
//! Stereo Mode
typedef enum _NV_STEREO_MODE
{
    NV_STEREO_MODE_DEFAULT = 0,
    NV_STEREO_MODE_EXPLICIT = 1,
    NV_STEREO_MODE_QUADBUFFER = 2,
    NV_STEREO_MODE_LAST,
}NV_STEREO_MODE;

//! See NvAPI_Stereo_GetAppInfo().
//! Browser type
typedef enum _NV_STEREO_BROWSER_TYPE
{
    NV_STEREO_BROWSER_NONE              = 0x000,
    NV_STEREO_BROWSER_IE_BASE           = 0x100,
    NV_STEREO_BROWSER_IE9_PLUS          = 0x101,
    NV_STEREO_BROWSER_FF_BASE           = 0x200,
    NV_STEREO_BROWSER_FF_3_6_4_PLUS     = 0x201,
    NV_STEREO_BROWSER_FF_4_PLUS         = 0x202,
    NV_STEREO_BROWSER_CHROME_BASE       = 0x300,
    NV_STEREO_BROWSER_LAST
} NV_STEREO_BROWSER_TYPE;

//! See NvAPI_Stereo_GetAppInfo().
//! Stereo Source video layout
typedef enum _NV_STEREO_SOURCE_LAYOUT
{
    NV_STEREO_SOURCE_LAYOUT_LEFT_RIGHT = 0,
    NV_STEREO_SOURCE_LAYOUT_RIGHT_LEFT = 1,
    NV_STEREO_SOURCE_LAYOUT_TOP_BOTTOM = 2,
    NV_STEREO_SOURCE_LAYOUT_BOTTOM_TOP = 3,
    NV_STEREO_SOURCE_LAYOUT_MONO_MODE  = 4,
    NV_STEREO_SOURCE_LAYOUT_LAST 
}NV_STEREO_SOURCE_LAYOUT;

//! See NvAPI_Stereo_GetAppInfo().
//! Stereo State
typedef enum _NV_STEREO_STATE
{
    NV_STEREO_STATE_NOT_READY       =-1,
    NV_STEREO_STATE_OFF             = 0,
    NV_STEREO_STATE_ON              = 1,
    NV_STEREO_STATE_FORCED_OFF      = 2,
    NV_STEREO_STATE_OFF_IN_REGISTRY = 3,
}NV_STEREO_STATE;

//! See NvAPI_Stereo_GetAppInfo().
//! DX version
typedef enum _NV_STEREO_DX_VERSION
{
    NV_STEREO_DX_VERSION_DX10_0 = 2,
    NV_STEREO_DX_VERSION_DX10_1 = 3,
    NV_STEREO_DX_VERSION_DX11_0 = 4,
    NV_STEREO_DX_VERSION_DX11_1 = 5,
}NV_STEREO_DX_VERSION;

//! See NvAPI_Stereo_GetAppInfo().
//! Stereo Viewer types
typedef enum _NV_STEREO_CFG
{
    NV_STEREO_CFG_STEREOACTIVATED            = 0x80000000,
    NV_STEREO_CFG_CONNECTIONTYPE             = 0x000007FF,
    NV_STEREO_CFG_DEFAULT_VIEWER             = 0x00000001,//!< supersedes old ELSADDC. Also includes nv30+ native stereo.
    NV_STEREO_CFG_ELSADDC                    = 0x00000001,
    NV_STEREO_CFG_INTERLACED                 = 0x00000002,
    NV_STEREO_CFG_COLORINTERLEAVED           = 0x00000003,
    NV_STEREO_CFG_MULTIHEAD                  = 0x00000004,//!< show eyes rather on different heads.
    NV_STEREO_CFG_INTERLEAVED                = 0x00000008,//!< mixes tiles from left & right eyes together in one view.
    NV_STEREO_CFG_LINECODE                   = 0x00000010,
    NV_STEREO_CFG_ANAGLYPH                   = 0x00000020,
    NV_STEREO_CFG_NVIDIA_ONBOARD_GPIO5_DAC0  = 0x00000040,//!< GPIO programming for DAC0 (maybe different form head)
    NV_STEREO_CFG_NVIDIA_ONBOARD_GPIO5_DAC1  = 0x00000080,//!< GPIO programming for DAC1 (maybe different form head) 
    NV_STEREO_CFG_PRAMDAC_STEREO             = 0x00000100,//!< stereo glasses control is done via pramdac (no dac selection necessary, but head)
    NV_STEREO_CFG_SHARP_GPIO4                = 0x00000200,
}NV_STEREO_CFG;

//! @}

//! \ingroup stereoapi
//! @{

//! See NvAPI_Stereo_GetAppInfo().
//! DX9 app info
typedef struct _NV_STEREO_APP_INFO_DX9
{
    NvU8            exeName[128];
    NvU32           stereoMode;
    NvU32           reserved1;
    
    //Stereo Status
    NvU32           stereoHWType;           //!< Stereo Viewer HW type.
    // NvU32   bit-field byte1
    NvU32            reservedbits7:8;
    
    // NvU32   bit-field byte2
    NvU32            isStereoActivated:1;    //!< Stereo is currently activated.
    NvU32            isStereoBlocked:1;      //!< Out of memory condition
    NvU32            isAnaglyphOnly:1;       //!< Protection defined
    NvU32            isHDMIStereo:1;
    NvU32            isHDMIAllowed:1;
    NvU32            isHDMISupported:1;
    NvU32            isHDMIProtected:1;
    NvU32            isHDMIWindowed:1;
    // NvU32   bit-field byte3
    NvU32            isSLIBroadcast:1;
    NvU32            isClonedMode:1;
    NvU32            isGameProfiled:1;
    NvU32            reservedbits1:5;
    // NvU32   bit-field byte4
    NvU32            reservedbits2:8;
    
    NvU32           reserved2;

    // Authentication
    // NvU32   bit-field byte1
    NvU32            isFullLicense:1;
    NvU32            isTestLicense:1;
    NvU32            isPanelReleased:1;
    NvU32            isDisplayIdentified:1;
    NvU32            isDisplayReleased:1;
    NvU32            isNB:1;
    NvU32            isQuadro:1;
    NvU32            isSandBox:1;
    // NvU32   bit-field byte2
    NvU32            reservedbits6:8;
    
    // NvU32   bit-field byte3
    NvU32            isDisableHighVBIOverride:1;
    NvU32            isDisableAuthentication:1;
    NvU32            isNBInternalPanel:1;
    NvU32            isBrowserStereoApp:1;
    NvU32            isBrowserPhotoApp:1;
    NvU32            isInDWM:1;                //!< current process is DWM
    NvU32            isBulkLicense:1;
    NvU32            isUserLicense:1;
    // NvU32   bit-field byte4
    NvU32            reservedbits4:8;
    
    NvU32           reserved3;
    
    // FS/Windowed, Aero ON/OFF
    // NvU32   bit-field byte1
    NvU32            isFullscreen:1;          
    NvU32            isAeroWindowModeEnabled:1;
    NvU32            isGDIWindowModeEnabled:1;
    NvU32            isAeroWindowModeActivated:1;
    NvU32            isGDIWindowModeActivated:1;
    NvU32            reservedBits4:3;
    
    // NvU32   bit-field byte2,3,4
    NvU32            reservedbits5:24;

    NvU32           reserved4;

    NvU32           browserType;
    
    // Swapchain parameters
    NvU32           primaryWidth;
    NvU32           primaryHeight;
    NvU32           primaryRR;
    NvU32           primaryFormat;
    NvU32           numStereoSwapChain;
    
    // used for silverlight streaming
    NvU32           currentVideoWidth;
    NvU32           currentVideoHeight;
    NvU32           reserved5;
    
   // Misc params
    NvU32           uFPS;
    NvU32           refreshRateOverride;
    NvU32           monitorHead;
    NvU32           originalRefreshRate;
    NvU32           stereoDesktopCount;
    NvU32           persistentStereoDesktop;
    NvU32           delayedStereoDesktop;
    NvU32           reserved6;
   // Display parameters
    NvU32           displayWidth;
    NvU32           displayHeight;
    NvU32           targetDisplayCount;

    NvU32           reserved7[20];
}NV_STEREO_APP_INFO_DX9;

//! See NvAPI_Stereo_GetAppInfo().
//! DX10+ app information
typedef struct _NV_STEREO_APP_INFO_DX10
{
    // NvU32   bit-field byte1
    NvU32                        reservedbits9:8;
    // NvU32   bit-field byte2
    NvU32                        isNvStereoEnabled:1;
    NvU32                        isDxStereoEnabled:1;
    NvU32                        isAnaglyphOnly:1;
    NvU32                        isStereoActivated:1;     //!< Stereo is currently activated.
    NvU32                        isSLIDisabled:1;
    NvU32                        isStereoEnabledInRegistry:1;    
    NvU32                        isAeroWindowedModeEnabled:1;
    NvU32                        isAeroWindowedModeActive:1;
    // NvU32   bit-field byte3
    NvU32                        isStereoDesktopCreationDelayed:1;
    NvU32                        isAeroEnabled:1;      
    NvU32                        isBrowserStereoApp:1; 
    NvU32                        isFirefoxHTML5:1;
    NvU32                        isIE9HTML5:1;
    NvU32                        isGameProfiled:1;
    NvU32                        reservedBits1:2; 
    // NvU32   bit-field byte4
    NvU32                        reservedbits2:8;
 
    NvU32                       reserved1;

    NvU32                       html5FFWidth ;     
    NvU32                       html5FFHeight ;  
    NvU32                       browserType ;      
    NvU32                       fireFoxLayout;   
    NvU32                       reserved2;
    // Application resources info
    NvU32                       primaryFormat;
    NvU32                       primaryWidth;
    NvU32                       primaryHeight;

    NvU32                       primaryRR;
    NvU32                       origAeroRefreshRate;

    NvU32                       numStereoSwapChain;
    NvU32                       reserved3;

    NvU32                       stereoHWType;       //!< Stereo Viewer HW type.
    // NvU32   bit-field byte1
    NvU32                        reservedbits10:8;
    
    // NvU32   bit-field byte2
    NvU32                        isDLPStereo:1;
    NvU32                        isAnaglypthStereo:1;
    NvU32                        isAutoStereo:1;
    NvU32                        isHDMIStereo:1;
    NvU32                        isHDMIAllowed:1;
    NvU32                        isHDMISupported:1;
    NvU32                        isHDMIProtected:1;
    NvU32                        isHDMIWindowed:1;
    // NvU32   bit-field byte3
    NvU32                        isHDMINotificationDone:1;
    NvU32                        isHDMIWARsApplied:1;
    NvU32                        isHDMI3DEnabled:1;
    NvU32                        isFullLicense:1;
    NvU32                        isTestLicense:1;
    NvU32                        isNB:1;
    NvU32                        isQuadro:1;
    NvU32                        isPanelReleased:1;
    // NvU32   bit-field byte4
    NvU32                        isBulkLicense:1;
    NvU32                        isUserLicense:1;
    NvU32                        reservedbits3:6;
    
    NvU32                       reserved4;

    NvU32                       state;                //!< stereo state flags, used by on() and off()

    NvU32                        appRealName[128];     //!< Same asszAppName (if not a symbolic link).
    NvU32                       stereoMode;

    NvU32                       stereoVSConst;
    NvU32                       numStereoVS;          //!< number of stereo Stereo VS has been created
    NvU32                       reserved5;
    
    // NvU32   bit-field byte1
    NvU32                        reservedbits4:8;
    // NvU32   bit-field byte2
    NvU32                        isClonedMode:1;
    NvU32                        isStereoBroadcastSLI:1;
    NvU32                        doNotStartInStereoOnInit:1; //!< trackStartInStereo state derived from settings for first activate
    NvU32                        isStereoTextureEnabled:1;
    NvU32                        isStereoSmallTexturesEnabled:1;
    NvU32                        isStereoSmallTexturesEnabledOnlyForRGB10A2:1;
    NvU32                        isEnableVerticalOrientedTextures:1;
    NvU32                        isStereoSquareTexturesEnabled:1;
    // NvU32   bit-field byte3
    NvU32                        isDisableSmallSquareStereoTextures:1;
    NvU32                        isDisableBBSeparationIfStereoTexureInUse:1;
    NvU32                        isDisableBBSeparationCompletely:1;
    NvU32                        isStereoPlaneRTEnabled:1;
    NvU32                        isDisableStereoGSShader:1;  //!< deleteme: temporary dirty hack for CoJ_DX10
    NvU32                        isDisableSeparationWithoutZB:1;
    NvU32                        isDisableTexSeparationIfStereoTexureInUse:1;
    NvU32                        isStereoSmallTexturesDisabledForRGBA8:1;
    // NvU32   bit-field byte4
    NvU32                        isEnableVSStereoShadersWithoutConst:1;
    NvU32                        isEnableDSStereoShadersWithoutConst:1;
    NvU32                        isEnableGSStereoShadersWithoutConst:1;
    NvU32                        isWasLastDrawCallStereoized:1;//!< Intended only for debug use [Bug 755091]

    NvU32                        isDisplayIdentified:1;
    NvU32                        isDisplayReleased:1;

    NvU32                        isSandBox:1;
    NvU32                        reservedbits6:1;
    // NvU32   bit-field byte1
    NvU32                        reservedbits7:8;
    // NvU32   bit-field byte2
    NvU32                        reservedbits11:8;

    // NvU32   bit-field byte3
    NvU32                        isDisableHighVBIOverride:1;
    NvU32                        isDisableAuthentication:1;
    NvU32                        isNotInFullScreen:1;
    NvU32                        isNBInternalPanel:1;
    NvU32                        allowWindowedOnGDIStereo:1;
    NvU32                        activeWindowedOnGDIStereo:1;
    NvU32                        isPersistentMode:1;//!< Are we currently in persistent mode. Currently, means persistent regkey is set.
    NvU32                        isForcedPersistence:1;//!< Represents forced persistency even if regkey is not set. Used in HDMI1.4 case.
    // NvU32   bit-field byte4
    NvU32                        reservedbits8:8;
    
    // NvU32   bit-field byte1,2,3,4
    NvU32                        reservedbits12:32;
    
    NvU32                       reserved6[3];

    NvU32                       stereoConfig;       //!< reflects the last config sucessfully sent to KMD 

    NvU32                       refreshRateOverride;
    NvU32                       defaultRefreshRate;

    NvU32                       surfaceCreateMode;//!< Mode in which surfaces will be created [Bug 718493]
    NvU32                       failToSetHighVBIDueToLackOfMonitor;
    NvU32                       totalDisplaysInSys;

    NvU32                       origRefreshRate;       //!< The primary display's refresh rate upon DX device creation.
    NvU32                       reserved7[20];
}NV_STEREO_APP_INFO_DX10;

//! See NvAPI_Stereo_GetAppInfo().
typedef struct _NV_STEREO_APP_INFO
{
    NvU32 dxVersion; //!< DX Version
    NvU32 processId; //!< PRocess ID
    NvU32 reserved[2];
    union
    {
        NvU8 appData[NV_STEREO_APP_INFO_SIZE];
        NV_STEREO_APP_INFO_DX9  dx9;
        NV_STEREO_APP_INFO_DX10 dx10;
    };
}NV_STEREO_APP_INFO;

//! See NvAPI_Stereo_GetAppInfo().
//! Stereo app info.
typedef struct  _NV_STEREO_DIAG_APP_INFO
{
    NvU32                           version;        //!< (IN) Stereo get app info version
    NvU32                           reserved1;
    NvU32                           appCount;       //!< (IN,OUT) App count(No of apps/device 
                                                    //!< that have diagnostic info updated
    NvU32                           appDataSize;    //!< (IN) App diag info size
    NV_STEREO_APP_INFO              info[NV_STEREO_INFO_MAX_APPS]; //!< (OUT) App diag info of all apps
    NvU32                           reserved2[10];
} NV_STEREO_DIAG_APP_INFO;

//! @}

//! \ingroup stereoapi
NVAPI_INTERFACE NvAPI_Stereo_GetAppInfo(__in NvDisplayHandle hNvDisplay, __inout NV_STEREO_DIAG_APP_INFO *pStereoInfo);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_CreateConfigurationProfileRegistryKey
//
//! \fn NvAPI_Stereo_CreateConfigurationProfileRegistryKey(NV_STEREO_REGISTRY_PROFILE_TYPE registryProfileType)
//!
//! DESCRIPTION:   Creates new configuration registry key for current application.
//!
//!                If there is no configuration profile prior to the function call,
//!                this API tries to create a new configuration profile registry key
//!                for a given application and fill it with the default values.
//!                If an application already has a configuration profile registry key, the API does nothing.
//!                The name of the key is automatically set to the name of the executable that calls this function.
//!                Because of this, the executable should have a distinct and unique name.
//!                If the application is using only one version of DirectX, then the default profile type will be appropriate.
//!                If the application is using more than one version of DirectX from the same executable,
//!                it should use the appropriate profile type for each configuration profile.
//!
//! HOW TO USE:    When there is a need for an application to have default stereo parameter values,
//!                use this function to create a key to store the values.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]    registryProfileType  Type of profile the application wants to create. It should be one of the symbolic constants defined in
//!                                     ::NV_STEREO_REGISTRY_PROFILE_TYPE. Any other value will cause function to do nothing and return
//!                                     ::NV_STEREO_REGISTRY_PROFILE_TYPE_NOT_SUPPORTED.
//!
//! \retval ::NVAPI_OK                                           Key exists in the registry.
//! \retval ::NVAPI_STEREO_REGISTRY_PROFILE_TYPE_NOT_SUPPORTED   This profile type is not supported.
//! \retval ::NVAPI_STEREO_REGISTRY_ACCESS_FAILED                Access to registry failed.
//! \retval ::NVAPI_API_NOT_INTIALIZED           
//! \retval ::NVAPI_STEREO_NOT_INITIALIZED                       Stereo part of NVAPI not initialized.
//! \retval ::NVAPI_ERROR 
//!
///////////////////////////////////////////////////////////////////////////////


//! \ingroup stereoapi
//! Used in NvAPI_Stereo_CreateConfigurationProfileRegistryKey() 
typedef enum _NV_StereoRegistryProfileType
{
    NVAPI_STEREO_DEFAULT_REGISTRY_PROFILE, //!< Default registry configuration profile.
    NVAPI_STEREO_DX9_REGISTRY_PROFILE,     //!< Separate registry configuration profile for a DirectX 9 executable.
    NVAPI_STEREO_DX10_REGISTRY_PROFILE     //!< Separate registry configuration profile for a DirectX 10 executable.
} NV_STEREO_REGISTRY_PROFILE_TYPE;


//! \ingroup stereoapi
NVAPI_INTERFACE NvAPI_Stereo_CreateConfigurationProfileRegistryKey(NV_STEREO_REGISTRY_PROFILE_TYPE registryProfileType);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_DeleteConfigurationProfileRegistryKey
//
//! DESCRIPTION:   Removes configuration registry key for current application.
//!
//!                If an application already has a configuration profile prior to this function call,
//!                the function attempts to remove the application's configuration profile registry key from the registry.
//!                If there is no configuration profile registry key prior to the function call,
//!                the function does nothing and does not report an error.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]   registryProfileType   Type of profile that the application wants to delete. This should be one of the symbolic 
//!                                     constants defined in ::NV_STEREO_REGISTRY_PROFILE_TYPE. Any other value will cause the function 
//!                                     to do nothing and return ::NV_STEREO_REGISTRY_PROFILE_TYPE_NOT_SUPPORTED.
//!
//! \retval ::NVAPI_OK                                           Key does not exist in the registry any more.
//! \retval ::NVAPI_STEREO_REGISTRY_PROFILE_TYPE_NOT_SUPPORTED   This profile type is not supported.
//! \retval ::NVAPI_STEREO_REGISTRY_ACCESS_FAILED                Access to registry failed.
//! \retval ::NVAPI_API_NOT_INTIALIZED                           NVAPI is not initialized.
//! \retval ::NVAPI_STEREO_NOT_INITIALIZED                       Stereo part of NVAPI is not initialized.
//! \retval ::NVAPI_ERROR 
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_DeleteConfigurationProfileRegistryKey(NV_STEREO_REGISTRY_PROFILE_TYPE registryProfileType);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_SetConfigurationProfileValue
//
//! \fn NvAPI_Stereo_SetConfigurationProfileValue(NV_STEREO_REGISTRY_PROFILE_TYPE registryProfileType, NV_STEREO_REGISTRY_ID valueRegistryID, void *pValue)
//!
//! DESCRIPTION:   This API sets the given parameter value under the application's registry key.
//!
//!                If the value does not exist under the application's registry key,
//!                the value will be created under the key.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]     registryProfileType  The type of profile the application wants to access. It should be one of the 
//!                                      symbolic constants defined in ::NV_STEREO_REGISTRY_PROFILE_TYPE. Any other value 
//!                                      will cause function to do nothing and return ::NV_STEREO_REGISTRY_PROFILE_TYPE_NOT_SUPPORTED.
//! \param [in]     valueRegistryID      ID of the value that is being set. It should be one of the symbolic constants defined in
//!                                      ::NV_STEREO_REGISTRY_PROFILE_TYPE. Any other value will cause function to do nothing
//!                                      and return ::NVAPI_STEREO_REGISTRY_VALUE_NOT_SUPPORTED.
//! \param [in]     pValue               Address of the value that is being set. It should be either address of a DWORD or of a float,
//!                                      dependent on the type of the stereo parameter whose value is being set. The API will then cast that
//!                                      address to DWORD* and write whatever is in those 4 bytes as a DWORD to the registry.
//!
//! \retval ::NVAPI_OK                                           Value is written to registry.
//! \retval ::NVAPI_STEREO_REGISTRY_PROFILE_TYPE_NOT_SUPPORTED   This profile type is not supported.
//! \retval ::NVAPI_STEREO_REGISTRY_VALUE_NOT_SUPPORTED          This value is not supported.
//! \retval ::NVAPI_STEREO_REGISTRY_ACCESS_FAILED                Access to registry failed.
//! \retval ::NVAPI_API_NOT_INTIALIZED                           NVAPI is not initialized.
//! \retval ::NVAPI_STEREO_NOT_INITIALIZED                       Stereo part of NVAPI is not initialized.
//! \retval ::NVAPI_ERROR                                        Something is wrong (generic error).
//
///////////////////////////////////////////////////////////////////////////////


//! \ingroup stereoapi
//! Used in NvAPI_Stereo_SetConfigurationProfileValue()
typedef enum _NV_StereoRegistryID
{
    NVAPI_CONVERGENCE_ID,         //!< Symbolic constant for convergence registry ID.
    NVAPI_FRUSTUM_ADJUST_MODE_ID, //!< Symbolic constant for frustum adjust mode registry ID.
} NV_STEREO_REGISTRY_ID;


//! \ingroup stereoapi
NVAPI_INTERFACE NvAPI_Stereo_SetConfigurationProfileValue(NV_STEREO_REGISTRY_PROFILE_TYPE registryProfileType, NV_STEREO_REGISTRY_ID valueRegistryID, void *pValue);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_DeleteConfigurationProfileValue
//
//! DESCRIPTION:   This API removes the given value from the application's configuration profile registry key.
//!                If there is no such value, the function does nothing and does not report an error.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]     registryProfileType   The type of profile the application wants to access. It should be one of the 
//!                                       symbolic constants defined in ::NV_STEREO_REGISTRY_PROFILE_TYPE. Any other value will 
//!                                       cause function to do nothing and return ::NV_STEREO_REGISTRY_PROFILE_TYPE_NOT_SUPPORTED.
//! \param [in]     valueRegistryID       ID of the value that is being deleted. It should be one of the symbolic constants defined in
//!                                       ::NV_STEREO_REGISTRY_PROFILE_TYPE. Any other value will cause function to do nothing and return
//!                                       ::NVAPI_STEREO_REGISTRY_VALUE_NOT_SUPPORTED.
//!
//! \retval ::NVAPI_OK                                           Value does not exist in registry any more.
//! \retval ::NVAPI_STEREO_REGISTRY_PROFILE_TYPE_NOT_SUPPORTED   This profile type is not supported.
//! \retval ::NVAPI_STEREO_REGISTRY_VALUE_NOT_SUPPORTED          This value is not supported.
//! \retval ::NVAPI_STEREO_REGISTRY_ACCESS_FAILED                Access to registry failed.
//! \retval ::NVAPI_API_NOT_INTIALIZED 
//! \retval ::NVAPI_STEREO_NOT_INITIALIZED                       Stereo part of NVAPI not initialized.
//! \retval ::NVAPI_ERROR 
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_DeleteConfigurationProfileValue(NV_STEREO_REGISTRY_PROFILE_TYPE registryProfileType, NV_STEREO_REGISTRY_ID valueRegistryID);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_Enable
//
//! DESCRIPTION:   This APU enables stereo mode in the registry.
//!                Calls to this function affect the entire system.
//!                If stereo is not enabled, then calls to functions that require that stereo is enabled have no effect,
//!                and will return the appropriate error code.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \retval ::NVAPI_OK                      Stereo is now enabled.
//! \retval ::NVAPI_API_NOT_INTIALIZED 
//! \retval ::NVAPI_STEREO_NOT_INITIALIZED  Stereo part of NVAPI not initialized.
//! \retval ::NVAPI_ERROR 
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_Enable(void);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_Disable
//
//! DESCRIPTION:   This API disables stereo mode in the registry.
//!                Calls to this function affect the entire system.
//!                If stereo is not enabled, then calls to functions that require that stereo is enabled have no effect,
//!                and will return the appropriate error code.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \retval ::NVAPI_OK                     Stereo is now disabled.
//! \retval ::NVAPI_API_NOT_INTIALIZED  
//! \retval ::NVAPI_STEREO_NOT_INITIALIZED Stereo part of NVAPI not initialized.
//! \retval ::NVAPI_ERROR 
//!
//! \ingroup stereoapi 
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_Disable(void);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_IsEnabled
//
//! DESCRIPTION:   This API checks if stereo mode is enabled in the registry.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [out]     pIsStereoEnabled   Address where the result of the inquiry will be placed.
//!
//! \retval ::NVAPI_OK                       Check was sucessfully completed and result reflects current state of stereo availability.
//! \retval ::NVAPI_API_NOT_INTIALIZED 
//! \retval ::NVAPI_STEREO_NOT_INITIALIZED   Stereo part of NVAPI not initialized.
//! \retval ::NVAPI_ERROR 
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_IsEnabled(NvU8 *pIsStereoEnabled);


//! \ingroup stereoapi
//! windowed-mode stereo modes
typedef enum _NVAPI_STEREO_WINDOWED_MODE
{
    WINDOWED_MODE_STEREO_OFF            = 0,  //!< Windowed mode stereo is off.
    WINDOWED_MODE_STEREO_AUTOMATIC      = 1,  //!< Desktop is in mono mode by default, but will automatically switch to a stereo mode when a stereo application launches.
    WINDOWED_MODE_STEREO_PERSISTENT     = 2,  //!< Desktop stays in stereo mode by default, so appications will run in stereo mode without a mode switch.
} NVAPI_STEREO_WINDOWED_MODE;

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_SetWindowedMode
//
//! DESCRIPTION:   This API enables/disables windowed stereo mode in the registry.
//!                It enters 120Hz High VBI mode and disables Aero by default.
//!                Calls to this function affect the entire system.
//!                It requires stereo to be enabled for any effect.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]    modes    mode to set
//! \param [in]    flags    reserved for future use, must be 0 
//!
//! \retval ::NVAPI_OK
//! \retval ::NVAPI_API_NOT_INTIALIZED
//! \retval ::NVAPI_STEREO_NOT_INITIALIZED
//! \retval ::NVAPI_ERROR
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_SetWindowedMode(NVAPI_STEREO_WINDOWED_MODE mode, NvU32 flags);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_GetWindowedMode
//
//! DESCRIPTION:   Ths API checks if windowed stereo is enabled in the registry.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [out]    pMode    Address where result of the inquiry will be placed.
//!
//! \retval ::NVAPI_OK
//! \retval ::NVAPI_API_NOT_INTIALIZED
//! \retval ::NVAPI_STEREO_NOT_INITIALIZED
//! \retval ::NVAPI_ERROR
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_GetWindowedMode(NVAPI_STEREO_WINDOWED_MODE *pMode);



//! \addtogroup stereoapi
//! @{

typedef struct _NVAPI_STEREO_CAPS
{
    NvU32 version;
    NvU32 supportsWindowedModeOff        : 1;
    NvU32 supportsWindowedModeAutomatic  : 1;
    NvU32 supportsWindowedModePersistent : 1;
    NvU32 reserved                       : 29;  // must be 0
    NvU32 reserved2[3];                         // must be 0
} NVAPI_STEREO_CAPS_V1;

#define NVAPI_STEREO_CAPS_VER1  MAKE_NVAPI_VERSION(NVAPI_STEREO_CAPS,1)
#define NVAPI_STEREO_CAPS_VER   NVAPI_STEREO_CAPS_VER1

typedef NVAPI_STEREO_CAPS_V1    NVAPI_STEREO_CAPS;

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_GetStereoSupport
//
//! DESCRIPTION:  This API checks what kind of stereo support is currently supported on a particular display.
//!               If the the display is prohibited from showing stereo (e.g. secondary in a multi-mon setup), we will 
//!               return 0 for all stereo modes (full screen exclusive, automatic windowed, persistent windowed).
//!               Otherwise, we will check which stereo mode is supported. On 120Hz display, this will be what
//!               the user chooses in control panel. On HDMI 1.4 display, persistent windowed mode is always assumed to be
//!               supported. Note that this function does not check if the CURRENT RESOLUTION/REFRESH RATE can support
//!               stereo. For HDMI 1.4, it is the app's responsibility to change the resolution/refresh rate to one that is
//!               3D compatible. For 120Hz, the driver will ALWAYS force 120Hz anyway.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 304
//!
//! \param [in]     hMonitor handle to monitor that app is going to run on
//! \param [out]    pCaps    Address where the result of the inquiry will be placed.
//!                          *pCaps is defined in NVAPI_STEREO_CAPS.
//! \return       This API can return any of the following error codes enumerated in #NvAPI_Status
//! \retval ::NVAPI_OK
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_GetStereoSupport(__in NvMonitorHandle hMonitor, __out NVAPI_STEREO_CAPS *pCaps);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_GetStereoCaps
//
//! DESCRIPTION:   This API checks if the system is capable of stereo features, e.g., windowed mode stereo.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [out]    pCaps    Address where the result of the inquiry will be placed.
//!                           *pCaps is defined in NVAPI_STEREO_CAPS.
//!
//! \retval ::NVAPI_OK
//! \retval ::NVAPI_API_NOT_INTIALIZED
//! \retval ::NVAPI_STEREO_NOT_INITIALIZED
//! \retval ::NVAPI_ERROR
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_GetStereoCaps(NVAPI_STEREO_CAPS *pCaps);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_GetStereoCapsInternal
//
//! DESCRIPTION:   This API checks if the system is capable of stereo features, e.g., windowed mode stereo.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [out]     pCaps   Address where the result of the inquiry will be placed.
//!                          *pCaps is defined in NVAPI_STEREO_CAPS.
//!
//! \retval ::NVAPI_OK
//! \retval ::NVAPI_API_NOT_INTIALIZED
//! \retval ::NVAPI_STEREO_NOT_INITIALIZED
//! \retval ::NVAPI_ERROR
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_GetStereoCapsInternal(NVAPI_STEREO_CAPS *pCaps);



#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_CreateHandleFromIUnknown
//
//! DESCRIPTION:   This API creates a stereo handle that is used in subsequent calls related to a given device interface.
//!                This must be called before any other NvAPI_Stereo_ function for that handle.
//!                Multiple devices can be used at one time using multiple calls to this function (one per each device). 
//!
//! HOW TO USE:    After the Direct3D device is created, create the stereo handle.
//!                On call success:
//!                -# Use all other NvAPI_Stereo_ functions that have stereo handle as first parameter.
//!                -# After the device interface that corresponds to the the stereo handle is destroyed,
//!                the application should call NvAPI_DestroyStereoHandle() for that stereo handle. 
//!
//! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]     pDevice        Pointer to IUnknown interface that is IDirect3DDevice9* in DX9, ID3D10Device*.
//! \param [out]    pStereoHandle  Pointer to the newly created stereo handle.
//!
//! \retval ::NVAPI_OK                       Stereo handle is created for given device interface.
//! \retval ::NVAPI_INVALID_ARGUMENT         Provided device interface is invalid.
//! \retval ::NVAPI_API_NOT_INTIALIZED  
//! \retval ::NVAPI_STEREO_NOT_INITIALIZED   Stereo part of NVAPI not initialized.
//! \retval ::NVAPI_ERROR 
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_CreateHandleFromIUnknown(IUnknown *pDevice, StereoHandle *pStereoHandle);

#endif // defined(_D3D9_H_) || defined(__d3d10_h__)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_DestroyHandle
//
//! DESCRIPTION:   This API destroys the stereo handle created with one of the NvAPI_Stereo_CreateHandleFrom() functions.
//!                This should be called after the device corresponding to the handle has been destroyed.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]     stereoHandle  Stereo handle that is to be destroyed.
//!
//! \retval ::NVAPI_OK                      Stereo handle is destroyed.
//! \retval ::NVAPI_API_NOT_INTIALIZED      
//! \retval ::NVAPI_STEREO_NOT_INITIALIZED  Stereo part of NVAPI not initialized.
//! \retval ::NVAPI_ERROR                   
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_DestroyHandle(StereoHandle stereoHandle);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_Activate
//
//! DESCRIPTION:   This API activates stereo for the device interface corresponding to the given stereo handle.
//!                Activating stereo is possible only if stereo was enabled previously in the registry.
//!                If stereo is not activated, then calls to functions that require that stereo is activated have no effect,
//!                and will return the appropriate error code. 
//!
//! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]    stereoHandle  Stereo handle corresponding to the device interface.
//!
//! \retval ::NVAPI_OK                                Stereo is turned on.
//! \retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE   Device interface is not valid. Create again, then attach again.
//! \retval ::NVAPI_API_NOT_INTIALIZED 
//! \retval ::NVAPI_STEREO_NOT_INITIALIZED            Stereo part of NVAPI not initialized.
//! \retval ::NVAPI_ERROR 
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_Activate(StereoHandle stereoHandle);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_Deactivate
//
//! DESCRIPTION:   This API deactivates stereo for the given device interface.
//!                If stereo is not activated, then calls to functions that require that stereo is activated have no effect,
//!                and will return the appropriate error code. 
//!
//! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]     stereoHandle  Stereo handle that corresponds to the device interface.
//!
//! \retval ::NVAPI_OK                               Stereo is turned off.
//! \retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE  Device interface is not valid. Create again, then attach again.
//! \retval ::NVAPI_API_NOT_INTIALIZED 
//! \retval ::NVAPI_STEREO_NOT_INITIALIZED           Stereo part of NVAPI not initialized.
//! \retval ::NVAPI_ERROR 
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_Deactivate(StereoHandle stereoHandle);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_IsActivated
//
//! DESCRIPTION:   This API checks if stereo is activated for the given device interface. 
//!
//! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]    stereoHandle  Stereo handle that corresponds to the device interface.
//! \param [in]    pIsStereoOn   Address where result of the inquiry will be placed.
//! 
//! \retval ::NVAPI_OK - Check was sucessfully completed and result reflects current state of stereo (on/off).
//! \retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE - Device interface is not valid. Create again, then attach again.
//! \retval ::NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.
//! \retval ::NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//! \retval ::NVAPI_ERROR - Something is wrong (generic error).
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_IsActivated(StereoHandle stereoHandle, NvU8 *pIsStereoOn);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_GetSeparation
//
//! DESCRIPTION:   This API gets current separation value (in percents). 
//!
//! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]     stereoHandle           Stereo handle that corresponds to the device interface.
//! \param [out]    pSeparationPercentage  Address of @c float type variable to store current separation percentage in.
//!
//! \retval ::NVAPI_OK                                Retrieval of separation percentage was successfull.
//! \retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE   Device interface is not valid. Create again, then attach again.
//! \retval ::NVAPI_API_NOT_INTIALIZED  
//! \retval ::NVAPI_STEREO_NOT_INITIALIZED            Stereo part of NVAPI not initialized.
//! \retval ::NVAPI_ERROR  
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_GetSeparation(StereoHandle stereoHandle, float *pSeparationPercentage);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_SetSeparation
//
//! DESCRIPTION:   This API sets separation to given percentage. 
//!
//! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to appropriate NvAPI_Stereo_CreateHandleFrom() function.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]     stereoHandle             Stereo handle that corresponds to the device interface.
//! \param [in]     newSeparationPercentage  New value for separation percentage.
//!
//! \retval ::NVAPI_OK                               Setting of separation percentage was successfull.
//! \retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE  Device interface is not valid. Create again, then attach again.
//! \retval ::NVAPI_API_NOT_INTIALIZED               NVAPI not initialized.
//! \retval ::NVAPI_STEREO_NOT_INITIALIZED           Stereo part of NVAPI not initialized.
//! \retval ::NVAPI_STEREO_PARAMETER_OUT_OF_RANGE    Given separation percentage is out of [0..100] range.
//! \retval ::NVAPI_ERROR 
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_SetSeparation(StereoHandle stereoHandle, float newSeparationPercentage);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_DecreaseSeparation
//
//! DESCRIPTION:   This API decreases separation for the given device interface (just like the Ctrl+F3 hotkey). 
//!
//! WHEN TO USE:   After the stereo handle for device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]   stereoHandle  Stereo handle that corresponds to the device interface.
//!
//! \retval ::NVAPI_OK - Decrease of separation percentage was successfull.
//! \retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE - Device interface is not valid. Create again, then attach again.
//! \retval ::NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.
//! \retval ::NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//! \retval ::NVAPI_ERROR - Something is wrong (generic error).
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_DecreaseSeparation(StereoHandle stereoHandle);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_IncreaseSeparation
//
//! DESCRIPTION:   This API increases separation for the given device interface (just like the Ctrl+F4 hotkey).
//!
//! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]    stereoHandle  Stereo handle that corresponds to the device interface.
//!
//! \retval ::NVAPI_OK                               Increase of separation percentage was successfull.
//! \retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE  Device interface is not valid. Create again, then attach again.
//! \retval ::NVAPI_API_NOT_INTIALIZED               NVAPI not initialized.
//! \retval ::NVAPI_STEREO_NOT_INITIALIZED           Stereo part of NVAPI not initialized.
//! \retval ::NVAPI_ERROR                            Something is wrong (generic error).
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_IncreaseSeparation(StereoHandle stereoHandle);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_GetConvergence
//
//! DESCRIPTION:   This API gets the current convergence value.
//!
//! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]     stereoHandle   Stereo handle that corresponds to the device interface.
//! \param [out]    pConvergence   Address of @c float type variable to store current convergence value in.
//!
//! \retval ::NVAPI_OK                               Retrieval of convergence value was successfull.
//! \retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE  Device interface is not valid. Create again, then attach again.
//! \retval ::NVAPI_API_NOT_INTIALIZED  
//! \retval ::NVAPI_STEREO_NOT_INITIALIZED           Stereo part of NVAPI not initialized.
//! \retval ::NVAPI_ERROR 
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_GetConvergence(StereoHandle stereoHandle, float *pConvergence);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_SetConvergence
//
//! DESCRIPTION:   This API sets convergence to the given value.
//!
//! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]     stereoHandle              Stereo handle that corresponds to the device interface.
//! \param [in]     newConvergence            New value for convergence.
//! 
//! \retval ::NVAPI_OK                                Setting of convergence value was successfull.
//! \retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE   Device interface is not valid. Create again, then attach again.
//! \retval ::NVAPI_API_NOT_INTIALIZED  
//! \retval ::NVAPI_STEREO_NOT_INITIALIZED            Stereo part of NVAPI not initialized.
//! \retval ::NVAPI_ERROR 
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_SetConvergence(StereoHandle stereoHandle, float newConvergence);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_DecreaseConvergence
//
//! DESCRIPTION:   This API decreases convergence for the given device interface (just like the Ctrl+F5 hotkey). 
//!
//! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]     stereoHandle  Stereo handle that corresponds to the device interface.
//!
//! \retval ::NVAPI_OK - Decrease of convergence was successfull.
//! \retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE - Device interface is not valid. Create again, then attach again.
//! \retval ::NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.
//! \retval ::NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//! \retval ::NVAPI_ERROR - Something is wrong (generic error).
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_DecreaseConvergence(StereoHandle stereoHandle);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_IncreaseConvergence
//
//! DESCRIPTION:   This API increases convergence for given the device interface (just like the Ctrl+F5 hotkey). 
//!
//! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]    stereoHandle  Stereo handle that corresponds to the device interface.
//!
//! \retval ::NVAPI_OK                               Increase of convergence was successfull.
//! \retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE  Device interface is not valid. Create again, then attach again.
//! \retval ::NVAPI_API_NOT_INTIALIZED 
//! \retval ::NVAPI_STEREO_NOT_INITIALIZED           Stereo part of NVAPI not initialized.
//! \retval ::NVAPI_ERROR 
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_IncreaseConvergence(StereoHandle stereoHandle);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_GetFrustumAdjustMode
//
//! \fn NvAPI_Stereo_GetFrustumAdjustMode(StereoHandle stereoHandle, NV_FRUSTUM_ADJUST_MODE *pFrustumAdjustMode)
//! DESCRIPTION:   This API gets the current frustum adjust mode value. 
//!
//! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]     stereoHandle         Stereo handle that corresponds to the device interface.
//! \param [out]    pFrustumAdjustMode   Address of the NV_FRUSTUM_ADJUST_MODE type variable to store current frustum value in.
//!
//! \retval ::NVAPI_OK - Retrieval of frustum adjust mode was successfull.
//! \retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE - Device interface is not valid. Create again, then attach again.
//! \retval ::NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.
//! \retval ::NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//! \retval ::NVAPI_ERROR - Something is wrong (generic error).
//!
///////////////////////////////////////////////////////////////////////////////

//! \ingroup stereoapi
//! Used in NvAPI_Stereo_GetFrustumAdjustMode().
typedef enum _NV_FrustumAdjustMode
{
    NVAPI_NO_FRUSTUM_ADJUST,    //!< Do not adjust frustum.
    NVAPI_FRUSTUM_STRETCH,      //!< Stretch images in X.
    NVAPI_FRUSTUM_CLEAR_EDGES   //!< Clear corresponding edges for each eye.
} NV_FRUSTUM_ADJUST_MODE;

//! \ingroup stereoapi
NVAPI_INTERFACE NvAPI_Stereo_GetFrustumAdjustMode(StereoHandle stereoHandle, NV_FRUSTUM_ADJUST_MODE *pFrustumAdjustMode);





///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_SetFrustumAdjustMode
//
//! DESCRIPTION:   This API sets the current frustum adjust mode value. 
//!
//! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]     stereoHandle                Stereo handle that corresponds to the device interface.
//! \param [in]     newFrustumAdjustModeValue   New value for frustum adjust mode. It should be one of the symbolic constants defined in
//!                                             ::NV_FRUSTUM_ADJUST_MODE. Any other value will cause function to do nothing and return
//!                                             ::NVAPI_STEREO_FRUSTUM_ADJUST_MODE_NOT_SUPPORTED.
//!
//! \retval ::NVAPI_OK                                         Retrieval of frustum adjust mode was successfull.
//! \retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE            Device interface is not valid. Create again, then attach again.
//! \retval ::NVAPI_API_NOT_INTIALIZED 
//! \retval ::NVAPI_STEREO_NOT_INITIALIZED                     Stereo part of NVAPI not initialized.
//! \retval ::NVAPI_STEREO_FRUSTUM_ADJUST_MODE_NOT_SUPPORTED   Given frustum adjust mode is not supported.
//! \retval ::NVAPI_ERROR 
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_SetFrustumAdjustMode(StereoHandle stereoHandle, NV_FRUSTUM_ADJUST_MODE newFrustumAdjustModeValue);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_CaptureJpegImage
//
//! DESCRIPTION:   This API captures the current stereo image in JPEG stereo format with the given quality.
//!                Only the last capture call per flip will be effective. 
//!
//! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]     stereoHandle  Stereo handle that corresponds to the device interface.
//! \param [in]     quality        Quality of the JPEG image to be captured. Integer value betweeen 0 and 100.
//! 
//! \retval ::NVAPI_OK                              Image captured.
//! \retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE Device interface is not valid. Create again, then attach again.
//! \retval ::NVAPI_API_NOT_INTIALIZED 
//! \retval ::NVAPI_STEREO_NOT_INITIALIZED 
//! \retval ::NVAPI_STEREO_PARAMETER_OUT_OF_RANGE   Given quality is out of [0..100] range.
//! \retval ::NVAPI_ERROR 
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_CaptureJpegImage(StereoHandle stereoHandle, NvU32 quality);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_InitActivation
//
//! DESCRIPTION:   This API allows an application to enable stereo viewing, without the need of a GUID/Key pair
//!				   This API cannot be used to enable stereo viewing on 3DTV.
//!
//! HOW TO USE:    Call this function immediately after device creation, then follow with a reset. \n 
//!                Very generically:
//!                Create Device->Create Stereo Handle->InitActivation->Reset Device
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! \since Release: 302
//!
//! \param [in]   stereoHandle            Stereo handle corresponding to the device interface.
//! \param [in]   bDelayed				  Use delayed activation
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, 
//!         they are listed below.
//! \retval ::NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////

//! \addtogroup stereoapi
//! @{

//! InitActivation Flags
typedef enum _NVAPI_STEREO_INIT_ACTIVATION_FLAGS
{
	NVAPI_STEREO_INIT_ACTIVATION_IMMEDIATE = 0X00,
    NVAPI_STEREO_INIT_ACTIVATION_DELAYED = 0x01,
} NVAPI_STEREO_INIT_ACTIVATION_FLAGS;

NVAPI_INTERFACE NvAPI_Stereo_InitActivation(__in StereoHandle hStereoHandle, __in NVAPI_STEREO_INIT_ACTIVATION_FLAGS flags);

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_Trigger_Activation
//
//! DESCRIPTION:   This API allows an application to trigger creation of a stereo desktop, 
//!				   in case the creation was stopped on application launch. 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! \since Release: 302
//!
//! \param [in]   stereoHandle   Stereo handle that corresponds to the device interface.
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, 
//!         they are listed below.
//! \retval ::NVAPI_STEREO_INIT_ACTIVATION_NOT_DONE - Stereo InitActivation not called.
//! \retval ::NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_Trigger_Activation(__in StereoHandle hStereoHandle);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_CapturePngImage
//
//! DESCRIPTION:   This API captures the current stereo image in PNG stereo format.
//!                Only the last capture call per flip will be effective. 
//!
//! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//! \param [in]     stereoHandle  Stereo handle corresponding to the device interface.
//!
//! \retval ::NVAPI_OK                               Image captured.
//! \retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE  Device interface is not valid. Create again, then attach again.
//! \retval ::NVAPI_API_NOT_INTIALIZED 
//! \retval ::NVAPI_STEREO_NOT_INITIALIZED           Stereo part of NVAPI not initialized.
//! \retval ::NVAPI_ERROR 
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_CapturePngImage(StereoHandle stereoHandle);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_ReverseStereoBlitControl
//
//! DESCRIPTION:   This API turns on/off reverse stereo blit.
//!
//! HOW TO USE:    Use after the stereo handle for the device interface is created via successfull call to the appropriate 
//!                NvAPI_Stereo_CreateHandleFrom() function.
//!                After reversed stereo blit control is turned on, blits from the stereo surface will
//!                produce the right-eye image in the left side of the destination surface and the left-eye
//!                image in the right side of the destination surface.
//!
//!                In DirectX 9, the destination surface must be created as the render target, and StretchRect must be used.
//!                Conditions:
//!                - DstWidth == 2*SrcWidth
//!                - DstHeight == SrcHeight
//!                - Src surface is the stereo surface.
//!                - SrcRect must be {0,0,SrcWidth,SrcHeight}
//!                - DstRect must be {0,0,DstWidth,DstHeight}
//!
//!                In DirectX 10, ResourceCopyRegion must be used. 
//!                Conditions:
//!                - DstWidth == 2*SrcWidth
//!                - DstHeight == SrcHeight
//!                - dstX == 0,
//!                - dstY == 0,
//!                - dstZ == 0,
//!                - SrcBox: left=top=front==0; right==SrcWidth; bottom==SrcHeight; back==1;
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]    stereoHandle  Stereo handle corresponding to the device interface.
//! \param [in]    TurnOn         != 0 : Turns on \n 
//!                               == 0 : Turns off 
//!
//!
//! \retval ::NVAPI_OK                                Retrieval of frustum adjust mode was successfull.
//! \retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE   Device interface is not valid. Create again, then attach again.
//! \retval ::NVAPI_API_NOT_INTIALIZED 
//! \retval ::NVAPI_STEREO_NOT_INITIALIZED            Stereo part of NVAPI not initialized.
//! \retval ::NVAPI_ERROR 
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_ReverseStereoBlitControl(StereoHandle hStereoHandle, NvU8 TurnOn);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_SetNotificationMessage
//
//! DESCRIPTION:   This API is a Setup notification message that the stereo driver uses to notify the application
//!                when the user changes the stereo driver state. 
//!
//!                When the user changes the stereo state (Activated or Deactivated, separation or conversion)
//!                the stereo driver posts a defined message with the following parameters:
//!
//!                lParam  is the current conversion. (Actual conversion is *(float*)&lParam )
//!          
//!                wParam == MAKEWPARAM(l, h) where
//!                - l == 0 if stereo is deactivated
//!                - l == 1 if stereo is deactivated
//!                - h is the current separation. (Actual separation is float(h*100.f/0xFFFF)  
//!                
//!                Call this API with NULL hWnd to prohibit notification.
//!
//! WHEN TO USE:   Use after the stereo handle for device interface is created via successful call to appropriate
//!                NvAPI_Stereo_CreateHandleFrom() function.
//!                
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 180
//!
//!
//! \param [in]     stereoHandle  Stereo handle corresponding to the device interface.
//! \param [in]     hWnd          Window HWND that will be notified when the user changes the stereo driver state.
//!                               Actual HWND must be cast to an NvU64.
//! \param [in]     messageID     MessageID of the message that will be posted to hWnd
//!
//! \retval ::NVAPI_OK                                Notification set.
//! \retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE   Device interface is not valid. Create again, then attach again.
//! \retval ::NVAPI_API_NOT_INTIALIZED 
//! \retval ::NVAPI_STEREO_NOT_INITIALIZED            Stereo part of NVAPI not initialized.
//! \retval ::NVAPI_ERROR 
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_SetNotificationMessage(StereoHandle hStereoHandle, NvU64 hWnd,NvU64 messageID);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_SetActiveEye
//
//! \fn NvAPI_Stereo_SetActiveEye(StereoHandle hStereoHandle, NV_STEREO_ACTIVE_EYE StereoEye);
//! DESCRIPTION:   This API sets the back buffer to left or right in Direct stereo mode.
//!                  
//! HOW TO USE:    After the stereo handle for device interface is created via successfull call to appropriate 
//!                NvAPI_Stereo_CreateHandleFrom function.
//!
//! \since Release: 285
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]   stereoHandle  Stereo handle that corresponds to the device interface.
//! \param [in]   StereoEye     Defines active eye in Direct stereo mode
//!
//! \retval ::NVAPI_OK - Active eye is set.
//! \retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE - Device interface is not valid. Create again, then attach again.
//! \retval ::NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.
//! \retval ::NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//! \retval ::NVAPI_INVALID_ARGUMENT - StereoEye parameter has not allowed value.
//! \retval ::NVAPI_SET_NOT_ALLOWED  - Current stereo mode is not Direct
//! \retval ::NVAPI_ERROR - Something is wrong (generic error).
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup stereoapi
typedef enum _NV_StereoActiveEye
{
    NVAPI_STEREO_EYE_RIGHT = 1,
    NVAPI_STEREO_EYE_LEFT = 2,
    NVAPI_STEREO_EYE_MONO = 3,
} NV_STEREO_ACTIVE_EYE;

//! \ingroup stereoapi
NVAPI_INTERFACE NvAPI_Stereo_SetActiveEye(StereoHandle hStereoHandle, NV_STEREO_ACTIVE_EYE StereoEye);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_SetDriverMode
//
//! \fn NvAPI_Stereo_SetDriverMode( NV_STEREO_DRIVER_MODE mode );
//! DESCRIPTION:   This API sets the 3D stereo driver mode: Direct or Automatic
//!                  
//! HOW TO USE:    This API must be called before the device is created.
//!                Applies to DirectX 9 and higher.
//!
//! \since Release: 285
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!      
//! \param [in]    mode       Defines the 3D stereo driver mode: Direct or Automatic
//!
//! \retval ::NVAPI_OK                      Active eye is set.
//! \retval ::NVAPI_API_NOT_INTIALIZED      NVAPI not initialized.
//! \retval ::NVAPI_STEREO_NOT_INITIALIZED  Stereo part of NVAPI not initialized.
//! \retval ::NVAPI_INVALID_ARGUMENT        mode parameter has not allowed value.
//! \retval ::NVAPI_ERROR                   Something is wrong (generic error).
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup stereoapi
typedef enum _NV_StereoDriverMode
{
    NVAPI_STEREO_DRIVER_MODE_AUTOMATIC = 0,
    NVAPI_STEREO_DRIVER_MODE_DIRECT    = 2,
} NV_STEREO_DRIVER_MODE;

//! \ingroup stereoapi
NVAPI_INTERFACE NvAPI_Stereo_SetDriverMode( NV_STEREO_DRIVER_MODE mode );



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_GetEyeSeparation
//
//! DESCRIPTION:   This API returns eye separation as a ratio of <between eye distance>/<physical screen width>.
//! 
//! HOW TO USE:    After the stereo handle for device interface is created via successfull call to appropriate API. Applies only to DirectX 9 and up.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]   stereoHandle  Stereo handle that corresponds to the device interface.
//! \param [out]  pSeparation   Eye separation.
//!
//! \retval ::NVAPI_OK                               Active eye is set.
//! \retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE  Device interface is not valid. Create again, then attach again.
//! \retval ::NVAPI_API_NOT_INTIALIZED               NVAPI not initialized.
//! \retval ::NVAPI_STEREO_NOT_INITIALIZED           Stereo part of NVAPI not initialized.
//! \retval ::NVAPI_ERROR  (generic error).
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_GetEyeSeparation(StereoHandle hStereoHandle,  float *pSeparation );

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_IsWindowedModeSupported
//
//! DESCRIPTION:   This API returns availability of windowed mode stereo
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [out] bSupported(OUT)    != 0  - supported,  \n
//!                                 == 0  - is not supported 
//!
//!
//! \retval ::NVAPI_OK                      Retrieval of frustum adjust mode was successfull.
//! \retval ::NVAPI_API_NOT_INTIALIZED      NVAPI not initialized.
//! \retval ::NVAPI_STEREO_NOT_INITIALIZED  Stereo part of NVAPI not initialized.
//! \retval ::NVAPI_ERROR                   Something is wrong (generic error).
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_IsWindowedModeSupported(NvU8* bSupported);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_SetVideoControl
//
//! \fn NvAPI_Stereo_SetVideoControl(StereoHandle hStereoHandle, NVAPI_STEREO_VIDEO_CONTROL* pStereoVideoControl)
//! \code
//! PARAMETERS:    stereoHandle(IN) - Stereo handle that corresponds to the device interface.
//!                pStereoVideoControl (IN) - pointer to struct NVAPI_STEREO_VIDEO_CONTROL
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION:   Sets the control parameters for stereo video
//!
//! HOW TO USE:
//!
//! RETURN STATUS:
//!                NVAPI_OK - Video control was successful
//!                NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.
//!                NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//!                NVAPI_ERROR - Something is wrong (generic error).
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \ingroup stereoapi
typedef enum _STEREO_SRC_LAYOUT
{
    STEREO_SRC_LAYOUT_LEFT_RIGHT = 0,
    STEREO_SRC_LAYOUT_RIGHT_LEFT = 1,
    STEREO_SRC_LAYOUT_TOP_BOTTOM = 2,
    STEREO_SRC_LAYOUT_BOTTOM_TOP = 3,
    STEREO_SRC_LAYOUT_MONO_MODE  = 4,
    STEREO_SRC_LAYOUT_LAST       = 5 
} STEREO_SRC_LAYOUT;

//! \ingroup stereoapi
typedef struct _NVAPI_STEREO_VIDEO_CONTROL
{
    NvU32               dwVersion;             // struct version
    STEREO_SRC_LAYOUT   eStereoSrcLayout;
    NvU32               dwClientIdentifier;
    NvU32               dwStereoEnable;
} NVAPI_STEREO_VIDEO_CONTROL_V1;

//! \ingroup stereoapi
typedef NVAPI_STEREO_VIDEO_CONTROL_V1      NVAPI_STEREO_VIDEO_CONTROL;
//! \ingroup stereoapi
#define NVAPI_STEREO_VIDEO_CONTROL_VER1    MAKE_NVAPI_VERSION(NVAPI_STEREO_VIDEO_CONTROL_V1, 1)
//! \ingroup stereoapi
#define NVAPI_STEREO_VIDEO_CONTROL_VER     NVAPI_STEREO_VIDEO_CONTROL_VER1
//! \ingroup stereoapi
NVAPI_INTERFACE NvAPI_Stereo_SetVideoControl(StereoHandle hStereoHandle, NVAPI_STEREO_VIDEO_CONTROL* pStereoVideoControl);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_SetVideoMetadata
//
//! \fn NvAPI_Stereo_SetVideoMetadata(StereoHandle hStereoHandle, NVAPI_STEREO_VIDEO_METADATA* pStereoVideoMetadata)
//! \code
//! PARAMETERS:    stereoHandle(IN) - Stereo handle that corresponds to the device interface.
//!                pStereoVideoMetadata (IN) - pointer to struct NVAPI_STEREO_VIDEO_METADATA
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION:   Sets the available stereo video metadata
//!
//! HOW TO USE:
//!
//! RETURN STATUS:
//!                NVAPI_OK - Setting of video metadata was successful
//!                NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.
//!                NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//!                NVAPI_ERROR - Something is wrong (generic error).
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \ingroup stereoapi
typedef struct _NVAPI_STEREO_VIDEO_METADATA
{
    NvU32               dwVersion;        // struct version
    NvU32               dwVideoWidth;
    NvU32               dwVideoHeight;
    NvU64               hSrcLuma;
    NvU64               hDst;
} NVAPI_STEREO_VIDEO_METADATA_V1;

//! \ingroup stereoapi
typedef NVAPI_STEREO_VIDEO_METADATA_V1      NVAPI_STEREO_VIDEO_METADATA;
//! \ingroup stereoapi
#define NVAPI_STEREO_VIDEO_METADATA_VER1    MAKE_NVAPI_VERSION(NVAPI_STEREO_VIDEO_METADATA_V1, 1)
//! \ingroup stereoapi
#define NVAPI_STEREO_VIDEO_METADATA_VER     NVAPI_STEREO_VIDEO_METADATA_VER1
//! \ingroup stereoapi
NVAPI_INTERFACE NvAPI_Stereo_SetVideoMetadata(StereoHandle hStereoHandle, NVAPI_STEREO_VIDEO_METADATA* pStereoVideoMetadata);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_AppHandShake
//
//! \fn NvAPI_Stereo_AppHandShake(StereoHandle hStereoHandle, NVAPI_STEREO_HANDSHAKE_PARAMS* pStereoHandshakeParams)
//! DESCRIPTION:   This API allows an approved application to enable stereo viewing through
//!                a handshake with the driver instead of via a hardcoded application exe name.
//!
//! HOW TO USE:    Call this function immediately after device creation, then follow with a reset. \n 
//!                Very generically:
//!                Create Device->Create Stereo Handle->Do Handshake->Reset Device
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]   stereoHandle            Stereo handle corresponding to the device interface.
//! \param [in]   pStereoHandshakeParams  pointer to struct NVAPI_STEREO_HANDSHAKE_PARAMS
//!
//! \retval ::NVAPI_OK - completed request
//! \retval ::NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.
//! \retval ::NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//! \retval ::NVAPI_INVALID_ARGUMENT - the vendor ID and/or response is invalid
//! \retval ::NVAPI_STEREO_HANDSHAKE_NOT_DONE - Stereo handshake failed
//! \retval ::NVAPI_ERROR - Something is wrong (generic error).
//
///////////////////////////////////////////////////////////////////////////////

//! \addtogroup stereoapi
//! @{

//! Stereo Handshake Commands
typedef enum _NVAPI_STEREO_HANDSHAKE_COMMANDS
{
    NVAPI_STEREO_HANDSHAKE_CMD_CHALLENGE = 0x01,
    NVAPI_STEREO_HANDSHAKE_CMD_RESPONSE  = 0x02,
} NVAPI_STEREO_HANDSHAKE_COMMANDS;

//! Stereo Handshake Constants
#define NVAPI_STEREO_HANDSHAKE_CHALLENGE_SIZE     16
#define NVAPI_STEREO_HANDSHAKE_RESPONSE_SIZE      20

//
//! Parameter data structure for the NVAPI_STEREO_HANDSHAKE_CMD_CHALLENGE command:
//! This command requests a random challenge from driver.
//! It must be invoked before the NVAPI_STEREO_HANDSHAKE_CMD_RESPONSE command.
typedef struct _NVAPI_STEREO_HANDSHAKE_CHALLENGE_PARAMS
{
    NvU8 challenge[NVAPI_STEREO_HANDSHAKE_CHALLENGE_SIZE];    //!< random challenge from driver (OUT)
} NVAPI_STEREO_HANDSHAKE_CHALLENGE_PARAMS;

//
//! Parameter data structure for the NVAPI_STEREO_HANDSHAKE_CMD_RESPONSE command
//!
//! The application must possess the following information in order to calculate a valid response:
//! - vendorGUID: a unique ID assigned to the application vendor by NVIDIA;
//! - vendorKEY:  a secret key issued to the application vendor by NVIDIA;
//!
//! The response is calculated as HMAC(vendorKEY, (vendorGUID || challenge))
//! where HMAC is the Keyed-Hash Message Authentication Code using SHA-1 as the
//! underlying hash function. See FIPS Publication 198 for details of the algorithm.
typedef struct _NVAPI_STEREO_HANDSHAKE_RESPONSE_PARAMS
{
    NvGUID vendorGUID;                                          //!< vendor GUID from app (IN)
    NvU8   response[NVAPI_STEREO_HANDSHAKE_RESPONSE_SIZE];    //!< response from app (IN)
    NvU32  flags;                                               //!< Flags set by application (IN/OPTIONAL)
} NVAPI_STEREO_HANDSHAKE_RESPONSE_PARAMS;

typedef struct _NVAPI_STEREO_HANDSHAKE_PARAMS
{
    NvU32 version;                      //!< structure version (IN)
    NvU32 dwCommand;                    //!< command (IN)
    union
    {
        NVAPI_STEREO_HANDSHAKE_CHALLENGE_PARAMS   ChallengeParams;
        NVAPI_STEREO_HANDSHAKE_RESPONSE_PARAMS    ResponseParams;
    };
} NVAPI_STEREO_HANDSHAKE_PARAMS_V1;

typedef NVAPI_STEREO_HANDSHAKE_PARAMS_V1      NVAPI_STEREO_HANDSHAKE_PARAMS;
#define NVAPI_STEREO_HANDSHAKE_PARAMS_VER1    MAKE_NVAPI_VERSION(NVAPI_STEREO_HANDSHAKE_PARAMS_V1, 1)
#define NVAPI_STEREO_HANDSHAKE_PARAMS_VER     NVAPI_STEREO_HANDSHAKE_PARAMS_VER1

NVAPI_INTERFACE NvAPI_Stereo_AppHandShake(StereoHandle hStereoHandle, NVAPI_STEREO_HANDSHAKE_PARAMS* pStereoHandshakeParams);

//! @}




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_HandShake_Trigger_Activation
//
//! DESCRIPTION:   This API allows an approved application (approved through handshake) to 
//!                trigger creation of a stereo desktop, in case the creation was stopped on application
//!                launch. 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]   stereoHandle   Stereo handle that corresponds to the device interface.
//!
//! \retval ::NVAPI_OK - completed request
//! \retval ::NVAPI_STEREO_HANDSHAKE_NOT_DONE - Stereo handshake not done prior to call
//! \retval ::NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.
//! \retval ::NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//! \retval ::NVAPI_ERROR - Something is wrong (generic error).
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_HandShake_Trigger_Activation(StereoHandle hStereoHandle);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_HandShake_Message_Control
//
//! DESCRIPTION:   This API allows an approved application (approved through handshake) to 
//!                turn on/off the stereo message displayed onscreen.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]   stereoHandle  Stereo handle that corresponds to the device interface.
//! \param [in]   TurnOn       != 0  - turns on,
//!                              == 0  - turns off
//!
//! \retval ::NVAPI_OK - completed request
//! \retval ::NVAPI_STEREO_HANDSHAKE_NOT_DONE - Stereo handshake not done prior to call
//! \retval ::NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.
//! \retval ::NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//! \retval ::NVAPI_ERROR - Something is wrong (generic error).
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_HandShake_Message_Control(StereoHandle hStereoHandle, NvU8 TurnOn);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_SetSurfaceCreationMode
//
//! \function NvAPI_Stereo_SetSurfaceCreationMode(StereoHandle hStereoHandle, NVAPI_STEREO_SURFACECREATEMODE creationMode)
//! \param [in]   hStereoHandle   Stereo handle that corresponds to the device interface.
//! \param [in]   creationMode    New surface creation mode for this device interface.
//!
//! \since Release: 285
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION: This API sets surface creation mode for this device interface.
//!
//! WHEN TO USE: After the stereo handle for device interface is created via successful call to appropriate NvAPI_Stereo_CreateHandleFrom function.
//!
//! \return      This API can return any of the error codes enumerated in #NvAPI_Status. 
//!              There are no return error codes with specific meaning for this API.
//!
///////////////////////////////////////////////////////////////////////////////

//! \ingroup stereoapi
typedef enum _NVAPI_STEREO_SURFACECREATEMODE 
{
    NVAPI_STEREO_SURFACECREATEMODE_AUTO,        //!< Use driver registry profile settings for surface creation mode. 
    NVAPI_STEREO_SURFACECREATEMODE_FORCESTEREO, //!< Always create stereo surfaces. 
    NVAPI_STEREO_SURFACECREATEMODE_FORCEMONO    //!< Always create mono surfaces. 
} NVAPI_STEREO_SURFACECREATEMODE; 

//! \ingroup stereoapi
NVAPI_INTERFACE NvAPI_Stereo_SetSurfaceCreationMode(__in StereoHandle hStereoHandle, __in NVAPI_STEREO_SURFACECREATEMODE creationMode);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_GetSurfaceCreationMode
//
//! \function NvAPI_Stereo_GetSurfaceCreationMode(StereoHandle hStereoHandle, NVAPI_STEREO_SURFACECREATEMODE* pCreationMode)
//! \param [in]   hStereoHandle   Stereo handle that corresponds to the device interface.
//! \param [out]   pCreationMode   The current creation mode for this device interface.
//!
//! \since Release: 295
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION: This API gets surface creation mode for this device interface.
//!
//! WHEN TO USE: After the stereo handle for device interface is created via successful call to appropriate NvAPI_Stereo_CreateHandleFrom function.
//!
//! \return      This API can return any of the error codes enumerated in #NvAPI_Status. 
//!              There are no return error codes with specific meaning for this API.
//!
///////////////////////////////////////////////////////////////////////////////

//! \ingroup stereoapi
NVAPI_INTERFACE NvAPI_Stereo_GetSurfaceCreationMode(__in StereoHandle hStereoHandle, __in NVAPI_STEREO_SURFACECREATEMODE* pCreationMode);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_Debug_WasLastDrawStereoized
//
//! \param [in]  hStereoHandle    Stereo handle that corresponds to the device interface.
//! \param [out] pWasStereoized   Address where result of the inquiry will be placed.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION: This API checks if the last draw call was stereoized. It is a very expensive to call and should be used for debugging purpose *only*.
//!
//! WHEN TO USE: After the stereo handle for device interface is created via successful call to appropriate NvAPI_Stereo_CreateHandleFrom function.
//!
//! \return      This API can return any of the error codes enumerated in #NvAPI_Status. 
//!              There are no return error codes with specific meaning for this API.
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_Debug_WasLastDrawStereoized(__in StereoHandle hStereoHandle, __out NvU8 *pWasStereoized);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_ForceToScreenDepth
//
//! \param [in]  hStereoHandle         Stereo handle that corresponds to the device interface.
//! \param [in]  bForceToScreenDepth   New mode for rendering depth of objects 
//!                   #true all objects after this call will be rendered at screen depth; 
//!                   #false all objects after this call will be rendered at their intended depth; 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION: This API forces objects to be rendered at screen depth (or at their intended depth).
//!
//! WHEN TO USE: After the stereo handle for device interface is created via successfull call to appropriate NvAPI_Stereo_CreateHandleFrom function.
//!
//! \return      This API can return any of the error codes enumerated in #NvAPI_Status. 
//!              There are no return error codes with specific meaning for this API.
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_ForceToScreenDepth(__in StereoHandle hStereoHandle, __in NvU8 bForceToScreenDepth);



#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_SetVertexShaderConstantF
//
//! \param [in]  hStereoHandle         Stereo handle that corresponds to the device interface.
//! \param [in]  StartRegister         Register number that will contain the first constant value.
//! \param [in]  pConstantDataMono     Pointer to an array of constants for mono view.
//! \param [in]  pConstantDataLeft     Pointer to an array of constants for left eye view.
//! \param [in]  pConstantDataRight    Pointer to an array of constants for right eye view.
//! \param [in]  Vector4fCount         Number of four float vectors in the array of constants.
//! \return      This API can return any of the error codes enumerated in #NvAPI_Status. 
//!              There are no return error codes with specific meaning for this API.
//!
//! \ingroup stereoapi
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION: This API specifies 3 sets of floating constants to be used in mono/left/right rendering paths.
//!
//! WHEN TO USE: After the stereo handle for device interface is created via successfull call to appropriate NvAPI_Stereo_CreateHandleFrom function.
//!
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_SetVertexShaderConstantF(__in StereoHandle hStereoHandle, __in UINT StartRegister, __in float *pConstantDataMono, __in float *pConstantDataLeft, __in float *pConstantDataRight, __in UINT Vector4fCount);

#endif //defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)

#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_SetVertexShaderConstantB
//
//! \param [in]  hStereoHandle         Stereo handle that corresponds to the device interface.
//! \param [in]  StartRegister         Register number that will contain the first constant value.
//! \param [in]  pConstantDataMono     Pointer to an array of constants for mono view.
//! \param [in]  pConstantDataLeft     Pointer to an array of constants for left eye view.
//! \param [in]  pConstantDataRight    Pointer to an array of constants for right eye view.
//! \param [in]  BoolCount             Number of boolean values in the array of constants.
//! \return      This API can return any of the error codes enumerated in #NvAPI_Status. 
//!              There are no return error codes with specific meaning for this API.
//!
//! \ingroup stereoapi
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION: This API specifies 3 sets of boolean constants to be used in mono/left/right rendering paths.
//!
//! WHEN TO USE: After the stereo handle for device interface is created via successfull call to appropriate NvAPI_Stereo_CreateHandleFrom function.
//!
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_SetVertexShaderConstantB(__in StereoHandle hStereoHandle, __in UINT StartRegister, __in BOOL *pConstantDataMono, __in BOOL *pConstantDataLeft, __in BOOL *pConstantDataRight, __in UINT BoolCount);

#endif //defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_SetVertexShaderConstantI
//
//! \param [in]  hStereoHandle         Stereo handle that corresponds to the device interface.
//! \param [in]  StartRegister         Register number that will contain the first constant value.
//! \param [in]  pConstantDataMono     Pointer to an array of constants for mono view.
//! \param [in]  pConstantDataLeft     Pointer to an array of constants for left eye view.
//! \param [in]  pConstantDataRight    Pointer to an array of constants for right eye view.
//! \param [in]  Vector4iCount         Number of four integer vectors in the array of constants.
//! \return      This API can return any of the error codes enumerated in #NvAPI_Status. 
//!              There are no return error codes with specific meaning for this API.
//!
//! \ingroup stereoapi
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION: This API specifies 3 sets of integer constants to be used in mono/left/right rendering paths.
//!
//! WHEN TO USE: After the stereo handle for device interface is created via successfull call to appropriate NvAPI_Stereo_CreateHandleFrom function.
//!
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_SetVertexShaderConstantI(__in StereoHandle hStereoHandle, __in UINT StartRegister, __in int *pConstantDataMono, __in int *pConstantDataLeft, __in int *pConstantDataRight, __in UINT Vector4iCount);

#endif //defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_GetVertexShaderConstantF
//
//! \param [in]      hStereoHandle      Stereo handle that corresponds to the device interface.
//! \param [in]      StartRegister      Register number that will contain the first constant value.
//! \param [in,out]  pConstantDataMono  Pointer to an array of constants for mono view.
//! \param [in,out]  pConstantDataLeft  Pointer to an array of constants for left eye view.
//! \param [in,out]  pConstantDataRight Pointer to an array of constants for right eye view.
//! \param [in]      Vector4fCount      Number of four float vectors in the array of constants.
//! \return          This API can return any of the error codes enumerated in #NvAPI_Status. 
//!                  There are no return error codes with specific meaning for this API.
//!
//! \ingroup stereoapi
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION: This API returns 3 sets of floating constants that are used in mono/left/right rendering paths.
//!
//! WHEN TO USE: After the stereo handle for device interface is created via successfull call to appropriate NvAPI_Stereo_CreateHandleFrom function.
//!
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_GetVertexShaderConstantF(__in StereoHandle hStereoHandle, __in UINT StartRegister, __inout float *pConstantDataMono, __inout float *pConstantDataLeft, __inout float *pConstantDataRight, __in UINT Vector4fCount);

#endif //defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_GetVertexShaderConstantB
//
//! \param [in]      hStereoHandle      Stereo handle that corresponds to the device interface.
//! \param [in]      StartRegister      Register number that will contain the first constant value.
//! \param [in,out]  pConstantDataMono  Pointer to an array of constants for mono view.
//! \param [in,out]  pConstantDataLeft  Pointer to an array of constants for left eye view.
//! \param [in,out]  pConstantDataRight Pointer to an array of constants for right eye view.
//! \param [in]      BoolCount          Number of boolean values in the array of constants.
//! \return          This API can return any of the error codes enumerated in #NvAPI_Status. 
//!                  There are no return error codes with specific meaning for this API.
//!
//! \ingroup stereoapi
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION: This API returns 3 sets of boolean constants that are used in mono/left/right rendering paths.
//!
//! WHEN TO USE: After the stereo handle for device interface is created via successfull call to appropriate NvAPI_Stereo_CreateHandleFrom function.
//!
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_GetVertexShaderConstantB(__in StereoHandle hStereoHandle, __in UINT StartRegister, __inout BOOL *pConstantDataMono, __inout BOOL *pConstantDataLeft, __inout BOOL *pConstantDataRight, __in UINT BoolCount);

#endif //defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_GetVertexShaderConstantI
//
//! \param [in]      hStereoHandle      Stereo handle that corresponds to the device interface.
//! \param [in]      StartRegister      Register number that will contain the first constant value.
//! \param [in,out]  pConstantDataMono  Pointer to an array of constants for mono view.
//! \param [in,out]  pConstantDataLeft  Pointer to an array of constants for left eye view.
//! \param [in,out]  pConstantDataRight Pointer to an array of constants for right eye view.
//! \param [in]      Vector4iCount      Number of four integer vectors in the array of constants.
//! \return          This API can return any of the error codes enumerated in #NvAPI_Status. 
//!                  There are no return error codes with specific meaning for this API.
//!
//! \ingroup stereoapi
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION: This API returns 3 sets of integer constants that are used in mono/left/right rendering paths.
//!
//! WHEN TO USE: After the stereo handle for device interface is created via successfull call to appropriate NvAPI_Stereo_CreateHandleFrom function.
//!
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_GetVertexShaderConstantI(__in StereoHandle hStereoHandle, __in UINT StartRegister, __inout int *pConstantDataMono, __inout int *pConstantDataLeft, __inout int *pConstantDataRight, __in UINT Vector4iCount);

#endif //defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_SetPixelShaderConstantF
//
//! \param [in]  hStereoHandle         Stereo handle that corresponds to the device interface.
//! \param [in]  StartRegister         Register number that will contain the first constant value.
//! \param [in]  pConstantDataMono     Pointer to an array of constants for mono view.
//! \param [in]  pConstantDataLeft     Pointer to an array of constants for left eye view.
//! \param [in]  pConstantDataRight    Pointer to an array of constants for right eye view.
//! \param [in]  Vector4fCount         Number of four float vectors in the array of constants.
//! \return      This API can return any of the error codes enumerated in #NvAPI_Status. 
//!              There are no return error codes with specific meaning for this API.
//!
//! \ingroup stereoapi
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION: This API specifies 3 sets of floating constants to be used in mono/left/right rendering paths.
//!
//! WHEN TO USE: After the stereo handle for device interface is created via successfull call to appropriate NvAPI_Stereo_CreateHandleFrom function.
//!
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_SetPixelShaderConstantF(__in StereoHandle hStereoHandle, __in UINT StartRegister, __in float *pConstantDataMono, __in float *pConstantDataLeft, __in float *pConstantDataRight, __in UINT Vector4fCount);

#endif //defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_SetPixelShaderConstantB
//
//! \param [in]  hStereoHandle         Stereo handle that corresponds to the device interface.
//! \param [in]  StartRegister         Register number that will contain the first constant value.
//! \param [in]  pConstantDataMono     Pointer to an array of constants for mono view.
//! \param [in]  pConstantDataLeft     Pointer to an array of constants for left eye view.
//! \param [in]  pConstantDataRight    Pointer to an array of constants for right eye view.
//! \param [in]  BoolCount             Number of boolean values in the array of constants.
//! \return      This API can return any of the error codes enumerated in #NvAPI_Status. 
//!              There are no return error codes with specific meaning for this API.
//!
//! \ingroup stereoapi
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION: This API specifies 3 sets of boolean constants to be used in mono/left/right rendering paths.
//!
//! WHEN TO USE: After the stereo handle for device interface is created via successfull call to appropriate NvAPI_Stereo_CreateHandleFrom function.
//!
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_SetPixelShaderConstantB(__in StereoHandle hStereoHandle, __in UINT StartRegister, __in BOOL *pConstantDataMono, __in BOOL *pConstantDataLeft, __in BOOL *pConstantDataRight, __in UINT BoolCount);

#endif //defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_SetPixelShaderConstantI
//
//! \param [in]  hStereoHandle         Stereo handle that corresponds to the device interface.
//! \param [in]  StartRegister         Register number that will contain the first constant value.
//! \param [in]  pConstantDataMono     Pointer to an array of constants for mono view.
//! \param [in]  pConstantDataLeft     Pointer to an array of constants for left eye view.
//! \param [in]  pConstantDataRight    Pointer to an array of constants for right eye view.
//! \param [in]  Vector4iCount         Number of four integer vectors in the array of constants.
//! \return      This API can return any of the error codes enumerated in #NvAPI_Status. 
//!              There are no return error codes with specific meaning for this API.
//!
//! \ingroup stereoapi
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION: This API specifies 3 sets of integer constants to be used in mono/left/right rendering paths.
//!
//! WHEN TO USE: After the stereo handle for device interface is created via successfull call to appropriate NvAPI_Stereo_CreateHandleFrom function.
//!
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_SetPixelShaderConstantI(__in StereoHandle hStereoHandle, __in UINT StartRegister, __in int *pConstantDataMono, __in int *pConstantDataLeft, __in int *pConstantDataRight, __in UINT Vector4iCount);

#endif //defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_GetPixelShaderConstantF
//
//! \param [in]      hStereoHandle      Stereo handle that corresponds to the device interface.
//! \param [in]      StartRegister      Register number that will contain the first constant value.
//! \param [in,out]  pConstantDataMono  Pointer to an array of constants for mono view.
//! \param [in,out]  pConstantDataLeft  Pointer to an array of constants for left eye view.
//! \param [in,out]  pConstantDataRight Pointer to an array of constants for right eye view.
//! \param [in]      Vector4fCount      Number of four float vectors in the array of constants.
//! \return          This API can return any of the error codes enumerated in #NvAPI_Status. 
//!                  There are no return error codes with specific meaning for this API.
//!
//! \ingroup stereoapi
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION: This API returns 3 sets of floating constants that are used in mono/left/right rendering paths.
//!
//! WHEN TO USE: After the stereo handle for device interface is created via successfull call to appropriate NvAPI_Stereo_CreateHandleFrom function.
//!
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_GetPixelShaderConstantF(__in StereoHandle hStereoHandle, __in UINT StartRegister, __inout float *pConstantDataMono, __inout float *pConstantDataLeft, __inout float *pConstantDataRight, __in UINT Vector4fCount);

#endif //defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_GetPixelShaderConstantB
//
//! \param [in]      hStereoHandle      Stereo handle that corresponds to the device interface.
//! \param [in]      StartRegister      Register number that will contain the first constant value.
//! \param [in,out]  pConstantDataMono  Pointer to an array of constants for mono view.
//! \param [in,out]  pConstantDataLeft  Pointer to an array of constants for left eye view.
//! \param [in,out]  pConstantDataRight Pointer to an array of constants for right eye view.
//! \param [in]      BoolCount          Number of boolean values in the array of constants.
//! \return          This API can return any of the error codes enumerated in #NvAPI_Status. 
//!                  There are no return error codes with specific meaning for this API.
//!
//! \ingroup stereoapi
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION: This API returns 3 sets of boolean constants that are used in mono/left/right rendering paths.
//!
//! WHEN TO USE: After the stereo handle for device interface is created via successfull call to appropriate NvAPI_Stereo_CreateHandleFrom function.
//!
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_GetPixelShaderConstantB(__in StereoHandle hStereoHandle, __in UINT StartRegister, __inout BOOL *pConstantDataMono, __inout BOOL *pConstantDataLeft, __inout BOOL *pConstantDataRight, __in UINT BoolCount);

#endif //defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_GetPixelShaderConstantI
//
//! \param [in]      hStereoHandle      Stereo handle that corresponds to the device interface.
//! \param [in]      StartRegister      Register number that will contain the first constant value.
//! \param [in,out]  pConstantDataMono  Pointer to an array of constants for mono view.
//! \param [in,out]  pConstantDataLeft  Pointer to an array of constants for left eye view.
//! \param [in,out]  pConstantDataRight Pointer to an array of constants for right eye view.
//! \param [in]      Vector4iCount      Number of four integer vectors in the array of constants.
//! \return          This API can return any of the error codes enumerated in #NvAPI_Status. 
//!                  There are no return error codes with specific meaning for this API.
//!
//! \ingroup stereoapi
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION: This API returns 3 sets of integer constants that are used in mono/left/right rendering paths.
//!
//! WHEN TO USE: After the stereo handle for device interface is created via successfull call to appropriate NvAPI_Stereo_CreateHandleFrom function.
//!
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_GetPixelShaderConstantI(__in StereoHandle hStereoHandle, __in UINT StartRegister, __inout int *pConstantDataMono, __inout int *pConstantDataLeft, __inout int *pConstantDataRight, __in UINT Vector4iCount);

#endif //if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)






///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_SetDefaultProfile
//
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION: This API defines the stereo profile used by the driver in case the application has no associated profile.
//!
//! WHEN TO USE: To take effect, this API must be called before D3D device is created. Calling once a device has been created will not affect the current device.
//!
//! \param [in]  szProfileName        Default profile name. 
//!                                 
//! \return      This API can return any of the error codes enumerated in #NvAPI_Status. 
//!              Error codes specific to this API are described below.
//!              
//! \retval      NVAPI_SUCCESS                               - Default stereo profile name has been copied into szProfileName.
//! \retval      NVAPI_INVALID_ARGUMENT                      - szProfileName == NULL.
//! \retval      NVAPI_DEFAULT_STEREO_PROFILE_DOES_NOT_EXIST - Default stereo profile does not exist
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_SetDefaultProfile(__in const char* szProfileName);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_GetDefaultProfile
//
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION: This API retrieves the current default stereo profile.
//!              
//!              After call cbSizeOut contain 0 if default profile is not set required buffer size cbSizeOut.
//!              To get needed buffer size this function can be called with szProfileName==0 and cbSizeIn == 0. 
//!
//! WHEN TO USE: This API can be called at any time.
//!              
//!
//! \param [in]   cbSizeIn             Size of buffer allocated for default stereo profile name.                  
//! \param [out]  szProfileName        Default stereo profile name. 
//! \param [out]  pcbSizeOut           Required buffer size.
//!                     # ==0 - there is no default stereo profile name currently set
//!                     # !=0 - size of buffer required for currently set default stereo profile name including trailing '0'.
//!
//!
//! \return      This API can return any of the error codes enumerated in #NvAPI_Status. 
//!              Error codes specific to this API are described below.
//! 
//! \retval      NVAPI_SUCCESS                                - Default stereo profile name has been copied into szProfileName.
//! \retval      NVAPI_DEFAULT_STEREO_PROFILE_IS_NOT_DEFINED  - There is no default stereo profile set at this time.
//! \retval      NVAPI_INVALID_ARGUMENT                       - pcbSizeOut == 0 or cbSizeIn >= *pcbSizeOut && szProfileName == 0
//! \retval      NVAPI_INSUFFICIENT_BUFFER                    - cbSizeIn < *pcbSizeOut
//!  
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_GetDefaultProfile( __in NvU32 cbSizeIn, __out_bcount_part_opt(cbSizeIn, *pcbSizeOut) char* szProfileName,  __out NvU32 *pcbSizeOut);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_ModeEnumControl
//! \fn NvAPI_Stereo_ModeEnumControl(__inout NVAPI_STEREO_DONGLE_CONTROL* pStereoDongleControl)
//!
//! DESCRIPTION: This API executes stereo mode enumeration control interface commands
//!
//! WHEN TO USE: This API can be called at any time.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [inout]  pStereoModeEnumControl    Pointer to a NVAPI_STEREO_MODE_ENUM_CONTROL structure containing input and output params
//!
//! \return    This API can return any of the error codes enumerated in #NvAPI_Status. 
//!
///////////////////////////////////////////////////////////////////////////////
//! \addtogroup stereoapi
//! @{

//! \ingroup stereoapi
typedef enum _STEREO_MODE_ENUM_CONTROL
{
    STEREO_MODE_ENUM_DISABLE    = 0,
    STEREO_MODE_ENUM_ENBALE     = 1,
    STEREO_MODE_ENUM_STATUS     = 2,

} STEREO_MODE_ENUM_CONTROL;

//! \ingroup stereoapi
typedef struct _NVAPI_STEREO_MODE_ENUM_CONTROL
{
    NvU32                           version;        //!< IN:  struct version
    STEREO_MODE_ENUM_CONTROL        command;        //!< IN:  Interface command for stereo mode enumeration control
    NvU32                           data;           //!< IN:  Data required for interface comamnd
} NVAPI_STEREO_MODE_ENUM_CONTROL;

//! \ingroup stereoapi
#define NVAPI_STEREO_MODE_ENUM_CONTROL_VER    MAKE_NVAPI_VERSION(NVAPI_STEREO_MODE_ENUM_CONTROL, 1)

//! \ingroup stereoapi
NVAPI_INTERFACE NvAPI_Stereo_ModeEnumControl(__inout NVAPI_STEREO_MODE_ENUM_CONTROL* pStereoModeEnumControl);

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_IsAccessoryDisplayEnabled
//
//! DESCRIPTION: This API determines if an Accessory Display is enabled or not.
//!
//! WHEN TO USE: This API can be called at any time.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [out]    IsAccessoryDisplayEnabled    == 1  - Accessory Display is enabled.
//!                                              == 0  - Accessory Display not detected in the current config.
//!
//! \return         This API can return any of the error codes enumerated in #NvAPI_Status.
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_IsAccessoryDisplayEnabled(__out NvU32* IsAccessoryDisplayEnabled);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_DongleControl
//! \fn NvAPI_Stereo_DongleControl(__in NvDisplayHandle hNvDisplay, __inout NVAPI_STEREO_DONGLE_CONTROL* pStereoDongleControl)
//!
//! DESCRIPTION: This API executes dongle control interface commands
//!
//! WHEN TO USE: This API can be called at any time.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]     hNvDisplay              NVIDIA Display handle enumerated with NvAPI_EnumNVidiaDisplayHandle()
//! \param [inout]  pStereoDongleControl    Pointer to a NVAPI_STEREO_DONGLE_CONTROL structure containing input and output params
//!
//! \return    This API can return any of the error codes enumerated in #NvAPI_Status. 
//!
///////////////////////////////////////////////////////////////////////////////
//! \addtogroup stereoapi
//! @{

//! \ingroup stereoapi
typedef enum _STEREO_DONGLE_CONTROL_COMMAND
{
    STEREO_DONGLE_COMMAND_POLL                      = 1,
    STEREO_DONGLE_COMMAND_SUPPORTED                 = 2,
    STEREO_DONGLE_COMMAND_SET_TIMING                = 3,
    STEREO_DONGLE_COMMAND_ACTIVATE                  = 4,
    STEREO_DONGLE_COMMAND_DEACTIVATE                = 5,
    STEREO_DONGLE_COMMAND_AEGIS_SURROUND            = 6,
    STEREO_DONGLE_COMMAND_GET_ACTIVE_COUNT          = 7,
    STEREO_DONGLE_COMMAND_SUPPORTED_DEVINDEPENDENT  = 8,
}STEREO_DONGLE_CONTROL_COMMAND;

//! \ingroup stereoapi
typedef struct _NVAPI_STEREO_DONGLE_CONTROL
{
    NvU32                           version;        //!< IN:  struct version
    STEREO_DONGLE_CONTROL_COMMAND   command;        //!< IN:  Interface command for stereo dongle
    NvU32                           data;           //!< IN:  Data required for interface comamnd
    NvU32                           result;         //!< OUT: Provides the command execution result
} NVAPI_STEREO_DONGLE_CONTROL_V1;

//! \ingroup stereoapi
typedef NVAPI_STEREO_DONGLE_CONTROL_V1      NVAPI_STEREO_DONGLE_CONTROL;
//! \ingroup stereoapi
#define NVAPI_STEREO_DONGLE_CONTROL_VER1    MAKE_NVAPI_VERSION(NVAPI_STEREO_DONGLE_CONTROL_V1, 1)
//! \ingroup stereoapi
#define NVAPI_STEREO_DONGLE_CONTROL_VER     NVAPI_STEREO_DONGLE_CONTROL_VER1

//! \ingroup stereoapi
NVAPI_INTERFACE NvAPI_Stereo_DongleControl(__in NvDisplayHandle hNvDisplay, __inout NVAPI_STEREO_DONGLE_CONTROL* pStereoDongleControl);

//! @}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_GetStereoDiag
//! \fn NvAPI_Stereo_GetStereoDiag(StereoHandle hStereoHandle, NVAPI_STEREO_DIAG *pDiag)
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION: This API queries diagnostic data from the current stereo device.
//!              It is a wrapper which uses interfaces to the D3D UMD and LDDM KMD drivers to query the current 
//!              stereo state from these driver instances.
//!
//! WHEN TO USE: Typically after a Present() operation of a D3D device.
//!
//! \param [in]  hStereoHandle        NVAPI stereo handle for the device requested
//! \param [in]  pDiag                Pointer to a NVAPI_STEREO_DIAG data structure containing pointers to the diagnostic data 
//!                                 
//! \return      This API can return any of the error codes enumerated in #NvAPI_Status. 
//!              Error codes specific to this API are described below.
//!              
//! \retval      NVAPI_SUCCESS                               - Diag data has been queried and stored in provided pointers.
//! \retval      NVAPI_INVALID_POINTER                       - pDiag == NULL, or neither UMD or KMD data pointers are provided.
//! \retval      NVAPI_INCOMPATIBLE_STRUCT_VERSION           - version mismatch of datatype passed in with pDiag or UMD or KMD data pointers.
//!
///////////////////////////////////////////////////////////////////////////////

//! \addtogroup stereoapi
//! @{

typedef struct _NVAPI_STEREO_DIAG_KMD
{
    NvU32 version;
    
    NvU32                   ulDongleActiveCount;          //!< OUT: current stereo dongle active count    
    NvU32                   ulStereoConfig[NV_MAX_HEADS]; //!< OUT: current stereo configuration per head
} NVAPI_STEREO_DIAG_KMD;

#define NVAPI_STEREO_DIAG_KMD_VER MAKE_NVAPI_VERSION(NVAPI_STEREO_DIAG_KMD, 1)

typedef struct _NVAPI_STEREO_DIAG
{
    NvU32 version;
    union                                //!< Anonymous union   
    {                              
    struct _NV_STEREO_API_DIAG_UMD *pUMDData;    
    NvU64 pad0;                       //!< Pad up to 64 bits on 32-bit systems
    };
    union                                //!< Anonymous union   
    {                              
    NVAPI_STEREO_DIAG_KMD* pKMDData;
    NvU64 pad1;                       //!< Pad up to 64 bits on 32-bit systems
    };
} NVAPI_STEREO_DIAG;

#define NVAPI_STEREO_DIAG_VER MAKE_NVAPI_VERSION(NVAPI_STEREO_DIAG, 1)

NVAPI_INTERFACE NvAPI_Stereo_GetStereoDiag(__in StereoHandle hStereoHandle, __in NVAPI_STEREO_DIAG *pDiag);

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_Is3DCursorSupported
//
//! DESCRIPTION:   This API checks if stereo cursor is supported on a given stereo device
//!
//! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 302
//!
//! \param [in]    stereoHandle  Stereo handle that corresponds to the device interface.
//! \param [out]   bSupported(OUT)    != 0  - supported,  \n
//!                                   == 0  - is not supported 
//! 
//! \retval ::NVAPI_OK - Check was sucessfully completed and result reflects current state of stereo (on/off).
//! \retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE - Device interface is not valid. Create again, then attach again.
//! \retval ::NVAPI_API_NOT_INTIALIZED - NVAPI not initialized.
//! \retval ::NVAPI_STEREO_NOT_INITIALIZED - Stereo part of NVAPI not initialized.
//! \retval ::NVAPI_ERROR - Something is wrong (generic error).
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_Is3DCursorSupported(__in StereoHandle stereoHandle, __out NvU8* bSupported);





///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_GetCursorSeparation
//
//! DESCRIPTION:   This API gets current cursor separation value (in percents). 
//!
//! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to the appropriate NvAPI_Stereo_CreateHandleFrom() function.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 302
//!
//! \param [in]     stereoHandle           Stereo handle that corresponds to the device interface.
//! \param [out]    pSeparationPercentage  Address of @c float type variable to store current separation percentage in.
//!
//! \retval ::NVAPI_OK                                Retrieval of separation percentage was successfull.
//! \retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE   Device interface is not valid. Create again, then attach again.
//! \retval ::NVAPI_API_NOT_INTIALIZED  
//! \retval ::NVAPI_STEREO_NOT_INITIALIZED            Stereo part of NVAPI not initialized.
//! \retval ::NVAPI_ERROR  
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_GetCursorSeparation(__in StereoHandle stereoHandle, __out float *pSeparationPercentage);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_SetCursorSeparation
//
//! DESCRIPTION:   This API sets cursor separation to given percentage. 
//!
//! WHEN TO USE:   After the stereo handle for the device interface is created via successfull call to appropriate NvAPI_Stereo_CreateHandleFrom() function.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 302
//!
//! \param [in]     stereoHandle             Stereo handle that corresponds to the device interface.
//! \param [in]     newSeparationPercentage  New value for separation percentage.
//!
//! \retval ::NVAPI_OK                               Setting of separation percentage was successfull.
//! \retval ::NVAPI_STEREO_INVALID_DEVICE_INTERFACE  Device interface is not valid. Create again, then attach again.
//! \retval ::NVAPI_API_NOT_INTIALIZED               NVAPI not initialized.
//! \retval ::NVAPI_STEREO_NOT_INITIALIZED           Stereo part of NVAPI not initialized.
//! \retval ::NVAPI_STEREO_PARAMETER_OUT_OF_RANGE    Given separation percentage is out of [0..100] range.
//! \retval ::NVAPI_ERROR 
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_SetCursorSeparation(__in StereoHandle stereoHandle, __in float newSeparationPercentage);




//! \ingroup stereoapi
#define NVAPI_STEREO_QUADBUFFERED_API_VERSION   0x2

//! \ingroup stereoapi
 typedef enum _NV_StereoSwapChainMode
 {
   NVAPI_STEREO_SWAPCHAIN_DEFAULT = 0,
   NVAPI_STEREO_SWAPCHAIN_STEREO = 1,
   NVAPI_STEREO_SWAPCHAIN_MONO = 2,
 } NV_STEREO_SWAPCHAIN_MODE;

#if defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D1x_CreateSwapChain
//
//! DESCRIPTION: This API allows the user to create a mono or a stereo swap chain.
//!
//!          NOTE: NvAPI_D3D1x_CreateSwapChain is a wrapper of the method IDXGIFactory::CreateSwapChain which
//!                additionally notifies the D3D driver of the mode in which stereo mode the swap chain is to be
//!                created.
//!
//! \since Release: 285
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]     hStereoHandle      Stereo handle that corresponds to the device interface.
//!                                   A pointer to the device that will write 2D images to the swap chain.
//! \param [in]     pDesc             A pointer to the swap-chain description (DXGI_SWAP_CHAIN_DESC). This parameter cannot be NULL.
//! \param [out]    ppSwapChain       A pointer to the swap chain created.
//! \param [in]     mode              The stereo mode fot the swap chain.
//!                                   NVAPI_STEREO_SWAPCHAIN_DEFAULT 
//!                                   NVAPI_STEREO_SWAPCHAIN_STEREO 
//!                                   NVAPI_STEREO_SWAPCHAIN_MONO 
//!
//! \retval ::NVAPI_OK                 The swap chain was created successfully.
//! \retval ::NVAPI_ERROR              The operation failed.
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D1x_CreateSwapChain(StereoHandle hStereoHandle,
                                            DXGI_SWAP_CHAIN_DESC* pDesc,
                                            IDXGISwapChain** ppSwapChain,
                                            NV_STEREO_SWAPCHAIN_MODE mode);

#endif //if defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)


#if defined(_D3D9_H_)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_D3D9_CreateSwapChain
//
//! DESCRIPTION: This API allows the user to create a mono or a stereo swap chain.
//!
//!          NOTE: NvAPI_D3D9_CreateSwapChain is a wrapper of the method IDirect3DDevice9::CreateAdditionalSwapChain which
//!                additionally notifies the D3D driver if the swap chain creation mode must be stereo or mono.
//!
//!
//! \since Release: 285
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]      hStereoHandle            Stereo handle that corresponds to the device interface.
//! \param [in, out] pPresentationParameters  A pointer to the swap-chain description (DXGI). This parameter cannot be NULL.
//! \param [out]     ppSwapChain              A pointer to the swap chain created.
//! \param [in]      mode                     The stereo mode for the swap chain.
//!                                           NVAPI_STEREO_SWAPCHAIN_DEFAULT 
//!                                           NVAPI_STEREO_SWAPCHAIN_STEREO 
//!                                           NVAPI_STEREO_SWAPCHAIN_MONO 
//!
//! \retval ::NVAPI_OK                        The swap chain creation was successful 
//! \retval ::NVAPI_ERROR                     The operation failed.
//!
//!\ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_D3D9_CreateSwapChain(StereoHandle hStereoHandle,
                                           D3DPRESENT_PARAMETERS *pPresentationParameters,
                                           IDirect3DSwapChain9 **ppSwapChain,
                                           NV_STEREO_SWAPCHAIN_MODE mode);
#endif //if defined(_D3D9_H_)




#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_SetProfileName
//
//! DESCRIPTION:   This API sets profile name on the device created.
//!                This profile will not get applied to the Direct3D calls coming to the driver before this call.
//!
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]    stereoHandle  Stereo handle corresponding to the device interface
//! \param [in]    ProfileName   Profile Name
//! \param [in]    Pointer to IUnknown interface that is IDirect3DDevice9* in DX9
//! \param [in]    flags
//!
//! \return      This API can return any of the error codes enumerated in #NvAPI_Status.
//!              If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_SetProfileName(__in StereoHandle hStereoHandle, __in NvAPI_String szProfileName, __in IUnknown *pDevice, __in unsigned int uiFlags);

#endif //if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_IsDisplayAegisDTType
//
//! DESCRIPTION:  This API checks whether a monitor specified by the the 'panel id', is AegisDT capable or not.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]    ulPanelId                Bytes 4-7 of the EDID, considered as a single DWORD
//! \param [out]   bAegisDTDetected         Address of variable that will return whether a AegisDT was detected or not.
//!                                         1   -  AegisDT detected.
//!                                         0   -  AegisDT not present.
//!
//! \return        This API can return any of the error codes enumerated in #NvAPI_Status.
//!                If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_IsDisplayAegisDTType(__in NvU32 ulPanelId, __out NvU8 * bAegisDTDetected);

//! 'NvAPI_Stereo_Dongle_Status' related.
//! Following define - STEREO_DONGLE_DEVICE_STATUS corresponds to a 'new' case that has been added in the KM code
//! in escape and stereo_dongle to request 'dongle status' information.

#define STEREO_DONGLE_DEVICE_STATUS                 0x00000009

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Stereo_Dongle_Status
//
//! DESCRIPTION:  This API returns status information at the lower most levels in the KM driver related to
//!               stereo dongle. Specifically, from stereo_dongle code(RM-stereo) corresponding to the USB
//!               and AegisDT emitters.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]     displayId               Display ID of the display to retrieve stereo dongle information for.
//! \param [in]     statusParam             Specifies the sub command for the specific dongle status required.
//! \param [out]    pResult                 Will contain the requested status. Following are possible values -
//!                                         '0x00000000' - Parameter corresponding to the command is disabled or in-active.
//!                                         '0x00000001' - Parameter corresponding to the command is enabled or active.
//!                                         '0xC0000000' - Command not supported.
//! \return         This API can return any of the error codes enumerated in #NvAPI_Status.
//!                 If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup stereoapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Stereo_Dongle_Status(__in NvU32 displayId, __in NvU8 statusParam, __out NvU32 *pResult);

#ifndef NV_VIDEO_POSTPROCESSING_DEFINE
#define NV_VIDEO_POSTPROCESSING_DEFINE

//! \addtogroup vidcontrol
//! @{


//! Used in NV_VIDEO_COLORCONTROL_INFO
typedef struct
{
    NvU32 value;        
    NvU32 min;        
    NvU32 max;        
} NV_VIDEO_POSTPROCESSING_RANGE_VALUE;


//! Used in NV_VIDEO_COLORCONTROL_INFO
typedef enum
{
    NV_VIDEO_POSTPROCESSING_CAPS_FEATURE_SUPPORTED          = 0x00,  
    NV_VIDEO_POSTPROCESSING_CAPS_FEATURE_NOT_SUPPORTED      = 0x01,  
} NV_VIDEO_POSTPROCESSING_CAPS;


// Deinterlace
 
//! Used in NV_VIDEO_POSTPROCESSING_DEINTERLACE_INFO
typedef enum _NV_VIDEO_POSTPROCESSING_DEINTERLACE_FEATURE
{
    NV_VIDEO_POSTPROCESSING_DEINTERLACE_FEATURE_DISABLE           = 0x00,       
    NV_VIDEO_POSTPROCESSING_DEINTERLACE_FEATURE_ENABLE            = 0x01,       
} NV_VIDEO_POSTPROCESSING_DEINTERLACE_FEATURE;


//! Used in NV_VIDEO_POSTPROCESSING_DEINTERLACE_INFO
typedef enum _NV_VIDEO_POSTPROCESSING_DEINTERLACE_ALG
{
    NV_VIDEO_POSTPROCESSING_DEINTERLACE_ALG_BOB              = 0x01,
    NV_VIDEO_POSTPROCESSING_DEINTERLACE_ALG_WEAVE            = 0x02,
    NV_VIDEO_POSTPROCESSING_DEINTERLACE_ALG_SIMPLE_ADAPTIVE  = 0x03,
    NV_VIDEO_POSTPROCESSING_DEINTERLACE_ALG_GRADIENT_SIMPLE  = 0x04,      
    NV_VIDEO_POSTPROCESSING_DEINTERLACE_ALG_GRADIENT_FULL    = 0x05,
    NV_VIDEO_POSTPROCESSING_DEINTERLACE_ALG_ADVANCED         = 0x06,
} NV_VIDEO_POSTPROCESSING_DEINTERLACE_ALG;


//! Used in NV_VIDEO_POSTPROCESSING_DEINTERLACE_INFO
typedef enum _NV_VIDEO_POSTPROCESSING_DEINTERLACE_ENHANCE
{
    NV_VIDEO_POSTPROCESSING_DEINTERLACE_ENHANCE_DIR_SPATIAL_DEFAULT  = 0x01,
    NV_VIDEO_POSTPROCESSING_DEINTERLACE_ENHANCE_DIR_SPATIAL_SIMPLE   = 0x02,
    NV_VIDEO_POSTPROCESSING_DEINTERLACE_ENHANCE_DIR_SPATIAL_ADVANCED = 0x03,
} NV_VIDEO_POSTPROCESSING_DEINTERLACE_ENHANCE;


//! Used in NV_VIDEO_POSTPROCESSING_DEINTERLACE_INFO
typedef enum _NV_VIDEO_POSTPROCESSING_DEINTERLACE_MISC
{
    NV_VIDEO_POSTPROCESSING_DEINTERLACE_MISC_NONE = 0x00,  // none so far

} NV_VIDEO_POSTPROCESSING_DEINTERLACE_MISC;


//! Used in NV_VIDEO_POSTPROCESSING_CTRL_INFO
typedef struct
{
    NV_VIDEO_POSTPROCESSING_CAPS caps;
    NV_VIDEO_POSTPROCESSING_DEINTERLACE_FEATURE feature;
    NV_VIDEO_POSTPROCESSING_DEINTERLACE_ALG     alg;
    NV_VIDEO_POSTPROCESSING_DEINTERLACE_ENHANCE enhance;
    NV_VIDEO_POSTPROCESSING_DEINTERLACE_MISC    misc;
} NV_VIDEO_POSTPROCESSING_DEINTERLACE_INFO;


//Scaling


//! Used in NV_VIDEO_POSTPROCESSING_SCALING_INFO
typedef enum _NV_VIDEO_POSTPROCESSING_SCALING_FEATURE
{
    NV_VIDEO_POSTPROCESSING_SCALING_FEATURE_DISABLE            = 0x00,       
    NV_VIDEO_POSTPROCESSING_SCALING_FEATURE_ENABLE             = 0x01,       
} NV_VIDEO_POSTPROCESSING_SCALING_FEATURE;


//! Used in NV_VIDEO_POSTPROCESSING_SCALING_INFO
typedef enum _NV_VIDEO_POSTPROCESSING_SCALING_ALG
{
    NV_VIDEO_POSTPROCESSING_SCALING_ALG_DEFAULT                = 0x01,
    NV_VIDEO_POSTPROCESSING_SCALING_ALG_4x4FILTER              = 0x02,
} NV_VIDEO_POSTPROCESSING_SCALING_ALG;


//! Used in NV_VIDEO_POSTPROCESSING_SCALING_INFO
typedef enum _NV_VIDEO_POSTPROCESSING_SCALING_ENHANCE
{
    NV_VIDEO_POSTPROCESSING_SCALING_ENHANCE_NONE               = 0x00,   // None so far 
} NV_VIDEO_POSTPROCESSING_SCALING_ENHANCE;


//! Used in NV_VIDEO_POSTPROCESSING_SCALING_INFO
typedef enum _NV_VIDEO_POSTPROCESSING_SCALING_MISC
{
    NV_VIDEO_POSTPROCESSING_SCALING_MISC_NONE                  = 0x00,  // none so far
} NV_VIDEO_POSTPROCESSING_SCALING_MISC;


//! Used in NV_VIDEO_POSTPROCESSING_CTRL_INFO
typedef struct
{
    NV_VIDEO_POSTPROCESSING_CAPS caps;
    NV_VIDEO_POSTPROCESSING_SCALING_FEATURE feature;
    NV_VIDEO_POSTPROCESSING_SCALING_ALG     alg;
    NV_VIDEO_POSTPROCESSING_SCALING_ENHANCE enhance;
    NV_VIDEO_POSTPROCESSING_SCALING_MISC    misc;
} NV_VIDEO_POSTPROCESSING_SCALING_INFO;


//Cadence


//! Used in NV_VIDEO_POSTPROCESSING_CADENCE_INFO
typedef enum _NV_VIDEO_POSTPROCESSING_CADENCE_FEATURE
{
    NV_VIDEO_POSTPROCESSING_CADENCE_FEATURE_DISABLE            = 0x00,       
    NV_VIDEO_POSTPROCESSING_CADENCE_FEATURE_ENABLE             = 0x01,       
} NV_VIDEO_POSTPROCESSING_CADENCE_FEATURE;


//! Used in NV_VIDEO_POSTPROCESSING_CADENCE_INFO
typedef enum _NV_VIDEO_POSTPROCESSING_CADENCE_ALG
{
    NV_VIDEO_POSTPROCESSING_CADENCE_ALG_NONE                   = 0x00, //None so far
} NV_VIDEO_POSTPROCESSING_CADENCE_ALG;


//! Used in NV_VIDEO_POSTPROCESSING_CADENCE_INFO
typedef enum _NV_VIDEO_POSTPROCESSING_CADENCE_ENHANCE
{
    NV_VIDEO_POSTPROCESSING_CADENCE_ENHANCE_NONE               = 0x00,   
    NV_VIDEO_POSTPROCESSING_CADENCE_ENHANCE_VOF                = 0x01,   
} NV_VIDEO_POSTPROCESSING_CADENCE_ENHANCE;


//! Used in NV_VIDEO_POSTPROCESSING_CADENCE_INFO
typedef enum _NV_VIDEO_POSTPROCESSING_CADENCE_MISC
{
    NV_VIDEO_POSTPROCESSING_CADENCE_MISC_NONE                  = 0x00,  // none so far
} NV_VIDEO_POSTPROCESSING_CADENCE_MISC;


//! Used in NV_VIDEO_POSTPROCESSING_CTRL_INFO
typedef struct
{
    NV_VIDEO_POSTPROCESSING_CAPS caps;
    NV_VIDEO_POSTPROCESSING_CADENCE_FEATURE feature;
    NV_VIDEO_POSTPROCESSING_CADENCE_ALG     alg;
    NV_VIDEO_POSTPROCESSING_CADENCE_ENHANCE enhance;
    NV_VIDEO_POSTPROCESSING_CADENCE_MISC    misc;
} NV_VIDEO_POSTPROCESSING_CADENCE_INFO;



// Edge Enhance

//! Used in NV_VIDEO_POSTPROCESSING_EE_INFO
typedef enum _NV_VIDEO_POSTPROCESSING_EE_FEATURE
{
    NV_VIDEO_POSTPROCESSING_EE_FEATURE_DISABLE            = 0x00,       
    NV_VIDEO_POSTPROCESSING_EE_FEATURE_ENABLE             = 0x01,       
} NV_VIDEO_POSTPROCESSING_EE_FEATURE;


//! Used in NV_VIDEO_POSTPROCESSING_EE_INFO
typedef enum _NV_VIDEO_POSTPROCESSING_EE_ALG
{
    NV_VIDEO_POSTPROCESSING_EE_ALG_NONE                   = 0x00, //None so far
} NV_VIDEO_POSTPROCESSING_EE_ALG;


//! Used in NV_VIDEO_POSTPROCESSING_EE_INFO
typedef enum _NV_VIDEO_POSTPROCESSING_EE_ENHANCE
{
    NV_VIDEO_POSTPROCESSING_EE_ENHANCE_NONE                = 0x00,   
} NV_VIDEO_POSTPROCESSING_EE_ENHANCE;


//! Used in NV_VIDEO_POSTPROCESSING_EE_INFO
typedef enum _NV_VIDEO_POSTPROCESSING_EE_MISC
{
    NV_VIDEO_POSTPROCESSING_EE_MISC_NONE                  = 0x00,  // none so far
} NV_VIDEO_POSTPROCESSING_EE_MISC;


//! Used in NV_VIDEO_POSTPROCESSING_CTRL_INFO
typedef struct
{
    NV_VIDEO_POSTPROCESSING_CAPS caps;
    NV_VIDEO_POSTPROCESSING_EE_FEATURE     feature;
    NV_VIDEO_POSTPROCESSING_EE_ALG         alg ;
    NV_VIDEO_POSTPROCESSING_EE_ENHANCE     enhance;
    NV_VIDEO_POSTPROCESSING_EE_MISC        misc;
    NV_VIDEO_POSTPROCESSING_RANGE_VALUE    rangeValue;
} NV_VIDEO_POSTPROCESSING_EE_INFO;


//Noise Reduction


//! Used in NV_VIDEO_POSTPROCESSING_NR_INFO
typedef enum _NV_VIDEO_POSTPROCESSING_NR_FEATURE
{
    NV_VIDEO_POSTPROCESSING_NR_FEATURE_DISABLE            = 0x00,       
    NV_VIDEO_POSTPROCESSING_NR_FEATURE_ENABLE             = 0x01,       
} NV_VIDEO_POSTPROCESSING_NR_FEATURE;


//! Used in NV_VIDEO_POSTPROCESSING_NR_INFO
typedef enum _NV_VIDEO_POSTPROCESSING_NR_ALG
{
    NV_VIDEO_POSTPROCESSING_NR_ALG_NONE                   = 0x00, //None so far
} NV_VIDEO_POSTPROCESSING_NR_ALG;


//! Used in NV_VIDEO_POSTPROCESSING_NR_INFO
typedef enum _NV_VIDEO_POSTPROCESSING_NR_ENHANCE
{
    NV_VIDEO_POSTPROCESSING_NR_ENHANCE_NONE                = 0x00,   
} NV_VIDEO_POSTPROCESSING_NR_ENHANCE;


//! Used in NV_VIDEO_POSTPROCESSING_NR_INFO
typedef enum _NV_VIDEO_POSTPROCESSING_NR_MISC
{
    NV_VIDEO_POSTPROCESSING_NR_MISC_NONE                  = 0x00,  // none so far
} NV_VIDEO_POSTPROCESSING_NR_MISC;


//! Used in NV_VIDEO_POSTPROCESSING_CTRL_INFO
typedef struct
{
    NV_VIDEO_POSTPROCESSING_CAPS caps;
    NV_VIDEO_POSTPROCESSING_NR_FEATURE     feature;
    NV_VIDEO_POSTPROCESSING_NR_ALG         alg;
    NV_VIDEO_POSTPROCESSING_NR_ENHANCE     enhance;
    NV_VIDEO_POSTPROCESSING_NR_MISC        misc;
    NV_VIDEO_POSTPROCESSING_RANGE_VALUE    rangeValue;
} NV_VIDEO_POSTPROCESSING_NR_INFO;


//Over Drive

//! Used in NV_VIDEO_POSTPROCESSING_OVERDRIVE_INFO
typedef enum _NV_VIDEO_POSTPROCESSING_OVERDRIVE_FEATURE
{
    NV_VIDEO_POSTPROCESSING_OVERDRIVE_FEATURE_DISABLE            = 0x00,       
    NV_VIDEO_POSTPROCESSING_OVERDRIVE_FEATURE_ENABLE             = 0x01,       
} NV_VIDEO_POSTPROCESSING_OVERDRIVE_FEATURE;


//! Used in NV_VIDEO_POSTPROCESSING_OVERDRIVE_INFO
typedef enum _NV_VIDEO_POSTPROCESSING_OVERDRIVE_ALG
{
    NV_VIDEO_POSTPROCESSING_OVERDRIVE_ALG_NONE                   = 0x00, //None so far
} NV_VIDEO_POSTPROCESSING_OVERDRIVE_ALG;


//! Used in NV_VIDEO_POSTPROCESSING_OVERDRIVE_INFO
typedef enum _NV_VIDEO_POSTPROCESSING_OVERDRIVE_ENHANCE
{
    NV_VIDEO_POSTPROCESSING_OVERDRIVE_ENHANCE_NONE                = 0x00,   
} NV_VIDEO_POSTPROCESSING_OVERDRIVE_ENHANCE;


//! Used in NV_VIDEO_POSTPROCESSING_OVERDRIVE_INFO
typedef enum _NV_VIDEO_POSTPROCESSING_OVERDRIVE_MISC
{
    NV_VIDEO_POSTPROCESSING_OVERDRIVE_MISC_NONE                  = 0x00,  // none so far
} NV_VIDEO_POSTPROCESSING_OVERDRIVE_MISC;


//! Used in NV_VIDEO_POSTPROCESSING_CTRL_INFO
typedef struct
{
    NV_VIDEO_POSTPROCESSING_CAPS caps;
    NV_VIDEO_POSTPROCESSING_OVERDRIVE_FEATURE feature;
    NV_VIDEO_POSTPROCESSING_OVERDRIVE_ALG     alg;
    NV_VIDEO_POSTPROCESSING_OVERDRIVE_ENHANCE enhance;
    NV_VIDEO_POSTPROCESSING_OVERDRIVE_MISC    misc;
} NV_VIDEO_POSTPROCESSING_OVERDRIVE_INFO;


//! Postprocessing info struct 
//! Used in NvAPI_Video_PostProcessing_Get() and NvAPI_Video_PostProcessing_Set()
typedef struct 
{
    NvU32 version;                                              //!< Structure version
    NV_VIDEO_POSTPROCESSING_DEINTERLACE_INFO  deinterlaceInfo;  //!< Deinterlace info struct
    NV_VIDEO_POSTPROCESSING_SCALING_INFO      scalingInfo;      //!< Scaling info struct
    NV_VIDEO_POSTPROCESSING_CADENCE_INFO      cadenceInfo;      //!< Cadence info struct
    NV_VIDEO_POSTPROCESSING_NR_INFO           nrInfo;           //!< Noise reduction info struct
    NV_VIDEO_POSTPROCESSING_EE_INFO           eeInfo;           //!< Edge enhance info struct
    NV_VIDEO_POSTPROCESSING_OVERDRIVE_INFO    overDriveInfo;    //!< Overdrive info struct
} NV_VIDEO_POSTPROCESSING_CTRL_INFO;

#define NV_VIDEO_POSTPROCESSING_CTRL_NVAPI_VER MAKE_NVAPI_VERSION(NV_VIDEO_POSTPROCESSING_CTRL_INFO,1)

//Video Color control

//! This range value is exclusive for color controls, special fields may be added in the future \n
//! Used in NV_VIDEO_COLORCONTROL_INFO
typedef struct
{
    NvU32 value;        
    NvU32 min;        
    NvU32 max;        
} NV_VIDEO_COLORCONTROL_RANGE_VALUE;

//Color control caps are different from post processing caps

//! Used in NV_VIDEO_COLORCONTROL_INFO
typedef enum
{
    NV_VIDEO_COLORCONTROL_CAPS_FEATURE_SUPPORTED          = 0x00,  
    NV_VIDEO_COLORCONTROL_CAPS_FEATURE_NOT_SUPPORTED      = 0x01,  
} NV_VIDEO_COLORCONTROL_CAPS;

//! Used in NV_VIDEO_COLORCONTROL_INFO
typedef enum _NV_VIDEO_COLORCONTROL_FEATURE
{
    NV_VIDEO_COLORCONTROL_FEATURE_DISABLE            = 0x00,       
    NV_VIDEO_COLORCONTROL_FEATURE_ENABLE             = 0x01,       
} NV_VIDEO_COLORCONTROL_FEATURE;

//! Used in NV_VIDEO_COLORCONTROL_INFO
typedef enum _NV_VIDEO_COLORTEMP_FEATURE
{
    NV_VIDEO_COLORTEMP_FEATURE_DISABLE            = 0x00,       
    NV_VIDEO_COLORTEMP_FEATURE_ENABLE             = 0x01,       
} NV_VIDEO_COLORTEMP_FEATURE;

//! Used in NV_VIDEO_COLORCONTROL_INFO
typedef enum _NV_VIDEO_GAMMA_FEATURE
{
    NV_VIDEO_GAMMA_FEATURE_DISABLE            = 0x00,       
    NV_VIDEO_GAMMA_FEATURE_ENABLE_Y           = 0x01,       
    NV_VIDEO_GAMMA_FEATURE_ENABLE_RGB         = 0x02,       
} NV_VIDEO_GAMMA_FEATURE;


//! Used in NV_VIDEO_COLORCONTROL_INFO
typedef enum _NV_VIDEO_COLOR_CONTROL_SETTING
{
    NV_VIDEO_COLORCONTROL_SETTING_OVERRIDE_APP_CTRLS  = 0x00,  //!< Overrides application controls with nvapi settings        
    NV_VIDEO_COLORCONTROL_SETTING_USE_APP_CTRLS       = 0x01,  //!< Use application controls        
                                                               //!< In the future we may add app profile setting here     

} NV_VIDEO_COLORCONTROL_SETTING;

//! Used in NvAPI_Video_ColorControl_GetDefault(), NvAPI_Video_ColorControl_Get(), and NvAPI_Video_ColorControl_Set()
typedef struct 
{
    NvU32 version;          // structure version

    NV_VIDEO_COLORCONTROL_SETTING colorControlSettings; 

    //Set #1  brightness contrast hue and saturation
    NV_VIDEO_COLORCONTROL_CAPS            colorCaps;
    NV_VIDEO_COLORCONTROL_FEATURE         colorFeature;
    NV_VIDEO_COLORCONTROL_RANGE_VALUE     brightnessRangeValue;
    NV_VIDEO_COLORCONTROL_RANGE_VALUE     contrastRangeValue;
    NV_VIDEO_COLORCONTROL_RANGE_VALUE     hueRangeValue;
    NV_VIDEO_COLORCONTROL_RANGE_VALUE     saturationRangeValue;
    
    //Set #2  colorTemp
    NV_VIDEO_COLORCONTROL_CAPS            colorTempCaps;
    NV_VIDEO_COLORTEMP_FEATURE            colorTempFeature;
    NV_VIDEO_COLORCONTROL_RANGE_VALUE     colorTempRangeValue;
    
    //Set #3  Gamma
    NV_VIDEO_COLORCONTROL_CAPS            gammaCaps;
    NV_VIDEO_GAMMA_FEATURE                gammaFeature;
    
    NV_VIDEO_COLORCONTROL_RANGE_VALUE     yGammaRangeValue;
    NV_VIDEO_COLORCONTROL_RANGE_VALUE     rgbGammaRRangeValue;
    NV_VIDEO_COLORCONTROL_RANGE_VALUE     rgbGammaGRangeValue;
    NV_VIDEO_COLORCONTROL_RANGE_VALUE     rgbGammaBRangeValue;
} NV_VIDEO_COLORCONTROL_INFO;

#define NV_VIDEO_COLORCONTROL_NVAPI_VER MAKE_NVAPI_VERSION(NV_VIDEO_COLORCONTROL_INFO,1)

//! @}

#endif // ifndef NV_VIDEO_POSTPROCESSING_DEFINE



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Video_PostProcessing_GetDefault
//
//! This function queries the video postprocessing default control information.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 100
//!
//! \return NVAPI_ERROR or NVAPI_OK
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Video_PostProcessing_GetDefault(NvDisplayHandle hNvDisplay, NV_VIDEO_POSTPROCESSING_CTRL_INFO* pVideoPPCtrlInfo);





///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Video_PostProcessing_Get
//
//! This function queries the video postprocessing current control information.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 100
//!
//! \return NVAPI_ERROR or NVAPI_OK
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Video_PostProcessing_Get(NvDisplayHandle hNvDisplay, NV_VIDEO_POSTPROCESSING_CTRL_INFO* pVideoPPCtrlInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Video_PostProcessing_Set
//
//! This function sets the video postprocessing current control information.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 100
//!
//! \return NVAPI_ERROR or NVAPI_OK
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Video_PostProcessing_Set(NvDisplayHandle hNvDisplay, NV_VIDEO_POSTPROCESSING_CTRL_INFO* pVideoPPCtrlInfo);


//color control apis
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Video_ColorControl_GetDefault
//
//! This function queries the video default color control information.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 100
//!
//! \return NVAPI_ERROR or NVAPI_OK
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_Video_ColorControl_GetDefault(NvDisplayHandle hNvDisplay, NV_VIDEO_COLORCONTROL_INFO* pVideoColorCtrlInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Video_ColorControl_Get
//
//! This function queries the video current color control information.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 100
//!
//! \return NVAPI_ERROR or NVAPI_OK
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_Video_ColorControl_Get(NvDisplayHandle hNvDisplay, NV_VIDEO_COLORCONTROL_INFO* pVideoColorCtrlInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Video_ColorControl_Set
//
//! This function sets the video current color control information.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 100
//!
//! \return NVAPI_ERROR or NVAPI_OK
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_Video_ColorControl_Set(NvDisplayHandle hNvDisplay, NV_VIDEO_COLORCONTROL_INFO* pVideoColorCtrlInfo);


//EVO Overlay LUT API

//! \ingroup vidcontrol
#define NV_EVO_VIDEO_LUT_VER  MAKE_NVAPI_VERSION(NV_EVO_VIDEO_LUT,1)

//! Used in NV_EVO_VIDEO_LUT.
//! \ingroup vidcontrol
typedef struct {
    NvU16 Red;
    NvU16 Green;
    NvU16 Blue;
    NvU16 Unused;
} NVAPI_EVO_VIDEO_CLUTDATA;

//! \ingroup videocontroltypes 
#define EVO_LUT_ENTRIES 257

//! See NV_EVO_VIDEO_LUT
//! \ingroup vidcontrol
typedef NVAPI_EVO_VIDEO_CLUTDATA NVAPI_EVO_VIDEO_LUT[EVO_LUT_ENTRIES];

//! Used in NvAPI_Video_EvoOverlayLUT_Get() and NvAPI_Video_EvoOverlayLUT_Set().
//! \ingroup vidcontrol
typedef struct
{
    NvU32 version;
    NVAPI_EVO_VIDEO_LUT lut;  
} NV_EVO_VIDEO_LUT;

 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Video_EvoOverlayLUT_Get
//
//!   DESCRIPTION: This function gets the EVO Overlay LUT.  For verification use only.
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 105
//!
//! \return NVAPI_ERROR or NVAPI_OK
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_Video_EvoOverlayLUT_Get(NvDisplayHandle hNvDisplay, NV_EVO_VIDEO_LUT* pLut);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Video_EvoOverlayLUT_Set
//
//!   DESCRIPTION: This function sets the EVO Overlay LUT.  For verification use only.
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 105
//!
//! \return NVAPI_ERROR or NVAPI_OK
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_Video_EvoOverlayLUT_Set(NvDisplayHandle hNvDisplay, NV_EVO_VIDEO_LUT* pLut);




#if defined(_D3D9_H_) && defined(__cplusplus)

//! \addtogroup videoapi
//! @{

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Video_Bringup
//
//! \fn NvAPI_Video_Bringup(IDirect3DDevice9 *pDev,
//!    NVAPI_VIDEO_BRINGUP_PARAMS *pVideoBringupParams)
//! \code
//!   DESCRIPTION: Run video engine bringup test
//!                Replaces the NVDIAG_CMD_ENGINE_BRINGUP
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! RETURN STATUS: NVAPI_ERROR or NVAPI_OK
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! Video engine bringup action type
typedef enum _NVAPI_VIDEO_BRINGUP_ACTION
{
    NVAPI_VIDEO_BRINGUP_ACTION_RUN_TEST     = 0x01,     //!< Run test
    NVAPI_VIDEO_BRINGUP_ACTION_CHECK_RESULT = 0x02,     //!< Check test result
    NVAPI_VIDEO_BRINGUP_ACTION_INIT_TRACE_PLAYER= 0x03, //!< Initialise trace player
    NVAPI_VIDEO_BRINGUP_ACTION_SETUP_BUFFERS    = 0x04, //!< Setup ctx dmas
    NVAPI_VIDEO_BRINGUP_ACTION_SETUP_EXECUTE    = 0x05, //!< PB execute
    NVAPI_VIDEO_BRINGUP_ACTION_DESTROY_TRACE    = 0x06, //!< Cleanup
} NVAPI_VIDEO_BRINGUP_ACTION;

//! Video engine bringup test type
typedef enum _NVAPI_VIDEO_BRINGUP_TEST
{
    NVAPI_VIDEO_BRINGUP_TEST_TCIPHER_BASIC  = 0x01,     //!< Turbo cipher basic test
    NVAPI_VIDEO_BRINGUP_TEST_COMPUTE_MULTI  = 0x02,     //!< Compute multi test
    NVAPI_VIDEO_BRINGUP_TEST_SEC_BASIC      = 0x03,     //!< SEC basic test
    NVAPI_VIDEO_BRINGUP_TEST_SEC_EXECUTE    = 0x04,     //!< SEC execute test
    NVAPI_VIDEO_BRINGUP_TEST_CE_EXECUTE     = 0x05,     //!< CE execute test
} NVAPI_VIDEO_BRINGUP_TEST;

typedef struct _NVAPI_VIDEO_BRINGUP_PARAMS
{
    NvU32                       version;                //!< structure version (IN)
    NVAPI_VIDEO_BRINGUP_ACTION  action;                 //!< action type (IN)
    NVAPI_VIDEO_BRINGUP_TEST    test;                   //!< test type (IN)
    NvU32                       params[4];              //!< input parameters (IN)
    void                       *pOutput;                //!< output (OUT)
    NvU32                       dwOutputSize;           //!< output size (IN)
} NVAPI_VIDEO_BRINGUP_PARAMS;

//! Macro for constrcuting the version field of ::NVAPI_VIDEO_BRINGUP_PARAMS
#define NVAPI_VIDEO_BRINGUP_PARAMS_VER \
    MAKE_NVAPI_VERSION(NVAPI_VIDEO_BRINGUP_PARAMS, 1)

NVAPI_INTERFACE NvAPI_Video_Bringup(IDirect3DDevice9 *pDev,
    NVAPI_VIDEO_BRINGUP_PARAMS *pVideoBringupParams);
//! @}

#endif // defined(_D3D9_H_) && defined(__cplusplus)









//-----------------------------------------------------------------------------
// Video Microcode Loading routines and data structures
//-----------------------------------------------------------------------------

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_LoadMicrocode
//
//! \fn NvAPI_LoadMicrocode(NvDisplayHandle hNvDisplay, NV_MICROCODE_INFO* pMicrocodeInfo)
//!  This function loads the microcode provided in the pMicrocodeInfo.
//!
//! SUPPORTED OS:  Windows XP
//!
//!  
//!
//! \since Release: 85
//!
//! \return  NVAPI_ERROR or NVAPI_OK
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup viducode
//! Used in NvAPI_LoadMicrocode().
typedef struct 
{
    NvU32 version;          //!<  Structure version
    NvU32 ucID;             //!<  Microcode ID for VP2 its the subclass this microcode belongs to
    NvU32 ucVersion;        //!<  Version of the microcode -- depends upon the author
    char szMicrocodeDescription[40]; //!<  Short description of the microcode -- depends upon the author
    NvU32 ucCRC;            //!<  CRC value for the uncompressed microcode data
    NvU32 unCompressedSize; //!<  Uncompressed size of the microcode
    NvU32 flags;            //!<  0x00000001 means compressesd
    NvU32 microcodeFormat;  //!<  Type of compression/layout for microcode
    NvU32 compSize;         //!<  Size of the compressed microcode
    union {                 //!<  Anonymous union 
    NvU8 *pImg;             //!<  Pointer to the microcode - Use only in the API call
    NvU64 pImgpad;          //!<  Pad up to 64 bits on 32-bit systems
    };
} NV_MICROCODE_INFO;

//! \ingroup viducode
#define NV_MICROCODE_INFO_VER MAKE_NVAPI_VERSION(NV_MICROCODE_INFO,1)


//! \ingroup viducode
//! Used in NvAPI_GetLoadedMicrocodePrograms()
typedef struct _NV_MICROCODE_REPOS_INDEX
{
    NvU32                version;        //!< Structure version
    NV_MICROCODE_INFO    info;           //!< Note that the image data here is not valid
    NvU32                offset;         //!< This is not used by the API.
    NvU32                loadedDataSize;
    NvS32                indexStatus;
    union                                //!< Anonymous union   
    {                              
    struct _NV_MICROCODE_REPOS_INDEX* pNext;
    NvU64 pImgpad;                       //!< Pad up to 64 bits on 32-bit systems
    };
} NV_MICROCODE_REPOS_INDEX;

//! \ingroup viducode
#define NV_MICROCODE_REPOS_INDEX_VER MAKE_NVAPI_VERSION(NV_MICROCODE_REPOS_INDEX,1)


//! \ingroup viducode
NVAPI_INTERFACE NvAPI_LoadMicrocode(NvDisplayHandle hNvDisplay, NV_MICROCODE_INFO* pMicrocodeInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetLoadedMicrocodePrograms
//
//!   This function queries the currently loaded microcode programs. 
//!
//! SUPPORTED OS:  Windows XP
//!
//!
//! \since Release: 85
//!
//! \return  NVAPI_ERROR or NVAPI_OK
//!
//! NOTE: It is very important that the caller of the function carefully 
//!       clears/frees up the memory of the linkedlist pMicrocodeReposIndex
//!
//! Sample code for freeing linked list
//! \code
//!   while (pMicrocodeReposIndex!= NULL) 
//!     {
//!        current = pMicrocodeReposIndex->pNext;
//!        delete pMicrocodeReposIndex;
//!        pMicrocodeReposIndex = current;
//!     }
//! \endcode
//!
//! \ingroup viducode
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetLoadedMicrocodePrograms(NvDisplayHandle hNvDisplay, NV_MICROCODE_REPOS_INDEX** pMicrocodeReposIndex);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetVideoPerformanceData
//
//!  This function returns video-related performance data (frame drops, enabled video 
//!  processing features flags, etc) for the most recently played video stream. \n
//!
//!              The data is returned in a string with following format: \n
//!              TokenName1=Value1;TokenName2=Value2;TokenName3=Value3;  
//!
//!              Token names and values consist of only non-whitespace characters excluding the
//!              '=' and ';' delimiter characters. There is no whitespace between
//!              TokenNames, Values, '=', and ';' characters
//!
//! SUPPORTED OS:  Windows XP
//!
//!  
//!
//! \since Release: 95
//!
//! \retval  NVAPI_INVALID_ARGUMENT pData is NULL 
//! \retval  NVAPI_OK               Data has been written to pData.
//! \retval  NVAPI_ERROR            Failed to retrieve performance data.
//! \ingroup vidperf
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetVideoPerformanceData(char *pData, NvU32 dataSize);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SetVideoPerformanceDataCollectionEnabled
//
//!  This function enables or disables logging of video performance data by the driver. 
//!  This data can be then collected using NvAPI_GetVideoPerformanceData call.
//!
//! SUPPORTED OS:  Windows XP
//!
//!  
//!
//! \since Release: 95
//!
//! \retval  NVAPI_OK     Logging was successfully enabled or disabled.
//! \retval  NVAPI_ERROR  Failed to set the registry flag enabling logging.
//! \ingroup vidperf
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetVideoPerformanceDataCollectionEnabled(NvU32 bEnabled);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetVideoPerformanceDataCollectionEnabled
//
//!  This function indicates whether video performance data collection is enabled.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 95
//!
//! \retval  NVAPI_INVALID_ARGUMENT  pbEnabled is NULL 
//! \retval  NVAPI_OK                Logging status was successfully written to pbEnabled.
//! \retval  NVAPI_ERROR             Failed to get the registry flag to determine if logging is enabled.
//! \ingroup vidperf
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetVideoPerformanceDataCollectionEnabled(NvU32* pbEnabled);



//! Used in NvAPI_Video_PmmC_SetMode()
//! \ingroup vidperf 
typedef enum _NV_VIDEO_PMMC_ACTION
{
    NV_VIDEO_PMMC_DELETE       = 0,        //!< Finished. Delete report and resources
    NV_VIDEO_PMMC_START,                   //!< Enable. Allocate resources and start logging
    NV_VIDEO_PMMC_STOP,                    //!< Stop logging. Free resources (except for the report)
} NV_VIDEO_PMMC_ACTION;


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Video_PmmC_SetMode
//
//!  DESCRIPTION: This function sets the video engines use of Perfmon Mode C based on the VideoPmmCSetModeAction enum. \n
//!               For information on PmmC, see nvPerfmonModeC.cpp - comments in the header.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 105
//!
//! \return  NVAPI_ERROR or NVAPI_OK
//! \ingroup vidperf
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Video_PmmC_SetMode(NV_VIDEO_PMMC_ACTION modeAction);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Video_PmmC_GetReport
//
//!  DESCRIPTION: This function gets the data from Video Perfmon Mode C. \n
//!               If pReport == NULL, then pbytesNeeded is filled so the caller 
//!               can allocate the memory.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 105
//!
//! \return NVAPI_ERROR or NVAPI_OK
//! \ingroup vidperf
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Video_PmmC_GetReport(NvU32 bytesAllocd, NvU32 *pBytesNeeded, char *pReport);



//! Used in NV_VIDEO_PMMC_DOMAIN_CONTROL_SETUP.
//! \ingroup vidperfunctions
typedef struct
{
    NvU32       version;            // structure version
    NvU32       dwControl;
    NvU32       dwTrig0Sel;
    NvU32       dwTrig1Sel;
    NvU32       dwEventSel;
    NvU32       dwSampleSel;
    NvU32       dwSampleOp;
    NvU32       engine[12];
    NvU32       sigtype[12];
} NV_VIDEO_PMMC_DOMAIN_CONTROL;

//! \ingroup vidperfunctions
#define NV_VIDEO_PMMC_DOMAIN_CONTROL_VER  MAKE_NVAPI_VERSION(NV_VIDEO_PMMC_DOMAIN_CONTROL,1)


//! Used in NvAPI_Video_Pmmc_SetDomainConfig()
//! \ingroup vidperfunctions
typedef struct
{
    NvU32                           version;            //!< structure version
    NvU32                           bEnable;
    NvU32                           dwMaxCaptureRecords;
    NvU32                           dwMaxReportRecords;
    NV_VIDEO_PMMC_DOMAIN_CONTROL    controlSetup;
} NV_VIDEO_PMMC_DOMAIN_CONTROL_SETUP;

//! \ingroup vidperfunctions
#define NV_VIDEO_PMMC_DOMAIN_CONTROL_SETUP_VER  MAKE_NVAPI_VERSION(NV_VIDEO_PMMC_DOMAIN_CONTROL_SETUP,1)


 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Video_Pmmc_SetDomainConfig
//
//!  DESCRIPTION: This function sets up the domain capture HW control for Video Perfmon Mode C
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 105
//!
//! \return NVAPI_ERROR or NVAPI_OK
//! \ingroup vidperf
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Video_Pmmc_SetDomainConfig(NvU32 domain, NV_VIDEO_PMMC_DOMAIN_CONTROL_SETUP *setupData);






// Video post-processing and color control APIs for private clients
// These add more information and include device choices


//! \ingroup vidcontrol
//! Used in NVAPI_VIDEO_GET_DEVICE_INFO.
typedef enum _NVAPI_VIDEO_STATE_DEVICE_KIND
{
    NVAPI_VIDEO_DEVICE_KIND_NONE      = -1,
    NVAPI_VIDEO_DEVICE_GLOBAL_DEFAULT     ,        //!< Default 
    NVAPI_VIDEO_DEVICE_MASK               ,        //!< By displayId
    NVAPI_VIDEO_DEVICE_EDID               ,        //!< EDID specified - there can be multiple EDIDs
    NVAPI_VIDEO_DEVICE_CONNECTOR_TYPE     ,        //!< GPU connector type
    NVAPI_VIDEO_DEVICE_KIND_LAST
} NVAPI_VIDEO_STATE_DEVICE_KIND;


//! \addtogroup vidcontrol
//! Used in NVAPI_VIDEO_GET_DEVICE_INFO.
//! @{
#define VIDEO_DEVICE_DESCRIPTION_LENGTH     40
#define VIDEO_DEVICE_REG_PREFIX_LENGTH      32
//! @}


//! \ingroup vidcontrol
//! Used in NvAPI_GetVideoDeviceInfo().
typedef struct _NVAPI_VIDEO_GET_DEVICE_INFO
{
    NvU32   version;                //!< (IN)  structure version
    NvU32   deviceIndex;            //!< (IN)  select device
    NvU32   deviceType;             //!< (OUT) specify what kind of device, one of NVAPI_VIDEO_STATE_DEVICE_KIND
    NvU32   deviceID;               //!< (OUT) device id (deviceMask, connector type, etc)
    NvU8    deviceDescription[VIDEO_DEVICE_DESCRIPTION_LENGTH];     //!< (OUT) what is the device
    NvU8    deviceRegistryPrefix[VIDEO_DEVICE_REG_PREFIX_LENGTH];   //!< (OUT) what is the device
    NvU32   bDefaultGammaCompIdx;   //!< (OUT) specifies the default gamma (Y/RGB) being used by this video device
    NvU8    reserved[4];            //!< (OUT) reserved for expansion
} NVAPI_VIDEO_GET_DEVICE_INFO;


//! \ingroup vidcontrol
//! Used in NVAPI_VIDEO_GET_DEVICE_INFO.
#define NVAPI_VIDEO_GET_DEVICE_INFO_VER  MAKE_NVAPI_VERSION(NVAPI_VIDEO_GET_DEVICE_INFO,1)


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetVideoDeviceCount
//
//!   DESCRIPTION: This function returns the number of devices available.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//!
//! \retval    NVAPI_OK
//! \retval    NVAPI_ERROR
//!
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetVideoDeviceCount(NvDisplayHandle hNvDisplay, NvU32 *pParms);





///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetVideoDeviceInfo
//
//!   DESCRIPTION: This function returns information on the device selected by the index.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//!
//! \retval  NVAPI_OK
//! \retval  NVAPI_NOT_SUPPORTED
//! \retval  NVAPI_INVALID_ARGUMENT
//! \reatval NVAPI_ERROR
//!
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetVideoDeviceInfo(NvDisplayHandle hNvDisplay, NVAPI_VIDEO_GET_DEVICE_INFO *pParms);


//! \ingroup vidcontrol
//! Active video device(s)-related enum \n
//! Used in #NVAPI_ACTIVE_VIDEO_DEVICE_INFO.
typedef enum _NVAPI_ACTIVE_VIDEO_DEVICE
{
    NVAPI_ACTIVE_VIDEO_DEVICE_USER_CHOICE =0, //!< The accompanying deviceIndex field determines the active device
    NVAPI_ACTIVE_VIDEO_DEVICE_PER_DISPLAY   , //!< Per-display settings are currently active, deviceIndex is irrelevant  
    NVAPI_ACTIVE_VIDEO_DEVICE_LAST
} NVAPI_ACTIVE_VIDEO_DEVICE;


//! \ingroup vidcontrol
//! Active video device(s)-related struct /n
//! Used in NvAPI_GetActiveVideoDevice().
typedef struct _NVAPI_ACTIVE_VIDEO_DEVICE_INFO
{
    NvU32   version;        //!< (IN)     Structure version
    NvU32   activeDevice;   //!< (IN/OUT) One of NVAPI_ACTIVE_VIDEO_DEVICE, denotes setting choice
    NvU32   deviceIndex;    //!< (IN/OUT) Select device to be set active
    NvU32   reserved[5];    //!< (IN/OUT) reserved for expansion
} NVAPI_ACTIVE_VIDEO_DEVICE_INFO;


//! \ingroup vidcontrol
//! Used in NVAPI_ACTIVE_VIDEO_DEVICE_INFO.
#define NVAPI_ACTIVE_VIDEO_DEVICE_INFO_VER  MAKE_NVAPI_VERSION(NVAPI_ACTIVE_VIDEO_DEVICE_INFO,1)


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetActiveVideoDevice
//
//!   DESCRIPTION: This function gets the active video device information that is currently being
//!                used. The active device being used could correspond to a single 
//!                video device if the _USER_CHOICE enum is returned. It could also
//!                correspond to multiple video devices if the _PER_DISPLAY enum
//!                is returned.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//!
//! \retval  NVAPI_OK
//! \retval  NVAPI_NOT_SUPPORTED
//! \retval  NVAPI_INVALID_ARGUMENT
//! \retval  NVAPI_ERROR
//!
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetActiveVideoDevice(NvDisplayHandle hNvDisplay, NVAPI_ACTIVE_VIDEO_DEVICE_INFO *pActiveVideoDevice);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SetActiveVideoDevice
//
//!   DESCRIPTION: This function sets the active video device to be used. The active device selected
//!                could either be specified as a single video device (only _GLOBAL_DEFAULT 
//!                or _DEVICE_MASK video devices can be set active); or could be 
//!                dynamically handled by the driver if per-display settings are
//!                requested by the client.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//! 
//! \retval  NVAPI_OK
//! \retval  NVAPI_NOT_SUPPORTED
//! \retval  NVAPI_INVALID_ARGUMENT
//! \retval  NVAPI_ERROR
//!
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetActiveVideoDevice(NvDisplayHandle hNvDisplay, NVAPI_ACTIVE_VIDEO_DEVICE_INFO *pActiveVideoDevice);





//! \ingroup vidcontrol
//! Used in NvAPI_GetVideoStateEx().
typedef struct _NVAPI_GET_VIDEO_STATE_COMPONENT_EX
{
    NvU32   version;                            //!< (IN)  Structure version
    NvU32   componentID;                        //!< (IN)  Identify the individual component
    NvU32   deviceIndex;                        //!< (IN)  Select device
    NvU32   bIsSupported                : 1;    //!< (OUT) Set if component is supported by driver
    NvU32   bIsHigherPriorityThanApp    : 1;    //!< (OUT) Flag to indicate priority of the NV Control Panel setting vs app-nvapi setting
    NvU32   bOverrideAppDefault         : 1;    //!< (OUT) Flag to indicate default priority of the NV Control Panel setting vs app-nvapi setting
    NvU32   reserved1                   : 29;   //!< (OUT) Reserved for future usage
    NvU32   isEnabled;                          //!< (OUT) Set if component is enabled by the NV Control Panel, one or more of NVAPI_VIDEO_COMPONENT_ENABLE bitmasks
    NvU32   defaultEnabledState;                //!< (OUT) Indicates the default enabled state for the NV Control Panel setting of this component
    NvU32   minValue;                           //!< (OUT) Minimum valid value
    NvU32   maxValue;                           //!< (OUT) Maximum valid value
    NvU32   totalSteps;                         //!< (OUT) number of steps between min and max
    NvU32   defaultValue;                       //!< (OUT) defaultNV value
    NvU32   unityValue;                         //!< (OUT) Value prescribed for unity (disabled state)
    NvU32   currentValueActive;                 //!< (OUT) Value in use, if it equals unity, operation can be skipped
    NvU64   defaultAlgo;                        //!< (OUT) Default algorithm
    NvU64   currentAlgoActive;                  //!< (OUT) Algorithm in use
    NvU32   appValueInUse  : 1;                 //!< (OUT) Let the NV Control Panel know if the application value is set
    NvU32   appAlgoInUse   : 1;                 //!< (OUT) Let the NV Control Panel know if the application algorithm is set
    NvU32   reserved2      : 30;                //!< (OUT) Reserved for future usage
    NvU32   appValue;                           //!< (OUT) Application value
    NvU64   appAlgo;                            //!< (OUT) Application algorithm
    NvU64   lastAlgoSet;                        //!< (OUT) Last control panel algorithm set - may be different than currentAlgoActive
    NvU32   lastValueSet;                       //!< (OUT) Last control panel value set - may be different than currentActiveValue
    NvU32   reserved3;                          //!< (OUT) Reserved for expansion
    NvU64   reserved4[4];                       //!< (OUT) Reserved for later use

} NVAPI_GET_VIDEO_STATE_COMPONENT_EX;


//! ingroup vidcontrol
//! Used in NVAPI_GET_VIDEO_STATE_COMPONENT_EX.
#define NVAPI_GET_VIDEO_STATE_COMPONENT_EX_VER  MAKE_NVAPI_VERSION(NVAPI_GET_VIDEO_STATE_COMPONENT_EX,1)


//! \ingroup vidcontrol
//! Used in NvAPI_SetVideoStateEx().
typedef struct _NVAPI_SET_VIDEO_STATE_COMPONENT_EX
{
    NvU32   version;                            //!< (IN)  Structure version
    NvU32   componentID;                        //!< (IN)  Identify the individual state
    NvU32   deviceIndex;                        //!< (IN)  Selects the device
    NvU32   bIsTopPriority  :1;                 //!< (IN)  Flag to indicate priority of control panel setting vs app-nvapi setting
    NvU32   reserved1       :31;                //!< (IN)  Reserved for expansion
    NvU32   enable;                             //!< (IN)  Flag to enable control panel setting of component, one or more of NVAPI_VIDEO_COMPONENT_ENABLE bitmasks
    NvU32   setToValue;                         //!< (IN)  Value to use
    NvU64   setToAlgo;                          //!< (IN)  Algorithm to use
    NvU32   retStatus;                          //!< (OUT) Result of video-component-set operation; a combination of VIDEO_COMP_STATUS_xxx bitmasks 
    NvU32   reserved2;                          //!< (IN)  Reserved for later use
    NvU64   reserved3[3];                       //!< (IN)  Reserved for later use

} NVAPI_SET_VIDEO_STATE_COMPONENT_EX;


//! \ingroup vidcontrol
//! Used in NVAPI_SET_VIDEO_STATE_COMPONENT_EX. 
#define NVAPI_SET_VIDEO_STATE_COMPONENT_EX_VER  MAKE_NVAPI_VERSION(NVAPI_SET_VIDEO_STATE_COMPONENT_EX,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetVideoStateEx
//
//!   DESCRIPTION: This function returns the video state component for the control panel 
//!                for the componentID passed in. Clients may use this call to 
//!                retrieve the component state for any video device (for example global,
//!                displayId-specific, etc.) by specifying the appropriate device 
//!                index that has been enumerated using NvAPI_GetVideoDeviceInfo().
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//!
//! \retval  NVAPI_OK
//! \retval  NVAPI_INVALID_ARGUMENT
//! \retval  NVAPI_ERROR
//!
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetVideoStateEx(NvDisplayHandle hNvDisplay, NVAPI_GET_VIDEO_STATE_COMPONENT_EX *pParms);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SetVideoStateEx
//
//!   DESCRIPTION: This function sets the video state component using the control panel. Clients
//!                may use this call to set the value/algorithm of a video component
//!                for any video device by supplying the device index. Please note
//!                that simply setting a value/algorithm for a particular video 
//!                component on a specific video device does not necessarily mean
//!                that this setting will be immediately applied to the video. 
//!                The setting will be immediately applied only if the current active
//!                device corresponds to the requested video device using this API.
//!                Clients may inquire about the current active video devices using
//!                the NvAPI_GetActiveVideoDevice() call. \n
//!                 
//!                The video component setting is determined using the following flags: 
//!
//!    <table>
//!    <tr> <td>bIsTopPriority</td>  <td>bEnableXXX</td>   <td>Value Source</td> </tr>
//!    <tr> <td>0</td>               <td>0</td>            <td>If present, Application NVAPI value; else defaultNV value</td> </tr>
//!    <tr> <td>0</td>               <td>1</td>            <td>If present, Application NVAPI value; else NV Control Panel value</td> </tr>
//!    <tr> <td>1</td>               <td>0</td>            <td>If present, Application NVAPI value; else defaultNV value</td> </tr>
//!    <tr> <td>1</td>               <td>1</td>            <td>The NV Control Panel value</td> </tr>
//!    </table>
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170  
//!
//! \retval  ::NVAPI_OK
//! \retval  ::NVAPI_INVALID_ARGUMENT
//! \retval  ::NVAPI_ERROR
//!
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetVideoStateEx(NvDisplayHandle hNvDisplay, NVAPI_SET_VIDEO_STATE_COMPONENT_EX *pParms);






// Let the control panel retrieve info on the various streams
    

//! \ingroup vidcontrol
//! Used in #NVAPI_VIDEO_GET_STREAM_INFO.
typedef enum _NVAPI_VIDEO_FORMAT_LAYOUT
{
    NVAPI_VIDEO_FMT_NONE          = 0,
    NVAPI_VIDEO_FMT_INTERLACED       ,
    NVAPI_VIDEO_FMT_PROGRESSIVE      ,
    NVAPI_VIDEO_FMT_FIELD            ,
    NVAPI_VIDEO_FMT_LAST
} NVAPI_VIDEO_FORMAT_LAYOUT;


//! \ingroup vidcontrol
//! Used in #NVAPI_VIDEO_GET_STREAM_INFO.
#define APP_NAME_LENGTH 64


//! \ingroup vidcontrol
//! Used in NvAPI_GetVideoStreamInfo().
typedef struct _NVAPI_VIDEO_GET_STREAM_INFO
{
    NvU32   version;                        //!< (IN)  Structure version, constructed from the macro #NVAPI_VIDEO_GET_STREAM_INFO_VER 
    NvU32   streamIndex;                    //!< (IN)  Selected stream
    NvU32   deviceIndex;                    //!< (OUT) Specifies which device is being applied to the stream
    NvU32   processID;                      //!< (OUT) Application process ID
    NvU8    processName[APP_NAME_LENGTH];   //!< (OUT) Application name
    NvU32   streamSrcWidth;                 //!< (OUT) Source width
    NvU32   streamSrcHeight;                //!< (OUT) Source height
    NvU32   streamSrcFormat;                //!< (OUT) Source fourCC format
    NvU32   streamFormatLayout;             //!< (OUT) Interlaced or progressive, one of #NVAPI_VIDEO_FORMAT_LAYOUT
    NvU32   streamSrcColorSpace;            //!< (OUT) colorspace of source, one of VIDEO_COMP_ALGO_COLOR_SPACE_xxx bitmask
    NvU32   streamDstWidth;                 //!< (OUT) Destination width
    NvU32   streamDstHeight;                //!< (OUT) Destination height
    NvU32   streamDstFormat;                //!< (OUT) Desination fourCC format
    NvU32   streamDstColorSpace;            //!< (OUT) Destination colorspace - one of VIDEO_COMP_ALGO_COLOR_SPACE_xxx bitmask
    NvU32   streamDstColorRange;            //!< (OUT) Destination color range - one of VIDEO_COMP_ALGO_COLOR_RANGE_xxx bitmask
    double  streamFreq;                     //!< (OUT) Video stream frequency reported by the application, not usable right now = 0
    double  streamFreqDetected;             //!< (OUT) Video stream frequency detected from the driver
    double  streamFreqPlayback;             //!< (OUT) Actual playback frequency
    NvU32   curPState;                      //!< (OUT) The current P-state
    NvU32   curPstateTuningAction;          //!< (OUT) The status of P-state tuning
    NvU64   lastUpdateTime;                 //!< (OUT) The last time that the stream is updated, use performance count/frequency
    NvU64   reserved;                       //!< (OUT) Reserved for future use
} NVAPI_VIDEO_GET_STREAM_INFO;


//! \ingroup vidcontrol
//! Used in #NVAPI_VIDEO_GET_STREAM_INFO.
#define NVAPI_VIDEO_GET_STREAM_INFO_VER  MAKE_NVAPI_VERSION(NVAPI_VIDEO_GET_STREAM_INFO,1)


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetVideoStreamCount
//
//!   DESCRIPTION: This function returns the number of streams that are active.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//!
//! \retval  NVAPI_OK
//! \reatval NVAPI_ERROR
//!
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetVideoStreamCount(NvDisplayHandle hNvDisplay, NvU32 *pParms);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetVideoStreamInfo
//
//!   DESCRIPTION: This function gets the stream information by video context using the control panel.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//!
//! \retval NVAPI_OK
//! \retval NVAPI_INVALID_ARGUMENT
//! \retval NVAPI_ERROR
//!
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetVideoStreamInfo(NvDisplayHandle hNvDisplay, NVAPI_VIDEO_GET_STREAM_INFO *pParms);





///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetAdaptiveContrastInfo()
//
//! \fn NvAPI_GetAdaptiveContrastInfo(NvDisplayHandle hNvDisplay, NV_ADAPTIVE_CONTRAST_INFO *pCfg)
//! DESCRIPTION:    This API gets the parameters for adaptive contrast enchancement and color shift/squeeze.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//!
//! \param [in]     hNvDisplay  NVIDIA Display selection \n
//!                 It can be #NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//!
//! \retval ::NVAPI_OK  
//! \retval ::NVAPI_ERROR
//! \retval ::NVAPI_API_NOT_INTIALIZED
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup vidcontrol
//! Used in NV_ADAPTIVE_CONTRAST_INFO.
#define NV_ADAPTIVE_CONTRAST_INFO_NUM_CONSTS 128

//! \ingroup vidcontrol
//! Used in NvAPI_GetAdaptiveContrastInfo() and NvAPI_SetAdaptiveContrastInfo().
typedef struct
{
    NvU32   version;                //!< Structure version
    NvU32   consts[NV_ADAPTIVE_CONTRAST_INFO_NUM_CONSTS];
     //!< -0-16 YUV2RGB coefs
     //! -16-24 maxdistance
     //! -24-32 squeeze constants
     //! -32-64 sliders
     //! -64-128 YUV regions for green,red, skin                                    
}NV_ADAPTIVE_CONTRAST_INFO;

//! \ingroup vidcontrol
//! Used in NV_ADAPTIVE_CONTRAST_INFO.
#define NV_ADAPTIVE_CONTRAST_INFO_VER  MAKE_NVAPI_VERSION(NV_ADAPTIVE_CONTRAST_INFO,1)


//! \ingroup vidcontrol
NVAPI_INTERFACE NvAPI_GetAdaptiveContrastInfo(NvDisplayHandle hNvDisplay, NV_ADAPTIVE_CONTRAST_INFO *pCfg);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SetAdaptiveContrastInfo()
//
//! DESCRIPTION:     This API sets the parameters for adaptive contrast enchancement and color shift/squeeze.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//!
//! \param [in]     hNvDisplay  NVIDIA Display selection \n
//!                 It can be #NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//!
//! \retval ::NVAPI_OK  
//! \retval ::NVAPI_ERROR
//! \retval ::NVAPI_API_NOT_INTIALIZED
//!
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetAdaptiveContrastInfo(NvDisplayHandle hNvDisplay, NV_ADAPTIVE_CONTRAST_INFO *pCfg);




///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GPU_SetVidPnInfo
//
//! DESCRIPTION:    This API allows the caller to inform the driver of any display
//!                 change events so that the VidPnSrcId's may be updated.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 173
//!
//! \param [in]     hPhysicalGpu            GPU selection
//!
//! \retval ::NVAPI_OK  
//! \retval ::NVAPI_ERROR
//! \retval ::NVAPI_INVALID_ARGUMENT
//!
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////    
NVAPI_INTERFACE NvAPI_GPU_SetVidPnInfo(NvPhysicalGpuHandle hPhysicalGpu);





///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetVideoState
//
//! \fn NvAPI_GetVideoState(NvDisplayHandle hNvDisplay, NVAPI_GET_VIDEO_STATE_COMPONENT *pGetVidStateComp)
//! DESCRIPTION:     This function return the video state component for the component ID passed in. It is the responsibility
//!                  of the caller to fill secret application key that enables authentication of the caller.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//!
//! \param [in]      hNvDisplay        NVIDIA Display selection \n
//!                                    It can be #NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//! \param [out]     pGetVidStateComp  NVAPI_GET_VIDEO_STATE_COMPONENT packet containing
//!                                    a valid component ID and a valid application secret key.
//!
//! \retval ::NVAPI_OK  
//! \retval ::NVAPI_ERROR
//! \retval ::NVAPI_INVALID_ARGUMENT
//
///////////////////////////////////////////////////////////////////////////////

#ifndef NV_VIDEO_COMPONENTS_DEFINE
#define NV_VIDEO_COMPONENTS_DEFINE

///////////////////////////////////////////////////////////////////////////////
// Structs and enums related to Video state
///////////////////////////////////////////////////////////////////////////////


//! \ingroup vidcontrol
//! Components related to video state \n
//! Used in NVAPI_GET_VIDEO_STATE_COMPONENT and NVAPI_SET_VIDEO_STATE_COMPONENT.
typedef enum _NVAPI_VIDEO_STATE_COMPONENT_ID
{
    NVAPI_VIDEO_STATE_COMPONENT_ID_NONE     = -1,   //!< Placeholder for invalid component ID
    NVAPI_VIDEO_STATE_COMPONENT_BRIGHTNESS      ,   //!<  Permits control of video's brightness value
    NVAPI_VIDEO_STATE_COMPONENT_CONTRAST        ,   //!<  Allows control of video's contrast value
    NVAPI_VIDEO_STATE_COMPONENT_HUE             ,   //!<  To control the hue value
    NVAPI_VIDEO_STATE_COMPONENT_SATURATION      ,   //!<  Allows control of video's saturation value
    NVAPI_VIDEO_STATE_COMPONENT_COLORTEMP       ,   //!<  Allows control of the color temperature value
    NVAPI_VIDEO_STATE_COMPONENT_Y_GAMMA         ,   //!<  To set the Y-gamma values
    NVAPI_VIDEO_STATE_COMPONENT_RGB_GAMMA_R     ,   //!<  To set the R value of RGB gamma
    NVAPI_VIDEO_STATE_COMPONENT_RGB_GAMMA_G     ,   //!<  To set the G value of RGB gamma
    NVAPI_VIDEO_STATE_COMPONENT_RGB_GAMMA_B     ,   //!<  To set the B value of RGB gamma
    NVAPI_VIDEO_STATE_COMPONENT_COLOR_SPACE     ,   //!<  Permits choice of various color spaces using VIDEO_COMP_ALGO_COLOR_SPACE_xxx
    NVAPI_VIDEO_STATE_COMPONENT_COLOR_RANGE     ,   //!<  Allows setting between a limited/full color range using VIDEO_COMP_ALGO_COLOR_RANGE_xxx
    NVAPI_VIDEO_STATE_COMPONENT_PLAYBACK_PROFILE,   //!<  Permits using special postprocessing for Adobe Flash 9 Content
    NVAPI_VIDEO_STATE_COMPONENT_DEINTERLACE     ,   //!<  To set various types of deinterlacing algorithms
    NVAPI_VIDEO_STATE_COMPONENT_SCALING         ,   //!<  Allows setting video scaling algorithms
    NVAPI_VIDEO_STATE_COMPONENT_CADENCE         ,   //!<  Allows control of the cadence algorithms
    NVAPI_VIDEO_STATE_COMPONENT_NOISE_REDUCE    ,   //!<  Allows setting post-processing noise reduction values
    NVAPI_VIDEO_STATE_COMPONENT_EDGE_ENHANCE    ,   //!<  Permits post-processing edge enhancement value adjustment
    NVAPI_VIDEO_STATE_COMPONENT_OVERDRIVE       ,   //!<  To control the overdrive feature
    NVAPI_VIDEO_STATE_COMPONENT_SPLITSCREEN     ,   //!<  To permit setting a splitscreen using one of VIDEO_COMP_ALGO_SPLITSCREEN_xxx
    NVAPI_VIDEO_STATE_COMPONENT_DEBLOCKING      ,   //!<  Allows out-of-loop deblocking
    NVAPI_VIDEO_STATE_COMPONENT_DYNAMIC_CONTRAST,   //!<  Permits control of video's dynamic contrast value
    NVAPI_VIDEO_STATE_COMPONENT_GREEN_STRETCH   ,   //!<  Permits control of green stretch
    NVAPI_VIDEO_STATE_COMPONENT_BLUE_STRETCH    ,   //!<  Allows control of blue enhancement
    NVAPI_VIDEO_STATE_COMPONENT_SKIN_TONE_CORRECTION, //!<  Allows skin-tone correction for video 
    NVAPI_VIDEO_STATE_COMPONENT_GAMUT_REMAPPING ,   //!<  Applies gamut remapping on video
    NVAPI_VIDEO_STATE_COMPONENT_2DTO3D          ,   //!< Converts 2D video to 3D stereo video
    NVAPI_VIDEO_STATE_COMPONENT_3D_ANALYSIS     ,   //!< Analyzing 3D stereo video
    NVAPI_VIDEO_STATE_COMPONENT_FRC             ,   //!< Frame Rate Converter
    NVAPI_VIDEO_STATE_COMPONENT_BEN             ,   //!< Applies deblocking on video
    NVAPI_VIDEO_STATE_COMPONENT_ID_LAST         ,   //!< All valid components defined before this one
} NVAPI_VIDEO_STATE_COMPONENT_ID;

//! \ingroup vidcontrol 
//! Dynamic contrast value. Kept this for backward compatibility.
#define NVAPI_VIDEO_STATE_COMPONENT_DYNAMIC_CONSTRAST  NVAPI_VIDEO_STATE_COMPONENT_DYNAMIC_CONTRAST  


//! \ingroup vidcontrol
//! Used in #_NVAPI_VIDEO_COMPONENT_ALGORITHM.
#define VIDEO_COMP_ALGO_CUSTOM_BASE 64

//! \ingroup vidcontrol
//! Algorithms controlling various video components
//! Used in NVAPI_GET_VIDEO_STATE_COMPONENT and NVAPI_SET_VIDEO_STATE_COMPONENT.
typedef enum _NVAPI_VIDEO_COMPONENT_ALGORITHM
{
    VIDEO_COMP_ALGO_COLOR_SPACE_601                  = 0,  //!<  Use the ITU-R BT.601 standard in color-space conversion for xxx_COLOR_SPACE component
    VIDEO_COMP_ALGO_COLOR_SPACE_709                  = 1,  //!<  Use the ITU-R BT.709 standard in color-space conversion for xxx_COLOR_SPACE component
    VIDEO_COMP_ALGO_COLOR_SPACE_CUSTOM_04            = VIDEO_COMP_ALGO_CUSTOM_BASE+4,   //!< Use custom color matrix.
    VIDEO_COMP_ALGO_COLOR_RANGE_STD                  = 0,  //!<  Full range of (0-255) for xxx_COLOR_RANGE component, equivalent to Microsoft's DXVADDI_NOMINALRANGE::DXVADDI_NominalRange_0_255
    VIDEO_COMP_ALGO_COLOR_RANGE_EXT                  = 1,  //!<  Limited range of (16-235) for xxx_COLOR_RANGE component, equivalent to Microsoft's DXVADDI_NOMINALRANGE::DXVADDI_NominalRange_16_235
    VIDEO_COMP_ALGO_PLAYBACK_PROFILE_NONE            = 0,  //!<  Use no playback profile
    VIDEO_COMP_ALGO_PLAYBACK_PROFILE_ADOBE_FLASH_9   = 1,  //!<  Use the internet video enhancement postprocessing for Adobe Flash 9 
    VIDEO_COMP_ALGO_DEINTERLACE_BOB                  = 0,  //!<  Perform Bob deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_WEAVE                = 1,  //!<  Use weave deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_SIMPLE_ADAPTIVE      = 2,  //!<  Perform a simple motion adaptive deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_GRADIENT_SIMPLE      = 3,  //!<  Use a simple gradient deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_GRADIENT_FULL        = 4,  //!<  Use advanced gradient deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_ADAPTIVE_FOUR_FIELD  = 5,  //!<  Perform four field motion adaptive deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_DIR_SPATIAL          = 6,  //!<  User directional spatial deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_ADVANCED             = 7,  //!<  Perform proprietary advanced deinterlacing
    VIDEO_COMP_ALGO_DEINTERLACE_GPU_CAPABLE          = 8,  //!<  Best available but GPU dependent. (video driver decides dynamically) 
    VIDEO_COMP_ALGO_DEINTERLACE_CUSTOM_00            = VIDEO_COMP_ALGO_CUSTOM_BASE+0,    //!< Use custom Deinterlacing algorithm
    VIDEO_COMP_ALGO_DEINTERLACE_CUSTOM_01            = VIDEO_COMP_ALGO_CUSTOM_BASE+1,    //!< Use custom Deinterlacing algorithm
    VIDEO_COMP_ALGO_SCALING_ALG_SIMPLE               = 0,  //!<  Do scaling using a simple algorithm       
    VIDEO_COMP_ALGO_SCALING_ALG_4x4FILTER            = 1,  //!<  Perform scaling using a 4x4 filter
    VIDEO_COMP_ALGO_SCALING_ALG_8x8FILTER            = 2,  //!< Perform scaling using a 8x8 filter
    VIDEO_COMP_ALGO_SCALING_ALG_CUSTOM_00            = VIDEO_COMP_ALGO_CUSTOM_BASE+0,    //!< Use custom scaling component
    VIDEO_COMP_ALGO_SCALING_ALG_CUSTOM_01            = VIDEO_COMP_ALGO_CUSTOM_BASE+1,    //!< Use custom scaling component
    VIDEO_COMP_ALGO_CADENCE_NONE                     = 0,  //!<  Turn cadence OFF
    VIDEO_COMP_ALGO_CADENCE_SIMPLE                   = 1,  //!<  Use simple cadence detection
    VIDEO_COMP_ALGO_CADENCE_VOF                      = 2,  //!<  Use video on film cadence detection
    VIDEO_COMP_ALGO_CADENCE_COMPUTE                  = 3,  //!<  Use compute cadence detection
    VIDEO_COMP_ALGO_CADENCE_GPU_CAPABLE              = 4,  //!<  Best available but GPU dependent. (video driver decides dynamically)
    VIDEO_COMP_ALGO_NOISE_REDUCE_PUREVIDEO           = 0,  //!<  Use PureVideo noise reduction
    VIDEO_COMP_ALGO_NOISE_REDUCE_CUSTOM_00           = VIDEO_COMP_ALGO_CUSTOM_BASE+0,  //!< Use custom noise reduction
    VIDEO_COMP_ALGO_NOISE_REDUCE_CUSTOM_01           = VIDEO_COMP_ALGO_CUSTOM_BASE+1,  //!< Use custom noise reduction
    VIDEO_COMP_ALGO_EDGE_ENHANCE_PUREVIDEO           = 0,  //!<  Use PureVideo Sharpening Filter
    VIDEO_COMP_ALGO_EDGE_ENHANCE_CUSTOM_00           = VIDEO_COMP_ALGO_CUSTOM_BASE+0,  //!< Use custom Sharpening Filter
    VIDEO_COMP_ALGO_EDGE_ENHANCE_CUSTOM_01           = VIDEO_COMP_ALGO_CUSTOM_BASE+1,  //!< Use custom Sharpening Filter
    VIDEO_COMP_ALGO_OVERDRIVE_SIMPLE                 = 0,  //!<  Use simple overdrive algorithm
    VIDEO_COMP_ALGO_SPLITSCREEN_TYPE_NORMAL          = 0,  //!<  Set the splitscreen in normal mode
    VIDEO_COMP_ALGO_SPLITSCREEN_TYPE_REPEATED        = 1,  //!<  Set the splitscreen to be repeated
    VIDEO_COMP_ALGO_SPLITSCREEN_TYPE_ON_MIRROR       = 2,  //!<  Set the splitscreen as a mirror
    VIDEO_COMP_ALGO_DYNAMIC_CONTRAST_PRESET_NONE     = 0,  //!<  Use the value setting for dynamic contrast instead of a preset
    VIDEO_COMP_ALGO_DYNAMIC_CONTRAST_PRESET_LOW      = 1,  //!<  Turn the dynamic contrast to a low setting
    VIDEO_COMP_ALGO_DYNAMIC_CONTRAST_PRESET_MEDIUM   = 2,  //!<  Turn the dynamic contrast to a medium setting
    VIDEO_COMP_ALGO_DYNAMIC_CONTRAST_PRESET_HIGH     = 3,  //!<  Turn the dynamic contrast to a high setting
    VIDEO_COMP_ALGO_GREEN_STRETCH_PRESET_NONE        = 0,  //!<  Use the value setting for green stretch instead of a preset
    VIDEO_COMP_ALGO_GREEN_STRETCH_PRESET_LOW         = 1,  //!<  Set the green strech to a low setting
    VIDEO_COMP_ALGO_GREEN_STRETCH_PRESET_MEDIUM      = 2,  //!<  Set the green strech to a medium setting
    VIDEO_COMP_ALGO_GREEN_STRETCH_PRESET_HIGH        = 3,  //!<  Set the green strech to a high setting
    VIDEO_COMP_ALGO_BLUE_STRETCH_PRESET_NONE         = 0,  //!<  Use the value setting for blue stretch instead of a preset   
    VIDEO_COMP_ALGO_BLUE_STRETCH_PRESET_LOW          = 1,  //!<  Set the blue strech to a low setting
    VIDEO_COMP_ALGO_BLUE_STRETCH_PRESET_MEDIUM       = 2,  //!<  Set the blue strech to a medium setting
    VIDEO_COMP_ALGO_BLUE_STRETCH_PRESET_HIGH         = 3,  //!<  Set the blue strech to a high setting
    VIDEO_COMP_ALGO_SKIN_TONE_CORRECTION_PRESET_NONE = 0,  //!<  Use the value setting for skin tone correction instead of a preset  
    VIDEO_COMP_ALGO_SKIN_TONE_CORRECTION_PRESET_SQUEEZE = 1,  //!<  Turn the skin tone correction to a low setting
    VIDEO_COMP_ALGO_SKIN_TONE_CORRECTION_PRESET_RED     = 2,  //!<  Turn the skin tone correction to a medium setting
    VIDEO_COMP_ALGO_SKIN_TONE_CORRECTION_PRESET_YELLOW  = 3,  //!<  Turn the skin tone correction to a high setting
    VIDEO_COMP_ALGO_GAMUT_REMAPPING_CUSTOM_00        = VIDEO_COMP_ALGO_CUSTOM_BASE+0, //!< Use custom 3x3 gamut remapping matrix
    VIDEO_COMP_ALGO_GAMUT_REMAPPING_CUSTOM_01        = VIDEO_COMP_ALGO_CUSTOM_BASE+1, //!< Use custom 3x3 gamut remapping matrix
    VIDEO_COMP_ALGO_2DTO3D_CUSTOM_00                 = VIDEO_COMP_ALGO_CUSTOM_BASE+0, //!< Use custom 2Dto3D conversion
    VIDEO_COMP_ALGO_2DTO3D_CUSTOM_01                 = VIDEO_COMP_ALGO_CUSTOM_BASE+1, //!< Use custom 2Dto3D conversion
    VIDEO_COMP_ALGO_3D_ANALYSIS_CUSTOM_00            = VIDEO_COMP_ALGO_CUSTOM_BASE+0, //!< Use custom 3DAnalysis algorithm
    VIDEO_COMP_ALGO_3D_ANALYSIS_CUSTOM_01            = VIDEO_COMP_ALGO_CUSTOM_BASE+1, //!< Use custom 3DAnalysis algorithm
    VIDEO_COMP_ALGO_FRC_CUSTOM_00                    = VIDEO_COMP_ALGO_CUSTOM_BASE+0, //!< Use custom frame rate converter
    VIDEO_COMP_ALGO_FRC_CUSTOM_01                    = VIDEO_COMP_ALGO_CUSTOM_BASE+1, //!< Use custom frame rate converter
    VIDEO_COMP_ALGO_BEN_CUSTOM_00                    = VIDEO_COMP_ALGO_CUSTOM_BASE+0, //!< Use custom deblocking algorithm
    VIDEO_COMP_ALGO_BEN_CUSTOM_01                    = VIDEO_COMP_ALGO_CUSTOM_BASE+1, //!< Use custom deblocking algorithm
} NVAPI_VIDEO_COMPONENT_ALGORITHM;


//! \ingroup vidcontrol
//! Bitmasks for video components' enable at various resolutions
//! Used in NVAPI_GET_VIDEO_STATE_COMPONENT and NVAPI_SET_VIDEO_STATE_COMPONENT.
typedef enum _NVAPI_VIDEO_COMPONENT_ENABLE
{
    VIDEO_COMP_ENA_480i     = 0x00000001, //!<  component is enabled at 480i video resolution
    VIDEO_COMP_ENA_480p     = 0x00000002, //!<  component is enabled at 480p video resolution
    VIDEO_COMP_ENA_576i     = 0x00000004, //!<  component is enabled at 576i video resolution
    VIDEO_COMP_ENA_576p     = 0x00000008, //!<  component is enabled at 576p video resolution
    VIDEO_COMP_ENA_720p     = 0x00000010, //!<  component is enabled at 720p video resolution
    VIDEO_COMP_ENA_1080i    = 0x00000020, //!<  component is enabled at 1080i video resolution
    VIDEO_COMP_ENA_1080p    = 0x00000040, //!<  component is enabled at 1080p video resolution
} NVAPI_VIDEO_COMPONENT_ENABLE;


//! \ingroup vidcontrol
//! Packet that facilitates retrieving information about a video component \n
//! Used in NvAPI_GetVideoState().
typedef struct _NVAPI_GET_VIDEO_STATE_COMPONENT
{
    NvU32   version;                    //!<  (IN)  NVAPI version that matches NVAPI_GET_VIDEO_STATE_COMPONENT_VER
    NvU32   componentID;                //!<  (IN)  identify the individual component, one of NVAPI_VIDEO_STATE_COMPONENT_xxx enums
    NvU32   bIsSupported        : 1;    //!<  (OUT) set if this component feature is supported
    NvU32   bIsOverridenByUser  : 1;    //!<  (OUT) set if component is overriden by user's choice
    NvU32   reserved1           : 30;   //!<  (OUT) reserved for future expansion
    NvU32   isEnabled;                  //!<  (OUT) set if component is enabled, one or more of NVAPI_VIDEO_COMPONENT_ENABLE bitmasks
    NvU32   minValue;                   //!<  (OUT) min valid value
    NvU32   maxValue;                   //!<  (OUT) max valid value
    NvU32   totalSteps;                 //!<  (OUT) number of steps between min and max
    NvU32   defaultValue;               //!<  (OUT) pre-defined NVIDIA default
    NvU32   unityValue;                 //!<  (OUT) unity is the disable value for a component
    NvU32   currentValueActive;         //!<  (OUT) value in use
    NvU64   defaultAlgo;                //!<  (OUT) default algo, one or more of #NVAPI_VIDEO_COMPONENT_ALGORITHM enums
    NvU64   currentAlgoActive;          //!<  (OUT) Algorithm in use, one or more of #NVAPI_VIDEO_COMPONENT_ALGORITHM enums
    union
    {
        NvU64 qwReserved[9];            
        struct
        {
            NvU32   dwAppKey;           //!< (IN) Secret key to authenticate the caller, used ONLY in NvAPI_SetVideoState()
            NvU32   bTopPriority   : 1; //!< (OUT)Indicates that these settings have precedence over D3D NvAPI settings;  valid ONLY in NvAPI_GetVideoState()
            NvU32   bHasCustomAlgo : 1; //!< (OUT)Indicates whether Out-of-process application has custom algorithm data
            NvU32   bReserved      : 30;//!< (OUT)Reserved for expansion   
            struct
            {
                NvU64   pData;          //!< (IN) Buffer to hold the retrieved custom algorithm data
                NvU32   dwSize;         //!< (IN) Size in Bytes of the above buffer, must be <= NVAPI_VIDEO_STATE_MAX_CUSTOM_ALGO_SIZE.
            } customAlgo;
        } appInfo; 
    }; 
} NVAPI_GET_VIDEO_STATE_COMPONENT;

//! \ingroup vidcontrol
//! Used in NVAPI_GET_VIDEO_STATE_COMPONENT.
#define NVAPI_GET_VIDEO_STATE_COMPONENT_VER  MAKE_NVAPI_VERSION(NVAPI_GET_VIDEO_STATE_COMPONENT,1)

//! \ingroup vidcontrol
//! Return status after attempting to set a video component
//! Used in NVAPI_SET_VIDEO_STATE_COMPONENT.
typedef enum _NVAPI_VIDEO_COMP_RETURN_STATUS
{
    VIDEO_COMP_STATUS_SUCCESS                   = 0x00000000, //!< Video component is set successfully
    VIDEO_COMP_STATUS_UNSUCCESSFUL              = 0x00000001, //!< Failed to set video component
    VIDEO_COMP_STATUS_COMPONENT_NOT_SUPPORTED   = 0x00000002, //!< Video component is not supported
    VIDEO_COMP_STATUS_VALUE_OUT_OF_RANGE        = 0x00000004, //!< Video component's value is invalid and does not fall into range
    VIDEO_COMP_STATUS_ALGO_NOT_RECOGNIZED       = 0x00000008, //!< Video component's algorithm is invalid 
    VIDEO_COMP_STATUS_OVERRIDDEN_BY_USER        = 0x00000010, //!< Request not completed because of user-mandated override
    VIDEO_COMP_STATUS_Y_GAMMA_ENABLED           = 0x00000020, //!< Cannot set RGB-gamma because Y-Gamma is already enabled
    VIDEO_COMP_STATUS_RGB_GAMMA_ENABLED         = 0x00000040, //!< Cannot set Y-gamma because RGB-Gamma is already enabled
} NVAPI_VIDEO_COMP_RETURN_STATUS;

// Packet containing information to allow setting the video component

#define NVAPI_VIDEO_STATE_MAX_CUSTOM_ALGO_SIZE 128

//! \ingroup vidcontrol
//! Used in NvAPI_SetVideoState().
typedef struct _NVAPI_SET_VIDEO_STATE_COMPONENT
{
    NvU32   version;                        //!< (IN) NVAPI version that matches NVAPI_SET_VIDEO_STATE_COMPONENT_VER
    NvU32   componentID;                    //!< (IN) identify the individual component, one of NVAPI_VIDEO_STATE_COMPONENT_xxx enums
    NvU32   enable;                         //!< (IN) flag to enable setting of component, one or more of NVAPI_VIDEO_COMPONENT_ENABLE bitmasks
    NvU32   setToValue;                     //!< (IN) value to use
    NvU64   setToAlgo;                      //!< (IN) algorithm to use
    NvU32   retStatus;                      //!< (OUT) result of video-component-set operation; a combination of VIDEO_COMP_STATUS_xxx bitmasks 
    NvU32   reserved;

    union
    {
        NvU64 qwReserved[4];
        struct
        {
            NvU32   dwAppKey;               //!< (IN) Secret key to authenticate the caller, ONLY used in NvAPI_SetVideoState
            NvU32   bTopPriority       : 1; //!< (IN) Force these settings to have priority over D3D NvAPI settings, ONLY valid in NvAPI_GetVideoState
            NvU32   bHasCustomAlgo     : 1; //!< (IN) Out-of-process application has custom algorithm data
            NvU32   bReserved          : 30;//!< (IN) reserved for expansion
            struct
            {
                NvU64   pData;              //!< (IN) (Used only when bHasCustomAlgo == 1) Pointer to the custom algorithm data.
                NvU32   dwSize;             //!< (IN) (Used only when bHasCustomAlgo == 1) Size in Bytes of the custom algorithm data, must be <= NVAPI_VIDEO_STATE_MAX_CUSTOM_ALGO_SIZE.
            } customAlgo;
        } appInfo; 
    }; 
} NVAPI_SET_VIDEO_STATE_COMPONENT;


//! \ingroup vidcontrol
//! Used in NVAPI_SET_VIDEO_STATE_COMPONENT.
#define NVAPI_SET_VIDEO_STATE_COMPONENT_VER  MAKE_NVAPI_VERSION(NVAPI_SET_VIDEO_STATE_COMPONENT,1)

#endif // ifndef NV_VIDEO_COMPONENTS_DEFINE



//!
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetVideoState(NvDisplayHandle hNvDisplay, NVAPI_GET_VIDEO_STATE_COMPONENT *pGetVidStateComp);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SetVideoState
//
//! DESCRIPTION:    This API that allows callers to set a particular video state component. It is the responsibility
//!                  of the caller to fill the secret application key that enables authentication of the caller.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//!
//! \param [in]     hNvDisplay(IN)     NVIDIA Display selection \n
//!                                    It can be #NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//! \param [in]     pSetVidStateComp   NVAPI_SET_VIDEO_STATE_COMPONENT packet containing 
//!                                    a valid component ID and a valid application secret key.                                  
//! \retval ::NVAPI_OK  
//! \retval ::NVAPI_ERROR
//! \retval ::NVAPI_INVALID_ARGUMENT
//!
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetVideoState(NvDisplayHandle hNvDisplay, NVAPI_SET_VIDEO_STATE_COMPONENT *pSetVidStateComp);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SetFrameRateNotify
//
//! \fn NvAPI_SetFrameRateNotify(NvDisplayHandle hNvDisplay, NVAPI_FRAME_RATE_NOTIFY_INFO* pFRNotifyInfo)
//! DESCRIPTION:     This API signals the driver to turn on/off notification to
//!                  the service application of the video frame rate. 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 175
//!
//!  \param [in]    hNvDisplay     NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated 
//!                                from NvAPI_EnumNVidiaDisplayHandle().
//!  \param [in]    pFRNotifyInfo  Pointer to the supplied NVAPI_FRAME_RATE_NOTIFY_INFO struct.
//!
//!  \retval ::NVAPI_OK 
//!  \retval ::NVAPI_ERROR 
//!  \retval ::NVAPI_INVALID_ARGUMENT
//!
//!  \ingroup vidcontrol
//
///////////////////////////////////////////////////////////////////////////////    


//! \ingroup vidcontrol
//! Structure containing the video frame rate notification instructions - used in NvAPI_SetFrameRateNotify()
typedef struct _NVAPI_FRAME_RATE_NOTIFY_INFO
{
    NvU32   version;                //!< (IN) Version of this struct constructed from the macro #NVAPI_FRAME_RATE_NOTIFY_INFO_VER
    NvU64   hWnd;                   //!< (IN) The window handle of the service application handling the RR adjust
    NvU32   bEnable         : 1;    //!< (IN) To turn feature ON/OFF
    NvU32   bReserved       : 31;   //!< (IN/OUT) Reserved for later use
} NVAPI_FRAME_RATE_NOTIFY_INFO;


//! \ingroup vidcontrol
//! Macro for constructing the version field of  NVAPI_FRAME_RATE_NOTIFY_INFO
#define NVAPI_FRAME_RATE_NOTIFY_INFO_VER  MAKE_NVAPI_VERSION(NVAPI_FRAME_RATE_NOTIFY_INFO,1)


//! \ingroup vidcontrol
NVAPI_INTERFACE NvAPI_SetFrameRateNotify(NvDisplayHandle hNvDisplay, NVAPI_FRAME_RATE_NOTIFY_INFO* pFRNotifyInfo);







///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SetPVExtName
//
//! DESCRIPTION:     This API specifies the name of the PureVideo extension DLL
//!                  to be used when custom algorithms are
//!                  enabled via NvAPI_SetVideoState() calls.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//! 
//! \since Release: 185
//!
//! \param [in]    hNvDisplay   NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated
//!                             from NvAPI_EnumNVidiaDisplayHandle().
//! \param [in]    szDllName    Name of the DLL to be used for custom algorithms
//!
//! \retval ::NVAPI_OK 
//! \retval ::NVAPI_ERROR 
//! \retval ::NVAPI_INVALID_ARGUMENT 
//!
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetPVExtName(NvDisplayHandle hNvDisplay, const char *szDllName);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetPVExtName
//
//! DESCRIPTION:     This API retrieves the name of the PureVideo extension DLL
//!                  to be used when custom algorithms are
//!                  enabled via NvAPI_SetVideoState() calls.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//! 
//! \since Release: 190
//!
//! \param [in]      hNvDisplay  NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated
//!                              from NvAPI_EnumNVidiaDisplayHandle().
//! \param [in]      szDllName   Name of the DLL that's currently registered with the driver
//!
//! \retval ::NVAPI_OK 
//! \retval ::NVAPI_ERROR 
//! \retval ::NVAPI_INVALID_ARGUMENT 
//!
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetPVExtName(NvDisplayHandle hNvDisplay, NvAPI_String szDllName);

//! SUPPORTED OS:  Windows XP and higher
//!
///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SetPVExtProfile
//
//! DESCRIPTION:     This API specifies the profile number that the PureVideo 
//!                  extension DLL should use.
//!
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//! 
//! \since Release: 190
//!
//! \param [in]     hNvDisplay  NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE
//!                             or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//! \param [in]     dwProfile   The profile number 
//!
//! \retval ::NVAPI_OK                completed request
//! \retval ::NVAPI_ERROR             miscellaneous error occurred
//! \retval ::NVAPI_INVALID_ARGUMENT  Invalid input parameter
//!
//! \ingroup vidcontrol 
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SetPVExtProfile(NvDisplayHandle hNvDisplay, NvU32 dwProfile);

//! SUPPORTED OS:  Windows XP and higher
//!

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetPVExtProfile
//
//! DESCRIPTION:     This API retrieves the profile number that the PureVideo 
//!                  extension DLL is set to use.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//! 
//! \since Release: 190
//!
//! \param [in]     hNvDisplay    NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE
//!                               or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle()
//! \param [out]    pProfile      The returned profile number
//!
//! \retval ::NVAPI_OK                completed request
//! \retval ::NVAPI_ERROR             miscellaneous error occurred
//! \retval ::NVAPI_INVALID_ARGUMENT  Invalid input parameter
//!
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetPVExtProfile(NvDisplayHandle hNvDisplay, NvU32* pProfile);



#ifndef NV_STEREO_VIDEO_FORMAT_DEFINE
#define NV_STEREO_VIDEO_FORMAT_DEFINE


//! \ingroup vidcontrol
typedef enum _NV_STEREO_VIDEO_FORMAT
{
    NV_STEREO_VIDEO_FORMAT_NOT_STEREO         = 0,

    NV_STEREO_VIDEO_FORMAT_SIDE_BY_SIDE_LR    = 1,
    NV_STEREO_VIDEO_FORMAT_SIDE_BY_SIDE_RL    = 2,
    NV_STEREO_VIDEO_FORMAT_TOP_BOTTOM_LR      = 3,
    NV_STEREO_VIDEO_FORMAT_TOP_BOTTOM_RL      = 4,
    NV_STEREO_VIDEO_FORMAT_ROW_INTERLEAVE_LR  = 5,
    NV_STEREO_VIDEO_FORMAT_ROW_INTERLEAVE_RL  = 6,
    NV_STEREO_VIDEO_FORMAT_TWO_FRAMES_LR      = 7,
    NV_STEREO_VIDEO_FORMAT_MONO_PLUS_OFFSET   = 8,

    NV_STEREO_VIDEO_FORMAT_LAST               = 9,
} NV_STEREO_VIDEO_FORMAT;

#endif // NV_STEREO_VIDEO_FORMAT_DEFINE

//! \ingroup vidcontrol
typedef struct _NV_VIDEO_STEREO_INFO {
    NvU32                     dwVersion;         //!< Must be NV_VIDEO_STEREO_INFO_VER
    NV_STEREO_VIDEO_FORMAT    eFormat;           //!< Stereo format of the surface (please note that format NV_STEREO_VIDEO_FORMAT_TWO_FRAMES_LR is invalid for this NvAPI)
    NvS32                     sViewOffset;       //!< Signed offset of each view (positive offset indicating left view is shifted left)
    NvU32                     bStereoEnable : 1; //!< Whether stereo rendering should be enabled (if FALSE, only left view will be used)
} NV_VIDEO_STEREO_INFO;

//! \ingroup vidcontrol
//! Macro for constructing the version field of ::_NV_VIDEO_STEREO_INFO
#define NV_VIDEO_STEREO_INFO_VER  MAKE_NVAPI_VERSION(NV_VIDEO_STEREO_INFO, 1)



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION_NAME:   NvAPI_VideoSetStereoInfo
//
//!   DESCRIPTION:   This API specifies the stereo format of the video source.
//! 
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]      hNvDisplay   NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE
//!                               or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//! \param [in]      pStereoInfo  The stereo format.
//!
//! \retval ::NVAPI_OK                completed request
//! \retval ::NVAPI_ERROR             miscellaneous error occurred
//! \retval ::NVAPI_INVALID_ARGUMENT  Invalid input parameter
//!
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_VideoSetStereoInfo(NvDisplayHandle hNvDisplay, NV_VIDEO_STEREO_INFO* pStereoInfo);




//! SUPPORTED OS:  Windows XP and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION_NAME:   NvAPI_VideoGetStereoInfo
//
//!   DESCRIPTION:   This API retrieves the stereo format of the video source (as set by 
//!                  NvAPI_VideoSetStereoInfo()). 
//!
//! \param [in]     hNvDisplay        NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE
//!                                   or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//! \param [in,out] pStereoInfo       The stereo format returned
//!
//! \retval ::NVAPI_OK                 completed request
//! \retval ::NVAPI_ERROR              miscellaneous error occurred
//! \retval ::NVAPI_INVALID_ARGUMENT   Invalid input parameter
//!
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_VideoGetStereoInfo(NvDisplayHandle hNvDisplay, NV_VIDEO_STEREO_INFO* pStereoInfo);




///////////////////////////////////////////////////////////////////////////////
// Structs and enums related to Video Ctrl
///////////////////////////////////////////////////////////////////////////////

//! \addtogroup vidcontrol
//! @{

//! Used in NvAPI_VideoCtrl(). 
typedef enum _NVAPI_VIDEO_CTRL_REQUEST
{
    NVAPI_VCTL_REQ_NONE                     = 0x00000000,
    NVAPI_VCTL_REQ_DI_BOB                   = 0x00000001, //!< Use bob
    NVAPI_VCTL_REQ_DI_MEDIAN                = 0x00000002, //!< Use fweave (do not use on NV4x GPUs)
    NVAPI_VCTL_REQ_DI_WEAVE                 = 0x00000004, //!< Use weave
    NVAPI_VCTL_REQ_DI_ADAPTIVE              = 0x00000008, //!< Use adaptive (do not use on NV1x GPUs; note - this is default for most NV3x GPUs and all NV4x GPUs.)
    NVAPI_VCTL_REQ_DI_EDGE_FULL             = 0x00000010, //!< Use full edge with adaptive (NV4x GPUs only)
    NVAPI_VCTL_REQ_DI_EDGE_SIMPLE           = 0x00000020, //!< Use simple edge with adaptive (NV4x GPUs only)
    NVAPI_VCTL_REQ_GAMMA_DISABLE            = 0x00000040, //!< Disable gamma
    NVAPI_VCTL_REQ_709EXT_ENABLE            = 0x00000080, //!< Enable 709 ext shader
    NVAPI_VCTL_REQ_709EXT_DISABLE           = 0x00000100, //!< Disable 709 ext shader
    NVAPI_VCTL_REQ_601EXT_DISABLE           = 0x00000200, //!< Disable 601 ext
    NVAPI_VCTL_REQ_OVERDRIVE_DISABLE        = 0x00000400, //!< Disable overdrive
    NVAPI_VCTL_REQ_COLORTEMP_DISABLE        = 0x00000800, //!< Disable color temp adjustment
    NVAPI_VCTL_REQ_INV32_DISABLE            = 0x00001000, //!< Disable inv32
    NVAPI_VCTL_REQ_VP_DISABLE               = 0x00002000, //!< Disable vp
    NVAPI_VCTL_REQ_DI_GRADIENT_FULL         = 0x00004000, //!< Use full gradient with adaptive (NV4x only)
    NVAPI_VCTL_REQ_DI_GRADIENT_SIMPLE       = 0x00008000, //!< Use simple gradient with adaptive (NV4x only)
    NVAPI_VCTL_REQ_INV22_DISABLE            = 0x00010000, //!< Disable inv22
    NVAPI_VCTL_REQ_DI_SIMPLE_ADAPTIVE       = 0x00020000, //!< Use simple adaptive
    NVAPI_VCTL_REQ_NO_PROCESSING            = 0x00040000, //!< No vid quality processing
    NVAPI_VCTL_REQ_DI_ONLY                  = 0x00080000, //!< No vid quality processing other than DI
    NVAPI_VCTL_REQ_NR_ONLY                  = 0x00100000, //!< No vid quality processing other than NR
    NVAPI_VCTL_REQ_EE_ONLY                  = 0x00200000, //!< No vid quality processing other than EE
    NVAPI_VCTL_REQ_CADENCE_ONLY             = 0x00400000, //!< No vid quality processing other than CADENCE
    NVAPI_VCTL_REQ_XFER_XTRA_SAME           = 0x00800000, //!< On video blit to csc, first transfer to the same format
    NVAPI_VCTL_REQ_XFER_XTRA_NV12           = 0x01000000, //!< On video blit to csc, first transfer to NV12
    NVAPI_VCTL_REQ_XFER_XTRA_YUY2           = 0x02000000, //!< On video blit to csc, first transfer to YUV2
    NVAPI_VCTL_REQ_XFER_XTRA_SCALE          = 0x04000000, //!< On video blit to csc, first transfer to scaled to 1.5 OR specified width/height
    NVAPI_VCTL_REQ_DI_ADVANCED              = 0x08000000, //!< Advanced Deinterlace
    NVAPI_VCTL_REQ_DI_DIR_SPATIAL           = 0x10000000, //!< Advanced Dir Spatial enable/disable spatial dir interp
    NVAPI_VCTL_REQ_DI_CADENCE               = 0x20000000, //!< Advanced Cadence enable disable
    NVAPI_VCTL_REQ_DI_VOF                   = 0x40000000, //!< VOF enable/disable
    NVAPI_VCTL_REQ_XFER_XTRA_ARGB           = 0x80000000, //!< On video blit to csc, first transfer to ArgB
} NVAPI_VIDEO_CTRL_REQUEST;



//! Used in NvAPI_VideoCtrl().
typedef enum _NVAPI_VIDEO_CTRL_REQUEST2
{
    NVAPI_VCTL2_REQ_10BITOVERLAY_ENABLE        = 0x00000001, //!< Enable 10 bit overlay
    NVAPI_VCTL2_REQ_VP2_SCALING_ENABLE         = 0x00000002, //!< Enable vp2 scaling
    NVAPI_VCTL2_REQ_VP2_SCALING_DISABLE        = 0x00000004, //!< Disable vp2 scaling
    NVAPI_VCTL2_REQ_CAPTURE_UNIQUE_FRAME       = 0x00000008, //!< Disable vp2 scaling
} NVAPI_VIDEO_CTRL_REQUEST2;



//! Video caps  
typedef enum _NVAPI_VIDEO_CTRL_CAPS_FLAG
{
    NVAPI_VIDEO_CTRL_CAPS_NONE                     = 0x00000000,
    NVAPI_VIDEO_CTRL_CAPS_MEDIAN_DI                = 0x00000001, //!< Supports median
    NVAPI_VIDEO_CTRL_CAPS_SPAD_DI                  = 0x00000002, //!< Supports spad
    NVAPI_VIDEO_CTRL_CAPS_ADV_DI                   = 0x00000004, //!< Supports adv and edge
    NVAPI_VIDEO_CTRL_CAPS_GAMMA                    = 0x00000008, //!< Supports gamma
    NVAPI_VIDEO_CTRL_CAPS_709EXT                   = 0x00000010, //!< Supports 709ext
    NVAPI_VIDEO_CTRL_CAPS_OVERDRIVE                = 0x00000020, //!< Supports overdrive
    NVAPI_VIDEO_CTRL_CAPS_COLORTEMP                = 0x00000040, //!< Supports colortemp
    NVAPI_VIDEO_CTRL_CAPS_INVAPI32                 = 0x00000080, //!< Supports iNVAPI32
    NVAPI_VIDEO_CTRL_CAPS_VP                       = 0x00000100, //!< Supports VP
    NVAPI_VIDEO_CTRL_CAPS_INVAPI22                 = 0x00000200, //!< Supports iNVAPI22
    NVAPI_VIDEO_CTRL_CAPS_XFER_XTRA                = 0x00000400, //!< Supports xfer xtra requests
    NVAPI_VIDEO_CTRL_CAPS_NVAPI24                  = 0x00000800, //!< Supports NVAPI24
} NVAPI_VIDEO_CTRL_CAPS_FLAG;





//! IDs related to video control - used in #NVAPI_VIDEO_CTRL
typedef enum _NVAPI_VIDEO_CTRL_ID
{
    NVAPI_VIDEO_CTRL_ID_NONE     = -1,   //!< Placeholder for invalid control ID
    NVAPI_VIDEO_CTRL_ID_REQ1         ,   //!< Veracity requests
    NVAPI_VIDEO_CTRL_ID_REQ2         ,   //!< Veracity requests
    NVAPI_VIDEO_CTRL_ID_CAPTURE      ,   //!< For veracity video capture information
    NVAPI_VIDEO_CTRL_ID_PERF         ,   //!< For veracity performance test
    NVAPI_VIDEO_CTRL_ID_LAST         ,   //!< All valid controls defined before this one
} NVAPI_VIDEO_CTRL_ID;



//! Get/set/reset video control flags - used in #NVAPI_VIDEO_CTRL
typedef enum _NVAPI_VIDEO_CTRL_FLAG
{
    NVAPI_VIDEO_CTRL_FLAG_SET            = 1, //!< 1 : Set Ctrl
    NVAPI_VIDEO_CTRL_FLAG_GET               , //!< 2 : Get Ctrl
    NVAPI_VIDEO_CTRL_FLAG_RESET             , //!< 3 : Reset Ctrl
} NVAPI_VIDEO_CTRL_FLAG;



//! Used in NVAPI_VIDEO_CTRL_V2
typedef enum _NVAPI_VIDEO_CAPTURE_FLAG
{
    NVAPI_VIDEO_CAPTURE_STOP             = 0x00000001,
    NVAPI_VIDEO_CAPTURE_SOURCE_ALSO      = 0x00000002,
    NVAPI_VIDEO_CAPTURE_ALLFRAMES        = 0x00000004,
    NVAPI_VIDEO_CAPTURE_NEWBUFFER        = 0x00000008,
} NVAPI_VIDEO_CAPTURE_FLAG;



//! Used in NVAPI_VIDEO_CTRL_V2
typedef enum _NVAPI_VIDEO_CAPTURE_POINT
{
    NVAPI_VIDEO_CAPTURE_POINT_NONE                     = 0,
    NVAPI_VIDEO_CAPTURE_POINT_OVERLAY_FLIP             = 1,
    NVAPI_VIDEO_CAPTURE_POINT_VIDEO_BLIT               = 2,
    NVAPI_VIDEO_CAPTURE_POINT_DELETED_RENDER_MPEG      = 3, 
    NVAPI_VIDEO_CAPTURE_POINT_DELETED_RENDER_WMV9      = 4,
    NVAPI_VIDEO_CAPTURE_POINT_PROCAMP_OUTPUT           = 5,
    NVAPI_VIDEO_CAPTURE_POINT_DI_OUTPUT                = 6,
    NVAPI_VIDEO_CAPTURE_POINT_DELETED_SUBPIC_OUTPUT    = 7,
    NVAPI_VIDEO_CAPTURE_POINT_CSC_OUTPUT               = 8,
    NVAPI_VIDEO_CAPTURE_POINT_DELETED_INV32_OUTPUT     = 9,
    NVAPI_VIDEO_CAPTURE_POINT_UNLOCK                   = 10,
    NVAPI_VIDEO_CAPTURE_POINT_DELETED_00               = 11,
    NVAPI_VIDEO_CAPTURE_POINT_MOCOMP_END_FRAME         = 12,
    NVAPI_VIDEO_CAPTURE_POINT_DELETED_MOCOMP_H264      = 13,
    NVAPI_VIDEO_CAPTURE_POINT_MIRROR                   = 14,
    NVAPI_VIDEO_CAPTURE_POINT_BLIT32_DST               = 15,
    NVAPI_VIDEO_CAPTURE_POINT_FE_SP_BLEND              = 16,
    NVAPI_VIDEO_CAPTURE_POINT_BE_SP_BLEND              = 17,
    NVAPI_VIDEO_CAPTURE_POINT_VP_OUTPUT                = 18,
    NVAPI_VIDEO_CAPTURE_POINT_DELETED_MOCOMP_VC1       = 19,
    NVAPI_VIDEO_CAPTURE_POINT_YUV_OUT                  = 20,
    NVAPI_VIDEO_CAPTURE_POINT_NR_OUTPUT                = 21,
    NVAPI_VIDEO_CAPTURE_POINT_ADI_OUTPUT               = 22,
    NVAPI_VIDEO_CAPTURE_POINT_MSDEC_OUTPUT             = 23,
} NVAPI_VIDEO_CAPTURE_POINT;





//! Packet that facilitates retrieving information about a video control - used in NvAPI_VideoCtrl() 
typedef struct _NVAPI_VIDEO_CTRL_V1
{
    NvU32   version;                    //!< (IN) NVAPI version that matches NVAPI_VIDEO_CTRL_VER
    NvU32   ctrlID;                     //!< (IN) Identify the individual ctrl, one of #NVAPI_VIDEO_CTRL_ID enums
    NvU32   ctrlFlag;                   //!< (IN) Set/Get/Reset #NVAPI_VIDEO_CTRL_FLAG enums
    NvU32   retStatus;                  //!< (OUT) Return Status, see #NVAPI_VIDEO_CTRL_RETURN_STATUS
    union                               //!< (IN/OUT) Parameters
    {
        NvU32   parm[8];     
        NvU32   diagCtrlReq1;
        NvU32   diagCtrlReq2;
    } u;
    NvU64   reserved3[10];              //!< (OUT) reserved for future expansion
} NVAPI_VIDEO_CTRL_V1;



//! Used in NvAPI_VideoCtrl()
typedef struct _NVAPI_VIDEO_CTRL_V2
{
    NvU32   version;                    //!< (IN) NVAPI version that matches NVAPI_VIDEO_CTRL_VER
    NvU32   ctrlID;                     //!< (IN) Identify the individual control; one of #NVAPI_VIDEO_CTRL_ID enums
    NvU32   ctrlFlag;                   //!< (IN) Set/Get/Reset #NVAPI_VIDEO_CTRL_FLAG enums
    NvU32   retStatus;                  //!< (OUT) Return Status, see #NVAPI_VIDEO_CTRL_RETURN_STATUS
    NvU32   bResetDiagCtrlInfo : 1;     //!< Reset driverdata variables based on it
    NvU32   bReserved : 31;             //!< Reserved for future expansion
    union                               //!< (IN/OUT) parameters
    {
        NvU32   parm[8];
        struct
        {
            NvU32   diagCtrlReq1;
            NvU32   diagCtrlReq2;
        } diagCtrlRequest;
        struct
        {
            NvU32 captureBufferAdd;         //!< (IN/OUT) Address of the veracity capture buffer
            NvU32 captureFlags;             //!<          See #NVAPI_VIDEO_CAPTURE_FLAG  
            NvU32 captureBufferSize;        //!< (IN/OUT) Size of the buffer
            NvU32 capturePoint;             //!< (IN/OUT) Where frame capture takes place, see #NVAPI_VIDEO_CAPTURE_POINT
            NvU32 captureFrameIndex;        //!< (IN/OUT) Number of the frame to capture
            NvU32 captureFrameRange : 16;   //!< (IN/OUT) The range of frames to capture
            NvU32 reserved2 : 16;           //!< Reserved for future expansion
        } captureInfo;
        struct
        {
            NvU32 startFrameIdx;            //!< (IN)  Frame index for starting the perf test 
            NvU32 endFrameIdx;              //!< (IN)  Frame index for ending the perf test 
            NvU32 bEnablePerf : 1;          //!< (IN)  Perf test is enabled 
            NvU32 reserved2 : 31;           //!< Reserved for future expansion
        } perftestInfo;
    } u;

    struct
    {
        NvU32            dwVideoControlDiagInfoBits;
        NvU32            dwVideoControlDiagInfo2Bits;
        NvU32            dwVideoControlDiagCapsBits;
    } diagVideoControlInfo;             //!< (IN/OUT) Storage for pDriverdata->nvVideoControlDiagInfo
    struct
    {
        NvU32            dwTargetWidth;
        NvU32            dwTargetHeight;
    } diagVideoControlParm;             //!< (IN/OUT) Storage for pDriverdata->nvVideoControlDiagParm
    NvU64   reserved3[7];               //!< (OUT) Reserved for future expansion
} NVAPI_VIDEO_CTRL_V2;




//! For backward compatibility  
typedef NVAPI_VIDEO_CTRL_V2 NVAPI_VIDEO_CTRL;


//! Macro for constructing the version field of NVAPI_VIDEO_CTRL_V1
#define NVAPI_VIDEO_CTRL_VER1  MAKE_NVAPI_VERSION(NVAPI_VIDEO_CTRL_V1,1)

//! Macro for constructing the version field of NVAPI_VIDEO_CTRL_V2
#define NVAPI_VIDEO_CTRL_VER2  MAKE_NVAPI_VERSION(NVAPI_VIDEO_CTRL_V2,2)

//! For backward compatibility  
#define NVAPI_VIDEO_CTRL_VER   NVAPI_VIDEO_CTRL_VER2



//!< Return status after attempting to set a video control 
typedef enum _NVAPI_VIDEO_CTRL_RETURN_STATUS
{
    NVAPI_VIDEO_CTRL_STATUS_SUCCESS                        = 0x00000000, //!< Video control is set successfully.
    NVAPI_VIDEO_CTRL_STATUS_UNSUCCESSFUL                   = 0x00000001, // 
    NVAPI_VIDEO_CTRL_STATUS_CTRL_NOT_SUPPORTED             = 0x00000002, //!< Invalid Ctrl
    NVAPI_VIDEO_CTRL_STATUS_CTRL_FLAG_INVALID              = 0x00000003, //!< Invalid Flag.
    NVAPI_VIDEO_CTRL_STATUS_CTRL_FIELD_NOT_SUPPORTED       = 0x00000004, //!< Unsupported Field in Ctrl
    NVAPI_VIDEO_CTRL_STATUS_CAPTURE_PENDING                = 0x00000005, //!< Capture not completed 
} NVAPI_VIDEO_CTRL_RETURN_STATUS;

//! @}

 
///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_VideoCtrl
//
//! DESCRIPTION:    This function allows callers to tweak a particular video control.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 173
//!
//! \param [in]    hNvDisplay        NVIDIA Display selection. It can be #NVAPI_DEFAULT_HANDLE or a handle enumerated
//!                                  from NvAPI_EnumNVidiaDisplayHandle().
//! \param [in]    pVideoCtrl        NVAPI_VIDEO_CTRL packet containing a valid ctrl ID (NVAPI_VIDEO_CTRL_ID) and flag 
//!                                  (NVAPI_VIDEO_CTRL_FLAG) for GET/RESET/SET video control information. 
//!
//!  \retval       NVAPI_OK                 Completed request
//!  \retval       NVAPI_ERROR              Miscellaneous error occurred
//!  \retval       NVAPI_INVALID_ARGUMENT   Invalid input parameter
//!
//!  \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_VideoCtrl(NvDisplayHandle hNvDisplay, NVAPI_VIDEO_CTRL *pVideoCtrl);





//! \ingroup vidcontrol
//! @{

// enums and structs related to video control points
#define NVAPI_MAX_CONTROL_POINT_DATA_SIZE_IN_BYTES  0x100
#define NVAPI_MAX_CONTROL_POINTS_PER_PACKET  20

typedef enum _NVAPI_VIDEO_CONTROL_RETURN_STATUS
{
    NVAPI_VIDEO_CONTROL_STATUS_SUCCESS = 0,
    NVAPI_VIDEO_CONTROL_STATUS_UNSUCCESSFUL,
    NVAPI_VIDEO_CONTROL_STATUS_COMPONENT_NOT_SUPPORTED,
    NVAPI_VIDEO_CONTROL_STATUS_VALUE_OUT_OF_RANGE,
    NVAPI_VIDEO_CONTROL_STATUS_DATA_TYPE_MISMATCH,
    NVAPI_VIDEO_CONTROL_STATUS_FLAG_INVALID,
    NVAPI_VIDEO_CONTROL_STATUS_UNREGISTERED,
    NVAPI_VIDEO_CONTROL_STATUS_INVALID_ARGUMENT,
    NVAPI_VIDEO_CONTROL_STATUS_INVALID_ID,
    NVAPI_VIDEO_CONTROL_STATUS_INVALID_DATA_SIZE,
    NVAPI_VIDEO_CONTROL_STATUS_DISABLED,
} NVAPI_VIDEO_CONTROL_RETURN_STATUS;

//! video control points, update the nvVidCtrlPointNames[] array in nvdisp.cpp as well when adding a new ID.
typedef enum _NVAPI_VIDEO_CONTROL_POINT_ID
{
    NVAPI_CPID_FIRST = -1,

    NVAPI_CPID_NoiseReductionStrength,
    NVAPI_CPID_EdgeEnhancementStrength,
    NVAPI_CPID_BrightnessValue,
    NVAPI_CPID_ContrastValue,
    NVAPI_CPID_HueValue,
    NVAPI_CPID_SaturationValue,
    NVAPI_CPID_GammaValueR,
    NVAPI_CPID_GammaValueG,
    NVAPI_CPID_GammaValueB,
    NVAPI_CPID_DeInterlacingAlgo,
    NVAPI_CPID_CadenceDetectionAlgo,
    NVAPI_CPID_SubPictureBlendingMode,
    NVAPI_CPID_ColorSpace,
    NVAPI_CPID_ColorRange,
    NVAPI_CPID_DynamicContrastEnhancement,
    NVAPI_CPID_Scaling,
    NVAPI_CPID_GamutRemap,
    NVAPI_CPID_SkinToneCorrection,
    NVAPI_CPID_DurationTrackingActive,
    
    // append here 

    NVAPI_CPID_LAST, // must be last
} NVAPI_VIDEO_CONTROL_POINT_ID;

//! update the nvVidCtrlPointDataTypes[] array in nvdisp.cpp as well when adding a new Datatype.
typedef enum _NVAPI_VIDEO_CONTROL_POINT_DATATYPE
{
    NVAPI_CPDT_UNKNOWN = 0,
    NVAPI_CPDT_Integer,
    NVAPI_CPDT_Float,
    NVAPI_CPDT_String,
    NVAPI_CPDT_Binary,
    NVAPI_CPDT_LAST,
} NVAPI_VIDEO_CONTROL_POINT_DATATYPE;

//! update the nvVidCtrlPointGranularity[] array in nvdisp.cpp as well when adding a new Granularity type.
typedef enum _NVAPI_CONTROL_POINT_GRANULARITY
{
    NVAPI_CPG_UNKNOWN = 0,
    NVAPI_CPG_InitTime,
    NVAPI_CPG_PerFrame,
} NVAPI_CONTROL_POINT_GRANULARITY;

typedef enum _NVAPI_VIDEO_CONTROL_GET_FLAG
{
    NVAPI_CP_FLAG_GET_UNKNOWN = 0,
    NVAPI_CP_FLAG_GET_COUNT,
    NVAPI_CP_FLAG_GET_DETAILS,
} NVAPI_VIDEO_CONTROL_GET_FLAG;

typedef enum _NVAPI_VIDEO_CONTROL_COMPONENT_ALGORITHM
{
    // Color space formats
    NV_VCTRL_ColorSpaceBase            = 0x1000,
    NV_VCTRL_ColorSpace601             = (NV_VCTRL_ColorSpaceBase) + 0x01,  //!< ITU-R BT.601
    NV_VCTRL_ColorSpace709             = (NV_VCTRL_ColorSpaceBase) + 0x02,  //!< ITU-R BT.709
    NV_VCTRL_ColorSpaceLast            = (NV_VCTRL_ColorSpaceBase) + 0x03,

    // Color range formats
    NV_VCTRL_ColorRangeBase            = 0x1100,
    NV_VCTRL_ColorRangeStd             = (NV_VCTRL_ColorRangeBase) + 0x01,  //!< color range of (0-255)
    NV_VCTRL_ColorRangeExt             = (NV_VCTRL_ColorRangeBase) + 0x02,  //!< color range of (16-235)
    NV_VCTRL_ColorRangeLast            = (NV_VCTRL_ColorRangeBase) + 0x03,

    // Deinterlacing Algos 
    NV_VCTRL_DIBase                    = 0x2000,
    NV_VCTRL_DIBob                     = (NV_VCTRL_DIBase) + 0x01,  //!< Perform Bob deinterlacing
    NV_VCTRL_DIMedian                  = (NV_VCTRL_DIBase) + 0x02,  //!< Use median filter 
    NV_VCTRL_DI3x3                     = (NV_VCTRL_DIBase) + 0x03,  //!< Perform a 3x3 adaptive deinterlacing
    NV_VCTRL_DIAdaptiveFourField       = (NV_VCTRL_DIBase) + 0x04,  //!< Perform four field motion adaptive deinterlacing
    NV_VCTRL_DIDirectionalSpatial      = (NV_VCTRL_DIBase) + 0x05,  //!< Use directional spatial deinterlacing for SD
    NV_VCTRL_DIOnePass                 = (NV_VCTRL_DIBase) + 0x06,  //!< Use One Pass deinterlacing
    NV_VCTRL_DISony                    = (NV_VCTRL_DIBase) + 0x07,  //!< Use Sony deinterlacing Algo
    NV_VCTRL_DILast                    = (NV_VCTRL_DIBase) + 0x08,

    // Cadence detection Algos 
    NV_VCTRL_CadenceBase               = 0x3000,
    NV_VCTRL_CadenceBasic              = (NV_VCTRL_CadenceBase) + 0x01,  //!< Basic cadence detection Algo
    NV_VCTRL_CadenceVideoOnFilm        = (NV_VCTRL_CadenceBase) + 0x02,  //!< Use video on film cadence detection
    NV_VCTRL_CadenceAdv                = (NV_VCTRL_CadenceBase) + 0x03,  //!< Advanced cadence detection Algo
    NV_VCTRL_CadenceLast               = (NV_VCTRL_CadenceBase) + 0x04,
    
    // Dynamic Contrast Color Enhancement Algos
    NV_VCTRL_DCCEBase                  = 0x4000,
    NV_VCTRL_DCCELow                   = (NV_VCTRL_DCCEBase) + 0x01,    //!< DCCE Low
    NV_VCTRL_DCCEMedium                = (NV_VCTRL_DCCEBase) + 0x02,    //!< DCCE Medium
    NV_VCTRL_DCCEHigh                  = (NV_VCTRL_DCCEBase) + 0x03,    //!< DCCE High
    NV_VCTRL_DCCELast                  = (NV_VCTRL_DCCEBase) + 0x04,
    
    // Scaling Algos
    NV_VCTRL_ScalingBase               = 0x5000,
    NV_VCTRL_ScalingSimple             = (NV_VCTRL_ScalingBase) + 0x01,  //!< Simple Shader Scaling
    NV_VCTRL_Scaling4x4Filter          = (NV_VCTRL_ScalingBase) + 0x02,  //!< Scaling by 4x4 filter
    NV_VCTRL_ScalingSony               = (NV_VCTRL_ScalingBase) + 0x03,  //!< Sony Scaling Algo          
    NV_VCTRL_ScalingLast               = (NV_VCTRL_ScalingBase) + 0x04,

    // Gamut Remap Algos
    NV_VCTRL_GamutRemapBase            = 0x6000,
    NV_VCTRL_GamutRemapSony            = (NV_VCTRL_GamutRemapBase) + 0x01, //!< Sony Gamut Remap Algo
    NV_VCTRL_GamutRemapLast            = (NV_VCTRL_GamutRemapBase) + 0x02,  

    // Skin-Tone Correction levels
    NV_VCTRL_SkinToneCorrectionBase    = 0x7000,
    NV_VCTRL_SkinToneCorrectionSqueeze = (NV_VCTRL_SkinToneCorrectionBase) + 0x01, //!< Turn the skin tone correction to a low setting
    NV_VCTRL_SkinToneCorrectionRed     = (NV_VCTRL_SkinToneCorrectionBase) + 0x02, //!< Turn the skin tone correction to a medium setting
    NV_VCTRL_SkinToneCorrectionYellow  = (NV_VCTRL_SkinToneCorrectionBase) + 0x03, //!< Turn the skin tone correction to a high setting 
    NV_VCTRL_SkinToneCorrectionLast    = (NV_VCTRL_SkinToneCorrectionBase) + 0x04,
     
} NVAPI_VIDEO_CONTROL_COMPONENT_ALGORITHM;

typedef struct _NVAPI_VIDEO_CONTROL_POINT_DESC
{
    NVAPI_VIDEO_CONTROL_POINT_ID        eID;
    NVAPI_VIDEO_CONTROL_POINT_DATATYPE  eType;
    NVAPI_CONTROL_POINT_GRANULARITY     eGranularity;
    NvU32                               dwDataSize;
    NvU32                               adwReserved[4];
} NVAPI_VIDEO_CONTROL_POINT_DESC;

typedef struct _NVAPI_VID_CTRL_POINT_DESC_STRINGS
{
    NVAPI_VIDEO_CONTROL_POINT_ID    eID;
    NvAPI_ShortString               szControlPoint; //!< ControlPoint name
    NvAPI_ShortString               szDataType;     //!< control point data type
    NvAPI_ShortString               szGranularity;  //!< control point Granularity
    NvAPI_ShortString               szReserved1;    //!< reserved for future expansion
} NVAPI_VID_CTRL_POINT_DESC_STRINGS;

typedef struct _NVAPI_VIDEO_CONTROL_POINT_DESC_PACKET
{
    NvU32                           version; //!< (IN) NVAPI version that matches NVAPI_VIDEO_CONTROL_POINT_DESC_PACKET_VER
    NvU32                           dwReturnStatus; //!< (OUT) one of the NVAPI_VIDEO_CONTROL_RETURN_STATUS
    NVAPI_VIDEO_CONTROL_GET_FLAG    eGetID; //!< (IN) get total CP count or CP details
    NVAPI_VIDEO_CONTROL_POINT_DESC  astCtrlPointDesc[NVAPI_MAX_CONTROL_POINTS_PER_PACKET]; //!< (OUT) details of supported control points
    NvU32                           dwCPCount; //!< (OUT) total count of enumerated control points
    NvU32                           dwStartCPCount; //!< (IN) starting CP count when reading the data
    NvU64                           aqwReserved[3]; //!< (IN/OUT) reserved for future expansion
} NVAPI_VIDEO_CONTROL_POINT_DESC_PACKET;

//! Macro for contructing the version field of ::_NVAPI_VIDEO_CONTROL_POINT_DESC_PACKET
#define NVAPI_VIDEO_CONTROL_POINT_DESC_PACKET_VER MAKE_NVAPI_VERSION(NVAPI_VIDEO_CONTROL_POINT_DESC_PACKET,1)

typedef enum _NVAPI_VID_CTRL_COMMAND
{
    NVAPI_VideoCtrlPoint_Set = 1,
    NVAPI_VideoCtrlPoint_Reset = 2,
    NVAPI_VideoCtrlPoint_ResetAll = 3,
} NVAPI_VID_CTRL_COMMAND;


typedef struct _NVAPI_VIDEO_CONTROL_POINT_DATA_PACKET
{
    NvU32                               version; //!< (IN) NVAPI version that matches NVAPI_VIDEO_CONTROL_POINT_DATA_PACKET_VER
    NvU32                               dwReturnStatus; //!< (OUT) one of the NVAPI_VIDEO_CONTROL_RETURN_STATUS
    NVAPI_VID_CTRL_COMMAND              eCommand;       //!< (IN) one of NVAPI_VideoCtrlPoint_XXX enums
    NVAPI_VIDEO_CONTROL_POINT_ID        eID;            //!< (IN) control point ID
    NVAPI_VIDEO_CONTROL_POINT_DATATYPE  eType;          //!< (IN) data type
    union                                               //!< anonymous union 
    {
        void*                           pData;          //!< (IN) pointer to control point data 
        NvU64                           qwDataPad;      //!< pad up to 64 bit on 32 bit systems
    };
    NvU32                               dwDataSize;     //!< (IN) control point data size 
    NvU32                               adwReserved[4]; //!< (IN/OUT) reserved for future expansion 
} NVAPI_VIDEO_CONTROL_POINT_DATA_PACKET;

//! Macro for contructing the version field of ::NVAPI_VIDEO_CONTROL_POINT_DATA_PACKET
#define NVAPI_VIDEO_CONTROL_POINT_DATA_PACKET_VER   MAKE_NVAPI_VERSION(NVAPI_VIDEO_CONTROL_POINT_DATA_PACKET,1)

typedef struct _NVAPI_VIDEO_CONTROL_POINT_DATA
{
    NVAPI_VID_CTRL_COMMAND              eCommand;
    NVAPI_VIDEO_CONTROL_POINT_ID        eID;
    NvU32                               dwReturnStatus;
    NVAPI_VIDEO_CONTROL_POINT_DATATYPE  eType;
    NvU32                               dwStartOffset;
    NvU8                                abyData[NVAPI_MAX_CONTROL_POINT_DATA_SIZE_IN_BYTES]; //!< control point data
    NvU32                               dwPacketDataSize; //!< size of current packet
    NvU32                               dwDataSize; //!< total size of control point data 
} NVAPI_VIDEO_CONTROL_POINT_DATA;

typedef struct _NVAPI_VIDEO_CONTROL_POINT_REGISTER
{
    NvU64   qwCPSupportedBitFlags; //!< to be passed to KMD/XP in order to set supported bit of control points
} NVAPI_VIDEO_CONTROL_POINT_REGISTER;

typedef enum _NVAPI_VIDEO_CONTROL_ID
{
    NVAPI_VID_CTRL_ENUM = 1,
    NVAPI_VID_CTRL_GET,
    NVAPI_VID_CTRL_SET,
    NVAPI_VID_CTRL_REGISTER,
    NVAPI_VID_CTRL_LAST, //!< must be last 
} NVAPI_VIDEO_CONTROL_ID;

//!! struct to be passed to KMD 
typedef struct _NVAPI_VIDEO_CONTROL
{
    NvU32       dwCtrlID; //!< (IN) identify the individual ctrl, one of NVAPI_VID_CTRL_XXX enums
    union
    {
        NVAPI_VIDEO_CONTROL_POINT_DESC_PACKET  stVidCtrlPointDesc; //!< (IN/OUT)
        NVAPI_VIDEO_CONTROL_POINT_DATA         stVidCtrlPointData; //!< (IN/OUT)
        NVAPI_VIDEO_CONTROL_POINT_REGISTER     stVidCtrlPointReg; //!< (IN/OUT)
    };
} NVAPI_VIDEO_CONTROL;

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_EnumerateVideoControlPoints
//
//! \code
//! DESCRIPTION:     API that enumerates all supported video control points to the caller 
//!                  caller will first call it with GET_COUNT flag. Then this API will be called repeatedly with 
//!                  GET_DETAILS flag until all the control points get enumerated.
//!
//! PARAMETERS:      hNvDisplay(IN)           - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle 
//!                                             enumerated from NvAPI_EnumNVidiaDisplayHandle().
//!                  pControlPointDesc(IN/OUT)- NVAPI_VIDEO_CONTROL_POINT_DESC_PACKET containing details of all 
//!                                             supported control points (NVAPI_VIDEO_CONTROL_POINT_DESC) and total count 
//!                  pCPDescNamesArray(OUT)   - Array of NVAPI_VID_CTRL_POINT_DESC_STRINGS structs of size NVAPI_MAX_CONTROL_POINTS_PER_PACKET.
//!                                              Strings will be filled if not NULL.
//! SUPPORTED OS:  Windows XP and higher
//!
//! RETURN STATUS: 
//!                  NVAPI_OK - completed request
//!                  NVAPI_ERROR - miscellaneous error occurred
//! \endcode
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_EnumerateVideoControlPoints(NvDisplayHandle hNvDisplay, 
                                                  NVAPI_VIDEO_CONTROL_POINT_DESC_PACKET* pControlPointDesc, 
                                                  NVAPI_VID_CTRL_POINT_DESC_STRINGS* pCPDescNamesArray);
///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_VideoControl
//
//! \code
//! DESCRIPTION:     API that allows the caller to set one video control point value and 
//!                  reset one/all control point value(s)
//!
//! PARAMETERS:      hNvDisplay(IN)        - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle 
//!                                          enumerated from NvAPI_EnumNVidiaDisplayHandle().
//!                  pControlPointData(IN) - NVAPI_VIDEO_CONTROL_POINT_DATA_PACKET containing a flag(eCommand) for 
//!                                          set one/ reset one/ reset all.
//!                                          For setting one CP other inputs are:
//!                                              a valid control point ID (NVAPI_VIDEO_CONTROL_POINT_ID),
//!                                              eType (NVAPI_VIDEO_CONTROL_POINT_DATATYPE), 
//!                                              data size and 
//!                                              data pointer 
//!                                          For resetting one CP other inputs are:
//!                                              a valid control point ID (NVAPI_VIDEO_CONTROL_POINT_ID).
//!                                          For resetting all CPs only the eCommand flag is required.
//! SUPPORTED OS:  Windows XP and higher
//!
//! RETURN STATUS: 
//!                  NVAPI_OK - completed request
//!                  NVAPI_ERROR - miscellaneous error occurred
//!                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//! \endcode
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_VideoControl(NvDisplayHandle hNvDisplay, NVAPI_VIDEO_CONTROL_POINT_DATA_PACKET* pControlPointData);

//! @}







//! \ingroup vidcontrol
//! @{

// enums and structs related to video data providers 

#define NVAPI_MAX_DATA_PROVIDER_DETAILS    10
#define NVAPI_MAX_CAPTURE_IMAGES           8
#define NVAPI_MAX_CAPTURE_EXTRA_INFO       8
#define NVAPI_MAX_PULL_MODEL_DP_DATA_SIZE_IN_BYTES  476


#define NVAPI_MAX_APPLIED_ALGO_PER_STREAM_RUN  30      //!< This is thrice that of MAX_ALGO_PER_STREAM_RUN defined in driver as of now.
                                                       //!< We have kept extra space to accomodate any future changes.

#define NVAPI_VIDEO_MAX_STREAMS                     12 //!< This is twice that of MAX_STREAMS defined 
                                                       //!< in driver as of now.We have kept extra space to accomodate 
                                                       //!< any future changes.

#define NVAPI_VIDEO_NAME_MAX_LENGTH                260 //!< same as MAX_PATH defined in windows
#define NVAPI_MAX_FUNCTION_CALLS_TO_TRACK          100  //!< Taking duration of 100 call per function


typedef enum _NVAPI_VIDEO_DATA_PROVIDER_STATUS
{
    NVAPI_DP_STATUS_SUCCESS = 0,
    NVAPI_DP_STATUS_UNSUCCESSFUL,
    NVAPI_DP_STATUS_INVALID_ID,
    NVAPI_DP_STATUS_VALUE_OUT_OF_RANGE,
    NVAPI_DP_STATUS_INVALID_DATA_SIZE,
    NVAPI_DP_STATUS_FLAG_INVALID,
    NVAPI_DP_STATUS_NOT_INTIALIZED,
    NVAPI_DP_STATUS_INVALID_ARGUMENT,
    NVAPI_DP_STATUS_DISABLED,
    NVAPI_DP_STATUS_MAX_CLIENT_REACHED,
    NVAPI_DP_STATUS_CLIENT_NOT_PRESENT,
    NVAPI_DP_STATUS_MAX_DP_PER_CLIENT_REACHED,
} NVAPI_VIDEO_DATA_PROVIDER_STATUS;

//! update the nvVidDataProviderNames[] array in nvdisp.cpp as well when adding a new Data Provider ID.
typedef enum _NVAPI_VIDEO_DATA_PROVIDER_ID
{
    NVAPI_DPID_INVALID = -1,
    NVAPI_DPID_DECODEDFRAMECOUNT,
    NVAPI_DPID_VPPSURFACECOUNT,
    NVAPI_DPID_VP2CYCLES,
    NVAPI_DPID_IMAGEBUFFER,
    NVAPI_DPID_FIXEDBUGS,
    NVAPI_DPID_INVTCWEAVEMODE,

    NVAPI_DPID_IMAGEBUFFER_OVERLAY_INTERNAL,
    NVAPI_DPID_IMAGEBUFFER_OVERLAY_EXTERNAL,
    NVAPI_DPID_IMAGEBUFFER_SHADER_DCCE,
    NVAPI_DPID_IMAGEBUFFER_SHADER_GAMUT_REMAP,
    NVAPI_DPID_IMAGEBUFFER_SHADER_GAMMA,
    NVAPI_DPID_IMAGEBUFFER_SHADER_PROCAMP,
    NVAPI_DPID_IMAGEBUFFER_SHADER_CSC,
    NVAPI_DPID_IMAGEBUFFER_SHADER_EE,
    NVAPI_DPID_IMAGEBUFFER_SHADER_FE,
    NVAPI_DPID_IMAGEBUFFER_SHADER_FMTXFER,
    NVAPI_DPID_IMAGEBUFFER_SHADER_NR,
    NVAPI_DPID_IMAGEBUFFER_SHADER_BLEND,
    NVAPI_DPID_IMAGEBUFFER_SHADER_SCALE,
    NVAPI_DPID_IMAGEBUFFER_4x4_SCALE,
    NVAPI_DPID_IMAGEBUFFER_COMPOSITOR_D3D,
    NVAPI_DPID_IMAGEBUFFER_DECODE,
    NVAPI_DPID_IMAGEBUFFER_SHADER_DI,
    NVAPI_DPID_IMAGEBUFFER_SHADER_ROTATE,
    NVAPI_DPID_DXVA_APPLIED_ALGORITHMS,
    NVAPI_DPID_BLITTER_APPLIED_ALGORITHMS,
    NVAPI_DPID_CALL_DURATION,
    NVAPI_DPID_IMAGEBUFFER_COMPOSITOR_VIC,
    NVAPI_DPID_IMAGEBUFFER_DMA_TRANSFER,
    NVAPI_DPID_IMAGEBUFFER_PRESENT_STEREO_LEFT,
    NVAPI_DPID_IMAGEBUFFER_PRESENT_STEREO_RIGHT,
    NVAPI_DPID_IMAGEBUFFER_UPDATE_OVERLAY_LEFT,
    NVAPI_DPID_IMAGEBUFFER_UPDATE_OVERLAY_RIGHT,
    NVAPI_DPID_IMAGEBUFFER_FLIP_OVERLAY_LEFT,
    NVAPI_DPID_IMAGEBUFFER_FLIP_OVERLAY_RIGHT,
    NVAPI_DPID_IMAGEBUFFER_SHADOWPLAY_OSD,
    
    // append here 
    NVAPI_DPID_LAST, // must be the last
} NVAPI_VIDEO_DATA_PROVIDER_ID;

typedef enum _NVAPI_VIDEO_DATA_PROVIDER_CAPTURE_STATUS
{
    NVAPI_DP_STATUS_CAPTURE_OFF = 0,
    NVAPI_DP_STATUS_CAPTURE_GENERIC_ERROR,
    NVAPI_DP_STATUS_CAPTURE_PENDING,
    NVAPI_DP_STATUS_CAPTURE_PENDING_SRC,
    NVAPI_DP_STATUS_CAPTURE_COMPLETE,
    NVAPI_DP_STATUS_CAPTURE_BUFFER_TOO_SMALL,
} NVAPI_VIDEO_DATA_PROVIDER_CAPTURE_STATUS;

typedef struct _NVAPI_VIDEO_DATA_PROVIDER_DESC
{
    NVAPI_VIDEO_DATA_PROVIDER_ID    eID;
    NvU32                           dwPeriod;
    NvU32                           dwBufferSize;
    NvU32                           dwBufferCount;
    NvU32                           bIsPullModelDataProvider:  1; //!< 0: Push model , 1: Pull model 
    NvU32                           bReserved1              : 31;
    NvU64                           aqwReserved2[3];
} NVAPI_VIDEO_DATA_PROVIDER_DESC;

//! names to be returned to APP. used inside NVAPI
typedef struct _NVAPI_VID_DATA_PROVIDER_DESC_STRINGS
{
    NVAPI_VIDEO_DATA_PROVIDER_ID    eID;
    NvAPI_ShortString               szDataProviderName; //!< name of the Data Provider
    NvAPI_ShortString               szReserved1; //!< reserved for future expansion
    NvAPI_ShortString               szReserved2; //!< reserved for future expansion
} NVAPI_VID_DATA_PROVIDER_DESC_STRINGS;

typedef enum _NVAPI_VID_DATA_PROVIDER_GET_FLAG
{
    NVAPI_DP_GET_COUNT = 0,
    NVAPI_DP_GET_DETAILS,
    NVAPI_DP_GET_REGISTERED_COUNT,
} NVAPI_VID_DATA_PROVIDER_GET_FLAG;

typedef struct _NVAPI_VIDEO_DATA_PROVIDER_DESCRIPTOR
{
    NvU32                            version; //!< (IN) version that matches NVAPI_VIDEO_DATA_PROVIDER_DESCRIPTOR_VER
    NvU32                            dwStatus; //!< (OUT) one of the NVAPI_VIDEO_DATA_PROVIDER_RETURN_STATUS 
    NVAPI_VID_DATA_PROVIDER_GET_FLAG eGetID; //!< (IN) get total DP count or DP details
    NvU32                            dwStartDPCount; //!< (IN) starting DP count when reading the data
    NvU32                            dwDPCount; //!< (OUT) DP count returned
    NVAPI_VIDEO_DATA_PROVIDER_DESC   astDataProviderDetails[NVAPI_MAX_DATA_PROVIDER_DETAILS]; //!< (OUT) DP description
    NvU32                            adwReserved[5]; //!< (IN/OUT) reserved for future expansion
} NVAPI_VIDEO_DATA_PROVIDER_DESCRIPTOR;

//! Macro for constructing the version field of ::_NVAPI_VIDEO_DATA_PROVIDER_DESCRIPTOR
#define NVAPI_VIDEO_DATA_PROVIDER_DESCRIPTOR_VER MAKE_NVAPI_VERSION(NVAPI_VIDEO_DATA_PROVIDER_DESCRIPTOR,1)

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_EnumVideoDataProviders
//
//! \code
//! DESCRIPTION:     API that enumerates all available data providers to the caller.
//!                  Users are suggested to prefer Push model data providers to Pull model ones, as pull model Data 
//!                  Providers are more incursive.
//!
//! PARAMETERS:      hNvDisplay(IN)        - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle 
//!                                         enumerated from NvAPI_EnumNVidiaDisplayHandle().
//!                  pVideoDataProviderDesc(IN) - NVAPI_VIDEO_DATA_PROVIDER_DESCRIPTOR containing a valid get ID
//!                                          (NVAPI_VID_DATA_PROVIDER_GET_FLAG), 
//!                                          First client calls with NVAPI_DP_GET_COUNT flag.
//!                                          Then it calls repeatedly with NVAPI_DP_GET_DETAILS flag to get the 
//!                                          data provider description.
//!                                          Additionally, using the flag NVAPI_DP_GET_REGISTERED_COUNT returns
//!                                          the number of registered DPIDs across all clients in dwDPCount.
//!                  pDataProvDescNamesArray(OUT) - NVAPI_VID_DATA_PROVIDER_DESC_STRINGS array of size NVAPI_MAX_DATA_PROVIDER_DETAILS.
//!                                          The array is filled up if not NULL.
//! SUPPORTED OS:  Windows XP and higher
//!
//! RETURN STATUS: 
//!                  NVAPI_OK - completed request
//!                  NVAPI_ERROR - miscellaneous error occurred
//!                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//! \endcode
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_EnumVideoDataProviders(NvDisplayHandle hNvDisplay, 
                                             NVAPI_VIDEO_DATA_PROVIDER_DESCRIPTOR* pVideoDataProviderDesc, 
                                             NVAPI_VID_DATA_PROVIDER_DESC_STRINGS* pDataProvDescNamesArray);




//! struct used for registering / unregistering data providers.
typedef struct _NVAPI_VIDEO_DATA_PROVIDER_REGISTRATION_INFO
{
    NvU32                       version;            //!< (IN) version that matches NVAPI_VIDEO_DATA_PROVIDER_REGISTRATION_INFO_VER
    NvU32                       dwStatus;           //!< (OUT) one of the NV_VIDEO_DATA_PROVIDER_STATUS 
    NVAPI_VIDEO_DATA_PROVIDER_ID   eID;             //!< (IN) ID of the data provider 
    NvU32                       dwClientID;         //!< (IN) process ID of the client
    NvU32                       dwBufferCount;      //!, (IN) number of buffers in the buffer array
    NvU32                       dwBufferSize;       //!< (IN) size of the buffer 
    NvU64                       qwBufferArrayAdd;   //!< (IN) address of the client allocated buffer array 
    NvU32                       dwCapturePoint;     //!< (IN) capture point mask for current DP 
    NvU32                       dwNotifyPeriod;     //!< (IN) number of frames between two consecutive notifications
    NvU64                       qwEventHandle;      //!< (IN) event handle used for synchronization 
    NvU32                       dwFrameStart;       //!< (IN) frame number to start capture (first frame is 1!)
    NvU32                       dwFrameEnd;         //!< (IN) frame number to end capture
    NvU32                       bEmulationMode : 1; //!< (IN) flag to indicate if emulation mode dump is enabled.
    NvU32                       bReserved      :31; //!< (IN) reserved for future boolean flags.
    NvU32                       dwReserved;         //!< (IN/OUT) reserved for future expansion 
    NvU64                       aqwReserved[3];     //!< (IN/OUT) reserved for future expansion 
} NVAPI_VIDEO_DATA_PROVIDER_REGISTRATION_INFO;

//! Macro for constructing the version field of ::_NVAPI_VIDEO_DATA_PROVIDER_REGISTRATION_INFO
#define NVAPI_VIDEO_DATA_PROVIDER_REGISTRATION_INFO_VER MAKE_NVAPI_VERSION(NVAPI_VIDEO_DATA_PROVIDER_REGISTRATION_INFO,1)

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_RegisterVideoDataProvider
//
//! \code
//! DESCRIPTION:     API that allow caller to register a video data provider 
//!
//! PARAMETERS:      hNvDisplay(IN)        - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle 
//!                                          enumerated from NvAPI_EnumNVidiaDisplayHandle().
//!                  pDataProviderReg(IN)  - NVAPI_VIDEO_DATA_PROVIDER_REGISTRATION_INFO containing 
//!                                          a valid data provider ID (eID), 
//!                                          a client ID(dwClientID), 
//!                                          address of the Buffer Array(qwBufferArrayAdd), 
//!                                          buffer count in array(dwBufferCount), 
//!                                          buffer size(dwBufferSize), 
//!                                          capture points (dwCapturePoint), 
//!                                          an event handle used for synchronization(qwEventHandle).
//! SUPPORTED OS:  Windows XP and higher
//!
//! RETURN STATUS: 
//!                  NVAPI_OK - completed request
//!                  NVAPI_ERROR - miscellaneous error occurred
//!                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//! \endcode
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_RegisterVideoDataProvider(NvDisplayHandle hNvDisplay, 
                                                NVAPI_VIDEO_DATA_PROVIDER_REGISTRATION_INFO* pDataProviderReg);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_UnregisterVideoDataProvider
//
//! \code
//! DESCRIPTION:     API that allow caller to register a video data provider 
//!
//! PARAMETERS:      hNvDisplay(IN)        - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle 
//!                                          enumerated from NvAPI_EnumNVidiaDisplayHandle().
//!                  pDataProviderReg(IN)  - NVAPI_VIDEO_DATA_PROVIDER_REGISTRATION_INFO containing 
//!                                          a valid data provider ID (eID), 
//!                                          a client ID(dwClientID).
//! SUPPORTED OS:  Windows XP and higher
//!
//! RETURN STATUS: 
//!                  NVAPI_OK - completed request
//!                  NVAPI_ERROR - miscellaneous error occurred
//!                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//! \endcode
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_UnregisterVideoDataProvider(NvDisplayHandle hNvDisplay, 
                                                NVAPI_VIDEO_DATA_PROVIDER_REGISTRATION_INFO* pDataProviderReg);

//! Internal struct used to get values of pull model data providers
typedef struct _NVAPI_PULL_MODEL_DATA_PACKET
{
    NvU32                           dwStatus;
    NVAPI_VIDEO_DATA_PROVIDER_ID    eID;
    NvU32                           dwBufferCount;
    NvU32                           dwBufferSize;
    NvU32                           dwStartOffset;
    NvU8                            abyData[NVAPI_MAX_PULL_MODEL_DP_DATA_SIZE_IN_BYTES];
    NvU32                           dwClientID;
} NVAPI_PULL_MODEL_DATA_PACKET;

typedef struct _NVAPI_VIDEO_DATA_GET
{
    NvU32                           version;        //!< (IN) version that matches NVAPI_VIDEO_DATA_GET_VER
    NvU32                           dwStatus;       //!< (OUT) one of the NV_VIDEO_DATA_PROVIDER_STATUS 
    NVAPI_VIDEO_DATA_PROVIDER_ID    eID;            //!< (IN) Video Data Provider ID 
    NvU32                           dwClientID;     //!< (IN) process ID of the client 
    NvU32                           dwBufferSize;   //!< (IN) size (in bytes) of each data element in the array
    NvU32                           dwBufferCount;  //!< (IN) number of elements in the array 
    union                                           //!< anonymous union 
    {
        void*                       pBuffArray;     //!< (IN) base address of buffer array 
        NvU64                       pPad;           //!< ensure proper sizing on 64bit OS 
    };
    NvU32                           dwReserved[3];  //!< (IN/OUT) reserved for future expansion 
} NVAPI_VIDEO_DATA_GET;

//! Macro for constructing the version field of ::_NVAPI_VIDEO_DATA_GET
#define NVAPI_VIDEO_DATA_GET_VER MAKE_NVAPI_VERSION(NVAPI_VIDEO_DATA_GET,1)

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GetVideoData
//
//! \code
//! DESCRIPTION:     API that allow caller to retrieve video data for a pull model data provider. Total size of 
//!                  the data array is limited to NVAPI_MAX_PULL_MODEL_DP_DATA_SIZE_IN_BYTES.
//!                  The caller should use this method as infrequently as possible, preferably after completion of 
//!                  one playback session.
//!
//! PARAMETERS:      hNvDisplay(IN)   - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle 
//!                                     enumerated from NvAPI_EnumNVidiaDisplayHandle().
//!                  pVidDataGet(IN)  - NVAPI_VIDEO_DATA_GET containing 
//!                                      a valid data provider ID (eID), 
//!                                      a client ID(dwClientID),
//!                                      data size,
//!                                      data Pointer,
//!                                      buffer count.
//! SUPPORTED OS:  Windows XP and higher
//!
//! RETURN STATUS: 
//!                  NVAPI_OK - completed request
//!                  NVAPI_ERROR - miscellaneous error occurred
//!                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//! \endcode
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetVideoData(NvDisplayHandle hNvDisplay, NVAPI_VIDEO_DATA_GET* pVidDataGet);




//! structures used for user allocated capture buffer, to be used for DPID_ImageBuffer.
typedef struct _NVAPI_IMAGE_BUFFER
{
    NvU32   dwDataSize;         //<! size of segment in bytes
    NvU32   dwPixelType;        //!< FOURCC code, or 1,2,3,4 for n-byte RGB data
    NvU32   dwHeight;           //!< height in pels
    NvU32   dwWidth;            //!< width in pels
    NvU32   bytesPerPixel:  3;  //!< number of bytes per pixel : width*bytesPerPixel = image data on each line
    NvU32   bReserved1   : 29;  //!< reserved for future expansion
    NvU32   dwPitch;            //!< pitch in bytes
    NvU32   dwInfo1;            //!< general info relevant to this pixeltype
    NvU32   dwInfo2;            //!< more general info
    union                       //!< anonymous union
    {
        NvU8*   pImgData;       //!< Pointer to data for this buffer
        NvU64   qwPad;          //!< pad up to 64 bit on 32 bit systems 
    };
    NvU64   aqwReserved2[2];    //!< reserved for future expansion
} NVAPI_IMAGE_BUFFER;


//! description of algo enum, name and flags. 
typedef struct _NVAPI_ALGO_DETAILS
{
    NvU32           dwAlgoID;             //!< DWORD corresponding to enums NRLuma/NRChroma/DI3x3/DIdirspat etc.
    char            cAlgoName[NVAPI_VIDEO_NAME_MAX_LENGTH];
    NvU64           qwflags[NVAPI_VIDEO_MAX_STREAMS];
} NVAPI_ALGO_DETAILS;

typedef struct _NVAPI_VIDEO_APPLIED_ALGOS_PER_STREAM
{
    NvU32                 dwAppliedAlgoCount;
    NVAPI_ALGO_DETAILS    astAppliedAlgoList[NVAPI_MAX_APPLIED_ALGO_PER_STREAM_RUN];
} NVAPI_VIDEO_APPLIED_ALGOS_PER_STREAM;

typedef struct _NVAPI_VIDEO_APPLIED_ALGOS_PER_VID_PROC_INSTANCE
{
    NvU32                                  dwVidProcInstanceIndex;
    char                                   cVidProcInstanceName[NVAPI_VIDEO_NAME_MAX_LENGTH];
    NvU32                                  dwNumStreams;
    NVAPI_VIDEO_APPLIED_ALGOS_PER_STREAM   astAppliedAlgosPerStream[NVAPI_VIDEO_MAX_STREAMS];
} NVAPI_VIDEO_APPLIED_ALGOS_PER_VID_PROC_INSTANCE;

typedef struct _NVAPI_VIDEO_APPLIED_ALGOS_BUFFER
{
    NvU32                                               dwCaptureStatus;
    NVAPI_VIDEO_APPLIED_ALGOS_PER_VID_PROC_INSTANCE     stAppliedAlgosPerVidProcInstance;
} NVAPI_VIDEO_APPLIED_ALGOS_BUFFER;


typedef enum _NVAPI_FUNCTION_NAME
{
    NVAPI_DecodeExecute = 0,
    NVAPI_DecodeBeginFrame,
    NVAPI_DecodeEndFrame,
    NVAPI_VideoProcessBlt,
    NVAPI_ExtensionExecute,
    NVAPI_FlipOverlay,            //!< CUMOverlay::FlipOverlay
    NVAPI_FlipOverlayNvApi,       //!< CUMOverlay::FlipOverlayNvApi
    NVAPI_OverlayTransfer,        //!< CUMOverlay::OverlayTransfer
    NVAPI_nvRenderDeinterlace,    //!< ->XP
    NVAPI_PresentVideoShow,       //!< CVideoOverlay::PresentVideoShow -> XP
    NVAPI_LAST_FUNCTION,          //!< Total number of functions
}NVAPI_FUNCTION_NAME;

typedef struct _NVAPI_VIDEO_FUNCTION_CALL_INFO
{
    NVAPI_FUNCTION_NAME          eFunctionName;
    NvU32                        iCallNumber;
    NvU32                        bIsFunctionActive;
    NvU64                        iCallDuration[NVAPI_MAX_FUNCTION_CALLS_TO_TRACK];
} NVAPI_VIDEO_FUNCTION_CALL_INFO;


typedef struct _NVAPI_VIDEO_CALL_DURATION_BUFFER
{
    NvU32                                           dwCaptureStatus;
    NVAPI_VIDEO_FUNCTION_CALL_INFO                  stCallDurationInfo[NVAPI_LAST_FUNCTION];
} NVAPI_VIDEO_CALL_DURATION_BUFFER;



typedef struct _NVAPI_VIDEO_CAPTURE_BUFFER
{
    NvU32           dwCaptureStatus;        //!< NVAPI_VIDEO_DATA_PROVIDER_CAPTURE_STATUS
    NvU32           dwCapturePoint;         //!< At what point was this frame captured
    NvU32           dwCaptureFrameIndex;    //!< What frame number is to be captured
    NvU32           dwCaptureBufferSize;    //!< Size of the buffer (including this header)
    NvU32           dwCurrentFrameIndex;    //!< What the frame number is now
    NvU32           dwImageCount;           //!< Number of image buffers used
    NVAPI_IMAGE_BUFFER  astImage[NVAPI_MAX_CAPTURE_IMAGES];

    NvU32           bCaptureSource    :  1;  //!< additional segments store source fields/frames (for deinterlace capture)
    NvU32           bCaptureAllFrames :  1;  //!< set only if we're capturing all frames (or at least more than just one)
    NvU32           byDecodedFrameType:  8;  //!< field (0=Progressive/1=A/2=B/3=Unknown) corresponding to decoded frame
    NvU32           reserved1         : 22;  //!< reserved for future expansion

    NvU32           dwCaptureFrameRange;    //!< set the range of frames to capture (typically only used for
                                            //!, golden captures on emulation)
    NvU32           dwDecodedFrameCount;    //!< Frame count of decoded frame corresponding to this buffer
    NvU32           dwUsedBufferSpace;      //!< Size used in the buffer (including this header)
    NvU32           dwSrcCount;
    NvU32           adwExtraInfo[NVAPI_MAX_CAPTURE_EXTRA_INFO]; //!< Extra info about this capture (specific to capture type)
    NvU32           dwVersion;              //!< Version number for distinguishing between this and earlier form of NVAPI_VIDEO_CAPTURE_BUFFER
                                            //!< Version 2 has two additional members dwAppliedAlgoCount and astAppliedAlgoList
    NvU32           dwReserved2[2];         //!< reserved for future expansion
    NvU32           dwAppliedAlgoCount;
    NVAPI_ALGO_DETAILS astAppliedAlgoList[NVAPI_MAX_APPLIED_ALGO_PER_STREAM_RUN];

    // Image buffer data immediately follows this struct in memory. astImage[i].pImgData points into it

} NVAPI_VIDEO_CAPTURE_BUFFER;

//! Macro for constructing the version field of ::_NVAPI_VIDEO_CAPTURE_BUFFER
#define NVAPI_VIDEO_CAPTURE_BUFFER_VER MAKE_NVAPI_VERSION(NVAPI_VIDEO_CAPTURE_BUFFER,2)


typedef struct _NVAPI_VIDEO_INVTC_WEAVEMODE_BUFFER
{
    NvU32           dwCaptureStatus;        //!< NV_VIDEO_DATA_PROVIDER_CAPTURE_STATUS        
    NvU32           dwWeaveMode;            //!< dwWeaveMode stores the WeaveMode decision
    NvU32           dwReserved[2];          //!< reserved for future expansion    
}NVAPI_VIDEO_INVTC_WEAVEMODE_BUFFER;

//! video capture points used for image capture 
typedef enum _NVAPI_VIDEO_CAPTURE_POINTS
{
    NVAPI_VIDEO_CAPTURE_NONE           = 0x00000000,
    NVAPI_VIDEO_CAPTURE_DECODE         = 0x00000001,
    NVAPI_VIDEO_CAPTURE_OVERLAY        = 0x00000002,
    NVAPI_VIDEO_CAPTURE_BLIT           = 0x00000004,
    NVAPI_VIDEO_CAPTURE_VPBLIT         = 0x00000008,
    NVAPI_VIDEO_CAPTURE_UNLOCK         = 0x00000010,
    NVAPI_VIDEO_CAPTURE_FE             = 0x00000020,
    NVAPI_VIDEO_CAPTURE_EE             = 0x00000040,
    NVAPI_VIDEO_CAPTURE_NR             = 0x00000080,
    NVAPI_VIDEO_CAPTURE_DI             = 0x00000100,
    NVAPI_VIDEO_CAPTURE_INVTC          = 0x00000200,
    NVAPI_VIDEO_CAPTURE_PROCAMP_CSC    = 0x00000400,
    NVAPI_VIDEO_CAPTURE_GAMMA          = 0x00000800,
    NVAPI_VIDEO_CAPTURE_GAMUT_REMAP    = 0x00001000,
    NVAPI_VIDEO_CAPTURE_DCCE           = 0x00002000,
    NVAPI_VIDEO_CAPTURE_BLEND          = 0x00004000,
    NVAPI_VIDEO_CAPTURE_SCALE          = 0x00008000,
    NVAPI_VIDEO_CAPTURE_COMPOSITOR     = 0x00010000,
} NVAPI_VIDEO_CAPTURE_POINTS;

//! Internal functions and structs for Video Data Providers.
typedef enum _NVAPI_VID_DATA_PROVIDER_CTRL_ID
{
    NV_DATA_PROVIDER_ENUM = 1,
    NV_DATA_PROVIDER_REGISTER = 2,
    NV_DATA_PROVIDER_UNREGISTER = 3,
    NV_DATA_PROVIDER_PULL_MODEL_GET = 6,

    NV_DATA_PROVIDER_CTRL_LAST = 7,
} NVAPI_VID_DATA_PROVIDER_CTRL_ID;

//! internal common struct to be passed to KMD/XP
typedef struct _NVAPI_VID_DATA_PROVIDER_CTRL
{
    NvU32           dwCtrlID; //!< (IN) one of the NV_DATA_PROVIDER_xxx enums 
    union //!< anonymous union 
    {
        NvU64 qwParams[70]; // this is to ensure proper sizing with the driver 

        NVAPI_VIDEO_DATA_PROVIDER_DESCRIPTOR           stDataProviderDesc; //!< (IN/OUT)
        NVAPI_VIDEO_DATA_PROVIDER_REGISTRATION_INFO    stDataProviderReg; //!< (IN/OUT)
        NVAPI_PULL_MODEL_DATA_PACKET                   stPullModelData; //!< (IN/OUT)
    };
} NVAPI_VID_DATA_PROVIDER_CTRL;

//! @}






//! \addtogroup vidcontrol
//! @{


//! See NV_VIDEO_GET_SURFACE_INFO
#define MAX_VIDEO_SURFACE_COUNT 64


//! See NV_VIDEO_STATE_INFO
#define NV_MAX_VID_PP_INSTANCE 8

//! DX Version used by app - used in NV_VIDEO_DECODE_STREAM_INFO_V2
typedef enum _D3D_Version
{
    D3D_Version_9  = 9,
    D3D_Version_11 = 11,
} D3D_Version;
 
//! DirectX VA decode stream information - used in NV_VIDEO_DXVA_INFO
typedef struct _NV_VIDEO_DECODE_STREAM_INFO_V1
{
    NvU32   streamIndex;                    //!< (IN)  Selected stream
    NvU32   processID;                      //!< (OUT) Application process ID
    NvU32   streamSrcWidth;                 //!< (OUT) Width
    NvU32   streamSrcHeight;                //!< (OUT) Height
    NvU32   streamFormat;                   //!< (OUT) Stream encode format
}NV_VIDEO_DECODE_STREAM_INFO_V1;

//! DirectX VA decode stream information - used in NV_VIDEO_DXVA_INFO
typedef struct _NV_VIDEO_DECODE_STREAM_INFO_V2
{
    NvU32   streamIndex;                    //!< (IN)  Selected stream
    NvU32   processID;                      //!< (OUT) Application process ID
    NvU32   streamSrcWidth;                 //!< (OUT) Width
    NvU32   streamSrcHeight;                //!< (OUT) Height
    NvU32   streamFormat;                   //!< (OUT) Stream encode format
    D3D_Version dxVersion;                  //!< (OUT) DX Version used by App
}NV_VIDEO_DECODE_STREAM_INFO_V2;


typedef NV_VIDEO_DECODE_STREAM_INFO_V2 NV_VIDEO_DECODE_STREAM_INFO;

//!  DirectX VA information obtained by NvAPI_Video_GetDXVAInfo() 
typedef struct _NV_VIDEO_DXVA_INFO_V1
{
    NvU32   version;                        //!< (IN) Version constructed by the macro #NV_VIDEO_DXVA_INFO_VER
    NvU32   dxvaObjectCount;                //!<  No DirectX VA object created
    NV_VIDEO_DECODE_STREAM_INFO_V1 streamInfo[NV_MAX_VID_STREAMS];
} NV_VIDEO_DXVA_INFO_V1;

typedef struct _NV_VIDEO_DXVA_INFO_V2
{
    NvU32   version;                        //!< (IN) Version constructed by the macro #NV_VIDEO_DXVA_INFO_VER
    NvU32   dxvaObjectCount;                //!<  No DirectX VA object created
    NV_VIDEO_DECODE_STREAM_INFO streamInfo[NV_MAX_VID_STREAMS];
} NV_VIDEO_DXVA_INFO_V2;


//! Macro for constructing the version field of structure NV_VIDEO_DXVA_INFO
typedef NV_VIDEO_DXVA_INFO_V2 NV_VIDEO_DXVA_INFO; 
#define NV_VIDEO_DXVA_INFO_VER_1  MAKE_NVAPI_VERSION(NV_VIDEO_DXVA_INFO_V1,1)
#define NV_VIDEO_DXVA_INFO_VER_2  MAKE_NVAPI_VERSION(NV_VIDEO_DXVA_INFO_V2,2)
#define NV_VIDEO_DXVA_INFO_VER    NV_VIDEO_DXVA_INFO_VER_2
//! @}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Video_GetDXVAInfo
//
//! DESCRIPTION:     This API retrieves DirectX VA decode information for SWAK.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 175
//!
//! \param [in]   hNvDisplay    NVIDIA Display selection. It can be #NVAPI_DEFAULT_HANDLE or a handle enumerated 
//!                             from NvAPI_EnumNVidiaDisplayHandle().
//! \param [out]  pDxvaInfo     Structure for retrieving DirectX VA information
//!
//! \retval ::NVAPI_OK
//! \retval ::NVAPI_INVALID_ARGUMENT
//! \retval ::NVAPI_API_NOT_INTIALIZED
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION
//! \retval ::NVAPI_ERROR
//! 
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Video_GetDXVAInfo(NvDisplayHandle hNvDisplay, NV_VIDEO_DXVA_INFO *pDxvaInfo);


//! \addtogroup vidcontrol
//! @{


//! Video overlay information obtained by NvAPI_Video_GetOverlayInfo()
typedef struct
{
    NvU32   version;                        //!< (IN) Version constructed by macro #NV_VIDEO_OVERLAY_INFO_VER
    NvU8    overlayInUse;                   //!< (OUT) Boolean:Is overlay in use
    NvU32   overlaySurfaceCount;            //!< (OUT) Number of overlay surfaces created
} NV_VIDEO_OVERLAY_INFO_V1;

typedef enum _NVAPI_VIDEO_OVERLAY_FLAGS
{
    NVAPI_OVERLAY_FLAG_UNKNOWN = 0,
    NVAPI_OVERLAY_FLAG_D3DAPI,
    NVAPI_OVERLAY_FLAG_NVAPI,
} NVAPI_VIDEO_OVERLAY_FLAGS;

typedef struct
{
    NvU32                      version;                        //!< (IN) Version constructed by macro #NV_VIDEO_OVERLAY_INFO_VER
    NvU8                       overlayInUse;                   //!< (OUT) Boolean:Is overlay in use
    NvU32                      overlaySurfaceCount;            //!< (OUT) Number of overlay surfaces created
    NvU8                       overlaySurfaceBPP[NV_MAX_HEADS];//!< (OUT) BPP of surface (tells us whether RGB or YUY2)
    NVAPI_VIDEO_OVERLAY_FLAGS  overlayFlags[NV_MAX_HEADS];     //!< (OUT) Overlay API details (from NVAPI_VIDEO_OVERLAY_FLAGS)
    NV_RECT                    overlaySrcRect[NV_MAX_HEADS];   //!< (OUT) Input dimension
    NV_RECT                    overlayDestRect[NV_MAX_HEADS];  //!< (OUT) Output dimension (to be displayed)
} NV_VIDEO_OVERLAY_INFO_V2;

//! Macro for constructing the version field of NV_VIDEO_OVERLAY_INFO
typedef NV_VIDEO_OVERLAY_INFO_V2 NV_VIDEO_OVERLAY_INFO; 

#define NV_VIDEO_OVERLAY_INFO_VER_1  MAKE_NVAPI_VERSION(NV_VIDEO_OVERLAY_INFO_V1,1)
#define NV_VIDEO_OVERLAY_INFO_VER_2  MAKE_NVAPI_VERSION(NV_VIDEO_OVERLAY_INFO_V2,2)
#define NV_VIDEO_OVERLAY_INFO_VER    NV_VIDEO_OVERLAY_INFO_VER_2

//! @}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Video_GetOverlayInfo
//
//! DESCRIPTION:     This API retrieves video overlay information for SWAK
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 175
//!
//! \param [in]      hNvDisplay              NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated 
//!                                          from NvAPI_EnumNVidiaDisplayHandle().
//! \param [out]     pVideoOverlayInfo       Structure for retrieving video overlay information
//!
//! \retval ::NVAPI_OK
//! \retval ::NVAPI_INVALID_ARGUMENT
//! \retval ::NVAPI_API_NOT_INTIALIZED
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION
//! \retval ::NVAPI_ERROR
//! 
//! \ingroup vidcontrol 
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Video_GetOverlayInfo(NvDisplayHandle hNvDisplay, NV_VIDEO_OVERLAY_INFO *pVideoOverlayInfo);





//! \addtogroup vidcontrol
//! @{

//! Video surface width, height, format, and size information - used in _NV_VIDEO_GET_SURFACE_INFO 
typedef struct _NV_VIDEO_SURFACE_INFO
{
    NvU32   surfaceWidth;                 //!< (OUT) Surface width
    NvU32   surfaceHeight;                //!< (OUT) Surface height
    NvU32   surfaceFormat;                //!< (OUT) FOURCC format
    NvU32   surfaceSize;                  //!< (OUT) Surface size in KB
}NV_VIDEO_SURFACE_INFO;


//! Video surface count obtained by NvAPI_Video_GetVideoSurfaceCount()
typedef struct _NV_VIDEO_GET_SURFACE_COUNT
{
    NvU32   version;                      //!< (IN)  Version constructed by the macro #NV_VIDEO_GET_SURFACE_COUNT_VER
    NvU32   surfaceFormat;                //!< (IN)  FOURCC format
    NvU32   videoSurfaceCount;            //!< (OUT) Video surface count
} NV_VIDEO_GET_SURFACE_COUNT;


//! Macro for constructing the version field of NV_VIDEO_GET_SURFACE_COUNT
#define NV_VIDEO_GET_SURFACE_COUNT_VER  MAKE_NVAPI_VERSION(NV_VIDEO_GET_SURFACE_COUNT,1)

//! @}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Video_GetVideoSurfaceCount
//
//! DESCRIPTION:     This API gets the video surface count for a specific FOURCC format.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 175
//!
//! \param [in]      hNvDisplay          NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated 
//!                                      from NvAPI_EnumNVidiaDisplayHandle().
//! \param [out]     pVideoSurfaceCount  Structure for retrieving video surface count
//!
//! \retval ::NVAPI_OK
//! \retval ::NVAPI_INVALID_ARGUMENT
//! \retval ::NVAPI_API_NOT_INTIALIZED
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION
//! \retval ::NVAPI_ERROR
//!
//!  \ingroup vidcontrol 
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Video_GetVideoSurfaceCount(NvDisplayHandle hNvDisplay, NV_VIDEO_GET_SURFACE_COUNT *pVideoSurfaceCount);





//! \addtogroup vidcontrol
//! @{

//! Video surface information - obtained by NvAPI_Video_GetVideoSurfaceInfo()
typedef struct  _NV_VIDEO_GET_SURFACE_INFO
{
    NvU32   version;                                            //!< (IN) Structure version constructed by macro #NV_VIDEO_GET_SURFACE_INFO_VER
    NvU32   surfaceFormat;                                      //!< (IN) FOURCC format
    NvU32   startSurfCount;                                     //!< (IN) starting surface count
    NvU32   videoSurfaceCount;                                  //!< (OUT) videoSurfaceCount
    NV_VIDEO_SURFACE_INFO  surfaceInfo[MAX_VIDEO_SURFACE_COUNT];//!< (OUT) video Surface information
} NV_VIDEO_GET_SURFACE_INFO;


//! Macro for constructing the version field of structure NV_VIDEO_GET_SURFACE_INFO
#define NV_VIDEO_GET_SURFACE_INFO_VER  MAKE_NVAPI_VERSION(NV_VIDEO_GET_SURFACE_INFO,1)

//! @}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Video_GetVideoSurfaceInfo
//
//! DESCRIPTION:     This API gets detailed video surface information for a given FOURCC format
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 175
//!
//! \param [in]     hNvDisplay          NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated 
//!                                     from NvAPI_EnumNVidiaDisplayHandle().
//! \param [out]    pVideoSurfaceInfo   Structure for retrieving detailed information for video surfaces of given FOURCC
//!
//! \retval ::NVAPI_OK
//! \retval ::NVAPI_INVALID_ARGUMENT
//! \retval ::NVAPI_API_NOT_INTIALIZED
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION
//! \retval ::NVAPI_ERROR
//!
//! \ingroup vidcontrol
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Video_GetVideoSurfaceInfo(NvDisplayHandle hNvDisplay, NV_VIDEO_GET_SURFACE_INFO *pVideoSurfaceInfo);






//! \addtogroup vidcontrol
//! @{

//! Video stream state - used in _NV_VIDEO_STATE_INFO
typedef struct _NV_VIDEO_STREAM_STATE_V1
{
    NvU32   streamIndex;                                            //!< (OUT) Stream Index
    NvU32   surfaceWidth;                                           //!< (OUT) width
    NvU32   surfaceHeight;                                          //!< (OUT) height
    NvU8    gdiDisplayName[32];                                     //!< (OUT) gdiName corresponding to the video window
    NVAPI_GET_VIDEO_STATE_COMPONENT vidComponent[NVAPI_VIDEO_STATE_COMPONENT_ID_LAST];
    NvU32   bVICInUse;                                              //!< (OUT) flag to display whether VIC is in use
    NvU32   dwReserved[8];                                          //!< (OUT) reserved DWORDS for future use (helps prevent 
}NV_VIDEO_STREAM_STATE_V1;

typedef struct _NV_VIDEO_STREAM_STATE_V2
{
    NvU32   streamIndex;                                            //!< (OUT) Stream Index
    NvU32   surfaceWidth;                                           //!< (OUT) width
    NvU32   surfaceHeight;                                          //!< (OUT) height
    NvU8    gdiDisplayName[32];                                     //!< (OUT) gdiName corresponding to the video window
    NVAPI_GET_VIDEO_STATE_COMPONENT vidComponent[NVAPI_VIDEO_STATE_COMPONENT_ID_LAST];
    NvU32   bVICInUse;                                              //!< (OUT) flag to display whether VIC is in use
    NvU32   dwReserved[8];                                          //!< (OUT) reserved DWORDS for future use (helps prevent 
    D3D_Version   dxVersion;                                        //!< (OUT) DxVersion used by App.
}NV_VIDEO_STREAM_STATE_V2;


typedef NV_VIDEO_STREAM_STATE_V2 NV_VIDEO_STREAM_STATE;


//! Video stream surface information - obtained by NvAPI_Video_GetVideoStateInfo() 
typedef struct
{
    NvU32                   version;                            //!< (IN) Version info constructed by macro #NV_VIDEO_STATE_INFO_VER
    NvU32                   streamCount;                        //!< (OUT) number of DirectX VA video processing devices created
    NV_VIDEO_STREAM_STATE_V1   streamInfo[NV_MAX_VID_PP_INSTANCE];
}NV_VIDEO_STATE_INFO_V1;

typedef struct
{
    NvU32                   version;                            //!< (IN) Version info constructed by macro #NV_VIDEO_STATE_INFO_VER
    NvU32                   streamCount;                        //!< (OUT) number of DirectX VA video processing devices created
    NV_VIDEO_STREAM_STATE   streamInfo[NV_MAX_VID_PP_INSTANCE];
 }NV_VIDEO_STATE_INFO_V2;


//! Macro for constructing the version field of NV_VIDEO_STATE_INFO

typedef NV_VIDEO_STATE_INFO_V2     NV_VIDEO_STATE_INFO; 
#define NV_VIDEO_STATE_INFO_VER_1  MAKE_NVAPI_VERSION(NV_VIDEO_STATE_INFO_V1,1)
#define NV_VIDEO_STATE_INFO_VER_2  MAKE_NVAPI_VERSION(NV_VIDEO_STATE_INFO_V2,2)
#define NV_VIDEO_STATE_INFO_VER    NV_VIDEO_STATE_INFO_VER_2

//! @}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Video_GetVideoStateInfo
//
//! DESCRIPTION:     This API retrieves state information for different video streams
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 175
//!
//! \param [in]    hNvDisplay(IN)    NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated 
//!                                  from NvAPI_EnumNVidiaDisplayHandle().
//! \param [out]   pVideoStateInfo   Structure of state information for different video streams 
//!
//! \retval ::NVAPI_OK
//! \retval ::NVAPI_INVALID_ARGUMENT
//! \retval ::NVAPI_API_NOT_INTIALIZED
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION
//! \retval ::NVAPI_ERROR
//!
//!  \ingroup vidcontrol 
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Video_GetVideoStateInfo(NvDisplayHandle hNvDisplay, NV_VIDEO_STATE_INFO *pVideoStateInfo);



//! \addtogroup vidcontrol
//! @{


//! See _NV_VIDEO_GET_INFO
typedef enum _NV_VIDEO_QUERY_ID
{
    NV_VIDEO_GET_DXVA_INFO,
    NV_VIDEO_GET_OVERLAY_INFO,
    NV_VIDEO_GET_VIDEO_SURFACE_COUNT,
    NV_VIDEO_GET_SURFACE_DETAIL,
    NV_VIDEO_GET_STATE_INFO,
    NV_VIDEO_GET_COMMAND_LAST
} NV_VIDEO_QUERY_ID;



typedef struct _NV_VIDEO_GET_INFO
{
    NvU32               version;            //! (IN) Version constructed by macro #NV_VIDEO_GET_INFO_VER
    NV_VIDEO_QUERY_ID   queryID;            //! (IN) Query type
    union
    {
        NV_VIDEO_DXVA_INFO          getDxvaInfo;
        NV_VIDEO_OVERLAY_INFO       getOverlayInfo;
        NV_VIDEO_GET_SURFACE_COUNT  getVideoSurfaceCount;
        NV_VIDEO_GET_SURFACE_INFO   getVideoSurfaceInfo;
        NV_VIDEO_STATE_INFO         getVideoStateInfo;
    };
} NV_VIDEO_GET_INFO;


//! Macro for constructing the version field of NV_VIDEO_GET_INFO
#define NV_VIDEO_GET_INFO_VER  MAKE_NVAPI_VERSION(NV_VIDEO_GET_INFO,1)

//! @}






//! \ingroup vidcontrol
//! @{

typedef struct _NV_VIDEO_LOCATION_MAP
{
    NvU32 vidPnSrcId;
    NvU32 head;
    NvU32 displayId;
    NvU8  gdiDisplayName[32];
} NV_VIDEO_LOCATION_MAP;

typedef struct _NV_VIDEO_GET_VID_LOCATION_MAP
{
    NvU32   version;                        //!< (IN)version info
    NV_VIDEO_LOCATION_MAP vidLocMap;
} NV_VIDEO_GET_VID_LOCATION_MAP;

//! Macro for constructing theversion field of ::_NV_VIDEO_GET_VID_LOCATION_MAP
#define NV_VIDEO_GET_VID_LOCATION_MAP_VER  MAKE_NVAPI_VERSION(NV_VIDEO_GET_VID_LOCATION_MAP,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetVidLocMap
//
//! \code
//! PARAMETERS:    hNvDisplay(IN) - NVIDIA Display selection. It can be NVAPI_DEFAULT_HANDLE or a handle enumerated from NvAPI_EnumNVidiaDisplayHandle().
//!                pGetVidLocMap(OUT) - The VID_LOC_MAP associated with the selected display handle hNvDisplay.
//!
//!   DESCRIPTION: Returns the VideoLocationMap associated with a physical GPU handle.
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! RETURN STATUS: NVAPI_INVALID_ARGUMENT: nvGPUHandle is not valid; hNvDisp is NULL
//!                NVAPI_OK: one handle was returned
//! \endcode
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GetVidLocMap(NvDisplayHandle hNvDisplay, NV_VIDEO_GET_VID_LOCATION_MAP *pGetVidLocMap);



//! \ingroup vidcontrol
//! @{

//!<struct _NV_ENC_CONFIG_H264
//!<H264 encoder configuration parameters
 
typedef struct _NV_ENCODE_CODEC_H264
{
    NvU32                   profile;                                //!< Specifies the encoding profile
    NvU32                   level;                                  //!< Specifies the encoding level
    NvU32                   numSlices;                              //!< Specifies number of slices
    NvU32                   intraRefreshCnt;                        //!< Specifies the number of frames over which intra refresh will happen
    NvU32                   transform8x8Mode;                       //!< Specifies the adaptive transform 8x8 mode
    NvU32                   numRefFrames;                           //!< Specifies the DPB size used for encoding. Setting it to 0 will let driver use the default dpb size
    NvU32                   sliceMode;                              //!< This parameter in conjunction with sliceModeData specifies the way in which the picture is divided into slices
    NvU32                   sliceModeData;                          //!< Specifies the parameter needed for sliceMode
    NvU32                   bSVCTemporalFlag                    :1; //!< Set to 1 to enable SVC temporal
    NvU32                   bHierarchicalPFrames                :1; //!< Set to 1 to enable hierarchical PFrames
    NvU32                   bHierarchicalBFrames                :1; //!< Set to 1 to enable hierarchical BFrames
    NvU32                   bRepeatSPSPPS                       :1; //!< Set to 1 to enable writing of Sequence and Picture parameter for every IDR frame
    NvU32                   bSeparateColourPlaneFlag            :1; //!< Set to 1 to enable 4:4:4 separate colour planes
    NvU32                   bVleCabacEnable                     :1; //!< Specifies entropy coding mode: 0 - CAVLC, 1 - CABAC
    NvU32                   bDeblockingFilterControlPresentFlag :1; //!< Specifies whether deblocking is needed
    NvU32                   reserved1                           :25;
    NvU32                   reserved2[7];
} NV_ENCODE_CODEC_H264_V1;

typedef NV_ENCODE_CODEC_H264_V1 NV_ENCODE_CODEC_H264;

typedef union _NV_ENCODE_CODEC
{
    NV_ENCODE_CODEC_H264_V1 h264Config;                             //!< Specifies the H.264-specific encoder configuration
    NvU32                   reserved[32];
} NV_ENCODE_CODEC;

typedef struct _NV_ENCODE_INSTANCE_INFO
{
    NvU32                   processId;                              //!< Process ID
    NvU32                   instanceId;                             //!< Instance ID- Id of the encode instance(a single process may create multiple encode instances)
    NvU32                   codecType;                              //!< codecType
    NvU32                   idrPeriod;                              //!< Specifies the IDR interval. If not set, this is made equal to gopLength in NV_ENC_CONFIG.
    NvU32                   rateControlMode;                        //!< Specifies the rate control mode
    NvU32                   maxqp[3];                               //!< Specifies the maximum QP used for rate control
    NvU32                   minqp[3];                               //!< Specifies the minimum QP used for rate control
    NvU32                   vbvBufferSize;                          //!< Specifies the VBV(HRD) buffer size. in bits. Set 0 to use the default VBV  buffer size.
    NvU32                   vbvInitialDelay;                        //!< Specifies the VBV(HRD) initial delay in bits. Set 0 to use the default VBV  initial delay
    NvU32                   hrdBitRate;                             //!< Specifies the maximum bitrate for the encoded output. This is used for VBR and ignored for CBR mode.
    NvU32                   rcAvgBitRate;                           //!< Specifies the average bitrate(in bits/sec) used for encoding.
    NvU32                   frmFldMode;                             //!< Specifies the frame/field mode
    NvU32                   encodeWidth;                            //!< o/p width
    NvU32                   encodeHeight;                           //!< o/p height
    NvU32                   darWidth;                               //!< Specifies the display aspect ratio Width
    NvU32                   darHeight;                              //!< Specifies the display aspect ratio Height
    double                  frameRate;                              //!< Specifies the frame rate used for encoding in frames per second
    NvU32                   numBFrames;                             //!< Specifies the number of B frames
    NvU32                   gopILength;                             //!< Specifies the number of pictures in one GOP. Low latency application client can set goplength to NVENC_INFINITE_GOPLENGTH so that keyframes are not inserted automatically
    NvU32                   msencPreset;                            //!< Specifies the encoder preset
    NV_ENCODE_CODEC         encodeCodec;                            //!< [in]: Specifies the codec specific config parameters through this union
    union
    {
        struct _NV_ENCODE_INSTANCE_INFO *pNext;                     //!< The next pointer of the node of the linked list
        NvU64                            padding;                   //!< Pad up to 64 bits on 32-bit systems
    };
    NvU32                   bEnableExternalHints :1;                //!< Set to 1 to enable external ME hints for the current frame.
    NvU32                   path                 :1;                //!< Default: 0 - D3D, 1 - NVCUVID
    NvU32                   reserved1            :30;
    NvU32                   reserved2[4];
} NV_ENCODE_INSTANCE_INFO_V1;

typedef NV_ENCODE_INSTANCE_INFO_V1 NV_ENCODE_INSTANCE_INFO;

typedef struct _NV_ENCODE_INSTANCE
{
    NvU32                   version;                                //!< Specifies struct version
    NvU32                   instCount;                              //!< Specifies number of encode application instances
    union
    {
        NV_ENCODE_INSTANCE_INFO_V1 *pEncInfo;                       //!< First instance info block
        NvU64                       padding;                        //!< Pad up to 64 bits on 32-bit systems
    };
    NvU32                   bGetInstanceInfoFlag :1;                //!< Specifies query type: 0 - retrieve instance_count, 1 - retrieve instance info 
    NvU32                   reserved1            :31;
    NvU32                   reserved2[4];
} NV_ENCODE_INSTANCE_V1;

typedef NV_ENCODE_INSTANCE_V1       NV_ENCODE_INSTANCE;
#define NV_ENCODE_INSTANCE_VER1     MAKE_NVAPI_VERSION(NV_ENCODE_INSTANCE_V1,1)
#define NV_ENCODE_INSTANCE_VER      NV_ENCODE_INSTANCE_VER1


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Video_GetEncodeInfo
//
//! \code
//! DESCRIPTION:     This API is used to retrieve encode information for currently running encode instances
//!
//! SUPPORTED OS:  Windows Vista and higher,  Mac OS X
//!
//! \Since Release:322
//!
//! PARAMETERS:      pEncodeInfo(OUT)        - structure for retrieving encode information per instance
//! RETURN STATUS:   This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with
//!                  specific meaning for this API, they are listed below.
//!                  NVAPI_NVIDIA_DEVICE_NOT_FOUND - Display Handle is default
//! \endcode
//! \ingroup diagapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Video_GetEncodeInfo(__inout NV_ENCODE_INSTANCE *pEncodeInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Video_SetEncodeInfo
//
//! \code
//! DESCRIPTION:     This API is used to set encode information by currently running encode instances
//!
//! SUPPORTED OS:  Windows Vista and higher,  Mac OS X
//!
//!
//!
//! PARAMETERS:      pEncodeInfo(IN)        - structure carrying encode information per instance
//! RETURN STATUS:   This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with
//!                  specific meaning for this API, they are listed below.
//!                  NVAPI_NVIDIA_DEVICE_NOT_FOUND - Display Handle is default
//! \endcode
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Video_SetEncodeInfo(__in NV_ENCODE_INSTANCE *pEncodeInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Video_ReleaseEncodeInfo
//
//! \code
//! DESCRIPTION:     This API is used to release KMD surfaces after the encode instance finishes execution
//!
//! SUPPORTED OS:  Windows Vista and higher,  Mac OS X
//!
//!
//!
//! PARAMETERS:      processId(IN),instanceId(IN)        - providing instance-id,process-id of instance to be deleted
//! RETURN STATUS:   This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with
//!                  specific meaning for this API, they are listed below.
//!                  NVAPI_NVIDIA_DEVICE_NOT_FOUND - Display Handle is default
//! \endcode
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Video_ReleaseEncodeInfo(__in NvU32 processId, __in NvU32 instanceId);

//! @}
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Audio_EnumDeviceHandle
//
//! \code
//! PARAMETERS:    thisEnum (IN)              - index of audio device for which device handle is requested
//!                hDeviceObject (OUT)        - pointer to NvAudioHandle
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//! DESCRIPTION:   Enumerates Audio devices present in the system
//!                
//!
//! RETURN STATUS: 
//!                NVAPI_OK - completed request
//!                NVAPI_ERROR - miscellaneous error occurred
//!                NVAPI_INVALID_ARGUMENT - invalid input parameter
//!                NVAPI_MATCHING_DEVICE_NOT_FOUND - No Nvidia HDA device installed
//!                NVAPI_END_ENUMERATION - thisEnum is greater than the number of nvidia audio devices in system
//! \endcode
//! \ingroup audioapi
///////////////////////////////////////////////////////////////////////////////

NVAPI_INTERFACE NvAPI_Audio_EnumDeviceHandle(NvU32 thisEnum, NvAudioHandle* hDeviceObject);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Audio_GetDeviceParameters
//
//! \fn NvAPI_Audio_GetDeviceParameters(NvAudioHandle NvAudioHandle, NV_AUDIO_PARAMETERS *pNV_AUDIO_PARAMETERS)
//! \code
//! PARAMETERS:    NvAudioHandle (IN)............... - NvAudioHandle value
//!                pNV_AUDIO_PARAMETERS (OUT)        - pointer to NV_AUDIO_PARAMETERS structure
//!                                  
//! SUPPORTED OS:  Windows XP and higher
//!
//! DESCRIPTION:   Provides various Audio Device Property values
//!
//! RETURN STATUS: 
//!                NVAPI_OK - completed request
//!                NVAPI_ERROR - miscellaneous error occurred
//!                NVAPI_INVALID_ARGUMENT - invalid input parameter
//!                NVAPI_INVALID_HANDLE - invalid handle to device
//!                NVAPI_INCOMPATIBLE_STRUCT_VERSION - Incompatible struct version
//! \endcode
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup audioapi
//! @{

typedef enum _NV_AUDIO_CHANNEL
{
    NV_AUDIO_CHAN_0 =          (1 << 0),
    NV_AUDIO_CHAN_1 =          (1 << 1),
    NV_AUDIO_CHAN_2 =          (1 << 2),
    NV_AUDIO_CHAN_3 =          (1 << 3),
    NV_AUDIO_CHAN_4 =          (1 << 4),
    NV_AUDIO_CHAN_5 =          (1 << 5),
    NV_AUDIO_CHAN_6 =          (1 << 6),
    NV_AUDIO_CHAN_7 =          (1 << 7),
    NV_AUDIO_CHAN_8 =          (1 << 8),
    NV_AUDIO_CHAN_9 =          (1 << 9),
    NV_AUDIO_CHAN_10 =         (1 << 10)
}NV_AUDIO_CHANNEL;

typedef enum _NV_AUDIO_SIZE
{
    NV_AUDIO_SIZE_16BIT =      (1 << 0),
    NV_AUDIO_SIZE_20BIT =      (1 << 1),
    NV_AUDIO_SIZE_24BIT =      (1 << 2),
}NV_AUDIO_SIZE;

typedef enum _NV_AUDIO_RATE
{
    NV_AUDIO_RATE_32000 =      (1 << 8),
    NV_AUDIO_RATE_44100 =      (1 << 9),
    NV_AUDIO_RATE_48000 =      (1 << 10),
    NV_AUDIO_RATE_88200 =      (1 << 11),
    NV_AUDIO_RATE_96000 =      (1 << 12),
    NV_AUDIO_RATE_176400 =     (1 << 13),
    NV_AUDIO_RATE_192000 =     (1 << 14),
}NV_AUDIO_RATE;

typedef enum _NV_AUDIO_FORMAT
{
    NV_AUDIO_FORMAT_LPCM =     (1 << 1),  //!< Linear PCM (e.g., IEC 60958)
    NV_AUDIO_FORMAT_AC3 =      (1 << 2),  //!< AC-3
    NV_AUDIO_FORMAT_MPEG1 =    (1 << 3),  //!< MPEG1 (Layers 1 & 2)
    NV_AUDIO_FORMAT_MP3 =      (1 << 4),  //!< MP3 (MPEG1 Layer 3)
    NV_AUDIO_FORMAT_MPEG2 =    (1 << 5),  //!< MPEG2 (multichannel)
    NV_AUDIO_FORMAT_AAC =      (1 << 6),  //!< AAC
    NV_AUDIO_FORMAT_DTS =      (1 << 7),  //!< DTS
    NV_AUDIO_FORMAT_ATRAC =    (1 << 8),  //!< ATRAC
    NV_AUDIO_FORMAT_SACD =     (1 << 9),  //!< One Bit Audio
    NV_AUDIO_FORMAT_DDPLUS =   (1 << 10), //!< Dolby Digital +
    NV_AUDIO_FORMAT_DTSHD =    (1 << 11), //!< DTS-HD
    NV_AUDIO_FORMAT_MAT =      (1 << 12), //!< MAT (MLP)
    NV_AUDIO_FORMAT_DST =      (1 << 13), //!< DST
    NV_AUDIO_FORMAT_WMAPRO =   (1 << 14), //!< WMA Pro
    NV_AUDIO_FORMAT_RESERVED = (1 << 15), //!< Reserved for audio format 15
}NV_AUDIO_FORMAT;

typedef struct _NV_AUDIO_PARAMETERS
{
    NvU32 version;                //!< Strucure version
    
    NvU32 venID;                  //!< Vendor ID
    NvU32 devID;                  //!< Developer ID
    NvU32 revID;                  //!< Revision ID
    
    NvU32 paramVersion;           //!< Parameter versioning used inside audio Driver
    
    //Contents of audio HeadScratch registers
    NvU32 regH0S0;                //!< NV_PDISP_AUDIO_HEAD0_SCRATCH0
    NvU32 regH0S1;                //!< NV_PDISP_AUDIO_HEAD0_SCRATCH1
    NvU32 regH1S0;                //!< NV_PDISP_AUDIO_HEAD1_SCRATCH0
    NvU32 regH1S1;                //!< NV_PDISP_AUDIO_HEAD1_SCRATCH1
    NvU32 regLPCM;                //!< NV_PDISP_AUDIO_EXAUD_LPCM
    
    // Current audio stream properties
    NvU32 currentState:1;         //!< State of current audio stream
    NvU32 currentChan;            //!< Number of channels in current audio stream
    NvU32 currentRate;            //!< Bitrate of current audio stream
    NvU32 currentSampleSize;      //!< samplesize for current audio stream
    
    //Device maximum settings
    NvU32 maxState:1;             //!< State of Device maximum settings (Valid/Invalid)
    NvU32 maxRate;                //!< Bitrates allowed by NVHDA codec present
    NvU32 maxSampleSize;          //!< SampleSizes allowed by NVHDA codec present
    NvU32 maxFormats;             //!< SampleSIzes allowed by NVHDA codec present
    NvU32 maxChan;                //!< SampleSizes allowed by NVHDA codec present
    
    //Driver sink settings 
    NvU32 sinkState:1;            //!< State of Driver Sink settings (Valid/Invalid)
    NvU32 sinkRate;               //!< Bitrates allowed by NVHDA codec present
    NvU32 sinkSampleSize;         //!< SampleSizes allowed by sink device present
    NvU32 sinkFormats;            //!< SampleSIzes allowed by sink devicec present
    NvU32 sinkChan;               //!< SampleSizes allowed by sink device present
    
    //Driver override settings
    NvU32 overrideState:1;        //!< State of Driver Overrides (Valid/Invalid)
    NvU32 overrideRate;           //!< Bitrates overrided
    NvU32 overrideSampleSize;     //!< SampleSizes overrided
    NvU32 overrideFormats;        //!< SampleSIzes overrided
    NvU32 overrideChan;           //!< SampleSizes overrided

} NV_AUDIO_PARAMETERS;

//! Macro for constructing the version field of ::_NV_AUDIO_PARAMETERS
#define NV_AUDIO_PARAMETERS_VER  MAKE_NVAPI_VERSION(NV_AUDIO_PARAMETERS,1)

//! @}

//! \ingroup audioapi
NVAPI_INTERFACE NvAPI_Audio_GetDeviceParameters(NvAudioHandle NvAudioHandle, NV_AUDIO_PARAMETERS *pNV_AUDIO_PARAMETERS);





///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Audio_SetDeviceParametersOverride
//
//! \code
//! PARAMETERS:    NvAudioHandle (IN)                - NvAudioHandle value
//!                pNV_AUDIO_PARAMETERS (IN)         - pointer to NV_AUDIO_PARAMETERS structure
//!                                  
//! SUPPORTED OS:  Windows XP and higher
//!
//! DESCRIPTION:   Sets various override parameters of Audio Device
//!
//! RETURN STATUS: 
//!                NVAPI_OK - completed request
//!                NVAPI_ERROR - miscellaneous error occurred
//!                NVAPI_INVALID_ARGUMENT - invalid input parameter
//!                NVAPI_INVALID_HANDLE - invalid handle to device
//!                NVAPI_INCOMPATIBLE_STRUCT_VERSION - Incompatible struct version
//! \endcode
//! \ingroup audioapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Audio_SetDeviceParametersOverride(NvAudioHandle NvAudioHandle, NV_AUDIO_PARAMETERS *pNV_AUDIO_PARAMETERS);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SecureAudio_GetSecureAudioAPIRevision
//!
//! DESCRIPTION:    Returns the Secure Audio API revision.
//! \deprecated  Do not use this function - it is deprecated in release 313. Instead, use NvAPI_SecureAudio_CheckAPICompatibility.
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!
//! \param [out]     nvSecureAudioAPIRevision               Revision number of Secure Audio API.
//!
//! RETURN STATUS: This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
//!
///////////////////////////////////////////////////////////////////////////////

//! \ingroup secureaudioapi
//! @{

//! Secure Audio API REVISION
//! Client uses this revision in NvAPI_SecureAudio_CheckAPICompatibility API to establish compatability between client API and driver.
#define NV_SECURE_AUDIO_API_REVISION  0x00010001

//! Content key header version
#define NV_CONTENT_KEY_HEADER_VERSION 0x01

//! Secure Audio Flags
#define NV_CONTENT_KEY_HEADER_KEY_IS_PLAINTEXT          NV_BIT(1)   //!< Flags bit #1, leave to 0 if content key is sent already encrypted
#define NV_CONTENT_KEY_HEADER_OOS_ENABLED               NV_BIT(2)   //!< Flags bit #2, Set if input stream has Kepler out-of-sync detection counter bytes enabled

//! Content key is copied as-is from the WAVEFORMATEXTENSIBLE data extension area
#define NV_CONTENT_KEY_HEADER_KEYLENGTH 16
#define NV_CONTENT_KEY_HEADER_IVLENGTH  16

//! Size of content key header structure.
#define NV_CONTENT_KEY_HEADER_SIZE sizeof(NV_CONTENT_KEY_HEADER)

typedef struct _NV_CONTENT_KEY_HEADER
{
    NvU8 version;                               //!< versioning maintained inside the audio driver
    NvU8 contentKeyHeaderLength;                //!< Size of the structure
    NvU8 flags;                                 //!< flag values specified above
    NvU8 counterWrapAround;                     //!< Counter value to be used in case of OOSD enabled
    NvU8 iv[NV_CONTENT_KEY_HEADER_IVLENGTH];    //!< Initial counter value used for data encryption using content key
    NvU8 key[NV_CONTENT_KEY_HEADER_KEYLENGTH];  //!< Content Key expected to be encrypted by the session key by the application.
} NV_CONTENT_KEY_HEADER;

//! @}

//! \ingroup secureaudioapi
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 313. Instead, use NvAPI_SecureAudio_CheckAPICompatibility.")
NVAPI_INTERFACE NvAPI_SecureAudio_GetSecureAudioAPIRevision(__out NvU32* nvSecureAudioAPIRevision);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SecureAudio_CheckAPICompatibility
//!
//! DESCRIPTION:    Checks API and Driver compatibility with the client. Return value NVAPI_OK suggests that the client is using compatible API version with the system driver. 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 313
//!
//! \param [in]    endpointID                   Pointer to an endpoint ID string. The caller typically obtains this string from the IMMDevice::GetId method
//! \param [in]    nvSecureAudioAPIRevision     Revision number of Secure Audio API.
//!
//! RETURN STATUS: This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
//!
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SecureAudio_CheckAPICompatibility( __in NvAPI_LPCWSTR endpointID, __in NvU32 nvSecureAudioAPIRevision);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SecureAudio_GetCustomFormatGUID
//
//! DESCRIPTION:    This API gets the subformat GUID as the input parameter and returns corresponding subformat for encrypted audio.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!
//! \param [in/out]    SubFormat    GUID for audio subformat
//!
//! RETURN STATUS: This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
//!
//! \ingroup secureaudioapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SecureAudio_GetCustomFormatGUID(__inout NvGUID* subFormat);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SecureAudio_NegotiateDHExchange
//
//! DESCRIPTION:    This API assists the application in negotiating Diffie-Hellman Key exchange with the audio hardware to establish the session Key.
//!                 Application generates the Challenge token for DH Key exchange (256 BYTE array of random numbers).
//!                 API communicates the Challenge token with HW. HW in turn generates the ResponseToken.
//!                 API provides this ResponseToken (256 BYTE) to the application. Application uses this ResponseToken to generate the session key.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!
//! \param [in]    endpointID                   Pointer to an endpoint ID string. The caller typically obtains this string from the IMMDevice::GetId method
//! \param [in]    challengeToken               ChallengeToken for DH Key exchange
//! \param [out]   responseToken                ResponseToken for DH Key exchange
//!
//! RETURN STATUS: This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
//! \retval ::NVAPI_INCOMPATIBLE_AUDIO_DRIVER
//!
//! \ingroup secureaudioapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SecureAudio_NegotiateDHExchange( __in NvAPI_LPCWSTR endpointID, __in NvU8* challengeToken, __out NvU8* responseToken );

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SecureAudio_ComputeSessionKey
//
//! DESCRIPTION:    This API negotiates Session key with audio HW. 
//!                 In this case Application is transparent to DH key exchange and it is completely handled by API.
//!                 Application gets ready-made SessionKey. Internally this API uses calls NvAPI_SecureAudio_NegotiateDHExchange.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!
//! \param [in]    endpointID                  Pointer to an endpoint ID string. The caller typically obtains this string from the IMMDevice::GetId method
//! \param [out]   sessionKey                  This key will be used to encrypt the content key generated by the application.
//!
//! RETURN STATUS: This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
//! \retval ::NVAPI_INCOMPATIBLE_AUDIO_DRIVER
//!
//! \ingroup secureaudioapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SecureAudio_ComputeSessionKey(__in NvAPI_LPCWSTR endpointID, __out NvU8* sessionKey);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SecureAudio_PollOOSDState
//
//! DESCRIPTION:    While audio stream is playing this API probes into audio driver for every few seconds to detect whether the stream is 'Out of Sync' (OOSD).
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!
//! \param [in]    endpointID                  Pointer to an endpoint ID string. The caller typically obtains this string from the IMMDevice::GetId method
//!
//! RETURN STATUS: This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
//! \retval ::NVAPI_STREAM_IS_OUT_OF_SYNC
//!           NVAPI_INCOMPATIBLE_AUDIO_DRIVER
//!
//! \ingroup secureaudioapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SecureAudio_PollOOSDState(__in NvAPI_LPCWSTR endpointID);






//! \ingroup gpuaudio
//! @{
typedef enum {
    NV_GPU_AUDIO_DE_LIST_TYPE_DEFAULT = 0, //!< Defaults to adapter
    NV_GPU_AUDIO_DE_LIST_TYPE_ADAPTER,
    NV_GPU_AUDIO_DE_LIST_TYPE_CONNECTOR,
} NV_AUDIO_PRIORITY_ENUM;

typedef struct
{
    NvU32  version;                 //!< Only element 0 must be properly set   
    NvU32  deviceEntry;             //!< The lower index in the array has higher priority
} NV_AUDIO_PRIORITY_ENTRY_V1;

typedef NV_AUDIO_PRIORITY_ENTRY_V1       NV_AUDIO_PRIORITY_ENTRY;
#define NV_AUDIO_PRIORITY_ENTRY_VER1     MAKE_NVAPI_VERSION(NV_AUDIO_PRIORITY_ENTRY_V1,1)
#define NV_AUDIO_PRIORITY_ENTRY_VER      NV_AUDIO_PRIORITY_ENTRY_VER1

//! @}



///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GPU_GetAudioDeviceEntryPriorityList
//
//! \code
//! DESCRIPTION:     This API gets the current priority list for audio device entries (DE).
//!                  The first DE on the list has higher priority than the next.
//!                  The list can be from the adapter or specific connector.
//!                  Number of entries per connector may vary and may be less than
//!                  the adapter's number.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:     rootConnectorId(IN)    : The displayId of the connector
//!                                          when used with NV_GPU_AUDIO_DE_LIST_TYPE_ADAPTER, changes DE priority list of all connectors
//!                                          on the logical GPU where displayId is located.
//!                 type(IN)               : Indicates the desired operation: on adapter or on connector.
//!                 pDeviceEntries(IN/OUT) : Pointer to NV_AUDIO_PRIORITY_ENTRY struct; each entry represents a device entry
//1                                          On return, if *pNumEntries is not zero, this is populated with deviceEntry values.
//!                                          Storage space must be provided by the caller.
//!                 pNumEntries(IN/OUT)    : Number of pDeviceEntries (IN); number of pDeviceEntries that is valid.
//!                                          When *pNumEntries is zero, it returns only the count entries in *pNumEntries (OUT); in this case, pDeviceEntries may be NULL.
//!                                          When *pNumEntries is not zero, pDeviceEntries[] returns the DE values.
//!
//! RETURN STATUS:
//!                  NVAPI_OK                          - completed request
//!                  NVAPI_API_NOT_INTIALIZED          - NVAPI not initialized
//!                  NVAPI_ERROR                       - miscellaneous error occurred
//!                  NVAPI_INVALID_ARGUMENT            - Invalid input parameter.
//!                  NVAPI_INCOMPATIBLE_STRUCT_VERSION - *pDeviceEntries version incompatible
//! \endcode
//! \ingroup gpuaudio
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetAudioDeviceEntryPriorityList(NvU32 rootConnectorId, NV_AUDIO_PRIORITY_ENUM type, NV_AUDIO_PRIORITY_ENTRY* pDeviceEntries, NvU32* pNumEntries);



///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_GPU_SetAudioDeviceEntryPriorityList
//
//! \code
//! DESCRIPTION:     This API changes the priority list for audio device entries (DE).
//!                  The first DE on the list has a higher priority than the next.
//!                  The list can be from the adapter or specific connector.
//!                  Number of entries per connector may vary and may be less than
//!                  the adapter's number.
//!                  When setting the adapter's list, the list on all audio-capable
//!                  connectors on the adapter are adjusted accordingly.
//!                  When setting a specific connector, only that connector's list
//!                  is updated.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:     rootConnectorId(IN)    : The displayId of the connector
//!                                          when used with NV_GPU_AUDIO_DE_LIST_TYPE_ADAPTER, changes DE priority list of all connectors
//!                                          on the logical gpu where displayId is located
//!                 type(IN)               : Indicates desired operation: on adapter or on connector.
//!                 pDeviceEntries(IN)     : Pointer to an NV_AUDIO_PRIORITY_ENTRY struct; each entry represents a device entry.
//!                                          Each entry must be deviceEntry value must be less than the value in *pNumEntries.
//!                 pNumEntries(IN)        : Number of pDeviceEntries (IN); number of pDeviceEntries that are valid.
//!
//! RETURN STATUS:
//!                  NVAPI_OK                          - completed request
//!                  NVAPI_API_NOT_INTIALIZED          - NVAPI not initialized
//!                  NVAPI_ERROR                       - miscellaneous error occurred
//!                  NVAPI_INVALID_ARGUMENT            - Invalid input parameter.
//!                  NVAPI_INCOMPATIBLE_STRUCT_VERSION - *pDeviceEntries version incompatible
//! \endcode
//! \ingroup gpuaudio
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetAudioDeviceEntryPriorityList(NvU32 rootConnectorId, NV_AUDIO_PRIORITY_ENUM type, NV_AUDIO_PRIORITY_ENTRY* pDeviceEntries, NvU32* pNumEntries);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GPU_GetMaxAudioStreamCount
//
//
//! DESCRIPTION: This API retrieves the maximum number of audio streams supported per adapter and/or per connector.
//!              Returns zero on architecture that doesn't support audio streams.
//!
//! HOW TO USE:   1) To query the maximum number of audio streams supported per physicalGpu basis,                   \n
//!                  the input can be the displayId of any of the monitors connected to the physicalGpu.             
//!               2) To query the maximum number of audio streams supported per connector basis,                     \n
//!                  the input should be the the displayId of the root connector. Note that this will also return the count per GPU.
//!
//!               Note : This API returns the "Max" and not "Total" audio streams for a given GPU/connector.        \n    
//!                      1) e.g. if a connector has 4 audio capable monitors connected to it but can drive a max of 2 audio streams,
//!                              the return value would be 2 and not 4.                                             \n
//!                      2) Similarly, if a GPU has 2 audio capable connectors A and B; both have 3 audio capable monitors connected each; 
//!                         If A can drive a max of 4 audio streams and B a max of 2, the return value for this GPU would be 4 and not 4+2 nor 3+3.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]    displayId                    displayId of the monitor connected to a GPU or displayId of a connector
//! \param [out]   pGpuAudioStreamsCount        Max number of audio streams for this GPU
//! \param [out]   pConnectorAudioStreamsCount  Max number of audio streams for this Connector
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with specific 
//!          meaning for this API, they are listed below.
//!
//! \ingroup gpuaudio
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetMaxAudioStreamCount(__in NvU32 displayId, __out_opt NvU32 *pGpuAudioStreamsCount, __out_opt NvU32 *pConnectorAudioStreamsCount);


//! \ingroup gpuaudio
//! @{

#define NVAPI_MAX_AUDIO_STREAMS_PER_CONNECTOR   16

//! Input state type values for Get Audio Interface
#define NV_GET_AUDIO_STREAMS_STATE_TYPE_DEFAULT         NV_BIT(0) //!< the fallback device, recalculated on each topology change/modeset. 
                                                                  //!< currently defined as the lowest DPMST address that supports audio on an active video stream. 
                                                                  //!< there can only be one, and there must be one. used when automatically selecting a new preferred.
#define NV_GET_AUDIO_STREAMS_STATE_TYPE_PREFERRED       NV_BIT(1) //!< An audio device is considered preferred :-
                                                                  //!< An audio device which got selected by the user (or)
                                                                  //!< An audio device that is active for more than 30 sec automatically becomes preferred
                                                                  
#define NV_GET_AUDIO_STREAMS_STATE_TYPE_ENABLED         NV_BIT(2) //!< An audio device is considered enabled if it is audio capable, 
                                                                  //!< may or may not be allowed to export it's audio capabilities to the audio subsystem
                                                                  //!< If bit is not set then audio device is disabled means the device was disabled by the user
                                                                  
#define NV_GET_AUDIO_STREAMS_STATE_TYPE_ACTIVE          NV_BIT(3) //!< An audio device is considered active if it is currently reported to the audio subsytem. 
                                                                  //!< A device has to be enabled in order to be active 
                                                                  //!< If bit is not set then audio device is inactive means the device is not reported to 
                                                                  //!< the audio subsystem

#define NV_GET_AUDIO_STREAMS_STATE_TYPE_MUTED           NV_BIT(4) //!< An audio device is considered muted if it is active but it's not playing audio 
                                                                 //!< If bit is not set then audio device is unmuted
                                                                 //!< Note :Mute/UnMute bit comes into the picture once STATE_TYPE_ACTIVE flag is set



typedef enum _NV_GET_AUDIO_DEVICE_TYPE
{
    NV_GET_AUDIO_ONLY_DEVICE                = 1,
    NV_GET_AUDIO_AND_VIDEO_DEVICE              
} NV_GET_AUDIO_DEVICE_TYPE;

typedef struct
{
    NV_GET_AUDIO_DEVICE_TYPE deviceType;    //!< contains info about device type either independent audio device or video + audio device
    NvU32 stateTypeFlags;                  //!< one or more of NV_GET_AUDIO_STREAMS_STATE_TYPE_* flags
    NvU32 audioStreamDisplayId;           //!< NvAPI Display Id of the DPMST/HDMI audio device
} NV_AUDIO_STREAMS;

typedef struct
 {
     NvU32  version;
     NvU32  audioStreamCount;       //!< Only "audioStreamCount" streams are valid in the below array and rest of the entries will be 0. Should be ignored.
     NV_AUDIO_STREAMS audioStreams[NVAPI_MAX_AUDIO_STREAMS_PER_CONNECTOR];
 } NV_GET_AUDIO_STREAMS_V1;

typedef NV_GET_AUDIO_STREAMS_V1           NV_GET_AUDIO_STREAMS;

#define NV_GET_AUDIO_STREAMS_VER          MAKE_NVAPI_VERSION(NV_GET_AUDIO_STREAMS_V1, 1)

//! @}


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_GPU_GetAudioStreams
//
//
//! DESCRIPTION:  This API returns audio capable streams, per connector, which are a subset of audio-capable targets. 
//!               It includes disabled streams which can enabled by NvAPI_GPU_SetAudioStreams().
//! HOW TO USE: \n
//! For DPMST : \n
//!               1) The root display ID should be the display ID of a DPMST connector on a GPU.                 \n
//!               2) NvAPI_GPU_GetConnectedDisplayIds can be used to get the connected displayId's on a GPU.     \n
//!               3) If a DPMST connector is found, then that connector rootdisplayId can be used as input to get the audio streams.  \n
//! For HDMI :  \n
//!               1) NvAPI_GPU_GetConnectedDisplayIds can be used to get the connected displayId's on a GPU.     \n
//!               2) If any NV_MONITOR_CONN_TYPE is HDMI, then that displayId can be used as input to get the audio streams.          \n
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]    rootDisplayId         This is the displayId of the DPMST/HDMI connector. 
//! \param [out]   pAudioStreamEntries   Pointer to a NV_GET_AUDIO_STREAMS structure.
//!
//! \return        This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
//!
//! \ingroup gpuaudio
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetAudioStreams(__in NvU32 rootDisplayId, __inout NV_GET_AUDIO_STREAMS *pAudioStreamEntries);


//! \ingroup gpuaudio
//! @{

//!< Input Enum values for Set Audio Interface
typedef enum _NV_SET_AUDIO_STREAMS_STATE_ENUM
{
    NV_SET_AUDIO_STREAMS_STATE_ENABLE                  = 1,
    NV_SET_AUDIO_STREAMS_STATE_PREFER                    ,
    NV_SET_AUDIO_STREAMS_STATE_DISABLE                   ,
    NV_SET_AUDIO_STREAMS_STATE_MUTE                      ,
    NV_SET_AUDIO_STREAMS_STATE_UNMUTE                    
} NV_SET_AUDIO_STREAMS_STATE_ENUM;



typedef struct
{
     NvU32  version;
     // IN
     NV_SET_AUDIO_STREAMS_STATE_ENUM type;  //!< [IN] Allows clients to Enable, Disable, Mute or Unmute the streams
     NvU32  rootDisplayId;           //!< [IN] displayId of the DPMST/HDMI connector
     NvU32  audioStreamCount;       //!< [IN] Only "audioStreamCount" streams are valid in the below array and rest of the entries will be 0. Should be ignored.
     NvU32  audioStreamDisplayIds[NVAPI_MAX_AUDIO_STREAMS_PER_CONNECTOR]; //!< [IN] Display Ids of the DPMST/HDMI audio devices
     // OUT
     NvU8   status[NVAPI_MAX_AUDIO_STREAMS_PER_CONNECTOR];              //!< [OUT] returns TRUE or FALSE
} NV_SET_AUDIO_STREAMS_V1;

typedef NV_SET_AUDIO_STREAMS_V1           NV_SET_AUDIO_STREAMS;

#define NV_SET_AUDIO_STREAMS_VER          MAKE_NVAPI_VERSION(NV_SET_AUDIO_STREAMS_V1, 1)


//! @}


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_GPU_SetAudioStreams
//
//
//! DESCRIPTION:  This API activates audio streams requested by clients across GPUs.
//!
//! HOW TO USE: \n
//! For DPMST/HDMI:  \n
//!               1) NvAPI_GPU_GetAudioStreams can be used to fetch the audio capable streams                   
//!                     for each connector on which the audio streams need to be activated.      \n
//!          2) pAudioStreamEntries should be assigned an array of NV_SET_AUDIO_STREAMS structures         
//!                     the size of which should be number of connectors on which the audio streams need to be activated. \n
//!               3) For each element in the array, audioStreamDisplayIds should be populated with the displayIds of the target audio devices
//!                  and the audioStreamCount value be set accordingly.  \n
//!               4) Note that for HDMI case, audioStreamCount should always be set to one. 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in,out] pAudioStreamEntries          audioStreamEntries requested by clients to activate
//! \param [in]     audioStreamEntriesCount      number of audioStream entries requested by clients to activate
//!
//! \return   This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes 
//!          with specific meaning for this API, they are listed below.
//!
//! \retval   NVAPI_SET_NOT_ALLOWED One of the passed in displayIds does not correspond to either a HDMI or DP connector. 
//! \retval   NVAPI_OK  The call is successful. However, the caller needs to check the individual status bits of each of the passed in entries if the intended action was successful.
//!    
//! \ingroup gpuaudio
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetAudioStreams(__inout_ecount(audioStreamEntriesCount) NV_SET_AUDIO_STREAMS *pAudioStreamEntries, __in NvU32 audioStreamEntriesCount);


//! \addtogroup drsapi
//! @{


// GPU Profile APIs

NV_DECLARE_HANDLE(NvDRSSessionHandle);
NV_DECLARE_HANDLE(NvDRSProfileHandle);

#define NVAPI_DRS_GLOBAL_PROFILE                             ((NvDRSProfileHandle) -1)

#define NVAPI_SETTING_MAX_VALUES                             100

typedef enum _NVDRS_SETTING_TYPE
{
     NVDRS_DWORD_TYPE,
     NVDRS_BINARY_TYPE,
     NVDRS_STRING_TYPE,
     NVDRS_WSTRING_TYPE
} NVDRS_SETTING_TYPE;

typedef enum _NVDRS_SETTING_LOCATION
{
     NVDRS_CURRENT_PROFILE_LOCATION,
     NVDRS_GLOBAL_PROFILE_LOCATION,
     NVDRS_BASE_PROFILE_LOCATION,
     NVDRS_DEFAULT_PROFILE_LOCATION
} NVDRS_SETTING_LOCATION;


typedef struct _NVDRS_GPU_SUPPORT
{
    NvU32 geforce    :  1;
    NvU32 quadro     :  1;
    NvU32 nvs        :  1;
    NvU32 reserved4  :  1;
    NvU32 reserved5  :  1;
    NvU32 reserved6  :  1;
    NvU32 reserved7  :  1;
    NvU32 reserved8  :  1;
    NvU32 reserved9  :  1;
    NvU32 reserved10 :  1;
    NvU32 reserved11 :  1;
    NvU32 reserved12 :  1;
    NvU32 reserved13 :  1;
    NvU32 reserved14 :  1;
    NvU32 reserved15 :  1;
    NvU32 reserved16 :  1;
    NvU32 reserved17 :  1;
    NvU32 reserved18 :  1;
    NvU32 reserved19 :  1;
    NvU32 reserved20 :  1;
    NvU32 reserved21 :  1;
    NvU32 reserved22 :  1;
    NvU32 reserved23 :  1;
    NvU32 reserved24 :  1;
    NvU32 reserved25 :  1;
    NvU32 reserved26 :  1;
    NvU32 reserved27 :  1;
    NvU32 reserved28 :  1;
    NvU32 reserved29 :  1;
    NvU32 reserved30 :  1;
    NvU32 reserved31 :  1;
    NvU32 reserved32 :  1;
} NVDRS_GPU_SUPPORT;

//! Enum to decide on the datatype of setting value.
typedef struct _NVDRS_BINARY_SETTING 
{
     NvU32                valueLength;               //!< valueLength should always be in number of bytes.
     NvU8                 valueData[NVAPI_BINARY_DATA_MAX];
} NVDRS_BINARY_SETTING;

typedef struct _NVDRS_SETTING_VALUES
{
     NvU32                      version;                //!< Structure Version
     NvU32                      numSettingValues;       //!< Total number of values available in a setting.
     NVDRS_SETTING_TYPE         settingType;            //!< Type of setting value.  
     union                                              //!< Setting can hold either DWORD or Binary value or string. Not mixed types.
     {
         NvU32                      u32DefaultValue;    //!< Accessing default DWORD value of this setting.
         NVDRS_BINARY_SETTING       binaryDefaultValue; //!< Accessing default Binary value of this setting.
                                                        //!< Must be allocated by caller with valueLength specifying buffer size, or only valueLength will be filled in.
         NvAPI_UnicodeString        wszDefaultValue;    //!< Accessing default unicode string value of this setting.
     };
     union                                                //!< Setting values can be of either DWORD, Binary values or String type,
     {                                                    //!< NOT mixed types.
         NvU32                      u32Value;           //!< All possible DWORD values for a setting
         NVDRS_BINARY_SETTING       binaryValue;        //!< All possible Binary values for a setting
         NvAPI_UnicodeString        wszValue;           //!< Accessing current unicode string value of this setting.
     }settingValues[NVAPI_SETTING_MAX_VALUES];
} NVDRS_SETTING_VALUES;

//! Macro for constructing the version field of ::_NVDRS_SETTING_VALUES
#define NVDRS_SETTING_VALUES_VER    MAKE_NVAPI_VERSION(NVDRS_SETTING_VALUES,1)
     
typedef struct _NVDRS_SETTING_V1
{
     NvU32                      version;                //!< Structure Version
     NvAPI_UnicodeString        settingName;            //!< String name of setting
     NvU32                      settingId;              //!< 32 bit setting Id
     NVDRS_SETTING_TYPE         settingType;            //!< Type of setting value.  
     NVDRS_SETTING_LOCATION     settingLocation;        //!< Describes where the value in CurrentValue comes from. 
     NvU32                      isCurrentPredefined;    //!< It is different than 0 if the currentValue is a predefined Value, 
                                                        //!< 0 if the currentValue is a user value. 
     NvU32                      isPredefinedValid;      //!< It is different than 0 if the PredefinedValue union contains a valid value. 
     union                                              //!< Setting can hold either DWORD or Binary value or string. Not mixed types.
     {
         NvU32                      u32PredefinedValue;    //!< Accessing default DWORD value of this setting.
         NVDRS_BINARY_SETTING       binaryPredefinedValue; //!< Accessing default Binary value of this setting.
                                                           //!< Must be allocated by caller with valueLength specifying buffer size, 
                                                           //!< or only valueLength will be filled in.
         NvAPI_UnicodeString        wszPredefinedValue;    //!< Accessing default unicode string value of this setting.
     };
     union                                              //!< Setting can hold either DWORD or Binary value or string. Not mixed types.
     {
         NvU32                      u32CurrentValue;    //!< Accessing current DWORD value of this setting.
         NVDRS_BINARY_SETTING       binaryCurrentValue; //!< Accessing current Binary value of this setting.
                                                        //!< Must be allocated by caller with valueLength specifying buffer size, 
                                                        //!< or only valueLength will be filled in.
         NvAPI_UnicodeString        wszCurrentValue;    //!< Accessing current unicode string value of this setting.
     };                                                 
} NVDRS_SETTING_V1;

//! Macro for constructing the version field of ::_NVDRS_SETTING
#define NVDRS_SETTING_VER1        MAKE_NVAPI_VERSION(NVDRS_SETTING_V1, 1)

typedef NVDRS_SETTING_V1          NVDRS_SETTING;
#define NVDRS_SETTING_VER         NVDRS_SETTING_VER1

typedef struct _NVDRS_APPLICATION_V1
{
     NvU32                      version;            //!< Structure Version
     NvU32                      isPredefined;       //!< Is the application userdefined/predefined
     NvAPI_UnicodeString        appName;            //!< String name of the Application
     NvAPI_UnicodeString        userFriendlyName;   //!< UserFriendly name of the Application
     NvAPI_UnicodeString        launcher;           //!< Indicates the name (if any) of the launcher that starts the application  
} NVDRS_APPLICATION_V1;

typedef struct _NVDRS_APPLICATION_V2
{
     NvU32                      version;            //!< Structure Version
     NvU32                      isPredefined;       //!< Is the application userdefined/predefined
     NvAPI_UnicodeString        appName;            //!< String name of the Application
     NvAPI_UnicodeString        userFriendlyName;   //!< UserFriendly name of the Application
     NvAPI_UnicodeString        launcher;           //!< Indicates the name (if any) of the launcher that starts the Application
     NvAPI_UnicodeString        fileInFolder;       //!< Select this application only if this file is found.
                                                    //!< When specifying multiple files, separate them using the ':' character.
} NVDRS_APPLICATION_V2;

typedef struct _NVDRS_APPLICATION_V3
{
     NvU32                      version;            //!< Structure Version
     NvU32                      isPredefined;       //!< Is the application userdefined/predefined
     NvAPI_UnicodeString        appName;            //!< String name of the Application
     NvAPI_UnicodeString        userFriendlyName;   //!< UserFriendly name of the Application
     NvAPI_UnicodeString        launcher;           //!< Indicates the name (if any) of the launcher that starts the Application
     NvAPI_UnicodeString        fileInFolder;       //!< Select this application only if this file is found.
                                                    //!< When specifying multiple files, separate them using the ':' character.
     NvU32                      isMetro:1;          //!< Windows 8 style app
     NvU32                      reserved:31;        //!< Reserved. Should be 0.
} NVDRS_APPLICATION_V3;

#define NVDRS_APPLICATION_VER_V1        MAKE_NVAPI_VERSION(NVDRS_APPLICATION_V1,1)
#define NVDRS_APPLICATION_VER_V2        MAKE_NVAPI_VERSION(NVDRS_APPLICATION_V2,2)
#define NVDRS_APPLICATION_VER_V3        MAKE_NVAPI_VERSION(NVDRS_APPLICATION_V3,3)

typedef NVDRS_APPLICATION_V3 NVDRS_APPLICATION;
#define NVDRS_APPLICATION_VER NVDRS_APPLICATION_VER_V3

typedef struct _NVDRS_PROFILE_V1
{
     NvU32                      version;            //!< Structure Version
     NvAPI_UnicodeString        profileName;        //!< String name of the Profile
     NVDRS_GPU_SUPPORT          gpuSupport;         //!< This read-only flag indicates the profile support on either
                                                    //!< Quadro, or Geforce, or both.
     NvU32                      isPredefined;       //!< Is the Profile user-defined, or predefined
     NvU32                      numOfApps;          //!< Total number of applications that belong to this profile. Read-only
     NvU32                      numOfSettings;      //!< Total number of settings applied for this Profile. Read-only
} NVDRS_PROFILE_V1;

typedef NVDRS_PROFILE_V1         NVDRS_PROFILE;

//! Macro for constructing the version field of ::NVDRS_PROFILE
#define NVDRS_PROFILE_VER1       MAKE_NVAPI_VERSION(NVDRS_PROFILE_V1,1)
#define NVDRS_PROFILE_VER        NVDRS_PROFILE_VER1


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_CreateSession
//
//!   DESCRIPTION: This API allocates memory and initializes the session.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [out]  *phSession Return pointer to the session handle.
//!                
//! \retval ::NVAPI_OK SUCCESS
//! \retval ::NVAPI_ERROR: For miscellaneous errors.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_CreateSession(NvDRSSessionHandle *phSession);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_DestroySession
//
//!   DESCRIPTION: This API frees the allocation: cleanup of NvDrsSession.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in] hSession Input to the session handle.
//!                
//! \retval ::NVAPI_OK SUCCESS
//! \retval ::NVAPI_ERROR For miscellaneous errors.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_DestroySession(NvDRSSessionHandle hSession);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_LoadSettings
//
//!   DESCRIPTION: This API loads and parses the settings data.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in] hSession  Input to the session handle.
//!                
//! \retval ::NVAPI_OK     SUCCESS
//! \retval ::NVAPI_ERROR  For miscellaneous errors.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_LoadSettings(NvDRSSessionHandle hSession);


///////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION NAME: NvAPI_DRS_LoadGoldSettings
//
//!   DESCRIPTION: This API loads and parses the settings data from the Gold DB.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   NvDRSSessionHandle  Input to the session handle.
//!
//! \retval ::NVAPI_OK      SUCCESS
//! \retval ::NVAPI_ERROR   For miscellaneous errors.
//!
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_LoadGoldSettings(NvDRSSessionHandle hSession);


///////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION NAME: NvAPI_DRS_LoadDefaultSettings
//
//!   DESCRIPTION: This API loads and parses the DefaultGlobal, BaseProfile and CurrentGlobalProfile into the current session.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   NvDRSSessionHandle  Input to the session handle.
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. 
//!                  If there are return error codes with specific meaning for this API, 
//!                  they are listed below:
//!
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_LoadDefaultSettings(__in NvDRSSessionHandle hSession);


///////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION NAME: NvAPI_DRS_DecryptSession
//
//!   DESCRIPTION: This API will decrypt (only the encrypted settings) in the current
//!                Session. This is a private API, those settings are encrypted for
//!                competitive reasons. 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   NvDRSSessionHandle  Input to the session handle.
//!
//! \retval ::NVAPI_OK                   SUCCESS
//! \retval ::NVAPI_ERROR                For miscellaneous errors.
//! \retval ::NVAPI_API_NOT_INTIALIZED   When NVAPI has not been initialized.
//! \retval ::NVAPI_INVALID_ARGUMENT     When hSession is not valid.
//!
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_DecryptSession(__in NvDRSSessionHandle hSession);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_SaveSettings
//
//!   DESCRIPTION: This API saves the settings data to the system.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in] hSession  Input to the session handle.
//!                
//! \retval ::NVAPI_OK    SUCCESS
//! \retval ::NVAPI_ERROR For miscellaneous errors.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_SaveSettings(NvDRSSessionHandle hSession);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_SaveSettingsEx
//
//!   DESCRIPTION: This API saves the settings data to the system and reloads the entire data only when 
//!                it has been modified by any other client.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]      hSession              Session handle.
//! \param [__inout] pFileModifiedTime     Input the time when the DRS database was queried.If the DRS database
//!                                        has been not modified the database reload will be skipped else the database
//!                                        will be reloaded and pFileModifiedTime will have the last modified time.
//!                                        Lower 32 bits contains the low-order part of the FILETIME structure.
//!                                        Upper 32 bits contains the high-order part of the FILETIME structure.
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. 
//!          If there are return error codes with specific meaning for this API, 
//!          they are listed below.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_SaveSettingsEx(__in NvDRSSessionHandle hSession, __inout NvU64 *pFileModifiedTime);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_LoadSettingsFromFile
//
//!   DESCRIPTION: This API loads settings from the given file path.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  hSession Input to the session handle
//! \param [in]  fileName Binary File Name/Path
//!                
//! \retval ::NVAPI_OK     SUCCESS
//! \retval ::NVAPI_ERROR  For miscellaneous errors.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_LoadSettingsFromFile(NvDRSSessionHandle hSession, NvAPI_UnicodeString fileName);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_SaveSettingsToFile
//
//!   DESCRIPTION: This API saves settings to the given file path.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  hSession  Input to the session handle.
//! \param [in]  fileName  Binary File Name/Path
//!                
//! \retval ::NVAPI_OK     SUCCESS
//! \retval ::NVAPI_ERROR  For miscellaneous errors.
//
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_SaveSettingsToFile(NvDRSSessionHandle hSession, NvAPI_UnicodeString fileName);

//! @}



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_SaveSettingsToPrdFile
//
//!   DESCRIPTION: This API saves settings to the given file path, in PRD file format.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param  hSession  Input to the session handle.
//! \param  fileName  Binary File Name/Path
//!                
//! \retval ::NVAPI_OK                    SUCCESS
//! \retval ::NVAPI_INVALID_ARGUMENT      Invalid Session handle or Empty PRD file name
//! \retval ::NVAPI_API_NOT_INTIALIZED    NvAPI initialization failed
//! \retval ::NVAPI_ERROR                 For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_SaveSettingsToPrdFile(NvDRSSessionHandle hSession, NvAPI_UnicodeString fileName);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_LoadSettingsFromPrdFile
//
//!   DESCRIPTION: Ths API loads settings from the given file path, in PRD file format.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param  hSession  Input to the session handle.
//! \param  fileName  Binary File Name/Path
//!                
//! \retval ::NVAPI_OK                    SUCCESS
//! \retval ::NVAPI_INVALID_ARGUMENT      Invalid Session handle or Empty PRD file name
//! \retval ::NVAPI_API_NOT_INTIALIZED    NvAPI initialization failed
//! \retval ::NVAPI_ERROR                 For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_LoadSettingsFromPrdFile(NvDRSSessionHandle hSession, NvAPI_UnicodeString fileName);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_CreateProfile
//
//!   DESCRIPTION: This API creates an empty profile.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  hSession        Input to the session handle.
//! \param [in]  *pProfileInfo   Input pointer to NVDRS_PROFILE.
//! \param [in]  *phProfile      Returns pointer to profile handle.
//!                
//! \retval ::NVAPI_OK     SUCCESS
//! \retval ::NVAPI_ERROR  For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_CreateProfile(NvDRSSessionHandle hSession, NVDRS_PROFILE *pProfileInfo, NvDRSProfileHandle *phProfile);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_DeleteProfile
//
//!   DESCRIPTION: This API deletes a profile or sets it back to a predefined value.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in] hSession  Input to the session handle.
//! \param [in] hProfile  Input profile handle.
//!                
//! \retval ::NVAPI_OK     SUCCESS if the profile is found
//! \retval ::NVAPI_ERROR  For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_DeleteProfile(NvDRSSessionHandle hSession, NvDRSProfileHandle hProfile);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_SetCurrentGlobalProfile
//
//!   DESCRIPTION: This API sets the current global profile in the driver.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in] hSession                Input to the session handle.
//! \param [in] wszGlobalProfileName    Input current Global profile name.
//!               
//! \retval ::NVAPI_OK     SUCCESS
//! \retval ::NVAPI_ERROR  For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_SetCurrentGlobalProfile(NvDRSSessionHandle hSession, NvAPI_UnicodeString wszGlobalProfileName);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_GetCurrentGlobalProfile
//
//!   DESCRIPTION: This API returns the handle to the current global profile.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   hSession     Input to the session handle.
//! \param [out]  *phProfile   Returns current Global profile handle.
//!                
//! \retval ::NVAPI_OK     SUCCESS
//! \retval ::NVAPI_ERROR  For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_GetCurrentGlobalProfile(NvDRSSessionHandle hSession, NvDRSProfileHandle *phProfile);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_GetProfileInfo
//
//!   DESCRIPTION: This API gets information about the given profile. User needs to specify the name of the Profile.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  hSession       Input to the session handle.
//! \param [in]  hProfile       Input profile handle.
//! \param [out] *pProfileInfo  Return the profile info.
//!                
//! \retval ::NVAPI_OK     SUCCESS
//! \retval ::NVAPI_ERROR  For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_GetProfileInfo(NvDRSSessionHandle hSession, NvDRSProfileHandle hProfile, NVDRS_PROFILE *pProfileInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_SetProfileInfo
//
//!   DESCRIPTION: Specifies flags for a given profile. Currently only the NVDRS_GPU_SUPPORT is
//!                used to update the profile. Neither the name, number of settings or applications
//!                or other profile information can be changed with this function. 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  hSession       Input to the session handle.
//! \param [in]  hProfile       Input profile handle.
//! \param [in]  *pProfileInfo  Input the new profile info.
//!                
//! \retval ::NVAPI_OK     SUCCESS
//! \retval ::NVAPI_ERROR  For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_SetProfileInfo(NvDRSSessionHandle hSession, NvDRSProfileHandle hProfile, NVDRS_PROFILE *pProfileInfo);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_FindProfileByName
//
//!   DESCRIPTION: This API finds a profile in the current session.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   hSession      Input to the session handle.
//! \param [in]   profileName   Input profileName.
//! \param [out]  phProfile     Input profile handle.
//!                
//! \retval ::NVAPI_OK                SUCCESS if the profile is found
//! \retval ::NVAPI_PROFILE_NOT_FOUND if profile is not found
//! \retval ::NVAPI_ERROR             For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_FindProfileByName(NvDRSSessionHandle hSession, NvAPI_UnicodeString profileName, NvDRSProfileHandle* phProfile);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_EnumProfiles
//
//!   DESCRIPTION: This API enumerates through all the profiles in the session.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   hSession        Input to the session handle.
//! \param [in]   index           Input the index for enumeration.
//! \param [out]  *phProfile      Returns profile handle.
//!                
//!   RETURN STATUS: NVAPI_OK: SUCCESS if the profile is found
//!                  NVAPI_ERROR: For miscellaneous errors.
//!                  NVAPI_END_ENUMERATION: index exceeds the total number of available Profiles in DB.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_EnumProfiles(NvDRSSessionHandle hSession, NvU32 index, NvDRSProfileHandle *phProfile);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_GetNumProfiles
//
//!   DESCRIPTION: This API obtains the number of profiles in the current session object.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  hSession       Input to the session handle.
//! \param out]  *numProfiles   Returns count of profiles in the current hSession.
//!                
//! \retval ::NVAPI_OK                  SUCCESS
//! \retval ::NVAPI_API_NOT_INTIALIZED  Failed to initialize.
//! \retval ::NVAPI_INVALID_ARGUMENT    Invalid Arguments.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_GetNumProfiles(NvDRSSessionHandle hSession, NvU32 *numProfiles);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_CreateApplication
//
//!   DESCRIPTION: This API adds an executable name to a profile.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  hSession       Input to the session handle.
//! \param [in]  hProfile       Input profile handle.
//! \param [in]  *pApplication  Input NVDRS_APPLICATION struct with the executable name to be added.
//!                
//! \retval ::NVAPI_OK     SUCCESS
//! \retval ::NVAPI_ERROR  For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_CreateApplication(NvDRSSessionHandle hSession, NvDRSProfileHandle  hProfile, NVDRS_APPLICATION *pApplication);
 

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_DeleteApplicationEx
//
//!   DESCRIPTION: This API removes an executable from a profile.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   hSession  - Input to the session handle.
//! \param [in]   hProfile  - Input profile handle.
//! \param [in]   *pApp     - Input all the information about the application to be removed.
//!
//! \retval ::NVAPI_OK  SUCCESS
//! \retval ::NVAPI_ERROR For miscellaneous errors.
//! \retval ::NVAPI_EXECUTABLE_PATH_IS_AMBIGUOUS If the path provided could refer to two different executables,
//!                                              this error will be returned.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_DeleteApplicationEx(NvDRSSessionHandle hSession, NvDRSProfileHandle hProfile, NVDRS_APPLICATION *pApp);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_DeleteApplication
//
//!   DESCRIPTION: This API removes an executable name from a profile.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  hSessionPARAMETERS   Input to the session handle.
//! \param [in]  hProfile             Input profile handle.
//! \param [in]  appName              Input the executable name to be removed.
//!                
//! \retval ::NVAPI_OK     SUCCESS
//! \retval ::NVAPI_ERROR  For miscellaneous errors.
//! \retval ::NVAPI_EXECUTABLE_PATH_IS_AMBIGUOUS If the path provided could refer to two different executables,
//!                                              this error will be returned
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_DeleteApplication(NvDRSSessionHandle hSession, NvDRSProfileHandle hProfile, NvAPI_UnicodeString appName);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_GetApplicationInfo
//
//!   DESCRIPTION: This API gets information about the given application.  The input application name
//!                must match exactly what the Profile has stored for the application. 
//!                This function is better used to retrieve application information from a previous
//!                enumeration.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   hSession       Input to the session handle.
//! \param [in]   hProfile       Input profile handle.
//! \param [in]   appName        Input application name.
//! \param [out]  *pApplication  Returns NVDRS_APPLICATION struct with all the attributes.
//!                
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. 
//!          If there are return error codes with specific meaning for this API, 
//!          they are listed below.
//! \retval ::NVAPI_EXECUTABLE_PATH_IS_AMBIGUOUS   The application name could not 
//                                                single out only one executable.
//! \retval ::NVAPI_EXECUTABLE_NOT_FOUND           No application with that name is found on the profile.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_GetApplicationInfo(NvDRSSessionHandle hSession, NvDRSProfileHandle hProfile, NvAPI_UnicodeString appName, NVDRS_APPLICATION *pApplication);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_EnumApplications
//
//!   DESCRIPTION: This API enumerates all the applications in a given profile from the starting index to the maximum length.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]      hSession         Input to the session handle.
//! \param [in]      hProfile         Input profile handle.
//! \param [in]      startIndex       Indicates starting index for enumeration.
//! \param [in,out]  *appCount        Input maximum length of the passed in arrays. Returns the actual length.
//! \param [out]     *pApplication    Returns NVDRS_APPLICATION struct with all the attributes.
//!                
//! \retval ::NVAPI_OK               SUCCESS
//! \retval ::NVAPI_ERROR            For miscellaneous errors.
//! \retval ::NVAPI_END_ENUMERATION  startIndex exceeds the total appCount.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_EnumApplications(NvDRSSessionHandle hSession, NvDRSProfileHandle hProfile, NvU32 startIndex, NvU32 *appCount, NVDRS_APPLICATION *pApplication);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_FindApplicationByName
//
//!   DESCRIPTION: This API searches the application and the associated profile for the given application name.
//!                If a fully qualified path is provided, this function will always return the profile
//!                the driver will apply upon running the application (on the path provided).
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   hSession       Input to the hSession handle
//! \param [in]   appName        Input appName. For best results, provide a fully qualified path of the type
//!                              c:/Folder1/Folder2/App.exe
//! \param [out]  *phProfile     Returns profile handle.
//! \param [out]  *pApplication  Returns NVDRS_APPLICATION struct pointer.
//!                
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. 
//!                  If there are return error codes with specific meaning for this API, 
//!                  they are listed below:
//! \retval ::NVAPI_APPLICATION_NOT_FOUND          If App not found
//! \retval ::NVAPI_EXECUTABLE_PATH_IS_AMBIGUOUS   If the input appName was not fully qualified, this error might return in the case of multiple matches
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_FindApplicationByName(NvDRSSessionHandle hSession, NvAPI_UnicodeString appName, NvDRSProfileHandle *phProfile, NVDRS_APPLICATION *pApplication);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_SetSetting
//
//!   DESCRIPTION: This API adds/modifies a setting to a profile.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  hSession     Input to the session handle.
//! \param [in]  hProfile     Input profile handle.
//! \param [in]   *pSetting   Input NVDRS_SETTING struct pointer.
//!                
//! \retval ::NVAPI_OK     SUCCESS
//! \retval ::NVAPI_ERROR  For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_SetSetting(NvDRSSessionHandle hSession, NvDRSProfileHandle hProfile, NVDRS_SETTING *pSetting);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_GetSetting
//
//!   DESCRIPTION: This API gets information about the given setting.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   hSession   Input to the session handle.
//! \param [in]   hProfile   Input profile handle.
//! \param [in]   settingId  Input settingId.
//! \param [out]  *pSetting  Returns all the setting info
//!                
//! \retval ::NVAPI_OK     SUCCESS
//! \retval ::NVAPI_ERROR  For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_GetSetting(NvDRSSessionHandle hSession, NvDRSProfileHandle hProfile, NvU32 settingId, NVDRS_SETTING *pSetting);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_EnumSettings
//
//!   DESCRIPTION: This API enumerates all the settings of a given profile from startIndex to the maximum length.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]      hSession        Input to the session handle.
//! \param [in]      hProfile        Input profile handle.
//! \param [in]      startIndex      Indicates starting index for enumeration.
//! \param [in,out]  *settingsCount  Input max length of the passed in arrays, Returns the actual length.
//! \param [out]     *pSetting       Returns all the settings info.
//!                
//! \retval ::NVAPI_OK              SUCCESS
//! \retval ::NVAPI_ERROR           For miscellaneous errors.
//! \retval ::NVAPI_END_ENUMERATION startIndex exceeds the total appCount.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_EnumSettings(NvDRSSessionHandle hSession, NvDRSProfileHandle hProfile, NvU32 startIndex, NvU32 *settingsCount, NVDRS_SETTING *pSetting);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_EnumAvailableSettingIds
//
//!   DESCRIPTION: This API enumerates all the Ids of all the settings recognized by NVAPI.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [out]    pSettingIds     User-provided array of length *pMaxCount that NVAPI will fill with IDs.
//! \param [in,out] pMaxCount       Input max length of the passed in array, Returns the actual length.
//!                
//! \retval ::NVAPI_OK     SUCCESS
//! \retval ::NVAPI_ERROR  For miscellaneous errors.
//!                  NVAPI_END_ENUMERATION: the provided pMaxCount is not enough to hold all settingIds.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_EnumAvailableSettingIds(NvU32 *pSettingIds, NvU32 *pMaxCount);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_EnumAvailableSettingValues
//
//!   DESCRIPTION: This API enumerates all available setting values for a given setting.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]      settingId          Input settingId.
//! \param [in,out]  maxNumCount        Input max length of the passed in arrays, Returns the actual length.
//! \param [out]     *pSettingValues    Returns all available setting values and its count.
//!                
//! \retval ::NVAPI_OK     SUCCESS
//! \retval ::NVAPI_ERROR  For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_EnumAvailableSettingValues(NvU32 settingId, NvU32 *pMaxNumValues, NVDRS_SETTING_VALUES *pSettingValues);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_GetSettingIdFromName
//
//!   DESCRIPTION: This API gets the binary ID of a setting given the setting name.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   settingName  Input Unicode settingName.
//! \param [out]  *pSettingId  Returns corresponding settingId.
//!                
//! \retval ::NVAPI_OK                 SUCCESS if the profile is found
//! \retval ::NVAPI_PROFILE_NOT_FOUND  if profile is not found
//! \retval ::NVAPI_SETTING_NOT_FOUND  if setting is not found
//! \retval ::NVAPI_ERROR              For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_GetSettingIdFromName(NvAPI_UnicodeString settingName, NvU32 *pSettingId);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_GetSettingNameFromId
//
//!   DESCRIPTION: This API gets the setting name given the binary ID.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  settingId        Input settingId.
//! \param [in]  *pSettingName    Returns corresponding Unicode settingName.
//!                
//! \retval ::NVAPI_OK                 SUCCESS if the profile is found
//! \retval ::NVAPI_PROFILE_NOT_FOUND  if profile is not found
//! \retval ::NVAPI_SETTING_NOT_FOUND  if setting is not found
//! \retval ::NVAPI_ERROR              For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_GetSettingNameFromId(NvU32 settingId, NvAPI_UnicodeString *pSettingName);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_DeleteProfileSetting
//
//!   DESCRIPTION: This API deletes a setting or sets it back to predefined value.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  hSession            Input to the session handle.
//! \param [in]  hProfile            Input profile handle.
//! \param [in]  settingId           Input settingId to be deleted.
//!                
//! \retval ::NVAPI_OK     SUCCESS if the profile is found
//! \retval ::NVAPI_ERROR  For miscellaneous errors.
//!
//! \ingroup drsapi
/////////////////////////////////////////////////////////////////////////////// 
NVAPI_INTERFACE NvAPI_DRS_DeleteProfileSetting(NvDRSSessionHandle hSession, NvDRSProfileHandle hProfile, NvU32 settingId);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_RestoreAllDefaults
//
//!   DESCRIPTION: This API restores the whole system to predefined(default) values.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  hSession  Input to the session handle.
//!                
//! \retval ::NVAPI_OK     SUCCESS if the profile is found
//! \retval ::NVAPI_ERROR  For miscellaneous errors.
//!
//! \ingroup drsapi
/////////////////////////////////////////////////////////////////////////////// 
NVAPI_INTERFACE NvAPI_DRS_RestoreAllDefaults(NvDRSSessionHandle hSession);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_RestoreDefaultSettings
//
//!   DESCRIPTION: This API either restores or ignores the given settings to predefined(default) values for 
//!                either a single profile(if valid hProfile is passed) or all profiles(if hProfile is NULL).
//!                Or restores all settings if pSettings = NULL and numSettings = 0.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  hSession    Input to the session handle.
//! \param [in]  hProfile    Input profile handle. If hProfile is NULL, this API will restore/ignore settings for all profiles. 
//! \param [in]  pSettingIds Input list of settingIds to be ignored or restored. pSettings must be NULL if all settings need to be restored.
//! \param [in]  numSettings Input number of settings to be ignored or restored.  numSettings must be 0 if all settings need to be restored.
//! \param [in]  bIgnore     Input flag, if true, ignores else includes the given settings while restoring all profiles.
//!      
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, 
//!         they are listed below.          
//! \retval ::NVAPI_INVALID_USER_PRIVILEGE
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_RestoreDefaultSettings(__in NvDRSSessionHandle hSession, __in NvDRSProfileHandle hProfile, 
                                                 __in_ecount_opt(numSettings) NvU32 *pSettingIds, 
                                                 __in NvU32 numSettings, __in NvU8 bIgnore);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_RestoreProfileDefault
//
//!   DESCRIPTION: This API restores the given profile to predefined(default) values.
//!                Any and all user specified modifications will be removed. 
//!                If the whole profile was set by the user, the profile will be removed.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  hSession  Input to the session handle.
//! \param [in]  hProfile  Input profile handle.
//!                
//! \retval ::NVAPI_OK              SUCCESS if the profile is found
//! \retval ::NVAPI_ERROR           For miscellaneous errors.
//! \retval ::NVAPI_PROFILE_REMOVED SUCCESS, and the hProfile is no longer valid.
//! \retval ::NVAPI_ERROR           For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_RestoreProfileDefault(NvDRSSessionHandle hSession, NvDRSProfileHandle hProfile);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_RestoreProfileDefaultSetting
//
//!   DESCRIPTION: This API restores the given profile setting to predefined(default) values.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  hSession  Input to the session handle.
//! \param [in]  hProfile  Input profile handle.
//! \param [in]  settingId Input settingId.
//!                
//! \retval ::NVAPI_OK     SUCCESS if the profile is found
//! \retval ::NVAPI_ERROR  For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_RestoreProfileDefaultSetting(NvDRSSessionHandle hSession, NvDRSProfileHandle hProfile, NvU32 settingId);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_EnumUISettingValues
//
//!   DESCRIPTION: Enumerate all the settings of a given profile from startIndex to the max length, but only if the setting is User Visible.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]      hSession        Input to the session handle.
//! \param [in]      hProfile        Input profile handle.
//! \param [in]      startIndex      Indicates starting index for enumeration.
//! \param [in,out]  *settingsCount  Input max length of the passed in arrays, Returns the actual length.
//! \param [out]     *pSetting       Returns all the settings info.
//!                
//! \retval ::NVAPI_OK               SUCCESS 
//! \retval ::NVAPI_ERROR            For miscellaneous errors.
//! \retval ::NVAPI_END_ENUMERATION  startIndex exceeds the total appCount.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_EnumUISettingValues(NvDRSSessionHandle hSession, NvDRSProfileHandle hProfile, NvU32 startIndex, NvU32 *settingsCount, NVDRS_SETTING *pSetting);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_GetDefaultGlobalProfile
//
//!   DESCRIPTION: This APi returns the handle to the default global profile.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   hSession   Input to the session handle.
//! \param [out]  *phProfile Returns default Global profile handle.
//!                
//! \retval ::NVAPI_OK     SUCCESS if the profile is found
//! \retval ::NVAPI_ERROR  For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_GetDefaultGlobalProfile(NvDRSSessionHandle hSession, NvDRSProfileHandle *phProfile);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_FindApplicationEx
//
//!   DESCRIPTION: This API searches the DRS db indicated by hSession trying to find an application
//!                as described in the in/out structure pApplication.
//!                If exactMatch is false, follows the same behavior as NvAPI_DRS_FindApplicationByName.
//!                  It will try to see which profile will get applied to an application as described by
//!                  pApplication.
//!                If exactMatch is true, then:
//!                  It will return only if there is an exact match, case insensitive. 
//!                  If FindFile is to be used, this field needs to be initialized.
//!                WARNING: the pApplication structure should be 'zero initialized' to guarantee that
//!                  all the strings it contains are either correct or empty. Lack of initialization can
//!                  result in garbage strings being considered input. 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   hSession       Input to the hSession handle
//! \param [in]   exactMatch     Boolean indicating whether an exact match is requested
//! \param [in,out]  *pApplication  NVDRS_APPLICATION struct describing the application to look for. If one is found,
//!                              this structure is filled with all information.
//! \param [out]  *phProfile     Returns profile handle.
//!                
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. 
//!                  If there are return error codes with specific meaning for this API, 
//!                  they are listed below:
//! \retval ::NVAPI_APPLICATION_NOT_FOUND          If App not found
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_FindApplicationEx(__in NvDRSSessionHandle hSession, __in NvU32 exactMatch, __inout NVDRS_APPLICATION *pApplication, __out NvDRSProfileHandle *phProfile);




//! \ingroup drsapi
typedef struct _NVDRS_VERSION_INFORMATION
{
     NvU32                      version;            //!< Structure Version
     NvAPI_LongString           driverTitle;        //!< Is the driver-title string for the latest writer to the DB
     NvAPI_UnicodeString        systemDrsPath;      //!< Is the path to the system location of the DRS DB. SWAK wants this
     NvU32                      changelistNumber;   //!< The changelist when the latest writer to the DB was built
     NvU32                      drslibVersion;      //!< Version of the NvDrsLib, seldom changes
} NVDRS_VERSION_INFORMATION;

//! Macro for constructing the version field of NVDRS_VERSION_INFORMATION
#define NVDRS_VERSION_INFORMATION_VER        MAKE_NVAPI_VERSION(NVDRS_VERSION_INFORMATION,1)

///////////////////////////////////////////////////////////////////////////////
//  This API is meant FOR SWAK USE ONLY.  Please contact
//  sw-nvapi if you wish to use this interface.
//
// FUNCTION NAME: NvAPI_DRS_GetSystemDrsVersion
//
//! \code
//!   DESCRIPTION: Retrieves the version information for the system DRS files. 
//!                It includes the driverTitle (a string), the changelistNumber an a 
//!                nvdrslib version number.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//!   PARAMETERS: NVDRS_VERSION_INFORMATION (OUT)  - Structure containing all the version information
//!
//! RETURN STATUS: NVAPI_INVALID_ARGUMENT: argument is NULL
//!                NVAPI_OK: The DRS version information is retrieved.
//!                NVAPI_ERROR: For miscellaneous errors.
//!                NVAPI_NOT_SUPPORTED: If the system does not support DRS
//! \endcode
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_GetSystemDrsVersion(NVDRS_VERSION_INFORMATION *pVersionInformation);

///////////////////////////////////////////////////////////////////////////////
//  This API is meant FOR SWAK USE ONLY.  Please contact
//  sw-nvapi if you wish to use this interface.
//
// FUNCTION NAME: NvAPI_DRS_GetGoldDBDrsVersion
//
//! \code
//!   DESCRIPTION: Retrieves the version information for the Gold DB DRS. 
//!                It includes the driverTitle (a string), the changelistNumber an a 
//!                nvdrslib version number.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//!   PARAMETERS: NVDRS_VERSION_INFORMATION (OUT)  - Structure containing all the version information
//!
//! RETURN STATUS: NVAPI_INVALID_ARGUMENT: argument is NULL
//!                NVAPI_OK: The DRS version information is retrieved.
//!                NVAPI_ERROR: For miscellaneous errors.
//!                NVAPI_NOT_SUPPORTED: If the system does not support DRS
//! \endcode
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_GetGoldDBDrsVersion(NVDRS_VERSION_INFORMATION *pVersionInformation);


///////////////////////////////////////////////////////////////////////////////
//  This API is meant FOR SWAK USE ONLY.  Please contact
//  sw-nvapi if you wish to use this interface.
//
// FUNCTION NAME: NvAPI_DRS_GetGoldDBDrsVersionEx
//
//! \code
//!   DESCRIPTION: Retrieves the version information for the Gold DB DRS. 
//!                It includes the driverTitle (a string), the changelistNumber an a 
//!                nvdrslib version number.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//!   PARAMETERS: NVDRS_VERSION_INFORMATION (OUT)  - Structure containing all the version information
//!
//! RETURN STATUS: NVAPI_INVALID_ARGUMENT: argument is NULL
//!                NVAPI_OK: The DRS version information is retrieved.
//!                NVAPI_ERROR: For miscellaneous errors.
//!                NVAPI_NOT_SUPPORTED: If the system does not support DRS
//! \endcode
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_GetGoldDBDrsVersionEx(NVDRS_VERSION_INFORMATION *pVersionInformation);


//! \ingroup drsapi
typedef enum _NVDRS_VERSION_TARGET
{
     NVDRS_SYSTEM_DB = 0,
     NVDRS_GOLD_DB,
     NVDRS_UPDATE_DB
} NVDRS_VERSION_TARGET;


///////////////////////////////////////////////////////////////////////////////
//  This API is meant FOR SWAK USE ONLY.  Please contact
//  sw-nvapi if you wish to use this interface.
//
//! \code
//! FUNCTION NAME: NvAPI_DRS_GetDrsVersion
//!
//!   DESCRIPTION: Retrieves the version information for a given DRS DB.
//!                The supported DRS DBs are those of the NVDRS_VERSION_TARGET enum. 
//!                Currently we support the System DB, the Gold DB and the Update DB.
//!                The update is delivered through the GFE deamon or upon user request.
//!                The version is returned on the NVDRS_VERSION_INFORMATION struct, 
//!                it includes the driverTitle (a string), the changelistNumber and a
//!                nvdrslib version number.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//!   PARAMETERS: NVDRS_VERSION_TARGET (IN)        - Enum identifying which DRS DB to target
//!   PARAMETERS: NVDRS_VERSION_INFORMATION (OUT)  - Structure containing all the version information
//!
//! RETURN STATUS: NVAPI_INVALID_ARGUMENT: argument is NULL, or the enum is not recognized
//!                NVAPI_OK: The DRS version information is retrieved.
//!                NVAPI_FILE_NOT_FOUND : There was no update found
//!                NVAPI_ERROR: For miscellaneous errors.
//!                NVAPI_NOT_SUPPORTED: If the system does not support DRS
//! \endcode
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_GetDrsVersion(NVDRS_VERSION_TARGET target, NVDRS_VERSION_INFORMATION *pVersionInformation);






///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_SetBaseProfile
//
//! \code
//!   DESCRIPTION: Sets the current global profile in the driver.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//!   PARAMETERS: NvDRSSessionHandle(IN)  - Input to the session handle.
//!               NvAPI_UnicodeString(IN) - Input Base profile name.
//!                
//!   RETURN STATUS: NVAPI_OK: SUCCESS
//!                  NVAPI_ERROR: For miscellaneous errors.
//! \endcode
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_SetBaseProfile(NvDRSSessionHandle hSession, NvAPI_UnicodeString wszBaseProfileName);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_GetBaseProfile
//
//!   DESCRIPTION: Returns the handle to the current global profile.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  hSession    Input to the session handle.
//! \param [in]  *phProfile   Returns Base profile handle.
//!                
//! \retval ::NVAPI_OK     SUCCESS if the profile is found
//! \retval ::NVAPI_ERROR  For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_GetBaseProfile(NvDRSSessionHandle hSession, NvDRSProfileHandle *phProfile);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_SetSettingEx
//
//!   DESCRIPTION: This API adds/modifies a setting to a Profile, with the option to specify the setting as predefined
//!      Predefined settings are 'default' values for settings and profiles as specified by NVIDIA.
//!      We do not want these settings being set outside NVIDIA, but this functionality is needed in order
//!      to implement Coproc on a timely manner in R256. 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   hSession      Input to the session handle.
//! \param [in]   hProfile      Input profile handle.
//! \param [in]   *pSetting     Input NVDRS_SETTING struct pointer.
//! \param [in]   isPredefined  Input 'boolean' indicating whether the setting is Predefined or not
//! \param [in]   isOverride    Input 'boolean' indicating whether the setting is Override, meaning
//!                             that it has precedence over all ACE settings. Only valid for the Base Profile.
//!                
//! \retval ::NVAPI_OK     SUCCESS if the profile is found
//! \retval ::NVAPI_ERROR  For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_SetSettingEx(NvDRSSessionHandle hSession, NvDRSProfileHandle hProfile, NVDRS_SETTING *pSetting, NvU32 isPredefined, NvU32 isOverride);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_GetSettingEx
//
//! \code
//!   DESCRIPTION: Get the information of the given setting, for internal use only
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//!   PARAMETERS: NvDRSSessionHandle(IN)  - Input to the session handle.
//!               NvDRSProfileHandle(IN)  - Input profile handle.
//!               NvU32(IN)               - Input settingId.
//!               NVDRS_SETTING(OUT)      - Returns all the setting info
//!               NvU32(OUT)              - Returns whether the setting is Override or not.
//!                
//!   RETURN STATUS: NVAPI_OK: SUCCESS
//!                  NVAPI_ERROR: For miscellaneous errors.
//! \endcode
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_GetSettingEx(NvDRSSessionHandle hSession, NvDRSProfileHandle hProfile, NvU32 settingId, NVDRS_SETTING *pSetting, NvU32 *isOverride);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_CreateApplicationEx
//
//!   DESCRIPTION: This API adds an executable name to a profile, allows to specify the executable as predefined.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  hSession       Input to the session handle.
//! \param [in]  hProfile       Input profile handle.
//! \param [in]  *pApplication  Input NVDRS_APPLICATION struct with the executable name to be added.
//! \param [in]  isPredefined   Input 'boolean' indicating whether the executable is Predefined or not
//!                
//! \retval ::NVAPI_OK     SUCCESS if the profile is found
//! \retval ::NVAPI_ERROR  For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_CreateApplicationEx(NvDRSSessionHandle hSession, NvDRSProfileHandle  hProfile, NVDRS_APPLICATION *pApplication, NvU32 isPredefined);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_CreateProfileEx
//
//!   DESCRIPTION: This API creates an empty profile, allowing the profile to be specified as predefined.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   hSession          Input to the session handle.
//! \param [in]   *pProfileInfo     Input pointer to NVDRS_PROFILE.
//! \param [out]  *phProfile        Returns pointer to profile handle.
//! \param [in]   isPredefined      Input 'boolean' indicating whether the profile is Predefined or not
//!                
//! \retval ::NVAPI_OK     SUCCESS if the profile is found
//! \retval ::NVAPI_ERROR  For miscellaneous errors.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_CreateProfileEx(NvDRSSessionHandle hSession, NVDRS_PROFILE *pProfileInfo, NvDRSProfileHandle *phProfile, NvU32 isPredefined);


typedef enum _NVDRS_FEATURE_ID
{
    NVDRS_FEATURE_ID_UNKNOWN = 0,
    NVDRS_FEATURE_ID_MFAA,
}NVDRS_FEATURE_ID;

typedef enum _NVDRS_FEATURE_MFAA_VALUES
{
    NVDRS_FEATURE_MFAA_UNKNOWN = 0,
    NVDRS_FEATURE_MFAA_OFF,
    NVDRS_FEATURE_MFAA_ON,
}NVDRS_FEATURE_MFAA_VALUES;

typedef struct _NVDRS_SETTING_INFO_V1
{
     NvU32                      version;                //!< Structure Version

     NVDRS_SETTING_V1           settingDetails;         //! Structure containing setting/feature details like the id, name, type of value(s), current value, default value, etc. 
     NvU32                      numSupportedValues;     //!< Total number of values supported in a setting.
     union                                              //!< Setting values can be of either DWORD, Binary values or String type.
     {                                                  //!< NOT mixed types.
         NvU32                      u32Value;           
         NVDRS_BINARY_SETTING       binaryValue;        
         NvAPI_UnicodeString        wszValue;           
     }supportedValues[NVAPI_SETTING_MAX_VALUES];        //!< Array of supported values.

} NVDRS_SETTING_INFO_V1;

#define NVDRS_SETTING_INFO_VER1        MAKE_NVAPI_VERSION(NVDRS_SETTING_INFO_V1, 1)

typedef NVDRS_SETTING_INFO_V1          NVDRS_SETTING_INFO;
#define NVDRS_SETTING_INFO_VER         NVDRS_SETTING_INFO_VER1


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_GetSettingInfo
//
//!   DESCRIPTION: This API returns setting info and supported values for the given setting. If the supported values are not found in the given profile, it will fallback to base/global profile.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]    hSession                   Session handle.
//! \param [in]    hProfile                   Profile handle.
//! \param [in]    settingId                  Setting(DRS setting id or feature id) for which the information needs to be queried.
//! \param [inout] pSettingInfo               Pointer to the structure containing data of the setting and the supported values for those setting.
//!                                           If caller passes in feature id(one of NV_DRS_FEATURE_ID enum values) in the 'settingId' argument, then 'settingDetails' structure of 'pSettingInfo' 
//!                                           argument will only have 'settingId', 'settingName', 'settingType' and current value('u32CurrentValue'/'binaryCurrentValue'/'wszCurrentValue')
//!                                           members set, other members will not be set.
//!                
//! \return    This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_GetSettingInfo(__in NvDRSSessionHandle hSession, __in NvDRSProfileHandle hProfile, __in NvU32 settingId, __inout NVDRS_SETTING_INFO *pSettingInfo);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_SetProfileData 
//
//!   DESCRIPTION: This API applies the setting values and their dependencies (if any) for the given setting(s).
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]    hSession                   Session handle.
//! \param [in]    hProfile                   Profile handle.
//! \param [in]    settingsCount              Number of setting info structures given by the user.
//! \param [in]    pSetting                   Pointer to the array of structures containing data to be set in the DRS database.
//!                
//! \return    This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//! \retval ::NVAPI_INVALID_ARGUMENT          If any of the setting ids are not supported for the given profile, the api will return this error code.
//! \retval ::NVAPI_NOT_SUPPORTED             If any user given setting value is not supported for the setting for the current system config, the api will return this error and 
//!                                           the api will not set any setting value.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_SetProfileData(__in NvDRSSessionHandle hSession, __in NvDRSProfileHandle hProfile, __in NvU32 settingsCount, __in NVDRS_SETTING *pSetting);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_GetLastDBChangeTime
//
//!   DESCRIPTION: This API returns the time stamp when the DRS database was last modified.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [out]   pLastModifyTime       Tells when the DRS database was last modified.
//!                                      Lower 32 bits contains the low-order part of the FILETIME structure. 
//!                                      Upper 32 bits contains the high-order part of the FILETIME structure. 
//!                
//! \return    This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!            specific meaning for this API, they are listed below.
//!
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_GetLastDBChangeTime(__out NvU64 *pLastModifyTime);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DRS_GetSettingForCurrentProcess
//
//!   DESCRIPTION: This function will retrieve a setting for the current process.
//! This function will only return settings as type DWORD, or BINARY. Any setting that
//!      is not of type DWORD, it will be considered BINARY. 
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]    settingId                  Input settingId.
//! \param [inout] pSettingInfo               Pointer to the structure containing data of the setting and the supported values for those setting.
//!
//! Return values:
//!      NVAPI_OK:                The setting has been found and returned. 
//!      NVAPI_ERROR:             Generic error when there has been an unexpected issue. 
//!      NVAPI_SETTING_NOT_FOUND: There has been no error, but the setting is not set anywhere. 
//! \ingroup drsapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DRS_GetSettingForCurrentProcess(__in NvU32 settingId, __inout NVDRS_SETTING *pSettingInfo);
////////////////////////////////////////DP MST SIMULATION APIs/////////////////////////////////////////////////////////////////////////////

//! \ingroup dpmst_fakemodel

#define DP_MST_MAX_EDID_DATA_SIZE 512

typedef struct
{
    NvU32      version;                        //!< Structure version
    NvU32      deviceType;                     //!< 
    NvU32      upstreamPorts;                  //!<
    NvU32      downstreamPorts;                //!<
    NvU32      validPorts;                     //!<
    NvU8       edidBuffer[DP_MST_MAX_EDID_DATA_SIZE]; //!< Buffer to hold the edid
    NvU32      edidLen;                        //!<
    NvU8       GUID[16];                       //!<

    NvU32      hasRevision12          : 1;     //!< 
    NvU32      hasAudio               : 1;     //!< 
    NvU32      reserved               : 30;    //!< Should be set to ZERO
} NV_DPFAKE_DEVICE_INFO_V1; 

#define NV_DPFAKE_DEVICE_INFO_VER1   MAKE_NVAPI_VERSION(NV_DPFAKE_DEVICE_INFO_V1,1)
#define NV_DPFAKE_DEVICE_INFO_VER     NV_DPFAKE_DEVICE_INFO_VER1

typedef NV_DPFAKE_DEVICE_INFO_V1 NV_DPFAKE_DEVICE_INFO;

//! \ingroup dpmst_fakemodel
typedef struct
{
    NvU32                   version;                    //!< Structure version
    NvU32                   lanes;                      //!< 
    NvU64                   peakRate;                   //!<
    NvU64                   minRate;                    //!<
    NvU32                   currentUsedPBN;             //!< 
    
    NvU32                   isEnhancedFraming   : 1;    //!< 
    NvU32                   isValid             : 1;    //!< 
    NvU32                   isInput             : 1;    //!< 
    NvU32                   isPlugged           : 1;    //!< 
    NvU32                   isMultiStream       : 1;    //!< 
    NvU32                   reserved            : 27;   //!< Should be set to ZERO
} NV_DPFAKE_DEVICE_CONNECTION_INFO_V1; 

#define NV_DPFAKE_DEVICE_CONNECTION_INFO_VER1   MAKE_NVAPI_VERSION(NV_DPFAKE_DEVICE_CONNECTION_INFO_V1,1)
#define NV_DPFAKE_DEVICE_CONNECTION_INFO_VER     NV_DPFAKE_DEVICE_CONNECTION_INFO_VER1

typedef NV_DPFAKE_DEVICE_CONNECTION_INFO_V1 NV_DPFAKE_DEVICE_CONNECTION_INFO;
   

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DPFAKE_CreateModel
//
//!   DESCRIPTION:  This API creates the DP MST fake model
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! 
//! \param [in]     displayId     The display ID of the DP1.2 connector.
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval  NVAPI_OK         Completed request
//!
//! \ingroup dpmst_fakemodel
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DPFAKE_CreateModel(__in NvU32 displayId);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DPFAKE_DestroyModel
//
//!   DESCRIPTION:  This API destroys the DP MST fake model that was previously created using NvAPI_DPFAKE_CreateModel.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! 
//! \param [in]     displayId     The display ID of the DP1.2 connector.
//! \param [in]     afterMsecs    The delay in milli seconds after which the fake model will be teared down.
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval  NVAPI_OK         Completed request
//!
//! \ingroup dpmst_fakemodel
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DPFAKE_DestroyModel(__in NvU32 displayId, __in NvU32 afterMsecs);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DPFAKE_StopSimulation
//
//!   DESCRIPTION:  This API stops simulation, and replaces FakeModel's AuxBus implementation by the 
//!   saved DD's AuxBus. Real devices can now be connected.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! 
//! \param [in]     displayId     The display ID of the DP1.2 connector.
//! \param [in]     afterMsecs    Delay (in milliseconds) after which to stop simulation
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval  NVAPI_OK         Completed request
//!
//! \ingroup dpmst_fakemodel
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DPFAKE_StopSimulation(__in NvU32 displayId, __in NvU32 afterMsecs);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DPFAKE_StartSimulation
//
//!   DESCRIPTION:  This API saves and replaces DD's AuxBus implementation with DP FakeModel's implementation, 
//!   and starts simulation with deviceID as root (first branch).
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! 
//! \param [in]   displayId         The display ID of the DP1.2 connector.
//! \param [in]   fakeDeviceRootId  Fake device to be set as root (first branch)
//! \param [in]   afterMsecs        Delay (in milliseconds) after which to fire the start simulation event
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval  NVAPI_OK         Completed request
//!
//! \ingroup dpmst_fakemodel
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DPFAKE_StartSimulation(__in NvU32 displayId, __in NvU32 fakeDeviceRootId, __in NvU32 afterMsecs);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DPFAKE_ConnectDevice
//
//!   DESCRIPTION:  This API connects two devices together on the specified ports.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]   displayId             The display ID of the DP1.2 connector. 
//! \param [in]   fakeDeviceparentId    Device ID of parent device 
//! \param [in]   fakeDeviceParentPort  Port on parent device
//! \param [in]   fakeDeviceChildId     Device ID of child device
//! \param [in]   fakeDeviceChildPort   Port on child device
//! \param [in]   afterMsecs            Delay (in milliseconds) after which to fire the connect event
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval  NVAPI_OK         Completed request
//!
//! \ingroup dpmst_fakemodel
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DPFAKE_ConnectDevice(__in NvU32 displayId, __in NvU32 fakeDeviceparentId, __in NvU32 fakeDeviceParentPort, __in NvU32 fakeDeviceChildId, __in NvU32 fakeDeviceChildPort, __in NvU32 afterMsecs);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DPFAKE_DisconnectDevice
//
//!   DESCRIPTION:  This API disconnects the specified port on the device with ID fakeDeviceID.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]   displayId             The display ID of the DP1.2 connector. 
//! \param [in]   fakeDeviceId          Fake device ID
//! \param [in]   fakeDevicePort        Port to be disconnected
//! \param [in]   afterMsecs            Delay (in milliseconds) after which to fire the disconnect event
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval  NVAPI_OK         Completed request
//!
//! \ingroup dpmst_fakemodel
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DPFAKE_DisconnectDevice(__in NvU32 displayId, __in NvU32 fakeDeviceId, __in NvU32 fakeDevicePort, __in NvU32 afterMsecs);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DPFAKE_NewFakeDevice
//
//!   DESCRIPTION:  This API adds a new device to the DP MST fake model that was previously created using NvAPI_DPFAKE_CreateModel.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]   displayId             The display ID of the DP1.2 connector.
//! \param [in]   pDpFakeDeviceInfo     Pointer to NV_DPFAKE_DEVICE_INFO that defines the new device being added. 
//! \param [out]  pFakeDeviceId         Pointer to a NvU32 variable that receives the deviceId of the new fake device that was added
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval  NVAPI_OK         Completed request
//!
//! \ingroup dpmst_fakemodel
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DPFAKE_NewFakeDevice(__in NvU32 displayId, __in NV_DPFAKE_DEVICE_INFO* pDpFakeDeviceInfo, __out NvU32* pFakeDeviceId);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DPFAKE_ChangeBandwidthOnLink
//
//!   DESCRIPTION:  This API changes the bandwidth on the link specified by the deviceID and port number to (newRate, newLanes).
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]   displayId             The display ID of the DP1.2 connector.
//! \param [in]   fakeDeviceId          Id of the fake device
//! \param [in]   fakeDevicePort        Port number on the fake device
//! \param [in]   newRate               New Link Rate
//! \param [in]   newLanes              New Number of Lanes
//! \param [in]   isLinkSupportedChange Change LinkSupported (max link config)
//! \param [in]   afterMsecs            Delay (in milliseconds) after which to fire the change bandwidth event
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval  NVAPI_OK         Completed request
//!
//! \ingroup dpmst_fakemodel
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DPFAKE_ChangeBandwidthOnLink(__in NvU32 displayId, __in NvU32 fakeDeviceId, __in NvU32 fakeDevicePort, __in NvU64 newRate, __in NvU32 newLanes, __in NvU8 isLinkSupportedChange, __in NvU32 afterMsecs);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DPFAKE_GetFakeDeviceProperties
//
//!   DESCRIPTION:  This API gets the properties of a fake device.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]   displayId             The display ID of the DP1.2 connector.
//! \param [in]   fakeDeviceId          Id of the fake device
//! \param [out]  pDpFakeDeviceInfo     Pointer to NV_DPFAKE_DEVICE_INFO that returns the properties of the device. 
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval  NVAPI_OK         Completed request
//!
//! \ingroup dpmst_fakemodel
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DPFAKE_GetFakeDeviceProperties(__in NvU32 displayId, __in NvU32 fakeDeviceId, __inout NV_DPFAKE_DEVICE_INFO* pDpFakeDeviceInfo);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DPFAKE_GetDeviceConnectionProperties
//
//!   DESCRIPTION:  This API gets the properties of a connection on a fake device.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]   displayId                     The display ID of the DP1.2 connector.
//! \param [in]   fakeDeviceID                  Id of the fake device 
//! \param [in]   fakeDevicePort                The port number on the fake device 
//! \param [out]  pDpFakeDeviceConnectionInfo   Pointer to NV_DPFAKE_DEVICE_CONNECTION_INFO that returns the properties of the device. 
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval  NVAPI_OK         Completed request
//!
//! \ingroup dpmst_fakemodel
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DPFAKE_GetDeviceConnectionProperties(__in NvU32 displayId, __in NvU32 fakeDeviceId, __in NvU32 fakeDevicePort, __inout NV_DPFAKE_DEVICE_CONNECTION_INFO* pDpFakeDeviceInfo);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DPFAKE_CheckSimulationStatus
//
//!   DESCRIPTION:  This API checks on the connector specified by the display ID whether: 1. FakeModel has been built, 2. Simulation is currently running and 3. Simulation setup is done
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//! 
//! \param [in]     displayId           The display ID of the DP1.2 connector.
//! \param [out]  fakeModelStatus       Status whether fake model has already been built on this connector
//! \param [out]  simulationStatus      Status whether simulation is running on this connector
//! \param [out]  simulationSetupStatus Status whether simulation has been setup successfully
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval  NVAPI_OK         Completed request
//!
//! \ingroup dpmst_fakemodel
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DPFAKE_CheckSimulationStatus(__in NvU32 displayId, __out NvU32* fakeModelStatus, __out NvU32* simulationStatus, __out NvU32* simulationSetupStatus);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DPFAKE_NotifySimulationSetupCompletion
//
//!   DESCRIPTION:  This API sets sets the status in FakeModel kernel module when the simulation setup is complete
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]   displayId             The display ID of the DP1.2 connector. 
//! \param [in]   afterMsecs            Delay (in milliseconds) after which simulation setup status will be set as completed
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval  NVAPI_OK         Completed request
//!
//! \ingroup dpmst_fakemodel
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DPFAKE_NotifySimulationSetupCompletion(__in NvU32 displayId, __in NvU32 afterMsecs);
// FUNCTION NAME:   NvAPI_DPFAKE_ResetDPAssertBuffer
//
//!   DESCRIPTION:  This API resets the DP Assert ring buffer
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]   displayId                     The display ID of the DP1.2 connector.
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval  NVAPI_OK         Completed request
//!
//! \ingroup dpmst_fakemodel
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DPFAKE_ResetDPAssertBuffer(__in NvU32 displayId);


//! \ingroup dpmst_fakemodel
typedef struct
{
    NvU32      version;                        //!< Structure version

    NvU64      breakpointAddr;                 //!<
} NV_DPFAKE_DP_ASSERT_HIT_RECORD_V1;

//! \ingroup diagapi
#define NV_DPFAKE_DP_ASSERT_HIT_RECORD_VER1   MAKE_NVAPI_VERSION(NV_DPFAKE_DP_ASSERT_HIT_RECORD_V1,1)

//! \ingroup diagapi
#define NV_DPFAKE_DP_ASSERT_HIT_RECORD_VER     NV_DPFAKE_DP_ASSERT_HIT_RECORD_VER1

//! \ingroup diagapi
typedef NV_DPFAKE_DP_ASSERT_HIT_RECORD_V1 NV_DPFAKE_DP_ASSERT_HIT_RECORD;


//! \ingroup dpmst_fakemodel
typedef struct
{
    NvU32      version;                        //!< Structure version

    char       msg[100];                       //!<
    NvU64      addr;                           //!<
} NV_DPFAKE_DP_LOG_CALL_RECORD_V1;

//! \ingroup diagapi
#define NV_DPFAKE_DP_LOG_CALL_RECORD_VER1   MAKE_NVAPI_VERSION(NV_DPFAKE_DP_LOG_CALL_RECORD_V1,1)

//! \ingroup diagapi
#define NV_DPFAKE_DP_LOG_CALL_RECORD_VER     NV_DPFAKE_DP_LOG_CALL_RECORD_VER1

//! \ingroup diagapi
typedef NV_DPFAKE_DP_LOG_CALL_RECORD_V1 NV_DPFAKE_DP_LOG_CALL_RECORD;


//! Maximum DP log message length
#define NV_DPFAKE_DP_LOG_MAX_MESSAGE_LEN 100

//! Maximum count of DP log records
#define NV_DPFAKE_DP_LOG_MAX_RECORD_COUNT 15

//! \ingroup diagapi
typedef enum _NV_DPFAKE_DP_LOG_QUERY_TYPE
{
    NV_DPFAKE_DP_LOG_QUERY_SIZE     = 0,
    NV_DPFAKE_DP_LOG_QUERY_ASSERT   = 1,
    NV_DPFAKE_DP_LOG_QUERY_DPLOGS   = 2,
} NV_DPFAKE_DP_LOG_QUERY_TYPE;


//! \ingroup diagapi
typedef union _NV_DPFAKE_DP_LOG_RECORD
{
    NV_DPFAKE_DP_ASSERT_HIT_RECORD  dpAssertHitRecord;      //!< Assert record
    NV_DPFAKE_DP_LOG_CALL_RECORD    dpLogCallRecord;        //!< Call record
} NV_DPFAKE_DP_LOG_RECORD;

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_DPFAKE_QueryDPLogs
//
//!   DESCRIPTION:  This API fetches the DP logs in the buffer passed
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]         displayId             The display ID of the DP1.2 connector. 
//! \param [in]         logQueryType          Type specifying if Assert logs or normal logs are to be queried
//! \param [out]        records               Buffer for copying the assert logs.
//! \param [in,out]     numRecords            The number of enteries buffer can hold and in case of output it denotes the number of enteries filled.
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!         If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \retval  NVAPI_OK         Completed request
//!
//! \ingroup dpmst_fakemodel
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DPFAKE_QueryDPLogs(__in NvU32 displayId, __in NV_DPFAKE_DP_LOG_QUERY_TYPE logQueryType, __out NV_DPFAKE_DP_LOG_RECORD *records, __inout NvU32 *numRecords);



//! \ingroup diagapi
typedef struct
{
    NvU32           version;                           //!< Structure version
    
    NvU32           TDRcount;                          //!< TDR count of the GPU
    NvU32           RCcount;                           //!< Robust Channel(RC) handler call count of the GPU
    NvU32           maxConsecutiveRC;                  //!< Max consecutive RC count for the GPU
} NV_TDR_INFO_V1;

//! \ingroup diagapi
typedef NV_TDR_INFO_V1 NV_TDR_INFO;

//! \ingroup diagapi
#define NV_TDR_INFO_VER_1 MAKE_NVAPI_VERSION(NV_TDR_INFO_V1,1)

//! \ingroup diagapi
#define NV_TDR_INFO_VER   NV_TDR_INFO_VER_1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_GPU_GetTDRInfo
//
//! DESCRIPTION:    This function gets Timeout Detection and Recovery (TDR) information of the GPU, 
//!                 whose Physical GPU Handle is passed as input.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]          hPhysicalGpu     A handle identifying the GPU, whose TDR Information is needed.
//! \param [in,out]      tdrInfo          The pointer for the input structure containing the TDR info.
//!
//! \return      This API can return any of the error codes enumerated in #NvAPI_Status. 
//!              Error codes specific to this API are described below.
//!              (None)
//! \ingroup diagapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetTDRInfo(__in NvPhysicalGpuHandle hPhysicalGpu ,__inout NV_TDR_INFO* tdrInfo);









//! \ingroup diagapi
typedef struct _NV_DISPLAYID_ENTRY_V1
{
    NvU32           version;

    NvU32           displayId;                  //!< this is a unique identifier for each device

    /*!
     * The following 3 fields are valid only when there is an associated monitor with this display Id. When the display Id table goes corrupt the 
     * following three fields will have incorrect values. In such cases the direct dump data below will help triage the issues
     */

    NvU32           targetId;                   //!< target Id of the monitor.
    NvU32           monitorHandlePosition;      //!< DD's internal monitor handle position value
    NvU32           deviceId;                   //!< RM display id associated with the monitor. For devices in MST this is dynamically allocated. 

    /*!
     * The following fields are dumped directly from the internal display id table
     */
    NvU32           ddmonitorHandlePosition;    //!< DD's internal monitor handle position value
    NvU32           rmDisplayID;                //!< valid only for for legacy displays. DP 1.2 MultiStream displays will have a dynamically allocated id which will be populated in the above devideId field.
    NvU32           rmRootDisplayID;            //!< DP 1.2 Root Node RM displayId (only used for DP 1.2 MultiStream displays)
    NV_DP_ADDRESS   rmAuxAddress;               //!< DP 1.2 Address (only used for DP 1.2 MultiStream displays)
    NvU32           ddClusterId;                //!< Id of the cluster which is represented by this display Id
} NV_DISPLAYID_ENTRY_V1;

//! \ingroup diagapi
typedef struct _NV_DISPLAYID_ENTRY_V2
{
    NvU32           version;

    NvU32           displayId;                  //!< this is a unique identifier for each device

    /*!
     * The following 3 fields are valid only when there is an associated monitor with this display Id. When the display Id table goes corrupt the 
     * following three fields will have incorrect values. In such cases the direct dump data below will help triage the issues
     */

    NvU32           targetId;                   //!< target Id of the monitor.
    NvU32           monitorHandlePosition;      //!< DD's internal monitor handle position value
    NvU32           deviceId;                   //!< RM display id associated with the monitor. For devices in MST this is dynamically allocated. 

    /*!
     * The following fields are dumped directly from the internal display id table
     */
    NvU32           ddmonitorHandlePosition;    //!< DD's internal monitor handle position value
    NvU32           rmDisplayID;                //!< valid only for for legacy displays. DP 1.2 MultiStream displays will have a dynamically allocated id which will be populated in the above devideId field.
    NvU32           rmRootDisplayID;            //!< DP 1.2 Root Node RM displayId (only used for DP 1.2 MultiStream displays)
    NV_DP_ADDRESS   rmAuxAddress;               //!< DP 1.2 Address (only used for DP 1.2 MultiStream displays)
    NvU32           ddClusterId;                //!< Id of the cluster which is represented by this display Id
    NvU32           auxHashCode;                //!< CRC24 of the aux address + rmOutputId combination
} NV_DISPLAYID_ENTRY_V2;

typedef NV_DISPLAYID_ENTRY_V2 NV_DISPLAYID_ENTRY;

//! \ingroup diagapi
//! Macro for constructing the version field of ::_NV_GPU_DISPLAYIDS
#define NV_DISPLAYID_ENTRY_VER1          MAKE_NVAPI_VERSION(NV_DISPLAYID_ENTRY_V1,1)
#define NV_DISPLAYID_ENTRY_VER2          MAKE_NVAPI_VERSION(NV_DISPLAYID_ENTRY_V2,2)
#define NV_DISPLAYID_ENTRY_VER           NV_DISPLAYID_ENTRY_VER2

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DIAG_DumpAllDisplayIds
//
//!   DESCRIPTION: This API dumps the contents of the internal display ID table
//!
//! HOW TO USE: 1. The first call should be made to get the all display ID count. To get the display ID count, send in \n
//!                  a) hPhysicalGpu    - a valid GPU handle(enumerated using NvAPI_EnumPhysicalGPUs()) as input,      \n
//!                  b) pDisplayIds     - NULL, as we just want to get the display ID count.                           \n 
//!                  c) pDisplayIdCount - a valid pointer to NvU32, whose value is set to ZERO.                        \n
//!                If all parameters are correct and this call is successful, this call will return the display ID's count. \n
//!             2. To get the display ID array, make the second call to NvAPI_GPU_GetAllDisplayIds() with              \n
//!                  a) hPhysicalGpu    - should be same value which was sent in first call,                           \n
//!                  b) pDisplayIds     - pointer to the display ID array allocated by caller based on display ID count,    \n 
//!                                       eg. malloc(sizeof(NV_DISPLAYID_ENTRY) * pDisplayIdCount).                     \n
//!                  c) pDisplayIdCount - a valid pointer to NvU32. This indicates for how many display IDs            \n
//!                                       the memory is allocated(pDisplayIds) by the caller.                          \n
//!                If all parameters are correct and this call is successful, this call will return the display ID array and actual
//!                display ID count (which was obtained in the first call to NvAPI_DIAG_DumpAllDisplayIds). If the input display ID count is
//!                less than the actual display ID count, it will overwrite the input and give the pDisplayIdCount as actual count and the
//!                API will return NVAPI_INSUFFICIENT_BUFFER.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in]     hPhysicalGpu         GPU selection.
//! \param [in,out] pDisplayIds          Pointer to an array of NV_DISPLAYID_ENTRY structure, each entry represents one displayID 
//!                                      and its attributes.
//! \param [in,out] pDisplayIdCount      As input, this parameter indicates the number of display's id's for which caller has 
//!                                      allocated the memory. As output, it will return the actual number of display IDs.
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \retval  NVAPI_INSUFFICIENT_BUFFER  When the input buffer(pDisplayIds) is less than the actual number of display IDs, this API 
//!                                     will return NVAPI_INSUFFICIENT_BUFFER. 
//!
//! \ingroup diagapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DIAG_DumpAllDisplayIds(__in NvPhysicalGpuHandle hPhysicalGpu, __inout_ecount_part_opt(*pDisplayIdCount, *pDisplayIdCount) NV_DISPLAYID_ENTRY* pDisplayIds, __inout NvU32* pDisplayIdCount);







//! \ingroup diagapi
//! @{

typedef struct
{
    NvU32   version;                //!< Structure version
    NvU32   sensorIndex;            //!< Index of requested internal thermal sensor

    NvS32   hotspotOffset;          //!< Hotspot offset of the sensor.  Signed fixed-point value with 8 decimal bits.   

} NV_DIAG_THERMAL_SENSOR_INFO_V1;

typedef NV_DIAG_THERMAL_SENSOR_INFO_V1      NV_DIAG_THERMAL_SENSOR_INFO;

#define NV_DIAG_THERMAL_SENSOR_INFO_VER_1   MAKE_NVAPI_VERSION(NV_DIAG_THERMAL_SENSOR_INFO_V1,1)
#define NV_DIAG_THERMAL_SENSOR_INFO_VER     NV_DIAG_THERMAL_SENSOR_INFO_VER_1

//! @} 



///////////////////////////////////////////////////////////////////////////////
//! \code
//! FUNCTION NAME:   NvAPI_Diag_GetThermalSensorInfo
//!
//! DESCRIPTION:     Retrieves NVIDIA-private thermal sensor information.  Full
//!                      description of all-applicable characteristics of the 
//!                      thermal sensor.
//!
//!                      NOTE: This API currently only returns the hotspot
//!                      offset.  We'll soon be expanding it to return all
//!                      thermal characteristics.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS :     pThermalSensorInfo(IN/OUT) - Pointer in which to return the hotspot
//!                      offset.  This is actually a fixed point value with 8 decimal bits.
//!
//! RETURN STATUS:
//!    NVAPI_OK - completed request
//!    NVAPI_ERROR - miscellaneous error occurred
//!    NVAPI_INVALID_ARGUMENT - NULL pointer passed (pHotspotOffset)
//!    NVAPI_HANDLE_INVALIDATED - handle passed has been invalidated (see user guide)
//!    NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE - handle passed is not a physical GPU handle
//!    NVAPI_NOT_SUPPORTED - thermal sensor info call is not supported
//! \endcode
//! \ingroup diagapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Diag_GetThermalSensorInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_DIAG_THERMAL_SENSOR_INFO *pThermalSensorInfo);

///////////////////////////////////////////////////////////////////////////////
//! \code
//! FUNCTION NAME: NvAPI_GPU_MapGpuTimestampToUsermode
//!
//! DESCRIPTION:   Maps the timestamp struct for the specified GPU.  This timestamp is from the GPU-internal
//!                timer which represents the number of nanoseconds since 00:00 GMT, January 1, 1970.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//!         INPUT:  NvPhysicalGpuHandle hPhysicalGpu,  // Handle to the physical gpu
//!                 NvU32 bUnmap,                      // Set to true to unmap the timestamp
//!
//!        OUTPUT:  void** ppMappedTimestamp,          // The mapped memory.  Returns NULL if unmap is true.
//!                 NvU32* pStructSizeInBytes          // Size of the mapped struct.  Allows for client validation.
//! \endcode
//! \ingroup diagapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_MapGpuTimestampToUsermode(NvPhysicalGpuHandle hPhysicalGpu, NvU32 bUnmap, NvU64** ppMappedTimestamp, NvU32* pStructSizeInBytes);








/////////////////////////////////////////////////////////////////////////////////

 /*************** NVIDIA MOBILE SOFTWARE INSTRUMENTATION API ******************\
 * Instrumentation API provides an interface for the user to collect power,    *
 * performance statistics from the various sensor locations on the board.      *
 * Since each board (E415, E417,...) will have different measurement locations,*
 * the user first has to  query what is available. The  list of locations,     *
 * measurements and sample rates will be passed as part of the capture settings*
 * to open the session. When session was started the measurements are taken at *
 * sample rates specified, at all the locations and samples are in kernel.     *
 * After stop/ session timout, data collected is retrived and session is closed*
 * for reuse. Only one client and one session were supported.                  *
 * For more information see                                                    *
 *   https://engwiki/index.php/Mobile_Software_Instrumentation_API             *
 \*****************************************************************************/

/////////////////////////////////////////////////////////////////////////////////

    
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SwInstr_GetInterfaceRevision
//
//!   \fn NvAPI_SwInstr_GetInterfaceRevision(NV_SWINSTR_REVISION *pNvSwInstrRev)
//!   DESCRIPTION: This function returns the NVIDIA Interface revision in structure NV_SWINSTR_REVISION.
//!
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//!  \retval ::NVAPI_INVALID_ARGUMENT             
//!  \retval ::NVAPI_OK                          
//!  \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION  
/////////////////////////////////////////////////////////////////////////////////

//! \ingroup instapi
//! Structure containing the interface revision - used in NvAPI_SwInstr_GetInterfaceRevision()
typedef struct
{
    NvU32  version;         //!< Structure version, constructed from the macro #NV_SWINSTR_REVISION_VER
    NvU8   revMin;        
    NvU8   revMaj;
    NvU8   verMin;
    NvU8   verMaj;
} NV_SWINSTR_REVISION;


//! \ingroup instapi
//! Macro for constructing the version field for NV_SWINSTR_REVISION.
#define NV_SWINSTR_REVISION_VER MAKE_NVAPI_VERSION(NV_SWINSTR_REVISION,1)


//! \ingroup instapi
NVAPI_INTERFACE NvAPI_SwInstr_GetInterfaceRevision(NV_SWINSTR_REVISION *pNvSwInstrRev);





///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SwInstr_GetSensorPoints
//
//!  \fn NvAPI_SwInstr_GetSensorPoints(NV_SWINSTR_SENSOR_POINTS *pNvSwInstrSensorPoints)
//!  DESCRIPTION: This function returns the sensor points for the board.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//!  \retval ::NVAPI_INVALID_ARGUMENT             
//!  \retval ::NVAPI_OK                          
//!  \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION 
/////////////////////////////////////////////////////////////////////////////


//! \addtogroup instapi
//! @{

//! Valid subsystems for sensor points - used in NV_SWINSTR_SENSOR_LOCATION
typedef enum _NV_SWINSTR_SENSOR_SUBSYSTEM
{    
    NV_SENSOR_SUBSYSTEM_CPU         = 0x01,
    NV_SENSOR_SUBSYSTEM_GPU         = 0x02,
    NV_SENSOR_SUBSYSTEM_CHIPSET     = 0x04,
    NV_SENSOR_SUBSYSTEM_MEMORY      = 0x08,
    NV_SENSOR_SUBSYSTEM_DISPLAY     = 0x10,
    NV_SENSOR_SUBSYSTEM_NETWORK     = 0x20,
    NV_SENSOR_SUBSYSTEM_PS          = 0x40,
    NV_SENSOR_SUBSYSTEM_SKIN        = 0x80,
    NV_SENSOR_SUBSYSTEM_ALL         = 0xFFFFFFFF,    
} NV_SWINSTR_SENSOR_SUBSYSTEM;


//! Valid sensor components - used in NV_SWINSTR_SENSOR_LOCATION
typedef enum _NV_SWINSTR_SENSOR_COMPONENT
{    
    NV_SENSOR_COMPONENT_CORE        = 0x01,
    NV_SENSOR_COMPONENT_MEMORY      = 0x02,
    NV_SENSOR_COMPONENT_BUS         = 0x04,
    NV_SENSOR_COMPONENT_PS          = 0x08,
    NV_SENSOR_COMPONENT_ALL         = 0xFFFFFFFF,
} NV_SWINSTR_SENSOR_COMPONENT;


//! Valid GPU subsystem/core partitions - used in NV_SWINSTR_SENSOR_LOCATION
typedef enum _NV_SWINSTR_SENSOR_GPU_CORE_PARTITION
{ 
    NV_SENSOR_PARTITION_GPU_FB         = 0x01,
    NV_SENSOR_PARTITION_GPU_RENDER     = 0x02,
    NV_SENSOR_PARTITION_GPU_HOST       = 0x04,
    NV_SENSOR_PARTITION_GPU_DISPLAY    = 0x08,
    NV_SENSOR_PARTITION_GPU_VIDEO      = 0x10,
    NV_SENSOR_PARTITION_GPU_ALL        = 0xFFFFFFFF,
} NV_SWINSTR_SENSOR_GPU_CORE_PARTITION;


//! Valid GPU subsystem/Local Memory component partitions - used in NV_SWINSTR_SENSOR_LOCATION
typedef enum _NV_SWINSTR_SENSOR_GFX_LM_PARTITION
{
    NV_SENSOR_PARTITION_GFX_LM_LOGIC    = 0x01,
    NV_SENSOR_PARTITION_GFX_LM_DATA     = 0x02,
    NV_SENSOR_PARTITION_GFX_LM_TOTAL    = 0xFFFFFFFF,
} NV_SWINSTR_SENSOR_GFX_LM_PARTITION;



//!  Valid GPU subsystem/Bus component partitions - used in NV_SWINSTR_SENSOR_LOCATION
typedef enum _NV_SWINSTR_SENSOR_GFX_BUS_PARTITION
{
    NV_SENSOR_PARTITION_GFX_BUS_PCIE    = 0x01,
    NV_SENSOR_PARTITION_GFX_BUS_MEMORY  = 0x02,
    NV_SENSOR_PARTITION_GFX_BUS_MIO     = 0x04,
    NV_SENSOR_PARTITION_GFX_BUS_TOTAL   = 0xFFFFFFFF,
} NV_SWINSTR_SENSOR_GFX_BUS_PARTITION;



//! Valid measurement types - used in NV_SWINSTR_SENSOR_POINT
typedef enum _NV_SWINSTR_MEASUREMENT_TYPE
{
    NV_SENSOR_MEASURE_UNKNOWN           = 0x00,
    NV_SENSOR_MEASURE_ALTRSVD           = 0x01,
    NV_SENSOR_MEASURE_UTIL              = 0x02,
    NV_SENSOR_MEASURE_PERF_STATE        = 0x04,
    NV_SENSOR_MEASURE_ABS_POWER         = 0x08,
    NV_SENSOR_MEASURE_TEMP              = 0x10,  
    NV_SENSOR_MEASURE_REL_POWER         = 0x20,
} NV_SWINSTR_MEASUREMENT_TYPE;



//! Defines the sensor location  - used in NV_SWINSTR_SENSOR_POINT
typedef struct
{
    NvU32 subSystem;          //!< Of type #NV_SWINSTR_SENSOR_SUBSYSTEM
    NvU32 component;          //!< Of type #NV_SWINSTR_SENSOR_COMPONENT
    NvU32 partition;          //!< Of type #NV_SWINSTR_SENSOR_GPU_CORE_PARTITION
                              //!< or #NV_SWINSTR_SENSOR_GFX_LM_PARTITION
                              //!< or #NV_SWINSTR_SENSOR_GFX_BUS_PARTITION
                              
    NvU32 instance;           //!< Specifies bitmask for GPUs to be used
} NV_SWINSTR_SENSOR_LOCATION;



//! Defines a sensor point - used in NV_SWINSTR_SENSOR_POINTS
typedef struct
{
    NV_SWINSTR_SENSOR_LOCATION sensorLocation;
    NvU32 measurementType;     //!< Of type #NV_SWINSTR_MEASUREMENT_TYPE
} NV_SWINSTR_SENSOR_POINT;




//! Maximum number of sensor points - see NV_SWINSTR_SENSOR_POINTS
#define NV_SWINSTR_MAX_SENSOR_POINTS                     (0x00000020)



//! Lists the sensor points for the board - used in NvAPI_SwInstr_GetSensorPoints()
typedef struct
{   NvU32 version;              //!< Structure version, constructed by macro #NV_SWINSTR_SENSOR_POINTS_VER
    NvU32 numPoints;            //!< The number of sensor points.
    NV_SWINSTR_SENSOR_POINT sensorPoints[NV_SWINSTR_MAX_SENSOR_POINTS];
} NV_SWINSTR_SENSOR_POINTS;



//! Macro for constructing the version field for NV_SWINSTR_SENSOR_POINTS 
#define NV_SWINSTR_SENSOR_POINTS_VER MAKE_NVAPI_VERSION(NV_SWINSTR_SENSOR_POINTS,1)

//! @}


//! \ingroup instapi

NVAPI_INTERFACE NvAPI_SwInstr_GetSensorPoints(NV_SWINSTR_SENSOR_POINTS *pNvSwInstrSensorPoints);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SwInstr_GetCapabilities
//
//!   \fn Instr_GetCapabilities(NV_SWINSTR_CAPTURE_CAPS *pNvSwInstrCapabilities)
//!   DESCRIPTION: This function returns the performance instrumentation engine information for
//!                the associated GPU.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//!  \retval ::NVAPI_INVALID_ARGUMENT             
//!  \retval ::NVAPI_OK                          
//!  \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION  
///////////////////////////////////////////////////////////////////////////////

//! \ingroup instapi
//! Performance instrumentation engine information - used in NvAPI_SwInstr_GetCapabilities()
typedef struct
{
    NvU32 version;       //!< Structure version, constructed by macro #NV_SWINSTR_CAPTURE_CAPS_VER
    struct
    {
        unsigned    bMovingAverage  : 1;    //!< Supports a Moving Average 
        unsigned    bMASampleWindow : 1;    //!< If a moving average sample window can be set
        unsigned    bMAWindowSamples: 1;    //!< If a moving average of measurements (samples or time) can be taken 
        unsigned    powerPosErr     : 7;    //!< Maximum positive deviation (%)
        unsigned    powerNegErr     : 7;    //!< Maximum negative deviation (%)
        unsigned    tempPosErr      : 7;    //!< Maximum positive deviation (%)
        unsigned    tempNegErr      : 7;    //!< Maximum negative deviation (%)
 
    } caps;
    NvU32 maxSamples;                //!< Buffers size limit, 0 = no limit
    NvU32 minMovingAverageWindow;    //!< Minimum moving average window (per bMAWindowSamples)
    NvU32 maxMovingAverageWindow;    //!< Maximum moving avergae window (per bMAWindowSamples) 
    NvU32 minSampleRate;            //!< Minimum sample rate in 0.001 Hz
    NvU32 maxPerfSampleRate;   //!< Maximum performance measurement sample rate
    NvU32 maxPowerSampleRate;  //!< Maximum power measurement sample rate
    NvU32 maxTempSampleRate;   //!< Maximum temperature measurement sample rate
    NvU32 maxUtilSampleRate;   //!< Maximum utility measurement sample rate
} NV_SWINSTR_CAPTURE_CAPS;


//! \ingroup instapi
//! Macro for constructing the version field for NV_SWINSTR_CAPTURE_CAPS. 
#define NV_SWINSTR_CAPTURE_CAPS_VER MAKE_NVAPI_VERSION(NV_SWINSTR_CAPTURE_CAPS,1)


//! \ingroup instapi
NVAPI_INTERFACE NvAPI_SwInstr_GetCapabilities(NV_SWINSTR_CAPTURE_CAPS *pNvSwInstrCapabilities);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SwInstr_OpenCaptureSession
//
//!   \fn NvAPI_SwInstr_OpenCaptureSession(NV_SWINSTR_CAPTURE_SETTINGS *pNvSwInstrCapSets)
//!   DESCRIPTION: This function initiates a capture session. Only one session can be 
//!                opened at a time. 
//!
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//!  \retval ::NVAPI_INVALID_ARGUMENT             
//!  \retval ::NVAPI_OK                          
//!  \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION  
//
///////////////////////////////////////////////////////////////////////////////

//! \ingroup instapi
//! Instrumentation capture settings - used by NvAPI_SwInstr_OpenCaptureSession().
typedef struct
{
    NvU32 version;              //!< Structure version, constructed by macro #NV_SWINSTR_CAPTURE_SETTINGS_VER
    NvU32 bufferSize;           //!< Size of the capture settings buffer
    NvU8  bCapturebyTime;       //!< True = byTime, else bycount
    NvU8  powerMode;            //!< True = power sample gives power, else voltage current
    NvU32 value;                //!< if byTime = True, value = total time in ms for capturing instrumentation data 
                                //!< else value = number of instrumentation data samples
    NvU32 powerSampleRate;      //!< Sample rate for capturing power data
    NvU32 perfSampleRate;       //!< Sample rate for capturing performance data
    NvU32 tempSampleRate;       //!< Sample rate for capturing temperature date    
    NvU32 utilSampleRate;       //!< Sample rate for capturing utility data
    NvU32 numPoints;            //!< Total number of sensor points for measuring data  
    NV_SWINSTR_SENSOR_POINT sensorPoints[NV_SWINSTR_MAX_SENSOR_POINTS]; 
}NV_SWINSTR_CAPTURE_SETTINGS;


//! \ingroup instapi
//! Macro for constructing the version field for NV_SWINSTR_CAPTURE_SETTINGS. 
#define NV_SWINSTR_CAPTURE_SETTINGS_VER MAKE_NVAPI_VERSION(NV_SWINSTR_CAPTURE_SETTINGS, 1)

//! \ingroup instapi

NVAPI_INTERFACE NvAPI_SwInstr_OpenCaptureSession(NV_SWINSTR_CAPTURE_SETTINGS *pNvSwInstrCapSets);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SwInstr_CloseCaptureSession
//
//!   DESCRIPTION: This function shuts down a capture session. A session must have been
//!                initiated with a call to NvAPI_SwInstr_OpenCaptureSession90.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//!  \retval ::NVAPI_OK
//!  \retval ::NVAPI_ERROR
//!
//!  \ingroup instapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SwInstr_CloseCaptureSession();

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SwInstr_StartCaptureSession
//
//!   DESCRIPTION: This function starts the capture of software instrumentation data.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//!  \retval ::NVAPI_OK
//!  \retval ::NVAPI_ERROR
//!
//!  \ingroup instapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SwInstr_StartCaptureSession();

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SwInstr_StopCaptureSession
//
//!   DESCRIPTION: This function stops the capture of software instrumentation data.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//!  \retval ::NVAPI_OK
//!  \retval ::NVAPI_ERROR
//!
//!  \ingroup instapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SwInstr_StopCaptureSession();






///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SwInstr_GetCaptureData
//
//!   \fn NvAPI_SwInstr_GetCaptureData(NV_SWINSTR_CAPTURE_BUFFER *pNvSwInstrCaptureData,
//!   DESCRIPTION: This function retrieves performance instrumentation data.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//!  \retval ::NVAPI_INVALID_ARGUMENT             
//!  \retval ::NVAPI_OK                          
//!  \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION  
//
//////////////////////////////////////////////////////////////////////////////

//! \addtogroup instapi
//! @{


//! Performance states - used in NV_SWINSTR_SAMPLE
typedef struct
{
    NvU32 currPerfState;     //!< Current performance state
    NvU32 totalPerfStates;   //!< Total performance states supported
} NV_SWINSTR_PERF_SAMPLE;


//! Voltage and current values - used in NV_SWINSTR_POWER_SAMPLE
typedef struct
{
    NvU16 voltage;           //!< Voltage value at the sensor location 
    NvU16 current;           //!< Current value at the sensor location 
} NV_SWINSTR_VOLTAGE_CURRENT;


//! Power and timestamp when measurement was taken - used in NV_SWINSTR_SAMPLE 
typedef struct 
{
    union
    {
        NvU32 power;         //!< Power value at the sensor location 
        NV_SWINSTR_VOLTAGE_CURRENT voltageCurrent;
    } data;
    NvU64 timeStamp;         //!< Time at which measurement is taken
} NV_SWINSTR_POWER_SAMPLE;


//! Temperature and timestamp when measurement was taken - used in NV_SWINSTR_SAMPLE
typedef struct
{
    NvS32 temp;             //!< Temperature at sensor location
    NvU64 timeStamp;        //!< Time when measurement is taken
} NV_SWINSTR_TEMP_SAMPLE;


//! Utilization value and timestamp when measurement was taken - used in NV_SWINSTR_SAMPLE 
typedef struct
{
    NvU32 utilization;      //!< Utilization value at the sensor location
    NvU64 timeStamp;        //!< Time when measurement is taken
} NV_SWINSTR_UTIL_SAMPLE;


//! Sample buffer - used in NV_SWINSTR_CAPTURE_BUFFER
typedef struct
{
    NV_SWINSTR_SENSOR_POINT sensor;   //!< Specifies where the measurement is taken
    union
    {
        NV_SWINSTR_PERF_SAMPLE perfSample;
        NV_SWINSTR_POWER_SAMPLE powerSample;
        NV_SWINSTR_TEMP_SAMPLE tempSample;
        NV_SWINSTR_UTIL_SAMPLE utilSample;
    } sample;                         //!< Measured data 
} NV_SWINSTR_SAMPLE;


//! \ingroup instapi
//! Instrumentation sample capture buffer - used in NvAPI_SwInstr_GetCaptureData()
typedef struct
{
    NvU32 version;                   //!< Structure version constructed by macro #NV_SWINSTR_CAPTURE_BUFFER_VER  
    NvU32 numSamples;                //!< Number of samples collected
    NV_SWINSTR_SAMPLE *pSamples;     //!< Pointer to the sample buffer
} NV_SWINSTR_CAPTURE_BUFFER;


//! Macro for constructing the version field for NV_SWINSTR_CAPTURE_BUFFER
#define NV_SWINSTR_CAPTURE_BUFFER_VER MAKE_NVAPI_VERSION(NV_SWINSTR_CAPTURE_BUFFER,1)

//! @}

 
//! \ingroup instapi
NVAPI_INTERFACE NvAPI_SwInstr_GetCaptureData(NV_SWINSTR_CAPTURE_BUFFER *pNvSwInstrCaptureData,
                                             NvU32 *pSize);
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SwInstr_GetSnapshot
//
//!   \fn NvAPI_SwInstr_GetSnapshot(NV_SWINSTR_CAPTURE_SETTINGS *pCaptureSettings,
//!   DESCRIPTION: This function retrieves a snapshot of instrumentation data.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//!  \retval ::NVAPI_INVALID_ARGUMENT             
//!  \retval ::NVAPI_OK                          
//!  \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION  
//
//////////////////////////////////////////////////////////////////////////////


//! \ingroup instapi
//! Macro for constructing the version field for NV_SWINSTR_SNAPSHOT_DATA
#define NV_SWINSTR_SNAPSHOT_DATA_VER MAKE_NVAPI_VERSION(NV_SWINSTR_SNAPSHOT_DATA,1)


 
//! \ingroup instapi
NVAPI_INTERFACE NvAPI_SwInstr_GetSnapshot(NV_SWINSTR_CAPTURE_SETTINGS *pCaptureSettings,
                                          NV_SWINSTR_CAPTURE_BUFFER* pNvSwInstrSnapshotData,
                                          NvU32 *pSize);




//! \ingroup diagapi
//! @{

typedef enum _NV_SET_HYBIRD_DIAG_FUNCTION_ID
{
    NVAPI_SET_HYBRID_DIAG_FUNCTION_ACPI_EVAL_METHOD = 0,        //!< Submit ACPI Eval Input Buffer to ACPI
    NVAPI_SET_HYBRID_DIAG_FUNCTION_QUERY_CHILD_RELATIONS,       //!< Ouery ACPIID and ChilduIDs of GPU child devices

    // MUST BE THE LAST ONE!!!  Don't add any new ID after this!!!
    NVAPI_SET_HYBRID_DIAG_NUM_SUPPORTED_FUNCTIONS               //!< # of SET_HYBRID_DIAG functions exported to NVAPI
} NV_SET_HYBRID_DIAG_FUNCTION_ID;

typedef enum _NV_SET_HYBRID_DIAG_MODE_ID
{
    NVAPI_SET_HYBRID_DIAG_MODE_USE_IGPU = 0,           //!< Execute diag function on IGPU escape
    NVAPI_SET_HYBRID_DIAG_MODE_USE_DGPU,               //!< Execute diag function on DGPU escape
    NVAPI_SET_HYBRID_DIAG_MODE_USE_MVIGPU,             //!< Execute diag function on MVIGPU escape
    NVAPI_SET_HYBRID_DIAG_MODE_USE_MVDGPU,             //!< Execute diag function on MVDGPU escape

    // MUST BE THE LAST ONE!!!  Don't add any new ID after this!!!
    NVAPI_SET_HYBRID_DIAG_NUM_SUPPORTED_FUNCTION_MODES          //!< # of SET_HYBRID_DIAG function modes exported to NVAPI
} NV_SET_HYBRID_DIAG_MODE_ID;


#define NV_SET_HYBRID_DIAG_BLOCK_SIZE (64*1024)

typedef struct
{
    NvU32   version;                                    //!< structure version

    NvU32   ulAcpiID;                                   //!< ACPI ID associated with diag function
    NvU32    ulDGPU;                                    //!< DGPU ID asscoiated with diag function
    NV_SET_HYBRID_DIAG_MODE_ID    modeID;                 //!< Desired Hybrid Escape handler for diag function

    NvU32   bufferSize;
    NvU8    buffer[NV_SET_HYBRID_DIAG_BLOCK_SIZE];      //!< Buffer for diag data
} NV_SET_HYBRID_DIAG_BLOCK;

//! Macro for constructing the version field of ::NV_SET_HYBRID_DIAG_BLOCK
#define NV_SET_HYBRID_DIAG_BLOCK_VER MAKE_NVAPI_VERSION(NV_SET_HYBRID_DIAG_BLOCK,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Diag_SetHybridDiag
//
//! \code
//!   DESCRIPTION: Execute a Hybrid Diagnostic function
//!
//!    PARAMETERS: hPhysicalGpu(IN) - GPU selection.
//!                diagFunction(IN) - Hybird Set Diag Function ID.
//!                pDiagBLock(IN/OUT) - pointer to Hybird Set Diag Block
//!
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! RETURN STATUS: NVAPI_INVALID_ARGUMENT: hPhysicalGpu or pDiagBlock is null
//!                NVAPI_OK: *pDiagBlock is set
//!                NVAPI_INCOMPATIBLE_STRUCT_VERSION: NV_SET_HYBRID_DIAG_BLOCK version not compatible with driver
//!                NVAPI_NVIDIA_DEVICE_NOT_FOUND: no NVIDIA GPU driving a display was found
//!                NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE: hPhysicalGpu was not a physical GPU handle
//!                NVAPI_INVALID_HYBRID_MODE: hybrid mode required by NV_SET_HYBRID_DIAG_BLOCK modeID not available
//! \endcode
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Diag_SetHybridDiag(NvPhysicalGpuHandle hPhysicalGpu, NV_SET_HYBRID_DIAG_FUNCTION_ID diagFunction, NV_SET_HYBRID_DIAG_BLOCK *pDiagBlock);

//! @}





//! \ingroup diagapi
//! @{

#define MAX_XCODE_INSTANCE 4

typedef struct _NV_XCODE_ENCODE_INFO
{
    NvU32          version;                        //!< (IN) version of struct
    NvU32          processId;                      //!< (IN/OUT) Process ID
    NvAPI_ShortString   szFramework;               //!< (IN/OUT) Dshow/Clib/MFT
    NvAPI_ShortString   szCodecType;               //!< (IN/OUT) codecType
    NvAPI_ShortString   szProfile;                 //!< (IN/OUT) profile
    NvAPI_ShortString   szPreset;                  //!< (IN/OUT) Preset type
    NvU32          level;                          //!< (IN/OUT) level
    NvAPI_ShortString   szFieldMode;               //!< (IN/OUT) progressive / interlaced
    NvU32          botFldFirst;                    //!< (IN/OUT) if interlaced, specify field order
    NvS32          width;                          //!< (IN/OUT) o/p width
    NvS32          height;                         //!< (IN/OUT) o/p height
    float          aspectRatio;                    //!< (IN/OUT) aspect ratio
    float          frameRate;                      //!< (IN/OUT) Frame rate in fps
    NvU32          bitRateAvg;                     //!< (IN/OUT) bitrate avg in bps
    NvU32          bitRatePeak;                    //!< (IN/OUT) bitrate peak in bps
    NvAPI_ShortString   vbrMode;                   //!< (IN/OUT) VBR/CBR
    NvU32          gpuOffloadLvl;                  //!< (IN/OUT) GPU offload level
    NvU8           bMultiGpu                   :1; //!< (IN/OUT) multi-gpu
    NvU8           reserved                    :7; //!< (IN/OUT) unused bits
    NvU32          totalDevMemUsed;                //!< (IN/OUT) total dev mem used for allocations in KB
} NV_XCODE_ENCODE_INFO_V1;

typedef NV_XCODE_ENCODE_INFO_V1 NV_XCODE_ENCODE_INFO;
#define NV_XCODE_ENCODE_INFO_VER1  MAKE_NVAPI_VERSION(NV_XCODE_ENCODE_INFO_V1,1)
#define NV_XCODE_ENCODE_INFO_VER   NV_XCODE_ENCODE_INFO_VER1


typedef struct _NV_XCODE_ENC_INSTANCE
{
    NvU32  version;
    NvU32  instCount;
    NV_XCODE_ENCODE_INFO encInfo[MAX_XCODE_INSTANCE];
} NV_XCODE_ENC_INSTANCE_V1;

typedef NV_XCODE_ENC_INSTANCE_V1 NV_XCODE_ENC_INSTANCE;
#define NV_XCODE_ENC_INSTANCE_VER1  MAKE_NVAPI_VERSION(NV_XCODE_ENC_INSTANCE_V1,1)
#define NV_XCODE_ENC_INSTANCE_VER   NV_XCODE_ENC_INSTANCE_VER1


typedef struct _NV_XCODE_DECODE_INFO
{
    NvU32          version;                        //!< (IN) version of struct
    NvU32          processId;                      //!< (IN/OUT) Process ID
    NvAPI_ShortString   szDecoderType;             //!< (IN/OUT) DXVA/CUDA HW encoder is in use
    NvU8           bMFTInterface               :1; //!< (IN/OUT) MFT /other interface
    NvU8           reserved                    :7; //!< (IN/OUT) unused bits
    NvAPI_ShortString   szCodecType;               //!< (IN/OUT) codecType
    NvU32          width;                          //!< (IN/OUT) i/p width
    NvU32          height;                         //!< (IN/OUT) i/p height
    NvU32          numDecSurf;                     //!< (IN/OUT) max Number of internal decoded surfaces
    NvAPI_ShortString   szDeinterlaceMode;         //!< (IN/OUT) progressive/interlaced then interlacing mode
    NvU32          outputFormat;                   //!< (IN/OUT) output decoded format (NV12)
    NvU32          targetWidth;                    //!< (IN/OUT) o/p width
    NvU32          targetHeight;                   //!< (IN/OUT) o/p height
    NvU32          numOutputSurf;                  //!< (IN/OUT) number of output surfaces mapped simultaneously
    NV_RECT        display_area;                   //!< (IN/OUT) rect
    NvU32          totalDevMemUsed;                //!< (IN/OUT) total device mem used for allocations in KB
} NV_XCODE_DECODE_INFO_V1;


typedef NV_XCODE_DECODE_INFO_V1 NV_XCODE_DECODE_INFO;
#define NV_XCODE_DECODE_INFO_VER1  MAKE_NVAPI_VERSION(NV_XCODE_DECODE_INFO_V1,1)
#define NV_XCODE_DECODE_INFO_VER   NV_XCODE_DECODE_INFO_VER1

typedef struct _NV_XCODE_DEC_INSTANCE
{
    NvU32  version;
    NvU32  instCount;
    NV_XCODE_DECODE_INFO decInfo[MAX_XCODE_INSTANCE];
} NV_XCODE_DEC_INSTANCE_V1;

typedef NV_XCODE_DEC_INSTANCE_V1 NV_XCODE_DEC_INSTANCE;
#define NV_XCODE_DEC_INSTANCE_VER1  MAKE_NVAPI_VERSION(NV_XCODE_DEC_INSTANCE_V1,1)
#define NV_XCODE_DEC_INSTANCE_VER   NV_XCODE_DEC_INSTANCE_VER1

typedef struct _NV_XCODE_NVAPIDMA_INFO
{
    NvU8  bUpdateFlag                     :1; //!< (IN) update/set flag
    NvU8  reserved                        :7; //!< (IN) unused bits
    NvU32 processId;                          //!< (IN/OUT) appId of app using NVAPI DMA
    NvU32 surfFormat;                         //!< (IN/OUT) surface format
    NV_RECT srcRect;                          //!< (IN/OUT) surface width
    NV_RECT destRect;                         //!< (IN/OUT) surface height
} NV_XCODE_NVAPIDMA_INFO;

typedef struct _NV_XCODE_NVAPIDMA_INSTANCE
{
    NvU32   version;
    NvU32   instCount;
    NV_XCODE_NVAPIDMA_INFO Info[MAX_XCODE_INSTANCE];
} NV_XCODE_NVAPIDMA_INSTANCE_V1;

typedef NV_XCODE_NVAPIDMA_INSTANCE_V1 NV_XCODE_NVAPIDMA_INSTANCE;
#define NV_XCODE_NVAPIDMA_INSTANCE_VER1  MAKE_NVAPI_VERSION(NV_XCODE_NVAPIDMA_INSTANCE_V1,1)
#define NV_XCODE_NVAPIDMA_INSTANCE_VER   NV_XCODE_NVAPIDMA_INSTANCE_VER1


typedef enum _NV_XCODE_QUERY_ID
{
    NV_XCODE_QUERY_ENCODE_INFO,
    NV_XCODE_QUERY_DECODE_INFO,
    NV_XCODE_QUERY_NVAPIDMA_INFO,
    NV_XCODE_QUERY_LAST
} NV_XCODE_QUERY_ID;

typedef struct _NV_XCODE_INFO
{
    NV_XCODE_QUERY_ID   queryID;            //!< (IN) query type
    NvU8                bFlag           :1; //!< (IN) Control flag = 1 for retrieving info
    NvU8                reserved        :7; //!< (IN) unused bits
    union
    {
        NV_XCODE_ENC_INSTANCE             EncodeInfo;
        NV_XCODE_DEC_INSTANCE             DecodeInfo;
        NV_XCODE_NVAPIDMA_INSTANCE        NvapiDMAInfo;
    };
} NV_XCODE_INFO;


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Xcode_SetEncodeInfo
//
//! \code
//! DESCRIPTION:     This API is used to set encode information from encode modules into KMD
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:      pEncodeInfo(IN)         - structure for passing encode information
//! RETURN STATUS:
//!                  NVAPI_OK - completed request
//!                  NVAPI_ERROR - miscellaneous error occurred
//!                  NVAPI_INVALID_ARGUMENT - invalid argument passed
//!                  NVAPI_API_NOT_INTIALIZED - nvapi not initialized
//!                  NVAPI_INCOMPATIBLE_STRUCT_VERSION - version does not match
//!                  NVAPI_NVIDIA_DEVICE_NOT_FOUND - Display Handle is default
//! \endcode
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Xcode_SetEncodeInfo( NV_XCODE_ENCODE_INFO *pEncodeInfo);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Xcode_SetDecodeInfo
//
//! \code
//! DESCRIPTION:     This API is used to set decode information from decode modules into KMD
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:      pDecodeInfo(IN)        - structure for passing decode information
//! RETURN STATUS:
//!                  NVAPI_OK - completed request
//!                  NVAPI_ERROR - miscellaneous error occurred
//!                  NVAPI_INVALID_ARGUMENT - invalid argument passed
//!                  NVAPI_API_NOT_INTIALIZED - nvapi not initialized
//!                  NVAPI_INCOMPATIBLE_STRUCT_VERSION - version does not match
//!                  NVAPI_NVIDIA_DEVICE_NOT_FOUND - Display Handle is default
//! \endcode
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Xcode_SetDecodeInfo(NV_XCODE_DECODE_INFO *pDecodeInfo);

//! @}



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Xcode_GetEncodeInfo
//
//! \code
//! DESCRIPTION:     This API is used to retrieve encode information for swak
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:      pEncodeInfo(OUT)        - structure for retrieving encode information per instance
//! RETURN STATUS:
//!                  NVAPI_OK - completed request
//!                  NVAPI_ERROR - miscellaneous error occurred
//!                  NVAPI_INVALID_ARGUMENT - invalid argument passed
//!                  NVAPI_API_NOT_INTIALIZED - nvapi not initialized
//!                  NVAPI_INCOMPATIBLE_STRUCT_VERSION - version does not match
//!                  NVAPI_NVIDIA_DEVICE_NOT_FOUND - Display Handle is default
//! \endcode
//! \ingroup diagapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Xcode_GetEncodeInfo(NV_XCODE_ENC_INSTANCE *pEncodeInfo);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Xcode_GetDecodeInfo
//
//! \code
//! DESCRIPTION:     This API is used to retrieve decode information for swak
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:      pDecodeInfo(OUT)        - structure for retrieving decode information per instance
//! RETURN STATUS:
//!                  NVAPI_OK - completed request
//!                  NVAPI_ERROR - miscellaneous error occurred
//!                  NVAPI_INVALID_ARGUMENT - invalid argument passed
//!                  NVAPI_API_NOT_INTIALIZED - nvapi not initialized
//!                  NVAPI_INCOMPATIBLE_STRUCT_VERSION - version does not match
//!                  NVAPI_NVIDIA_DEVICE_NOT_FOUND - Display Handle is default
//! \endcode
//! \ingroup diagapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Xcode_GetDecodeInfo(NV_XCODE_DEC_INSTANCE *pDecodeInfo);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Xcode_GetNvapiDMAInfo
//
//! \code
//! DESCRIPTION:     This API is used to get nvapi DMA info for swak
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! PARAMETERS:      pNvapiDMAInfo(OUT)      - structure for retrieving nvapi DMA info.
//! RETURN STATUS:
//!                  NVAPI_OK - completed request
//!                  NVAPI_ERROR - miscellaneous error occurred
//!                  NVAPI_INVALID_ARGUMENT - invalid argument passed
//!                  NVAPI_API_NOT_INTIALIZED - nvapi not initialized
//!                  NVAPI_INCOMPATIBLE_STRUCT_VERSION - version does not match
//!                  NVAPI_NVIDIA_DEVICE_NOT_FOUND - Display Handle is default
//! \endcode
//! \ingroup diagapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Xcode_GetNvapiDMAInfo(NV_XCODE_NVAPIDMA_INSTANCE *pNvapiDMAInfo);





//! \ingroup diagapi
//! @{

#define NVAPI_FB_ECC_PARTITION_COUNT 6

typedef enum NV_EDC_FLAGS
{
    NV_EDC_FLAGS_NONE                          = 0x00000000 ,
    NV_EDC_FLAGS_FB_EDC_MAX_DELTAS_FLAGS_RESET = 0x00000001 

} NV_EDC_FLAGS;


typedef struct
{
    NvU32           version;                                   //!< Structure version

    NvU32           maxDeltas[NVAPI_FB_ECC_PARTITION_COUNT];   //!<This output parameter stores NV_PFB_FBPA_CRC_ERROR_MAX_DELTA_VALUE per partition.
                                                               //!<Floor-swept partitions are compacted and extra partition data is set to 0.
    NvU32           crcTickValue;                              //!<This output parameter stores NV_PFB_FBPA_CRC_TICK_VALUE which is needed to calculate the actual error rate

} NV_EDC_INFO_V1;

typedef NV_EDC_INFO_V1 NV_EDC_INFO;

#define NV_EDC_INFO_VER_1 MAKE_NVAPI_VERSION(NV_EDC_INFO_V1,1)

#define NV_EDC_INFO_VER   NV_EDC_INFO_VER_1

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_DIAG_GetEDCInfo
//
//! DESCRIPTION:    This function returns the Error Detection Code Information. 
//!                 It is currently used to query EDC max error deltas for each of the partitions on Frame buffer.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]         hPhysicalGpu                   - Physical Gpu Handle.
//!                                                   
//! \param [in]         flags                          - Additional flags 
//!
//! \param [in,out]     pEDCInfo                       - Pointer to the structure containing EDC info. 
//!
//! \return      This API can return any of the error codes enumerated in #NvAPI_Status. 
//!              Error codes specific to this API are described below.
//!              (None)
//!\ingroup diagapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DIAG_GetEDCInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout  NV_EDC_INFO* pEDCInfo, __in NV_EDC_FLAGS flags);




//! \ingroup diagapi
//! @{

#define NV_DISP_CRC_BUFFER_SIZE                         (256)

typedef enum _NVAPI_DISP_CRC_POLL_COMMAND
{
    NVAPI_DISP_CRC_POLL_COMMAND_START,
    NVAPI_DISP_CRC_POLL_COMMAND_READ,
    NVAPI_DISP_CRC_POLL_COMMAND_STOP
} NVAPI_DISP_CRC_POLL_COMMAND;

typedef struct 
{
    NvU32   secs;
    NvU32   uSecs;
}NVAPI_DISP_CRC_TIME_STAMP;

typedef struct 
{
    NvU32 compCRC[NV_DISP_CRC_BUFFER_SIZE];
    NvU32 primeOutputCRC[NV_DISP_CRC_BUFFER_SIZE];
    NvU32 frameNumber[NV_DISP_CRC_BUFFER_SIZE];
    NVAPI_DISP_CRC_TIME_STAMP headTimeStamp;
}NVAPI_DISP_CRC_BUFFER;

typedef struct 
{
    NvU32 version;    // Structure version
    NVAPI_DISP_CRC_POLL_COMMAND command;
    NVAPI_DISP_CRC_BUFFER *pDispCrcBuffer;
    NvPhysicalGpuHandle hPhysicalGPU[NVAPI_MAX_PHYSICAL_GPUS];
    NvU32 validEntryCount[NVAPI_MAX_PHYSICAL_GPUS];
    NvU32 displayOutputId[NVAPI_MAX_PHYSICAL_GPUS];
    NvU32 validGpuCount;
} NVAPI_CONFIG_DISP_CRC_POLLING_PARAMS;

//! Macro for constructing the version field of  NVAPI_CONFIG_DISP_CRC_POLLING_PARAMS
#define NVAPI_CONFIG_DISP_CRC_POLLING_PARAMS_VER  MAKE_NVAPI_VERSION(NVAPI_CONFIG_DISP_CRC_POLLING_PARAMS,1)


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_DIAG_ConfigDispCrcPolling
//
//! \code
//! PARAMETERS:    command              (IN)  - Option to start/read/stop CRCs collection.
//!           pDispCrcBuffer    (IN)  - Pointer to Buffer that gets filled with CRCs.
//!           hPhysicalGPU        (IN)  - Physical GPU handle array of interest.                  
//!                validEntryCount    (IN)  - Array that gets filled with count of valid CRCs.
//!                displayOutputId      (IN)  - outputDisplay Ids on which CRCs should be collected. 
//!           validGpuCount        (IN)  - Count of valid GPU handles filled in hPhysicalGPU[].
//!        
//! SUPPORTED OS:  Windows Vista and higher
//!
//! DESCRIPTION:   Pass allowed inputs commands with the list of GPU handles of interst,
//!                to start/stop CRC collection, as well as to read the CRC buffers.  
//!                Once started, till stop is called, frequent read commands should be called to 
//!                avoid buffer overflows.
//!
//! RETURN STATUS: 
//!                NVAPI_OK                  - completed request
//!                NVAPI_API_NOT_INITIALIZED - nvapi not initialized
//!                NVAPI_ERROR               - miscellaneous error occurred
//!                NVAPI_INVALID_ARGUMENT    - no suitable pixel clock was found
//! \endcode
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_DIAG_ConfigDispCrcPolling(NVAPI_CONFIG_DISP_CRC_POLLING_PARAMS *pDispCrcConfigParams);

//! @}



/////////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_Diag_Escape
//
//!   DESCRIPTION: This API sends an escape to the specified GPU. This is for new feature 
//!                developement only, and should not be used, even internally, 
//!                for any supported tools like SWAK. This allows DD to test 
//!                escape calls directly.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]     hPhysicalGpu  - Physical GPU handle, or NVIDIA_DEFAULT_HANDLE
//! \param [in]     escapeId      - Escape ID for escape initialization
//! \param [in,out] pData         - Buffer to pass down via escape
//! \param [in]     dataSize      - Size of pData
//!
//! \retval ::NVAPI_OK  Escape call succeeded.
//! \retval ::NVAPI_ERROR  Escape call failed.
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND No NVIDIA device could be found.
//!
//! \ingroup diagapi
//////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Diag_Escape(NvPhysicalGpuHandle hPhysicalGpu, NvU32 escapeId, void* pData, NvU32 dataSize);

/////////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_Diag_NvRmAllocRoot
//
//!   DESCRIPTION: This API makes an NvRmAllocRoot call to the RM directly. This is for
//!                new feature development only, and should not be used, even
//!                internally, for any supported tools like SWAK. This allows RM
//!                to test RM features without DD or NvAPI implementations.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!

//! \param [out]  phClient   Handle to the client returned by NvRmAllocRoot
//!
//! \retval ::NVAPI_OK   RmAllocRoot call succeeded.
//! \retval ::NVAPI_ERROR  RmAllocRoot call failed.
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND  No NVIDIA device could be found.
//!
//! \ingroup diagapi
//////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Diag_NvRmAllocRoot(NvU32* phClient);


/////////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_Diag_NvRmAlloc
//
//!   DESCRIPTION: This API makes an NvRmAlloc call to the RM directly. This is for
//!                new feature development only, and should not be used, even
//!                internally, for any supported tools like SWAK. This allows RM
//!                to test RM features without DD or NvAPI implementations.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]      hClient      - See documentation for NvRmAlloc
//! \param [in]      hParent      - See documentation for NvRmAlloc
//! \param [in]      hObject      - See documentation for NvRmAlloc
//! \param [in]      hClass       - See documentation for NvRmAlloc
//! \param [in,out]  pAllocParams - See documentation for NvRmAlloc
//! \param [in]      allocParamSize  - Size of buffer pointed to by pAllocParams
//!
//! \retval ::NVAPI_OK RmAlloc call succeeded.
//! \retval ::NVAPI_ERROR RmAlloc call failed.
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND No NVIDIA device could be found.
//!
//! \ingroup diagapi
//////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Diag_NvRmAlloc(NvU32 hClient, NvU32 hParent, NvU32 hObject, NvU32 hClass, void* pAllocParams, NvU32 allocParamSize);


/////////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_Diag_NvRmControl
//
//!   DESCRIPTION: Makes an NvRmControl call to the RM directly. This is for
//!                new feature development only, and should not be used, even
//!                internally, for any supported tools like SWAK. This allows RM
//!                to test RM features without DD or NvAPI implementations.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]      hClient  - See documentation for NvRmControl
//! \param [in]      hObject  - See documentation for NvRmControl
//! \param [in]      cmd      - See documentation for NvRmControl
//! \param [in,out]  pParams  - See documentation for NvRmControl
//! \param [in]      paramsSize  - Size of buffer pointed to by pParams
//!
//! \retval ::NVAPI_OK RmControl call succeeded.
//! \retval ::NVAPI_ERROR RmControl call failed.
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND No NVIDIA device could be found.
//!
//! \ingroup diagapi
//////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Diag_NvRmControl(NvU32 hClient, NvU32 hObject, NvU32 cmd, void *pParams, NvU32 paramsSize);


/////////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_Diag_NvRmFree
//
//!   DESCRIPTION: This API makes an NvRmFree call to the RM directly. This is for
//!                new feature development only, and should not be used, even
//!                internally, for any supported tools like SWAK. This allows RM
//!                to test RM features without DD or NvAPI implementations.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]   hClient  - See documentation for NvRmFree
//! \param [in]   hParent  - See documentation for NvRmFree
//! \param [in]   hObject  - See documentation for NvRmFree
//!
//! \retval ::NVAPI_OK: RmFree call succeeded.
//! \retval ::NVAPI_ERROR: RmAlloc call failed.
//! \retval ::NVAPI_NVIDIA_DEVICE_NOT_FOUND: No NVIDIA device could be found.
//!
//! \ingroup diagapi
//////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Diag_NvRmFree(NvU32 hClient, NvU32 hParent, NvU32 hObject);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_ToggleICafeFrameTag
//
//!   DESCRIPTION: Toggle frame tagging for ICafe
//!
//! SUPPORTED OS:  Windows XP
//!
//!
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_ToggleICafeFrameTag();

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_ToggleICafeStatsDump
//
//!   DESCRIPTION: Toggle dumping of frame statistics for ICafe
//!
//! SUPPORTED OS:  Windows XP
//!
//!
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_ToggleICafeStatsDump();

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_ToggleICafeImageDump
//
//!   DESCRIPTION: Toggle dumping of image data for ICafe
//!
//! SUPPORTED OS:  Windows XP
//!
//!
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_ToggleICafeImageDump();

//! \ingroup diagapi

#define MAX_PEX_COUNTER_TYPES 26

// PEX counter flags to manipulate the pexCounterMask
#define NVAPI_PEX_COUNTER_TYPE                           0x00000000
#define NVAPI_PEX_COUNTER_RECEIVER_ERRORS                0x00000001
#define NVAPI_PEX_COUNTER_REPLAY_COUNT                   0x00000002
#define NVAPI_PEX_COUNTER_REPLAY_ROLLOVER_COUNT          0x00000004 
#define NVAPI_PEX_COUNTER_BAD_DLLP_COUNT                 0x00000008
#define NVAPI_PEX_COUNTER_BAD_TLP_COUNT                  0x00000010
#define NVAPI_PEX_COUNTER_8B10B_ERRORS_COUNT             0x00000020
#define NVAPI_PEX_COUNTER_SYNC_HEADER_ERRORS_COUNT       0x00000040
#define NVAPI_PEX_COUNTER_LCRC_ERRORS_COUNT              0x00000080
#define NVAPI_PEX_COUNTER_FAILED_L0S_EXITS_COUNT         0x00000100
#define NVAPI_PEX_COUNTER_NAKS_SENT_COUNT                0x00000200
#define NVAPI_PEX_COUNTER_NAKS_RCVD_COUNT                0x00000400
#define NVAPI_PEX_COUNTER_LANE_ERRORS                    0x00000800
#define NVAPI_PEX_COUNTER_L1_TO_RECOVERY_COUNT           0x00001000
#define NVAPI_PEX_COUNTER_L0_TO_RECOVERY_COUNT           0x00002000
#define NVAPI_PEX_COUNTER_RECOVERY_COUNT                 0x00004000
#define NVAPI_PEX_COUNTER_CHIPSET_XMIT_L0S_ENTRY_COUNT   0x00008000
#define NVAPI_PEX_COUNTER_GPU_XMIT_L0S_ENTRY_COUNT       0x00010000
#define NVAPI_PEX_COUNTER_L1_ENTRY_COUNT                 0x00020000
#define NVAPI_PEX_COUNTER_L1P_ENTRY_COUNT                0x00040000
#define NVAPI_PEX_COUNTER_DEEP_L1_ENTRY_COUNT            0x00080000
#define NVAPI_PEX_COUNTER_ASLM_COUNT                     0x00100000
#define NVAPI_PEX_COUNTER_TOTAL_CORR_ERROR_COUNT         0x00200000
#define NVAPI_PEX_COUNTER_CORR_ERROR_COUNT               0x00400000
#define NVAPI_PEX_COUNTER_NON_FATAL_ERROR_COUNT          0x00800000
#define NVAPI_PEX_COUNTER_FATAL_ERROR_COUNT              0x01000000
#define NVAPI_PEX_COUNTER_UNSUPP_REQ_COUNT               0x02000000


typedef struct _NV_PEX_COUNTER_INFO_V1
{
    NvU32  version;
       
    NvU32  pexCounterMask;                      //!< Mask to define which counter values to fetch
    
    NvU32  pexTotalCorrectableErrors;           //!< This parameter gives the total correctable errors which includes
                                                //! NV_XVE_ERROR_COUNTER1 plus LCRC Errors, 8B10B Errors, NAKS and Failed L0s.
    
    NvU16  pexCorrectableErrors;                //!< This parameter only includes NV_XVE_ERROR_COUNTER1 value.

    NvU8   pexTotalNonFatalErrors;              //!< This parameter returns total Non-Fatal Errors which may or may not
                                                //! include Correctable Errors.

    NvU8   pexTotalFatalErrors;                 //!< This parameter returns Total Fatal Errors.

    NvU8   pexTotalUnsupportedReqs;             //!< This parameter returns Total Unsupported Requests.
    
    NvU16  pexCounters[MAX_PEX_COUNTER_TYPES];  //!< This array contains the error counts for each error type as requested from
                                                //! the pexCounterMask. The array indices correspond to the mask bits one-to-one.
    
}NV_PEX_COUNTER_INFO_V1;

//! Structure Versioning
typedef NV_PEX_COUNTER_INFO_V1          NV_PEX_COUNTER_INFO;
#define NVAPI_PEX_COUNTER_INFO_VER1     NVAPI_PEX_COUNTER_INFO_VER
#define NVAPI_PEX_COUNTER_INFO_VER      MAKE_NVAPI_VERSION(NV_PEX_COUNTER_INFO,1)

/////////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_GetPEXCounters
//
//!   DESCRIPTION: This API gets the current values for PEX counters as specified
//!                in the pexCounterMask mask. This API is supported only on Kepler+
//!                cards.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]     hPhysicalGpuHandle  - GPU handle of which PEX counter values are required
//! \param [in/out] info                - Structure which contains the PEX counters array and its statistics.
//!
//! \return : This API can return any of the error codes enumerated in #NvAPI_Status. 
//!           If there are return error codes with specific meaning for this API, they are listed below
//!
//! \ingroup diagapi
//////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Diag_GetPexCounters(__in NvPhysicalGpuHandle hPhysicalGpuHandle, __inout NV_PEX_COUNTER_INFO* info);

/////////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_ResetPEXCounters
//
//!   DESCRIPTION: This API resets the values of the PEX counters as specified in the pexCounterMask.
//!                The value in the pexCounterMask determines which counters are to be reset. This API 
//!                is supported only on Kepler+ cards.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  hPhysicalGpuHandle     - GPU handle of which PEX counter values are required
//! \param [in]  pexCounterMask         - PEX counters mask.
//!
//! \return : This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!               specific meaning for this API, they are listed below
//!
//! \ingroup diagapi
//////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Diag_ResetPexCounters(__in NvPhysicalGpuHandle hPhysicalGpuHandle, __in NvU32 pexCounterMask);



//! \ingroup diagapi

typedef enum _NV_DIAG_GC6_DEBUG_INFO_FLAGS
{
    NV_GC6_DEBUG_INFO_VBIOS_FBCLAMP_ENABLED          = NV_BIT(0),  
    NV_GC6_DEBUG_INFO_VBIOS_IFR_ENABLED              = NV_BIT(1), 
    NV_GC6_DEBUG_INFO_SBIOS_ENABLED                  = NV_BIT(2), 
    NV_GC6_DEBUG_INFO_ROMLESS_OPTIMUS_RESUME_ENABLED = NV_BIT(3), 
    NV_GC6_DEBUG_INFO_ROM_JT_GC6_ENABLED             = NV_BIT(4), 
    NV_GC6_DEBUG_INFO_PGISLAND_PRESENT               = NV_BIT(5), 

} NV_DIAG_GC6_DEBUG_INFO_FLAGS;

typedef enum _NV_DIAG_GC6_CAPS_INFO_FLAGS
{
    NV_GC6_CAPS_INFO_CORE_SEQUENCE_ENABLED          = NV_BIT(0),
    NV_GC6_CAPS_INFO_ROM_SEQUENCE_ENABLED           = NV_BIT(1),

} NV_DIAG_GC6_CAPS_INFO_FLAGS;


typedef struct _NV_DIAG_GC6_DEBUG_INFO_V1
{
    NvU32 version;      //!<NV_DIAG_GC6_DEBUG_INFO struct version
    
    NvU32 gc6DebugInfo; //!<Combination of NV_DIAG_GC6_DEBUG_INFO_FLAGS

} NV_DIAG_GC6_DEBUG_INFO_V1;

typedef struct _NV_DIAG_GC6_DEBUG_INFO_V2
{
    NvU32 version;      //!<NV_DIAG_GC6_DEBUG_INFO struct version
    
    NvU32 gc6DebugInfo; //!<Combination of NV_DIAG_GC6_DEBUG_INFO_FLAGS

    NvU32 gc6CapsInfo;  //!<Combination of NV_DIAG_GC6_CAPS_INFO_FLAGS

} NV_DIAG_GC6_DEBUG_INFO_V2;    

typedef NV_DIAG_GC6_DEBUG_INFO_V2     NV_DIAG_GC6_DEBUG_INFO;

#define NV_DIAG_GC6_DEBUG_INFO_VER1   MAKE_NVAPI_VERSION(NV_DIAG_GC6_DEBUG_INFO_V1,1)
#define NV_DIAG_GC6_DEBUG_INFO_VER2   MAKE_NVAPI_VERSION(NV_DIAG_GC6_DEBUG_INFO_V2,2)
#define NV_DIAG_GC6_DEBUG_INFO_VER    NV_DIAG_GC6_DEBUG_INFO_VER2


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_Diag_GetGC6DebugInfo
//
//! DESCRIPTION:     This API call gives the detailed info required for GC6 tool.                  
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in]         hPhysicalGpu  - Physical GPU Handle. 
//! \param [in,out]     pGC6DebugInfo - Pointer to the NV_DIAG_GC6_DEBUG_INFO structure. 
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \ingroup diagapi
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Diag_GetGC6DebugInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_DIAG_GC6_DEBUG_INFO *pGC6DebugInfo);
///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SYS_IsPhysXApplication
//
//! DESCRIPTION:     This API is used to query whether the current application should
//!                  report to KMD as a physX application only.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [out]     isPhysXApplication  Returns true if current application reports to KMD as
//!                                      a physx application only.  
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_IsPhysXApplication(__out NvU32 *isPhysXApplication);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SYS_IsPhysXValidConfig
//
//! DESCRIPTION:     This API is used to query whether physx can be supported on the system.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [out]     isPhysXValidConfig  Returns true if physx can be supported on the system.  
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_IsPhysXValidConfig(__out NvU8 *isPhysXValidConfig);

//! Used in NvAPI_SYS_SetFeatureState() and NvAPI_SYS_GetFeatureState().
typedef enum _NV_FEATURE_ID
{ 
    NV_FEATURE_ID_SGM_CLOCK_LOCK  = 0,             //!< Clock locking for SDI, GSync, Mosaic
                                                   //!< No need to set Physical GPU or displayId for this feature
    NV_FEATURE_ID_PAN_SCAN_STATE = 1,              //!< Pan Scan State of the display. Set displayId of the desired pan scan target.
    NV_FEATURE_ID_VRR_STATE = 2,                   //!< VRR State of VRR capable display. Set displayId of the desired display.
    NV_FEATURE_ID_CONSISTENT_PERF = 3,             //!< Clock locking for consistent performance.
    NV_FEATURE_ID_HYPER_SAMPLING = 4,              //!< hyper sampling on all display of a Gpu. Set hPhysicalGpu of the desired Gpu.
    NV_FEATURE_ID_GC6_NOTIFY_STATE_CHANGE = 5,     //!< GC6 State Change Event for GPU logging feature during GC6 state change.
    NV_FEATURE_ID_DIRECTMODE = 6                   //!< Direct Mode display support for VR. Can be called with both hPhysicalGpu or displayId. 
                                                   //!< Note that even if a GPU supports this feature, the connected display might not.
} NV_FEATURE_ID;

typedef enum _NV_FEATURE_ID_VALUE
{ 
    NV_FEATURE_ID_OFF  = 0,     //!< feature on
    NV_FEATURE_ID_ON   = 1,     //!< feature off
} NV_FEATURE_ID_VALUE;

//! \ingroup sysgeneral                
typedef struct _NV_SYS_FEATURE_DATA_V1 {
    NvU32                  version;                  //!< Version of this structure
    NV_FEATURE_ID          featureId;                //!< feature Id of the feature
    NV_FEATURE_ID_VALUE    featureIdValue;           //!< status of the feature 
    union
    {
        NvPhysicalGpuHandle    hPhysicalGpu;             //!< (Optional)need to be fill in only if feature configuration requires it
        NvU32                  displayId;                //!< (Optional)need to be fill in only if feature configuration requires it
    };
}NV_SYS_FEATURE_DATA_V1;

#define NV_FEATURE_NO_SUPPORT_DISABLED                      NV_BIT(0)  //!< The feature is not enabled
#define NV_FEATURE_NO_SUPPORT_GPU                           NV_BIT(1)  //!< The current GPU does not support this feature 
#define NV_FEATURE_NO_SUPPORT_DISPLAY                       NV_BIT(2)  //!< The current monitor does not support this feature 
#define NV_FEATURE_NO_SUPPORT_DISPLAY_DRIVER                NV_BIT(3)  //!< The current installed display driver not support this feature 
#define NV_FEATURE_NO_SUPPORT_CURRENT_DISPLAY_SETTINGS      NV_BIT(4)  //!< The current display topology does not support this feature 

//! \ingroup sysgeneral                
typedef struct _NV_SYS_FEATURE_DATA_V2 {
    NvU32                  version;              //!< Version of this structure
    NV_FEATURE_ID          featureId;            //!< feature Id of the feature
    NV_FEATURE_ID_VALUE    featureIdValue;       //!< status of the feature 
    union
    {
        NvPhysicalGpuHandle    hPhysicalGpu;     //!< (Optional)need to be fill in only if feature configuration requires it
        NvU32                  displayId;        //!< (Optional)need to be fill in only if feature configuration requires it
    };
    NvU32                 problemFlags;          //!< The problem flags (combination of NV_FEATURE_NO_SUPPORT_XXX values) when featureIdValue is NV_FEATURE_ID_OFF
}NV_SYS_FEATURE_DATA_V2;

//! \ingroup sysgeneral
typedef NV_SYS_FEATURE_DATA_V2 NV_SYS_FEATURE_DATA;
#define NV_SYS_FEATURE_DATA_VER_1   MAKE_NVAPI_VERSION(NV_SYS_FEATURE_DATA_V1,1)
#define NV_SYS_FEATURE_DATA_VER_2   MAKE_NVAPI_VERSION(NV_SYS_FEATURE_DATA_V2,2)
#define NV_SYS_FEATURE_DATA_VER NV_SYS_FEATURE_DATA_VER_2   

//! SUPPORTED OS:  Windows XP and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_SYS_SetFeatureState
//
//! \code
//! DESCRIPTION:    This API sets feature status
//!
//! PARAMETERS:     featureId (IN)  data of feature to be controlled
//!
//! DESCRIPTION:    This API sets feature status
//!
//! \return      This API can return any of the error codes enumerated in #NvAPI_Status. 
//!
//! \endcode 
/////////////////////////////////////////////////////////////////////////////// 

NVAPI_INTERFACE NvAPI_SYS_SetFeatureState( __in NV_SYS_FEATURE_DATA featureData);

//! SUPPORTED OS:  Windows XP and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_SYS_GetFeatureState
//
//! \code
//! PARAMETERS:     featureData(IN/OUT)  data of the feature 
//!
//! DESCRIPTION:    This API Gets the current state of corresponding feature
//!
//! \return      This API can return any of the error codes enumerated in #NvAPI_Status. 
//!
//! \endcode 
/////////////////////////////////////////////////////////////////////////////// 

NVAPI_INTERFACE NvAPI_SYS_GetFeatureState(__inout NV_SYS_FEATURE_DATA *featureData);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SYS_GetApprovalCookies
//
//! \fn NvAPI_SYS_GetApprovalCookies(NV_APPROVAL_COOKIES *pApprovalCookies)
//! \code
//! DESCRIPTION: retrieves the approval cookies. These are strings returned 
//!              by the SBIOS and used to allow features like SLI or Coproc.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!  
//! PARAMETERS:     pApprovalCookies (OUT)         - the approval cookie list
//! 
//! 
//! RETURN STATUS:
//!    NVAPI_OK - completed request
//!    NVAPI_ERROR - miscellaneous error occurred
//!    NVAPI_INVALID_ARGUMENT - one or more args are invalid
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! \ingroup sysgeneral
typedef enum _NV_APPROVAL_COOKIE_TYPE
{
    NV_APPROVAL_COOKIE_TYPE_UNKNOWN  = 0x00,
    NV_APPROVAL_COOKIE_TYPE_SLI      = 0x01,
    NV_APPROVAL_COOKIE_TYPE_COPROC   = 0x02,
    NV_APPROVAL_COOKIE_TYPE_TEMPLATE = 0x03,
} NV_APPROVAL_COOKIE_TYPE;

//! \ingroup sysgeneral
#define MAX_APPROVAL_COOKIE 4

//! \ingroup sysgeneral
typedef struct
{
    NvU32                   version;                                    //!< structure version
    NvU32                   ApprovalCookieCount;                        //!< the approval cookie count
    NV_APPROVAL_COOKIE_TYPE ApprovalCookieType[MAX_APPROVAL_COOKIE];    //!< the array of approval cookie types
    NvAPI_String            ApprovalCookieString[MAX_APPROVAL_COOKIE];  //!< the array of approval cookie strings
} NV_APPROVAL_COOKIES;

//! \ingroup sysgeneral
//! Macro for constructing the version field of ::NV_APPROVAL_COOKIES
#define NV_APPROVAL_COOKIES_VER  MAKE_NVAPI_VERSION(NV_APPROVAL_COOKIES,1)

//! \ingroup sysgeneral
NVAPI_INTERFACE NvAPI_SYS_GetApprovalCookies(NV_APPROVAL_COOKIES *pApprovalCookies);



//! \addtogroup sysgeneral
//! @{ 

typedef enum _NV_ACPI_EVENT_TYPE
{
    NVAPI_ACPI_EVENT_TYPE_LID_STATE,
    NVAPI_ACPI_EVENT_TYPE_POWER_SOURCE,
    NVAPI_ACPI_EVENT_TYPE_DOCK_STATE,
    NVAPI_ACPI_EVENT_TYPE_TRUST_LID,
    NVAPI_ACPI_EVENT_TYPE_TRUST_DOCK,
} NV_ACPI_EVENT_TYPE;

typedef enum _NV_ACPI_EVENT_DATA
{
    NVAPI_ACPI_EVENT_DATA_LID_OPEN,
    NVAPI_ACPI_EVENT_DATA_LID_CLOSED,
    NVAPI_ACPI_EVENT_DATA_POWER_BATTERY,
    NVAPI_ACPI_EVENT_DATA_POWER_AC,
    NVAPI_ACPI_EVENT_DATA_DOCK_UNDOCKED,
    NVAPI_ACPI_EVENT_DATA_DOCK_DOCKED,
    NVAPI_ACPI_EVENT_DATA_TRUST_LID_DCS,
    NVAPI_ACPI_EVENT_DATA_TRUST_LID_NVIF,
    NVAPI_ACPI_EVENT_DATA_TRUST_LID_ACPI,
    NVAPI_ACPI_EVENT_DATA_TRUST_LID_POLL,
    NVAPI_ACPI_EVENT_DATA_TRUST_DOCK_DCS,
    NVAPI_ACPI_EVENT_DATA_TRUST_DOCK_NVIF,
    NVAPI_ACPI_EVENT_DATA_TRUST_DOCK_ACPI,
    NVAPI_ACPI_EVENT_DATA_TRUST_DOCK_POLL,
} NV_ACPI_EVENT_DATA;

typedef enum _NV_ACPI_EVENT_FORCED_DATA
{
    NVAPI_ACPI_EVENT_FORCED_DATA_NO,
    NVAPI_ACPI_EVENT_FORCED_DATA_YES
} NV_ACPI_EVENT_FORCED_DATA;

//! @}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_SYS_ACPI_NotifyEvent
//
//! \code
//!   DESCRIPTION: This call is used to trigger mobile related systems events in RM.
//!                (lid open/close, dock/undock and power plug/unplug (ac/battery))
//!                This events should be triggered by OS and this is a backdoor to
//!                trigger them during testing.
//!
//!    PARAMETERS: eventType(IN) - type of event (see enum _NV_ACPI_EVENT_TYPE)
//!                eventData(IN) - event specific data (see enum _NV_ACPI_EVENT_DATA)
//!                dataForced(IN) - used to specify whether to trust Lid/Dock state
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! RETURN STATUS: NVAPI_OK: execution succeeded
//!                NVAPI_NOT_SUPPORTED: required notification is NOT supported
//!                NVAPI_INVALID_ARGUMENT: event type or data are incorrect
//!                NVAPI_INVALID_HANDLE: invalid GPU handle
//!                NVAPI_ERROR: miscellaneous error
//! \endcode
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_ACPI_NotifyEvent(NvPhysicalGpuHandle hPhysicalGpu, NV_ACPI_EVENT_TYPE eventType, NV_ACPI_EVENT_DATA eventData, NV_ACPI_EVENT_FORCED_DATA dataForced);

//! \ingroup sysNVIF
//! NVIF function IDs - used in NvAPI_SYS_NVIF_QuerySupport(), NvAPI_SYS_NVIF_GetValues(), and NvAPI_SYS_NVIF_SetValues().
typedef enum _NV_NVIF_FUNC_ID
{
    NVAPI_NVIF_FUNC_LID_STATUS = 0,      //!< Get lid status
    NVAPI_NVIF_FUNC_DOCKING_STATUS,      //!< Get docking status
    NVAPI_NVIF_FUNC_THERMAL_MONITOR,     //!< GPU thermal monitor
    NVAPI_NVIF_FUNC_BRIGHTNESS_CONTROL,  //!< LCD backlight brightness control
    NVAPI_NVIF_FUNC_POWERMIZER_LIMIT,    //!< PowerMizer level limit
    NVAPI_NVIF_FUNC_DISPLAY_ATTRIBUTES,  //!< Display device hotplug detection
    NVAPI_NVIF_FUNC_HDCP,                //!< Get HDCP keys (High bandwidth Digital Content Protection)
    NVAPI_NVIF_FUNC_DISPLAY_GET_VALUE,   //!< Query display device attribute preferences
    NVAPI_NVIF_FUNC_DISPLAY_SET_VALUE,   //!< Set display device attribute preferences
    NVAPI_NVIF_FUNC_PLATFORM_CONFIG,     //!< Get system memory bandwidth and latency information
    NVAPI_NVIF_FUNC_NUM,                 //!< The number of possible function IDs
} NV_NVIF_FUNC_ID; 


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SYS_NVIF_QuerySupport
//
//! DESCRIPTION: This function queries if an NVIF method (specified by func) is 
//! supported by the system BIOS. \n
//! NVIF is an NVIDIA extension of the Advanced Configuration and Power Interface (ACPI) that OEMs can choose to implement in their system BIOS. 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 165
//!
//! \retval   NVAPI_OK                 The queried NVIF method is supported.
//! \retval   NVAPI_NOT_SUPPORTED      The queried NVIF method is NOT supported.
//! \retval   NVAPI_INVALID_ARGUMENT   Function ID not recognized.
//! \retval   NVAPI_ERROR              Failed to retrieve support info.
//! \ingroup  sysNVIF
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_NVIF_QuerySupport(NV_NVIF_FUNC_ID func);

//! \ingroup sysNVIF
//! Contains NVIF-related data by display output - used in NvAPI_SYS_NVIF_GetValues() and NvAPI_SYS_NVIF_SetValues().
typedef struct
{
    NvU32   version;
    struct
    {
        NvU32   displayOutputId;       //!< Display output ID
        NvU32   data;                  //!< Contains one or more pieces of data whose type depends on #NVIF_FUNC_REQUEST_ID
    }
    displayData[NVAPI_MAX_DISPLAYS];

    NvU32   validDataSize;    //!< Valid number of entries in the displayData array
} NVIF_FUNC_DATA_SET;


//! \ingroup sysNVIF
#define NVIF_FUNC_DATA_SET_VER  MAKE_NVAPI_VERSION(NVIF_FUNC_DATA_SET,1)


//! \ingroup sysNVIF
//! Category of NVIF-related data - used in NvAPI_SYS_NVIF_GetValues() and NvAPI_SYS_NVIF_SetValues(). 
typedef enum 
{
    NVIF_FUNC_REQUEST_SCALING  = 0,  //!< The data set contains one more display scaling methods (see #NV_SCALING).
    NVIF_FUNC_REQUEST_TVFORMAT = 1,  //!< The data set contains one more display tv formats (see #NV_DISPLAY_TV_FORMAT).
    NVIF_FUNC_REQUEST_NUM,
} NVIF_FUNC_REQUEST_ID;
 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SYS_NVIF_GetValues
//
//! DESCRIPTION: This function gets display attributes from the system BIOS using NVIF. NVIF is an
//!              NVIDIA extension of the Advanced Configuration and Power
//!              Interface (ACPI) that OEMs can choose to implement in
//!              their system BIOS. 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//!  \param [in]   func            NVIF function ID.
//!  \param [in]   dataReqId       Specifies the type of data to return (supported scaling or TV formats) from the system BIOS.
//!  \param [out]  data            Contains one or more pieces of data whose type depends on the #NVIF_FUNC_REQUEST_ID.
//!
//!  \retval ::NVAPI_OK
//!  \retval ::NVAPI_NOT_SUPPORTED
//!  \retval ::NVAPI_INVALID_ARGUMENT
//!  \retval ::NVAPI_ERROR
//!
//!  \ingroup sysNVIF
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_NVIF_GetValues(NV_NVIF_FUNC_ID func, NVIF_FUNC_REQUEST_ID dataReqId, NVIF_FUNC_DATA_SET *data);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SYS_NVIF_SetValues
//
//! DESCRIPTION: This function sets display attributes in the system BIOS using NVIF. NVIF is an
//!              NVIDIA extension of the Advanced Configuration and Power
//!              Interface (ACPI) that OEMs can choose to implement in
//!              their system BIOS. 
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//!  \param [in]   func        NVIF function ID
//!  \param [in]   dataReqId   Specifies the type of data to set (supported scaling or TV formats) in the system BIOS.
//!  \param [in]   data        Contains one or more pieces of data whose type depends on the #NVIF_FUNC_REQUEST_ID.
//!
//!  \retval ::NVAPI_OK
//!  \retval ::NVAPI_NOT_SUPPORTED
//!  \retval ::NVAPI_INVALID_ARGUMENT
//!  \retval ::NVAPI_ERROR
//!
//!  \ingroup sysNVIF
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_NVIF_SetValues(NV_NVIF_FUNC_ID func, NVIF_FUNC_REQUEST_ID dataReqId, NVIF_FUNC_DATA_SET data);



//! \ingroup sysgeneral
#define NVAPI_MEM_DATA_SIZE 128

//! \ingroup sysNVIF
//! Used in NvAPI_SYS_NVIF_PlatformConfig().
typedef struct 
{
    NvU32    version;
    NvU32    dataBlob[NVAPI_MEM_DATA_SIZE];
    NvU32    dataSize; // size in bytes.
    
}NVIF_FUNC_MEM_BW_INFO;

//! \ingroup sysNVIF
#define NVIF_FUNC_MEM_BW_INFO_VER  MAKE_NVAPI_VERSION(NVIF_FUNC_MEM_BW_INFO,1)


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SYS_NVIF_PlatformConfig
//
//! DESCRIPTION:  This API gets system memory bandwidth and latency information from the SBIOS. NVIF is an
//!              NVIDIA extension of ACPI that OEMs can choose to implement in
//!              their SBIOS. ACPI stands for Advanced Configuration and Power
//!              Interface.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//! \param  [in]  func   NVIF fun ID.
//! \param [out]  data   contains the return data
//!
//! \retval ::NVAPI_OK                queried NVIF method is supported
//! \retval ::NVAPI_NOT_SUPPORTED     queried NVIF method is NOT supported
//! \retval ::NVAPI_INVALID_ARGUMENT  function ID not recognized
//! \retval :: NVAPI_ERROR            failed to retrieve support info
//!
//! \ingroup sysNVIF
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_NVIF_PlatformConfig(NV_NVIF_FUNC_ID func, NVIF_FUNC_MEM_BW_INFO *data);


//! \addtogroup sysgeneral
//! @{

//! Used in NV_CPU_INFO
typedef enum _NV_CPU_TYPE
{ 
    NV_CPU_TYPE_UNKNOWN         = 0x00000000,
    NV_CPU_TYPE_P5              = 0x00000001, //!< Intel type
    NV_CPU_TYPE_P55             = 0x00000002, //!< Intel type
    NV_CPU_TYPE_P6              = 0x00000003, //!< Intel type
    NV_CPU_TYPE_P2              = 0x00000004, //!< Intel type
    NV_CPU_TYPE_P2XC            = 0x00000005, //!< Intel type
    NV_CPU_TYPE_CELA            = 0x00000006, //!< Intel type
    NV_CPU_TYPE_P3              = 0x00000007, //!< Intel type
    NV_CPU_TYPE_P3_INTL2        = 0x00000008, //!< Intel type
    NV_CPU_TYPE_P4              = 0x00000009, //!< Intel type
    NV_CPU_TYPE_CORE2           = 0x00000010, //!< Intel type
    NV_CPU_TYPE_CELN_M16H       = 0x00000011, //!< Intel type
    NV_CPU_TYPE_CORE2_EXTRM     = 0x00000012, //!< Intel type

    NV_CPU_TYPE_IA64            = 0x00000020, //!< Intel type

    NV_CPU_TYPE_K5              = 0x00000030, //!< AMD type
    NV_CPU_TYPE_K6              = 0x00000031, //!< AMD type
    NV_CPU_TYPE_K62             = 0x00000032, //!< AMD type
    NV_CPU_TYPE_K63             = 0x00000033, //!< AMD type
    NV_CPU_TYPE_K7              = 0x00000034, //!< AMD type
    NV_CPU_TYPE_K8              = 0x00000035, //!< AMD type
    NV_CPU_TYPE_K10             = 0x00000036, //!< AMD type
    NV_CPU_TYPE_K11             = 0x00000037, //!< AMD type
    NV_CPU_TYPE_C6              = 0x00000060, //!< IDT/Centaur type
    NV_CPU_TYPE_C62             = 0x00000061, //!< IDT/Centaur type
    NV_CPU_TYPE_GX              = 0x00000070, //!< Cyrix type
    NV_CPU_TYPE_M1              = 0x00000071, //!< Cyrix type
    NV_CPU_TYPE_M2              = 0x00000072, //!< Cyrix type
    NV_CPU_TYPE_MGX             = 0x00000073, //!< Cyrix type
    NV_CPU_TYPE_TM_CRUSOE       = 0x00000080, //!< Transmeta type
    NV_CPU_TYPE_PPC603          = 0x00000090, //!< PowerPC type
    NV_CPU_TYPE_PPC604          = 0x00000091, //!< PowerPC type
    NV_CPU_TYPE_PPC750          = 0x00000092, //!< PowerPC type
} NV_CPU_TYPE;


//! Used in NV_CPU_INFO
typedef enum _NV_CPU_CAPABILITIES
{ 
  NV_CPU_CAP_MMX                    = 0x00000001,
  NV_CPU_CAP_SSE                    = 0x00000002,
  NV_CPU_CAP_3DNOW                  = 0x00000004,
  NV_CPU_CAP_SSE2                   = 0x00000008,
  NV_CPU_CAP_SFENCE                 = 0x00000010,
  NV_CPU_CAP_WRITE_COMBINING        = 0x00000020,
  NV_CPU_CAP_ALTIVEC                = 0x00000040,
  NV_CPU_CAP_PUT_NEEDS_IO           = 0x00000080,
  NV_CPU_CAP_NEEDS_WC_WORKAROUND    = 0x00000100,
  NV_CPU_CAP_3DNOW_EXT              = 0x00000200,
  NV_CPU_CAP_MMX_EXT                = 0x00000400,
  NV_CPU_CAP_CMOV                   = 0x00000800,
  NV_CPU_CAP_CLFLUSH                = 0x00001000,
  NV_CPU_CAP_NEEDS_WAR_190854       = 0x00002000,
  NV_CPU_CAP_SSE3                   = 0x00004000,
  NV_CPU_CAP_NEEDS_WAR_124888       = 0x00008000,
  NV_CPU_CAP_HT_CAPABLE             = 0x00010000,
} NV_CPU_CAPABILITIES;


//! Used in NvAPI_SYS_GetCpuInfo().
typedef struct
{
    NvU32 version;                            //!< Structure version

    NV_CPU_TYPE         type;                 //!< Processor type
    NV_CPU_CAPABILITIES capabilities;         //!< Processor capability flags
    NvU32               clock;                //!< Processor speed (MHz)
    NvU32               L1DataCacheSize;      //!< L1 dcache size (KB)
    NvU32               L2DataCacheSize;      //!< L2 dcache size (KB)
    NvU32               dataCacheLineSize;    //!< L1 dcache bytes/line
    NvU32               numLogicalCpus;       //!< Logical processor count
    NvU32               numPhysicalCpus;      //!< Physical processor count
    NvU32               numCoresOnDie;        //!< Number of CPU cores on the die
    NvAPI_ShortString   szEmbeddedName;       //!< Embedded CPU name
} NV_CPU_INFO;

//! Used in NV_CPU_INFO.
#define NV_CPU_INFO_VER  MAKE_NVAPI_VERSION(NV_CPU_INFO,2)

//! Used in NvAPI_SYS_GetCpuInfo()
typedef struct
{
    NvU32 version;                            //!< Structure version

    NV_CPU_TYPE         type;                 //!< Processor type
    NV_CPU_CAPABILITIES capabilities;         //!< Processor capability flags
    NvU32               clock;                //!< Processor speed (MHz)
    NvU32               L1DataCacheSize;      //!< L1 dcache size (KB)
    NvU32               L2DataCacheSize;      //!< L2 dcache size (KB)
    NvU32               dataCacheLineSize;    //!< L1 dcache bytes/line
    NvU32               numLogicalCpus;       //!< Logical processor count
    NvU32               numPhysicalCpus;      //!< Physical processor count
    NvAPI_ShortString   szEmbeddedName;       //!< Embedded CPU name
} NV_CPU_INFO_v1;

//! Used in NV_CPU_INFO_v1.
#define NV_CPU_INFO_VER_1  MAKE_NVAPI_VERSION(NV_CPU_INFO_v1,1)


//! @}

 
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SYS_GetCpuInfo
//
//!  This function returns information about the CPU(s) in the system.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 85
//!
//! \retval  NVAPI_INVALID_ARGUMENT             Argument is NULL.
//! \retval  NVAPI_OK                          *pInfo is now set.
//! \retval  NVAPI_NVIDIA_DEVICE_NOT_FOUND      No NVIDIA device maps to that display name.
//! \retval  NVAPI_INCOMPATIBLE_STRUCT_VERSION  NV_CPU_INFO version not compatible with driver.
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_GetCpuInfo(NV_CPU_INFO *pInfo);




//! \addtogroup sysgeneral
//! @{

typedef struct
{
    NvU32               version;            //!< structure version
    NvU32               vendorId;           //!< Chipset vendor identification
    NvU32               deviceId;           //!< Chipset device identification
    NvAPI_ShortString   szVendorName;       //!< Chipset vendor Name
    NvAPI_ShortString   szChipsetName;      //!< Chipset device Name
    NvU32               flags;              //!< Chipset info flags - obsolete
    NvU32               subSysVendorId;     //!< Chipset subsystem vendor identification
    NvU32               subSysDeviceId;     //!< Chipset subsystem device identification 
    NvAPI_ShortString   szSubSysVendorName; //!< subsystem vendor Name
    NvU32               HBvendorId;         //!< Host bridge vendor identification
    NvU32               HBdeviceId;         //!< Host bridge device identification
    NvU32               HBsubSysVendorId;   //!< Host bridge subsystem vendor identification
    NvU32               HBsubSysDeviceId;   //!< Host bridge subsystem device identification

} NV_CHIPSET_INFO_v4;

typedef struct
{
    NvU32               version;            //!< structure version
    NvU32               vendorId;           //!< vendor ID
    NvU32               deviceId;           //!< device ID
    NvAPI_ShortString   szVendorName;       //!< vendor Name
    NvAPI_ShortString   szChipsetName;      //!< device Name
    NvU32               flags;              //!< Chipset info flags - obsolete
    NvU32               subSysVendorId;     //!< subsystem vendor ID
    NvU32               subSysDeviceId;     //!< subsystem device ID
    NvAPI_ShortString   szSubSysVendorName; //!< subsystem vendor Name
} NV_CHIPSET_INFO_v3;

typedef enum
{
    NV_CHIPSET_INFO_HYBRID          = 0x00000001,
} NV_CHIPSET_INFO_FLAGS;

typedef struct
{
    NvU32               version;        //!< structure version
    NvU32               vendorId;       //!< vendor ID
    NvU32               deviceId;       //!< device ID
    NvAPI_ShortString   szVendorName;   //!< vendor Name
    NvAPI_ShortString   szChipsetName;  //!< device Name
    NvU32               flags;          //!< Chipset info flags
} NV_CHIPSET_INFO_v2;

typedef struct
{
    NvU32               version;        //structure version
    NvU32               vendorId;       //vendor ID
    NvU32               deviceId;       //device ID
    NvAPI_ShortString   szVendorName;   //vendor Name
    NvAPI_ShortString   szChipsetName;  //device Name
} NV_CHIPSET_INFO_v1;

#define NV_CHIPSET_INFO_VER_1  MAKE_NVAPI_VERSION(NV_CHIPSET_INFO_v1,1)
#define NV_CHIPSET_INFO_VER_2   MAKE_NVAPI_VERSION(NV_CHIPSET_INFO_v2,2)
#define NV_CHIPSET_INFO_VER_3   MAKE_NVAPI_VERSION(NV_CHIPSET_INFO_v3,3)
#define NV_CHIPSET_INFO_VER_4   MAKE_NVAPI_VERSION(NV_CHIPSET_INFO_v4,4)

#define NV_CHIPSET_INFO         NV_CHIPSET_INFO_v4
#define NV_CHIPSET_INFO_VER     NV_CHIPSET_INFO_VER_4

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SYS_GetChipSetInfo
//
//!  This function returns information about the system's chipset.
//!
//! SUPPORTED OS:  Windows XP and higher,  Mac OS X
//!
//!
//! \since Release: 95
//!
//! \retval  NVAPI_INVALID_ARGUMENT              pChipSetInfo is NULL.
//! \retval  NVAPI_OK                           *pChipSetInfo is now set.
//! \retval  NVAPI_INCOMPATIBLE_STRUCT_VERSION   NV_CHIPSET_INFO version not compatible with driver.
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_GetChipSetInfo(NV_CHIPSET_INFO *pChipSetInfo);


//! \ingroup sysgeneral
//! Lid and dock information - used in NvAPI_GetLidDockInfo()
typedef struct 
{
    NvU32 version;    //! Structure version, constructed from the macro #NV_LID_DOCK_PARAMS_VER
    NvU32 currentLidState;
    NvU32 currentDockState;
    NvU32 currentLidPolicy;
    NvU32 currentDockPolicy;
    NvU32 forcedLidMechanismPresent;
    NvU32 forcedDockMechanismPresent;
}NV_LID_DOCK_PARAMS;


//! ingroup sysgeneral
#define NV_LID_DOCK_PARAMS_VER  MAKE_NVAPI_VERSION(NV_LID_DOCK_PARAMS,1)
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_GetLidDockInfo
//
//! DESCRIPTION: This function returns the current lid and dock information.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 177
//!
//! \retval ::NVAPI_OK  
//! \retval ::NVAPI_ERROR
//! \retval ::NVAPI_NOT_SUPPORTED
//! \retval ::NVAPI_HANDLE_INVALIDATED
//! \retval ::NVAPI_API_NOT_INTIALIZED 
//!
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_GetLidAndDockInfo(NV_LID_DOCK_PARAMS *pLidAndDock);




//! \ingroup sysgeneral
//! Used in NvAPI_SYS_GetChipSetSliBondInfo().
typedef struct
{
    NvU32               version;        //!< Structure version
    NvU32               sliBondId;      
    NvAPI_ShortString   szSliBondName;
} NV_CHIPSET_SLI_BOND_INFO;


//! \ingroup sysgeneral
//! Used in NV_CHIPSET_SLI_BOND_INFO.
#define NV_CHIPSET_SLI_BOND_INFO_VER  MAKE_NVAPI_VERSION(NV_CHIPSET_SLI_BOND_INFO,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SYS_GetChipSetSliBondInfo
//
//!  DESCRIPTION: This function returns information about the system's chipset SLI bond.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 170
//!
//!  \retval  NVAPI_INVALID_ARGUMENT              pChipSetSliBondInfo is NULL.
//!  \retval  NVAPI_OK                           *pChipSetSliBondInfo is now set.
//!  \retval  NVAPI_INCOMPATIBLE_STRUCT_VERSION   NV_CHIPSET_SLI_BOND_INFO version is not compatible with the driver.
//!
//!  \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_GetChipSetSliBondInfo(NV_CHIPSET_SLI_BOND_INFO *pChipSetSliBondInfo);


//! \ingroup sysgeneral
typedef struct
{
    NvU32 version;                      //!< Structure version, constructed from macro below
    NvU32 hwbcId;                       //!< Opaque ID unique to this HWBC
    NvU32 firmwareVersion;              //!< The version of the firmware on the HWBC 
    NvU32 secondaryBus;                 //!< Secondary bus number of this PCIE bridge
    NvU32 subordinateBus;               //!< Subordinate bus number of this PCIE bridge
} NV_HWBC_INFO;

//! \ingroup sysgeneral
//! Macro for constructing the version field of ::NV_HWBC_INFO
#define NV_HWBC_INFO_VER  MAKE_NVAPI_VERSION(NV_HWBC_INFO,1)

//! \ingroup sysgeneral
typedef struct
{
    NvU32 version;  //!< Structure version, constructed from macro below
    NV_HWBC_INFO hwbcInfo[NVAPI_SYSTEM_MAX_HWBCS];
} NV_HWBC_INFO_PARAMS;

//! \ingroup sysgeneral
//! Macro for constructing the version field of ::NV_HWBC_INFO_PARAMS
#define NV_HWBC_INFO_PARAMS_VER  MAKE_NVAPI_VERSION(NV_HWBC_INFO_PARAMS,1)

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SYS_GetHwbcInfo
//
//! \code
//!   DESCRIPTION: Returns information about all BR04-based HWBCs (PCIE bridges)
//!                present in the system.
//!
//!   PARAMETERS: pHwbcInfoParams (OUT) - Pointer to a user-allocated NV_HWBC_-
//!                                       INFO_PARAMS structure. This structure
//!                                       contains an array of NV_HWBC_INFO 
//!                                       structures into which HWBC information
//!                                       is placed. There is one entry for each
//!                                       HWBC present in the system. Valid 
//!                                       entries are contiguous, invalid 
//!                                       entries have hwbcId equal to NVAPI_-
//!                                       SYSTEM_HWBC_INVALID_ID.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! RETURN STATUS: NVAPI_OK: The query was successful.
//!                NVAPI_ERROR: A miscellaneous error occurred.
//!                NVAPI_INVALID_POINTER: The pointer argument is NULL.
//!                NVAPI_HANDLE_INVALIDATED: NVAPI escape result handle is invalid.
//!                NVAPI_API_NOT_INTIALIZED: NVAPI not initialized.
//! \endcode
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_GetHwbcInfo(NV_HWBC_INFO_PARAMS *pHwbcInfoParams);


//! \ingroup sysgeneral
//! @{

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SYS_SetStereoMetaData
//
//! \fn NvAPI_SYS_SetStereoMetaData(NV_STEREO_METADATA* pNvStereoMetaData)
//! \code
//! DESCRIPTION:     Provides the stereo metadata for frame-packed stereo video's
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:      pNvStereoMetaData(IN)  - pointer to the stereo metadata struct
//!
//! RETURN STATUS:
//!                  NVAPI_OK - completed request
//!                  NVAPI_ERROR - miscellaneous error occurred
//!                  NVAPI_INVALID_ARGUMENT - Invalid input parameter
//! \endcode
///////////////////////////////////////////////////////////////////////////////

//! frame layout
typedef enum _NV_STEREO_PACKED_FRAME_LAYOUT
{
    PACKED_FRAME_LEFT_RIGHT        = 0x0,
    PACKED_FRAME_RIGHT_LEFT        = 0x1,
    PACKED_FRAME_OVER_UNDER        = 0x2,
    PACKED_FRAME_UNDER_OVER        = 0x3,
    PACKED_FRAME_LAST
} NV_STEREO_PACKED_FRAME_LAYOUT;


//! state for the metadata
typedef enum _NV_STEREO_METADATA_STATE
{
    METADATA_STATE_ENABLE          = 0x0,
    METADATA_STATE_DISABLE         = 0x1,
    METADATA_STATE_LAST
} NV_STEREO_METADATA_STATE;

//! stereo command
typedef enum _NV_STEREO_COMMAND
{
    STEREO_COMMAND_ADD_RECORD      = 0x0,
    STEREO_COMMAND_REMOVE_RECORD   = 0x1,
    STEREO_COMMAND_LAST
} NV_STEREO_COMMAND;


//! stereo frame info
typedef struct _NV_STEREO_FRAME_INFO
{
    NvU32                           processID;                  //!< (IN) app process id
    NvU32                           streamSrcWidth;             //!< (IN) width
    NvU32                           streamSrcHeight;            //!< (IN) height
    NV_STEREO_PACKED_FRAME_LAYOUT   streamFormat;               //!< (IN) Stream src layout
    NV_STEREO_COMMAND               stereoCmd;                  //!< (IN) stereo command
    NV_STEREO_METADATA_STATE        stereoState;                //!< (IN) stereo state
    NvU32                           IsFromNPAPIPlugin;          //!< (IN) boolean, true if called by an NPAPI plugin
    NvU32                           dwReserved[7];              //!< (IN) reserved DWORDS for future use
} NV_STEREO_FRAME_INFO;

typedef struct _NV_STEREO_METADATA_V1
{
    NvU32                   version;                            //!< (IN) version info
    NV_STEREO_FRAME_INFO    frameInfo;                          //!< packed frame info
} NV_STEREO_METADATA_V1;


typedef NV_STEREO_METADATA_V1 NV_STEREO_METADATA;
#define NV_STEREO_METADATA_VER1 MAKE_NVAPI_VERSION(NV_STEREO_METADATA_V1,1)
#define NV_STEREO_METADATA_VER  NV_STEREO_METADATA_VER1

NVAPI_INTERFACE NvAPI_SYS_SetStereoMetaData(NV_STEREO_METADATA* pNvStereoMetaData);

//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SYS_EnableDisplayHotkeyHandling
//
//! DESCRIPTION:  This function configures the display driver to handle ACPI hotkeys.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 165
//!
//!   \retval     NVAPI_OK     Completed request
//!   \retval     NVAPI_ERROR  Miscellaneous error occurred
//!
//!   \ingroup    sysgeneral
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_EnableDisplayHotkeyHandling(void);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SYS_DisableDisplayHotkeyHandling
//
//! DESCRIPTION:  This function configures the display driver to send events only on ACPI 
//!               hotkeys.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 165
//!
//!   \retval     NVAPI_OK     Completed request
//!   \retval     NVAPI_ERROR  Miscellaneous error occurred
//!
//!   \ingroup    sysgeneral
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_DisableDisplayHotkeyHandling(void);


//! Used in NvAPI_GPU_GetSmartDimmerConfig and NvAPI_GPU_SetSmartDimmerConfig for aggressivenessLevel.
typedef enum
{
    NV_SMART_DIMMER_LEVEL_OFF = 0,
    NV_SMART_DIMMER_LEVEL_HIGHEST_QUALITY = 1,
    NV_SMART_DIMMER_LEVEL_HIGHER_QUALITY = 2,
    NV_SMART_DIMMER_LEVEL_BALANCED = 3,
    NV_SMART_DIMMER_LEVEL_HIGHER_BATT_LIFE = 4,
    NV_SMART_DIMMER_LEVEL_HIGHEST_BATT_LIFE = 5,
} NV_SMART_DIMMER_LEVEL;
   
#define NV_SMART_DIMMER_DISABLED         NV_SMART_DIMMER_LEVEL_OFF
#define NV_SMART_DIMMER_AGGR_LEVEL_MIN   NV_SMART_DIMMER_LEVEL_HIGHEST_QUALITY
#define NV_SMART_DIMMER_AGGR_LEVEL_MAX   NV_SMART_DIMMER_LEVEL_HIGHEST_BATT_LIFE

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_SYS_GetSmartDimmerLevel
//
//! \code
//! DESCRIPTION:    This API queries the current SmartDimmer state
//!
//! PARAMETERS:     pLevel - Pointer to the variable receiving SmartDimmer state info
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! HOW TO USE:     NvS32 level;
//!                 ret = NvAPI_SYS_GetSmartDimmerLevel(&level);
//!                 On call success:
//!                 level would indicate if the feature is currently disabled 
//!                 or the current aggressiveness level if it is enabled
//!
//! RETURN STATUS:
//!                NVAPI_OK - completed request
//!                NVAPI_ERROR - miscellaneous error occurred
//!                NVAPI_NOT_SUPPORTED - SmartDimmer3.0 is not available on the target hardware
//!                NVAPI_INVALID_ARGUMENT - invalid argument passed
//!                NVAPI_API_NOT_INTIALIZED - nvapi not initialized
//! \endcode
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_GetSmartDimmerLevel(NV_SMART_DIMMER_LEVEL *pLevel);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_SYS_SetSmartDimmerLevel
//
//! \code
//! DESCRIPTION:    This API sets the current SmartDimmer state & level
//!
//! PARAMETERS:     Level - NV_SMART_DIMMER_DISABLED or aggressiveness level if request to enable
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! HOW TO USE:     NvS32 level = 0 (for disable)
//!                             = aggresiveness level (k) (for enable)
//!                 ret = NvAPI_SYS_SetSmartDimmerLevel(level);
//!                 On call success:
//!                 SmartDimmer feature would be enabled or disabled & aggresiveness set to the specified level
//!
//! RETURN STATUS:
//!                 NVAPI_OK - completed request
//!                 NVAPI_ERROR - miscellaneous error occurred
//!                 NVAPI_NOT_SUPPORTED - SmartDimmer3.0 feature is either not available on the target hardware 
//!                                       or not supported in the current configuration
//!                 NVAPI_INVALID_ARGUMENT - invalid argument passed
//!                 NVAPI_API_NOT_INTIALIZED - nvapi not initialized
//! \endcode
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_SetSmartDimmerLevel(NV_SMART_DIMMER_LEVEL level);



typedef struct
{
        NvU32                   version;               //!< Version of this structure

    NvU8                    enable;                //!< Enable SD or not (Tegra only)
    NV_SMART_DIMMER_LEVEL   aggressivenessLevel;   //!< Level 0-5, 0 is min which means "no effect" and 5 is max means "Hightest battery life"
    NvU16                   flickerThreshold;      //!< Specify the min amount the new backlight level must deviate from the current level for SD to update (Tegra only)
    NvU16                   flickerTimeLimit;      //!< Specify the min amount of time the new backlight level must exceed the current level for SD to update (Tegra only)
    NvU16                   backlightStep;         //!< Specify the initial step in the backlight correction as a fraction of 255 (Tegra only)
    NvU16                   backlightTC;           //!< Specify the time-constant of the backlight correction as a fraction of 1024 (Tegra only)
} NV_SMART_DIMMER_CONFIG_V1;

typedef NV_SMART_DIMMER_CONFIG_V1 NV_SMART_DIMMER_CONFIG;
#define NV_SMART_DIMMER_CONFIG_VER1  MAKE_NVAPI_VERSION(NV_SMART_DIMMER_CONFIG_V1,1)
#define NV_SMART_DIMMER_CONFIG_VER   NV_SMART_DIMMER_CONFIG_VER1
   
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_GPU_GetSmartDimmerConfig
//
//! \code
//! DESCRIPTION:    This API queries the current SmartDimmer config
//!
//! PARAMETERS:     pConfig - Pointer to the variable receiving SmartDimmer config info
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! HOW TO USE:     For big GPU, just setup the aggressivenessLevel of config (Note that set it to 0 also means disable).
//!                 For Tegra, need to setup all the fields of config. 
//!                 Passing the target GPU handle and the config into this call.  
//!                 On call success:
//!                 config would indicate current status/settings of this feature.
//!
//! RETURN STATUS: This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
//!                
//!                NVAPI_NOT_SUPPORTED - SmartDimmer is not available on the target hardware
//!                                      or not supported in the current configuration
//! \endcode
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_GetSmartDimmerConfig(NvPhysicalGpuHandle hPhysicalGpu, NV_SMART_DIMMER_CONFIG *pConfig);



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_GPU_SetSmartDimmerConfig
//
//! \code
//! DESCRIPTION:    This API sets the current SmartDimmer config
//!
//! PARAMETERS:     config
//!
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! HOW TO USE:     For big GPU, just setup the aggressivenessLevel of config (Note that set it to 0 also means disable).
//!                 For Tegra, need to setup all the fields of config. 
//!                 Passing the target GPU handle and the config into this call.  
//!                 On call success:
//!                 SmartDimmer feature would be set to the specified config
//!
//! RETURN STATUS:
//! RETURN STATUS: This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
//!                
//!                NVAPI_NOT_SUPPORTED - SmartDimmer is not available on the target hardware
//!                                      or not supported in the current configuration
//! \endcode
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_GPU_SetSmartDimmerConfig(NvPhysicalGpuHandle hPhysicalGpu, NV_SMART_DIMMER_CONFIG config);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:  NvAPI_SYS_NotifySBiosDisplaySwitch
//
//! \code
//! PARAMETERS:     ulDevicesMask(IN) - Display device mask.
//!
//! DESCRIPTION:    This API notifies SBIOS of a display switch to display devices specified by ulDevicesMask
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//! HOW TO USE:     ret = NvAPI_NotifySBiosDisplaySwitch(ulDevicesMask);
//!                 On call success:
//!                 SBIOS will be notified of a display switch to the ulDevicesMask specified display devices.
//!
//! RETURN STATUS:
//!                 NVAPI_OK - completed request
//!                 NVAPI_ERROR - miscellaneous error occurred
//!                 NVAPI_INVALID_ARGUMENT - invalid argument passed
//! \endcode
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_NotifySBiosDisplaySwitch(NvU32 ulDevicesMask);

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_SYS_SetPostOutput
//
//! \fn NvAPI_SYS_SetPostOutput(NvU32 address, NVAPI_POST_PORT_FORMAT format, NvU32 data)
//!
//! DESCRIPTION:     This API sends a byte value to the motherboard POST output.
//!                  This call works only on systems having GPUs with
//!                  engineering VBIOS! Systems with production VBIOS
//!                  will return ::NVAPI_NOT_SUPPORTED.
//!                  Supported address range is 0x80-0x84.
//!
//! HOW TO USE:      
//! \verbatem      ret = NvAPI_SYS_SetPostOutput(address, format, data);
//!                      address - POST port I/O address
//!                      format - format of data field
//!                      data - value to display
//!                              0-255 if _FORMAT_HEX
//!                              0-99  if _FORMAT_BCD 
//!                      (HEX->BCD conversion is performed by NvAPI)
//! \endverbatem
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \since Release: 180
//!
//! \retval ::NVAPI_OK 
//! \retval ::NVAPI_ERROR 
//! \retval ::NVAPI_INVALID_ADDRESS 
//! \retval ::NVAPI_INVALID_ARGUMENT    Incorrect data value (see limits above)
//! \retval ::NVAPI_NOT_SUPPORTED       The call is not supported (on production VBIOS-es)
//! \retval ::NVAPI_API_NOT_INTIALIZED 
//!
///////////////////////////////////////////////////////////////////////////////


//! \ingroup sysgeneral
//! Used in NvAPI_SYS_SetPostOutput().
typedef enum _NV_SYS_POST_PORT_FORMAT
{
    NVAPI_POST_PORT_FORMAT_HEX  = 0,
    NVAPI_POST_PORT_FORMAT_BCD,
} NVAPI_POST_PORT_FORMAT;

//! \ingroup sysgeneral
NVAPI_INTERFACE NvAPI_SYS_SetPostOutput(NvU32 address, NVAPI_POST_PORT_FORMAT format, NvU32 data);


//! SUPPORTED OS:  Windows Vista and higher
//!
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SYS_FixInvalidDriverState
//
//! \code
//!   DESCRIPTION: This function validates the current driver state, and will
//!                do a driver reload if necessary
//!
//!   PARAMETERS:   None
//!
//! RETURN STATUS: 
//!    NVAPI_OK - completed request
//!    NVAPI_ERROR - miscellaneous error occurred
//!    NVAPI_NOT_SUPPORTED - functionality not supported 
//!    NVAPI_API_NOT_INTIALIZED - nvapi not initialized
//! \endcode
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_FixInvalidDriverState();


//! \ingroup sysgeneral
//! @{

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_SYS_SpbControl
//
//! \fn NvAPI_SYS_SpbControl(NVAPI_SPB_COMMAND command, NVAPI_SPB_LOCALE locale, NvU32 *pParam)
//! \code
//! PARAMETERS:      command (IN)        - SPB control command to be executed
//!                  locale (IN)         - locale ID
//!                  param (IN, OUT)     - command specific paramater
//!                                      -- power is specified in (milliwatt)
//!                                      -- temperature in (millidegree Celsius)
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION:     This API call is used to control SPB functionality.
//!                  It is used to get/set single SPB parameter as well as to
//!                  control SPB execution mode.
//!                  NVAPI_SPB_DATA_* commands require correct locale parameter.
//!                  NVAPI_SPB_CMD_* and NVAPI_SPB_SYS_* commands require
//!                  locale to be set to NVAPI_SPB_LOCALE_SYSTEM.
//!                  NVAPI_SYS_CMD_* uses only enums defined
//!                  in NVAPI_SPB_COMMAND_PARAM.
//!                  Other commands that require additional parameter must
//!                  respect required units as specified in parameter
//!                  description.
//!
//!                  Do not use this call unles you work on SPB functionlaity.
//!                  It is still under development and minor changes can occur.
//!
//!
//! RETURN STATUS: 
//!    NVAPI_OK - completed request
//!    NVAPI_ERROR - miscellaneous error occurred
//!    NVAPI_INVALID_POINTER - NULL argument passed
//!    NVAPI_INVALID_ARGUMENT - incorrect param value
//!    NVAPI_NO_IMPLEMENTATION - command not implemented
//!    NVAPI_NOT_SUPPORTED - call is not supported
//!    NVAPI_API_NOT_INTIALIZED - NvAPI not initialized
//! \endcode
//
///////////////////////////////////////////////////////////////////////////////


typedef enum _NV_SPB_COMMAND
{
    NVAPI_SPB_CMD_GET_INIT                      = 0x0000,
    NVAPI_SPB_CMD_SET_EXEC,
    NVAPI_SPB_CMD_GET_EXEC,
    NVAPI_SPB_CMD_SET_ACTIONS,
    NVAPI_SPB_CMD_GET_ACTIONS,
    NVAPI_SPB_CMD_SET_LOGIC,
    NVAPI_SPB_CMD_GET_LOGIC,
    NVAPI_SPB_CMD_SET_PREFERENCE,
    NVAPI_SPB_CMD_GET_PREFERENCE,
    NVAPI_SPB_CMD_SET_GPU2CPU_LIMIT,
    NVAPI_SPB_CMD_GET_GPU2CPU_LIMIT,
    NVAPI_SPB_CMD_SET_PMU_SPB_STATE,
    NVAPI_SPB_CMD_GET_PMU_SPB_STATE,

    NVAPI_SPB_SYS_SET_MAX_POWER                 = 0x0100,
    NVAPI_SPB_SYS_GET_MAX_POWER,
    NVAPI_SPB_SYS_SET_COOLING_BUDGET,
    NVAPI_SPB_SYS_GET_COOLING_BUDGET,
    NVAPI_SPB_SYS_SET_INTEGRAL_PERIOD,
    NVAPI_SPB_SYS_GET_INTEGRAL_PERIOD,
    NVAPI_SPB_SYS_SET_RULESET,
    NVAPI_SPB_SYS_GET_RULESET,
    NVAPI_SPB_SYS_GET_RULE_COUNT,
    NVAPI_SPB_SYS_SET_APP_BOOST,
    NVAPI_SPB_SYS_GET_APP_BOOST,
    NVAPI_SPB_SYS_SET_PWR_SUPPLY_MODE,
    NVAPI_SPB_SYS_GET_PWR_SUPPLY_MODE,
    NVAPI_SPB_SYS_GET_VCT_SUPPORT_INFO,
    NVAPI_SPB_SYS_GET_SUPPORTED_FUNCTIONS,

    NVAPI_SPB_DATA_GET_POWER                    = 0x0200,
    NVAPI_SPB_DATA_GET_POWER_DELTA,
    NVAPI_SPB_DATA_GET_POWER_FUTURE,
    NVAPI_SPB_DATA_GET_POWER_LTMAVG,
    NVAPI_SPB_DATA_GET_POWER_INTEGRAL,
    NVAPI_SPB_DATA_GET_POWER_BURDEN,
    NVAPI_SPB_DATA_GET_POWER_INTERMEDIATE,

    NVAPI_SPB_DATA_GET_SENSOR_PARAMETERS        = 0x0210,

    NVAPI_SPB_DATA_GET_TEMP                     = 0x0220,
    NVAPI_SPB_DATA_GET_TEMP_DELTA,
    NVAPI_SPB_DATA_GET_TEMP_FUTURE,

    NVAPI_SPB_DATA_GET_PSTATE                   = 0x0240,
    NVAPI_SPB_DATA_GET_PSTATE_CAP,
    NVAPI_SPB_DATA_GET_PSTATE_MIN,
    NVAPI_SPB_DATA_GET_PSTATE_MAX,
    NVAPI_SPB_DATA_GET_PSTATE_ACTION,
    NVAPI_SPB_DATA_GET_PSTATE_SLFM_PRESENT,
    NVAPI_SPB_CMD_SET_POWER_SIM_STATE           = 0x0250,
    NVAPI_SPB_CMD_GET_POWER_SIM_STATE,
    NVAPI_SPB_DATA_SET_POWER_SIM_DATA,
    NVAPI_SPB_DATA_GET_POWER_SIM_DATA,

    NVAPI_SPB_DATA_PING_SBIOS_FOR_EVENT         = 0x0321

} NVAPI_SPB_COMMAND;

typedef enum _NV_SPB_LOCALE
{
    NVAPI_SPB_LOCALE_SYSTEM                     = 0x0000,
    NVAPI_SPB_LOCALE_CPU_0                      = 0x0100,
    NVAPI_SPB_LOCALE_CPU_1,
    NVAPI_SPB_LOCALE_GPU_0                      = 0x0200,
    NVAPI_SPB_LOCALE_GPU_1

} NVAPI_SPB_LOCALE;

typedef enum _NV_SPB_COMMAND_PARAM
{
    NVAPI_SPB_CMD_DEF_INVALID               = 0x80000000,
    NVAPI_SPB_CMD_DEF_INIT_NO                        = 0,
    NVAPI_SPB_CMD_DEF_INIT_YES,
    NVAPI_SPB_CMD_DEF_EXEC_STOP                      = 0,
    NVAPI_SPB_CMD_DEF_EXEC_START,
    NVAPI_SPB_CMD_DEF_ACTIONS_OFF                    = 0,
    NVAPI_SPB_CMD_DEF_ACTIONS_ON,
    NVAPI_SPB_CMD_DEF_LOGIC_OFF                      = 0,
    NVAPI_SPB_CMD_DEF_LOGIC_FUZZY,
    NVAPI_SPB_CMD_DEF_LOGIC_DETERMINISTIC,
    NVAPI_SPB_CMD_DEF_PREFERENCE_CPU                 = 0,
    NVAPI_SPB_CMD_DEF_PREFERENCE_GPU,
    NVAPI_SPB_CMD_DEF_PREFERENCE_BOTH,
    NVAPI_SPB_CMD_DEF_PMU_SPB_STATE_OFF              = 0,
    NVAPI_SPB_CMD_DEF_PMU_SPB_STATE_ON,
    NVAPI_SPB_CMD_DEF_PWR_SUPPLY_REAL                = 0,
    NVAPI_SPB_CMD_DEF_PWR_SUPPLY_FAKE_AC,
    NVAPI_SPB_CMD_DEF_PWR_SUPPLY_FAKE_BATT,
    NVAPI_SPB_SYS_DEF_FUNC_SUPPORT          = 0x00000001,
    NVAPI_SPB_SYS_DEF_FUNC_VENTURASTATUS    = 0x00000002,
    NVAPI_SPB_SYS_DEF_FUNC_GETPSS           = 0x00000004,
    NVAPI_SPB_SYS_DEF_FUNC_SETPPC           = 0x00000008,
    NVAPI_SPB_SYS_DEF_FUNC_GETPPC           = 0x00000010,
    NVAPI_SPB_SYS_DEF_FUNC_VENTURACB        = 0x00000020,
    NVAPI_SPB_SYS_DEF_FUNC_SYSPARAMS        = 0x00000040,
    NVAPI_SPB_DATA_DEF_ACTION_DEC_TO_P0              = 0,
    NVAPI_SPB_DATA_DEF_ACTION_DEC_BY_1,
    NVAPI_SPB_DATA_DEF_ACTION_DO_NOTHING,
    NVAPI_SPB_DATA_DEF_ACTION_SET_CURRENT,
    NVAPI_SPB_DATA_DEF_ACTION_INC_BY_1,
    NVAPI_SPB_DATA_DEF_ACTION_INC_BY_2,
    NVAPI_SPB_DATA_DEF_ACTION_INC_TO_LFM,
    NVAPI_SPB_DATA_DEF_ACTION_INC_TO_SLFM,
    NVAPI_SPB_DATA_DEF_SLFM_PRESENT_NO               = 0,
    NVAPI_SPB_DATA_DEF_SLFM_PRESENT_YES,
    NVAPI_SPB_DATA_DEF_POWER_SIM_STATE_OFF           = 0,
    NVAPI_SPB_DATA_DEF_POWER_SIM_STATE_ON

} NVAPI_SPB_COMMAND_PARAM;


NVAPI_INTERFACE NvAPI_SYS_SpbControl(NVAPI_SPB_COMMAND command, NVAPI_SPB_LOCALE locale, NvU32 *pParam);

//! @}


//! \ingroup sysgeneral
//! @{

#define NVAPI_SPB_BATCH_COMMANDS_MAX 16

typedef struct
{
    NvU32   version;            //!< [in] structure version
    NvU32   cmdCount;           //!< [in,out] number of commands to execute
    NvU32   succeeded;          //!< [out] number of succesfully executed commands

    struct
    {
        NVAPI_SPB_COMMAND   command;    //!< [in] SPB command
        NVAPI_SPB_LOCALE    locale;     //!< [in] SPB locale
        NvU32               param;      //!< [in/out] SPB param
    } commands[NVAPI_SPB_BATCH_COMMANDS_MAX];

} NV_SPB_BATCH_COMMAND_STRUCT;

//! Macro for constructing the version field of NV_SPB_BATCH_COMMAND_STRUCT
#define NV_SPB_BATCH_COMMAND_STRUCT_VER  MAKE_NVAPI_VERSION(NV_SPB_BATCH_COMMAND_STRUCT,1)


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_SYS_SpbBatchControl
//
//! \code
//! PARAMETERS:      pCmdStruct (IN, OUT) - Array of SPB commands to be executed
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION:     This API call allows execution of multiple SpbControl
//!                  commands. 
//!                  On output each commands[i].param holds output value
//!                  for appropriate command.  If command has failed
//!                  param holds value NVAPI_SPB_CMD_DEF_INVALID.
//!                  For more details on command/device/param refer to        
//!                  NvAPI_SYS_SpbControl().
//!
//! RETURN STATUS: 
//!    NVAPI_OK - completed request
//!    NVAPI_ERROR - miscellaneous error occurred
//!    NVAPI_INVALID_POINTER - NULL argument passed
//!    NVAPI_INVALID_ARGUMENT - incorrect cmdCount value
//!    NVAPI_NO_IMPLEMENTATION - command not implemented
//!    NVAPI_NOT_SUPPORTED - call is not supported
//!    NVAPI_API_NOT_INTIALIZED - NvAPI not initialized
//!    NVAPI_INVALID_CALL - invalid command/device/param & cmdCount holds # of failing entry
//!    NVAPI_INCOMPATIBLE_STRUCT_VERSION - the version of the INFO struct is not supported
//! \endcode
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_SpbBatchControl(NV_SPB_BATCH_COMMAND_STRUCT *pCmdStruct);

//! @}



//! \ingroup sysgeneral
//! @{

#define NVAPI_MAX_SPB_CPU_PSTATE 15

typedef struct
{
    NvU32 version;                 //!< Structure version

    NvU32 numOfCpuPstates;
    // This structure defines CPU PState table entries.
    struct
    {
        NvU32   coreFreq;          //!< MHz (650 = 650MHz)
        NvU32   power;             //!< mW - milliwatt (8200mW = 8.2W)
        NvU32   transitionLatency; //!< us - microseconds (500 = 500us)
        NvU32   busMasterLatency;  //!< us - microseconds (300 = 300us)
        NvU32   control;           //!< see ACPI spec
        NvU32   status;            //!< see ACPI spec
    } cpuPstateTable[NVAPI_MAX_SPB_CPU_PSTATE];

} NV_SPB_GET_CPU_PSTATE_TABLE_V1;

typedef NV_SPB_GET_CPU_PSTATE_TABLE_V1 NV_SPB_GET_CPU_PSTATE_TABLE;

#define NV_SPB_GET_CPU_PSTATE_TABLE_VER_1 MAKE_NVAPI_VERSION(NV_SPB_GET_CPU_PSTATE_TABLE_V1,1)
#define NV_SPB_GET_CPU_PSTATE_TABLE_VER   NV_SPB_GET_CPU_PSTATE_TABLE_VER_1


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_SYS_SpbGetPstateTable
//
//! \code
//! PARAMETERS:      pPstateTable (OUT)     - PState table of CPU
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION:     This API call is used to get SPB PSTATE Table of CPU.
//!
//!                  Do not use this call unles you work on SPB functionlaity.
//!                  It is still under development and minor changes can occur.
//!
//! RETURN STATUS: 
//!    NVAPI_OK - completed request
//!    NVAPI_ERROR - miscellaneous error occurred
//!    NVAPI_INVALID_POINTER - NULL argument passed
//!    NVAPI_INVALID_ARGUMENT - incorrect param value
//!    NVAPI_NO_IMPLEMENTATION - command not implemented
//!    NVAPI_NOT_SUPPORTED - call is not supported
//!    NVAPI_API_NOT_INTIALIZED - NvAPI not initialized
//! \endcode
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_SpbGetPstateTable(NV_SPB_GET_CPU_PSTATE_TABLE *pPstateTable);

//! @}


//! \ingroup sysgeneral
//! @{

#define NVAPI_SPB_MAX_SENSORS     8

typedef struct
{
    NvU32                  version;                     //!< Structure version

    NvU32 sensorCount;
    // This structure defines Sensor Data for CPU/GPU sensors.
    struct
    {
        NvU32 target;        //!< 0 = CPU sensor; 1 = GPU sensor
        NvU32 type;          //!< 0 = Relative_POWER; 1 = Absolute_POWER
        NvU32 i2cPort;       //!< GPU I2C port for this sensor
        NvU32 i2cAddress;    //!< I2C address for this sensor
        NvU32 configIndex;   //!< Sensor register location
        NvU32 configValue;   //!< Value to write to sensor register
        NvU32 calibIndex;    //!< Calibration register location
        NvU32 calibValue;    //!< Value to write to calibration register
        NvU32 powerIndex;    //!< Power register location
        NvU32 pollFreq;      //!< Frequency to sample sensor (in Hz)
        NvU32 resistor;      //!< Value of sense resistor (in milli-ohms)
    } sensorConfig[NVAPI_SPB_MAX_SENSORS];

} NV_SPB_GET_SENSOR_CONFIG_V1;

typedef NV_SPB_GET_SENSOR_CONFIG_V1 NV_SPB_GET_SENSOR_CONFIG;

#define NV_SPB_GET_SENSOR_CONFIG_VER_1 MAKE_NVAPI_VERSION(NV_SPB_GET_SENSOR_CONFIG_V1,1)
#define NV_SPB_GET_SENSOR_CONFIG_VER   NV_SPB_GET_SENSOR_CONFIG_VER_1


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_SYS_SpbGetSensorConfig
//
//! \code
//! PARAMETERS:      psensorConfig (OUT)   - SPB Sensor Data for CPU/GPU sensor
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION:     This API call is used to get SPB Sensor Data of CPU and GPU.
//!
//!                  Do not use this call unles you work on SPB functionlaity.
//!                  It is still under development and minor changes can occur.
//!
//! RETURN STATUS: 
//!    NVAPI_OK - completed request
//!    NVAPI_ERROR - miscellaneous error occurred
//!    NVAPI_INVALID_POINTER - NULL argument passed
//!    NVAPI_INVALID_ARGUMENT - incorrect param value
//!    NVAPI_NO_IMPLEMENTATION - command not implemented
//!    NVAPI_NOT_SUPPORTED - call is not supported
//!    NVAPI_API_NOT_INTIALIZED - NvAPI not initialized
//! \endcode
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_SpbGetSensorConfig(NV_SPB_GET_SENSOR_CONFIG *pSensorConfig);

//! @}


///////////////////////////////////////////////////////////////////////////////
//
// New view APIs 
//
///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SYS_GetDisplayIdFromGpuAndOutputId
//
//! DESCRIPTION:     This API converts a Physical GPU handle and output ID to a
//!                  display ID.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]     hPhysicalGpu   Handle to the physical GPU
//! \param [in]     outputId       Connected display output ID on the 
//!                                target GPU - must only have one bit set
//! \param [out]    displayId      Pointer to an NvU32 which contains
//!                                 the display ID
//!
//! \retval  ::NVAPI_OK - completed request
//! \retval  ::NVAPI_API_NOT_INTIALIZED - NVAPI not initialized
//! \retval  ::NVAPI_ERROR - miscellaneous error occurred
//! \retval  ::NVAPI_INVALID_ARGUMENT - Invalid input parameter.
//!
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_GetDisplayIdFromGpuAndOutputId(NvPhysicalGpuHandle hPhysicalGpu, NvU32 outputId, NvU32* displayId);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SYS_GetGpuAndOutputIdFromDisplayId
//
//! DESCRIPTION:     This API converts a display ID to a Physical GPU handle and output ID.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]     displayId       Display ID of display to retrieve 
//!                                 GPU and outputId for
//! \param [out]    hPhysicalGpu    Handle to the physical GPU
//! \param [out]    outputId )      Connected display output ID on the 
//!                                 target GPU will only have one bit set.
//!
//! \retval ::NVAPI_OK 
//! \retval ::NVAPI_API_NOT_INTIALIZED 
//! \retval ::NVAPI_ID_OUT_OF_RANGE    The DisplayId corresponds to a 
//!                                    display which is not within the
//!                                    normal outputId range.
//! \retval ::NVAPI_ERROR   
//! \retval ::NVAPI_INVALID_ARGUMENT 
//!
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_GetGpuAndOutputIdFromDisplayId(NvU32 displayId, NvPhysicalGpuHandle *hPhysicalGpu, NvU32 *outputId);


///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SYS_GetPhysicalGpuFromDisplayId
//
//! \code
//! DESCRIPTION:     This API retrieves the Physical GPU handle of the connected display
//!
//! \since Release: 313
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:      displayId(IN)     - Display ID of display to retrieve 
//!                                      GPU handle
//!                  hPhysicalGpu(OUT) - Handle to the physical GPU
//!
//! RETURN STATUS:
//!                  NVAPI_OK - completed request
//!                  NVAPI_API_NOT_INTIALIZED - NVAPI not initialized
//!                  NVAPI_ERROR - miscellaneous error occurred
//!                  NVAPI_INVALID_ARGUMENT - Invalid input parameter.
//! \endcode
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_GetPhysicalGpuFromDisplayId(NvU32 displayId, NvPhysicalGpuHandle *hPhysicalGpu);


//! \ingroup sysgeneral
//! @{

#define NV_LUID_CONTAINS_EDID             NV_BIT(0) //!< This is Read only flag - Generate a LUID based on the EDID

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SYS_GetLUIDFromDisplayID
//
//! \code
//! DESCRIPTION:   Converts a displayId to a LUID.
//! HOW TO USE:    for each PhysicalGpu Query for NvAPI_GPU_GetConnectedDisplayIds to get list of displayId's
//!                On call success:
//!                Use NvAPI_SYS_GetLUIDFromDisplayID function to get a LUID corresponding to the displayId.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:      displayId(IN) - Display ID of display to retrieve LUID
//!
//!                  luId(OUT)     - A Locally unique identifier or LUID is a special type of identifier designed
//!                                  to maintain the persistent. LUID is valid across reboots, driver reloads and topology changes.
//!                  flags(IN)     - one or more defines from NV_LUID_CONTAINS_* as valid flags.
//!
//! RETURN STATUS:
//!                  NVAPI_OK - completed request
//!                  NVAPI_API_NOT_INTIALIZED - NVAPI not initialized
//!                  NVAPI_ID_OUT_OF_RANGE - The DisplayId corresponds to a 
//!                                          display which is not within the
//!                                          normal outputId range.
//!                  NVAPI_ERROR - miscellaneous error occurred
//!                  NVAPI_INVALID_ARGUMENT - Invalid input parameter.
//! \endcode
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_GetLUIDFromDisplayID(NvU32 displayId, NvU32 flags, NvLUID *luId);

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME:   NvAPI_SYS_GetDisplayIdFromLUID
//
//! \code
//! DESCRIPTION:   Converts a LUID to a displayId
//! HOW TO USE:    Client needs to pass a LUID which they already having
//!
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! PARAMETERS:      luId(IN)       - A Locally unique identifier or LUID is a special type of identifier designed 
//!                                   to maintain the persistent. LUID is valid across reboots, driver reloads and topology changes.
//!                                  
//!                  displayId(OUT) - Pointer to an NvU32 which will contain the displayID
//!
//! RETURN STATUS:
//!                  NVAPI_OK - completed request
//!                  NVAPI_API_NOT_INTIALIZED - NVAPI not initialized
//!                  NVAPI_ERROR - miscellaneous error occurred
//!                  NVAPI_INVALID_ARGUMENT - Invalid input parameter.
//!                  NVAPI_MATCHING_DEVICE_NOT_FOUND - The display Id could not be located
//! \endcode
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_GetDisplayIdFromLUID(NvLUID luId, NvU32* displayId);

//! @}







//! \ingroup sysgeneral
//! @{

#define NV_MAX_MDTL_COMBINATIONS         30            //!< as per spec limit

typedef struct _NV_MDTL_COMBINATION_V1

{
    NvU32               ulACPIId1;                  //!< Device ACPI ID 1
    NvU32               ulACPIId2;                  //!< Device ACPI ID 2
    
} NV_MDTL_COMBINATION_V1;

typedef struct _NV_MDTL_COMBINATION_V2
{
    NvU32                 ulACPIId1;                  //!< Device ACPI ID 1
    NvU32                 ulACPIId2;                  //!, Device ACPI ID 2
    NV_TARGET_VIEW_MODE   viewMode;                   //!< NV_VIEW_MODE_STANDARD/CLONE/DUALVIEW

} NV_MDTL_COMBINATION_V2;

typedef NV_MDTL_COMBINATION_V2 NV_MDTL_COMBINATION; 


typedef struct _NV_MDTL_LIST_DATA_V1
{
    NvU32   version;                                               //!< (IN)version info

    NvU32 ulValidMdtlCombinations;                                 //!< Total valid MDTL entries
    NV_MDTL_COMBINATION_V1 mdtlList[NV_MAX_MDTL_COMBINATIONS];     //!< MDTL list containing all possible hot key display combinations

}NV_MDTL_LIST_DATA_V1;



typedef struct _NV_MDTL_LIST_DATA_V2
{
    NvU32   version;                                               //!< (IN)version info
    NvU32 ulValidMdtlCombinations;                                 //!< Total valid MDTL entries
    NV_MDTL_COMBINATION mdtlList[NV_MAX_MDTL_COMBINATIONS];        //!< MDTL list containing all possible hot key display combinations

}NV_MDTL_LIST_DATA_V2;


//! Macro for constructing the version field of ::_NV_MDTL_LIST_DATA
#define NV_MDTL_LIST_DATA_VER1  MAKE_NVAPI_VERSION(NV_MDTL_LIST_DATA_V1,1)
#define NV_MDTL_LIST_DATA_VER2  MAKE_NVAPI_VERSION(NV_MDTL_LIST_DATA_V2,2)
#define NV_MDTL_LIST_DATA_VER NV_MDTL_LIST_DATA_VER2
typedef NV_MDTL_LIST_DATA_V2  NV_MDTL_LIST_DATA;

typedef struct _NV_MDTL_VALID_INDEX_V1
{
    NvU32   version;                                               // (IN)version info
    
    NvU32   ulValidMdtlIndex;                                      // The valid MDTL combination index informed to SBIOS.

}NV_MDTL_VALID_INDEX_V1;

#define NV_MDTL_VALID_INDEX_VER1  MAKE_NVAPI_VERSION(NV_MDTL_VALID_INDEX_V1,1)
#define NV_MDTL_VALID_INDEX_VER NV_MDTL_VALID_INDEX_VER1
typedef NV_MDTL_VALID_INDEX_V1  NV_MDTL_VALID_INDEX;



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_SYS_GetMDTLData
//
//! \code
//! PARAMETERS:      pMdtlData (OUT)         - Out Pointer to the NV_MDTL_LIST_DATA. 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION:     This API call is used to get the MDTL List from the Driver.
//!                  If call succeeds,  "pMdtlList" points to the List.
//!
//!
//! RETURN STATUS:
//!    NVAPI_OK - completed request
//!    NVAPI_INCOMPATIBLE_STRUCT_VERSION - NV_MDTL_LIST_DATA structure version mismatch.
//!    NVAPI_ERROR - miscellaneous error occurred
//!    NVAPI_INVALID_POINTER - NULL argument passed
//!    NVAPI_NOT_SUPPORTED - call is not supported
//!    NVAPI_API_NOT_INTIALIZED - NvAPI not initialized
//! \endcode
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_GetMDTLData(NV_MDTL_LIST_DATA *pMdtlData);

//! @}







///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_SYS_SetValidMDTLIndex
//! \code
//! PARAMETERS:      pMdtlIndexData (IN)         - In Pointer to the NV_MDTL_VALID_INDEX data index data
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION:     This API call sets the MDTL index, chosen by nvsvc, to the SBIOS 
//!                  via display driver
//!
//!
//! RETURN STATUS:
//!    NVAPI_OK - completed request
//!    NVAPI_INCOMPATIBLE_STRUCT_VERSION - NV_MDTL_VALID_INDEX structure version mismatch.
//!    NVAPI_ERROR - An unknown error occurred.
//!    NVAPI_INVALID_POINTER - NULL argument passed
//!    NVAPI_NOT_SUPPORTED - call is not supported
//!    NVAPI_API_NOT_INTIALIZED - NvAPI not initialized
//! \endcode
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_SetValidMDTLIndex(NV_MDTL_VALID_INDEX *pMdtlIndexData);




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_SYS_VenturaGetState
//
//! \fn NvAPI_SYS_VenturaGetState(NVAPI_VENTURA_STATE *state)
//!
//!  DESCRIPTION:   This API queries the current Ventura state.
//!                  If the call succeeds, the variable state holds one of the following
//!                  values:
//!                  - NVAPI_VENTURA_STATE_UNSUPPORTED - when executed on 
//!                  Ventura non-capable system
//!                  - NVAPI_VENTURA_STATE_DISABLED - Ventura control is not
//!                  active (but system is Ventura capable)
//!                  - NVAPI_VENTURA_STATE_ENABLED - Ventura is actively
//!                  managing power consumption to stay within defined budget
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 185
//!
//! \param [out]   state    The current Ventura state
//!
//! \retval ::NVAPI_OK 
//! \retval ::NVAPI_ERROR 
//! \retval ::NVAPI_INVALID_POINTER   NULL argument passed
//! \retval ::NVAPI_INVALID_ARGUMENT  Incorrect param value
//! \retval ::NVAPI_NOT_SUPPORTED 
//! \retval ::NVAPI_API_NOT_INTIALIZED 
//!
///////////////////////////////////////////////////////////////////////////////

//! \ingroup sysgeneral
//! Used in NvAPI_SYS_VenturaSetState() and NvAPI_SYS_VenturaGetState().
typedef enum _NVAPI_VENTURA_STATE
{
    NVAPI_VENTURA_STATE_UNSUPPORTED,
    NVAPI_VENTURA_STATE_DISABLED,    //!< Deactivate Ventura 
    NVAPI_VENTURA_STATE_ENABLED      //!< Activate Ventura

} NVAPI_VENTURA_STATE;

//! \ingroup sysgeneral
NVAPI_INTERFACE NvAPI_SYS_VenturaGetState(NVAPI_VENTURA_STATE *state);





///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_SYS_VenturaSetState
//
//! DESCRIPTION:     This API controls the Ventura state.
//!                  See ::NVAPI_VENTURA_STATE for valid state values. 
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]    state    The new Ventura state
//!
//! \retval ::NVAPI_OK 
//! \retval ::NVAPI_ERROR
//! \retval ::NVAPI_INVALID_ARGUMENT 
//! \retval ::NVAPI_NOT_SUPPORTED 
//! \retval ::NVAPI_API_NOT_INTIALIZED 
//!
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_VenturaSetState(NVAPI_VENTURA_STATE state);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_SYS_VenturaGetCoolingBudget
//
//! DESCRIPTION:     This API retrieves the cooling budget that is
//!                  currently being used by Ventura.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 185
//!
//! \param [out]     budget   The current cooling budget (in mW)
//!
//! \retval ::NVAPI_OK 
//! \retval ::NVAPI_ERROR 
//! \retval ::NVAPI_INVALID_POINTER 
//! \retval ::NVAPI_INVALID_ARGUMENT 
//! \retval ::NVAPI_NOT_SUPPORTED 
//! \retval ::NVAPI_API_NOT_INTIALIZED 
//!
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_VenturaGetCoolingBudget(NvU32 *budget);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_SYS_VenturaSetCoolingBudget
//
//! DESCRIPTION:     This API call sets the new cooling budget
//!                  that will be used by Ventura.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \since Release: 185
//!
//! \param [in]      budget    The new cooling budget (in mW)
//!
//! \retval ::NVAPI_OK - completed request
//! \retval ::NVAPI_ERROR - miscellaneous error occurred
//! \retval ::NVAPI_INVALID_ARGUMENT - incorrect param value
//! \retval ::NVAPI_NOT_SUPPORTED - call is not supported
//! \retval ::NVAPI_API_NOT_INTIALIZED - NvAPI not initialized
//!
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_VenturaSetCoolingBudget(NvU32 budget);

//! \ingroup sysgeneral
//! @{
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_SYS_VenturaGetPowerReading
//
//! \fn NvAPI_SYS_VenturaGetPowerReading(NVAPI_VENTURA_DEVICE device, NvU32 *power)
//!
//! \param [in]     device          targeted device
//! \param [out]    power           latest power reading [mW]
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION:     This API call is used to query for latest power reading.
//!                  'Device' describes desired target device .
//!                  If call succeeds, variable 'power' holds device's latest
//!                  power reading in [mW] (1/1000 of Watt).
//!
//!                  Power measurement for device 'system' can be greater than
//!                  sum of power measurements for devices 'cpu_0' and 'gpu_0'
//!                  since additional devices can be introduced in the future.
//!
//! \return 
//!    ::NVAPI_OK,  
//!    ::NVAPI_ERROR, 
//!    ::NVAPI_INVALID_POINTER, 
//!    ::NVAPI_INVALID_ARGUMENT, 
//!    ::NVAPI_NOT_SUPPORTED, 
//!    ::NVAPI_API_NOT_INTIALIZED, 
//
///////////////////////////////////////////////////////////////////////////////

//! See NvAPI_SYS_VenturaGetPowerReading().
typedef enum _NVAPI_VENTURA_DEVICE
{
    NVAPI_VENTURA_DEVICE_SYSTEM,
    NVAPI_VENTURA_DEVICE_CPU_0,
    NVAPI_VENTURA_DEVICE_GPU_0

} NVAPI_VENTURA_DEVICE;


NVAPI_INTERFACE NvAPI_SYS_VenturaGetPowerReading(NVAPI_VENTURA_DEVICE device, NvU32 *power);

//! @}





//! \ingroup sysgeneral
typedef enum
{
    NV_SS_FEATURE_LICENSE_MODE_UNKNOWN					= 0,
    NV_SS_FEATURE_LICENSE_MODE_3DVISION_PANEL			= 1,
    NV_SS_FEATURE_LICENSE_MODE_3DTV_OEM_BULK			= 2,
    NV_SS_FEATURE_LICENSE_MODE_3DTV_END_USER			= 3,
    NV_SS_FEATURE_LICENSE_MODE_3DV_ANY					= 4,
    NV_SS_FEATURE_LICENSE_MODE_3DTV_PLAYPLUS_END_USER   = 5,
    
    NV_SS_FEATURE_LICENSE_MODE_CSC_OEM_BULK   = 0x100,
    NV_SS_FEATURE_LICENSE_MODE_CSC_END_USER   = 0x200,
    NV_SS_FEATURE_LICENSE_MODE_CSC_ANY        = 0xF00,

    /* Add new feature and license mode here */
} NV_SS_FEATURE_LICENSE_MODE;

///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_SYS_CheckLicense
//
//! \code
//!   DESCRIPTION: Check for an effective license for the specified software feature on the system.
//!    PARAMETERS: mode(IN)                            - Feature license mode, must be NV_SS_FEATURE_LICENSE_MODE_*_ANY.
//!                pEffectiveLicenseMode(OUT OPTIONAL) - Return the effective license mode if found.
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! 
//! RETURN STATUS: NVAPI_INVALID_ARGUMENT: Invalid feature license mode.
//!                NVAPI_OK: Effective license found.
//!                NVAPI_ERROR: No license found or call failed.
//! \endcode
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_CheckLicense(NV_SS_FEATURE_LICENSE_MODE mode , NV_SS_FEATURE_LICENSE_MODE *pEffectiveLicenseMode);



///////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_SYS_IdentifyLicense
//
//! \code
//!    DESCRIPTION: Return the session-key encrypted software serial number & 4PID.
//!    PARAMETERS: mode(IN)              - Feature license mode, must be NV_SS_FEATURE_LICENSE_MODE_*_END_USER.
//!                sessionKey(IN)        - 128-bit session encryption key.
//!                random(OUT)           - 256-bit random number.
//!                serialNumber4PID(OUT) - Encrypted feature software serial number, 128 bits, followed by
//!                                        encrypted 4PartID, 128 bits. 4PartID is 64-bit, 0 pre-padding to 128-bit before encryption.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! RETURN STATUS: NVAPI_INVALID_ARGUMENT: Invalid feature license mode.
//!                NVAPI_OK: License data returned.
//!                NVAPI_ERROR: Call failed.
//! \endcode
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_IdentifyLicense(NV_SS_FEATURE_LICENSE_MODE mode, NvU8 sessionKey[16], NvU8 random[32], NvU8 serialNumber4PID[32]);





/////////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_SYS_ValidateLicense
//
//! \code 
//!   DESCRIPTION:  Validate the feature license specified by mode.
//!    PARAMETERS: mode(IN) - Feature license mode
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! RETURN STATUS: NVAPI_INVALID_ARGUMENT: Invalid feature license mode or invalid pointers.
//!                NVAPI_OK: License validated.
//!                NVAPI_ERROR: No license, invalid license or call failed.
//! \endcode
//! \ingroup sysgeneral
//////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_ValidateLicense(NV_SS_FEATURE_LICENSE_MODE mode);



/////////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_SYS_GenerateLicense
//
//! \code
//!   DESCRIPTION: Verify double encrypted software serial number. If valid, generate an end-user license and save it to registry.
//!    PARAMETERS: mode(IN)         - Feature license mode, must be NV_SS_FEATURE_LICENSE_MODE_*_END_USER.
//!                sessionKey(IN)   - Session key used in previous call of NvAPI_SYS_IdentifyLicense.
//!                serialNumber(IN) - 128-bit software serial number double encrypted by session key & a feature-specific key shared
//!                                   between DR license-protected client and SEC uCode.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! RETURN STATUS: NVAPI_INVALID_ARGUMENT: invalid feature license mode.
//!                NVAPI_OK: Feature license generated and saved.
//!                NVAPI_ERROR: Call failed.
//! \endcode
//! \ingroup sysgeneral 
//////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_GenerateLicense(NV_SS_FEATURE_LICENSE_MODE mode , NvU8 sessionKey[16], NvU8 serialNumber[16]);




/////////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_SYS_RemoveLicense
//
//! \code
//!   DESCRIPTION: Remove end-user feature license saved in registry.
//!    PARAMETERS: mode(IN) - Feature license mode, must be NV_SS_FEATURE_LICENSE_MODE_*_END_USER.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! RETURN STATUS: NVAPI_INVALID_ARGUMENT: invalid feature license mode.
//!                NVAPI_OK: Feature license removed or not found.
//!                NVAPI_ERROR: Call failed.
//! \endcode
//! \ingroup sysgeneral
//////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_RemoveLicense(NV_SS_FEATURE_LICENSE_MODE mode);



/////////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_SYS_SetMiscLicenseInfo
//
//! \code
//!    DESCRIPTION: This API changes the encrypted DR license info in the kernel driver.
//!    PARAMETERS: mode(IN)         - Feature license mode, must be NV_SS_FEATURE_LICENSE_MODE_*_END_USER.
//!                licenseInfo(IN)  - Encrypted DR license info.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! RETURN STATUS: NVAPI_INVALID_ARGUMENT: invalid feature license mode.
//!                NVAPI_OK: Succeeded.
//!                NVAPI_ERROR: Call failed.
//! \endcode
//! \ingroup sysgeneral
//////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_SetMiscLicenseInfo(NV_SS_FEATURE_LICENSE_MODE mode, NvU8 licenseInfo[256]);


/////////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_SYS_ClearMiscLicenseInfo
//
//! \code
//!   DESCRIPTION: This API clears the encrypted DR license info saved in the kernel driver.
//!    PARAMETERS: mode(IN)         - Feature license mode, must be NV_SS_FEATURE_LICENSE_MODE_*_END_USER.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! RETURN STATUS: NVAPI_INVALID_ARGUMENT: invalid feature license mode.
//!                NVAPI_OK: License info cleared or not found.
//!                NVAPI_ERROR: Call failed.
//! \endcode
//! \ingroup sysgeneral
//////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_ClearMiscLicenseInfo(NV_SS_FEATURE_LICENSE_MODE mode);




//! \ingroup sysgeneral
//! @{

typedef struct _NV_SS_MISC_LICENSE_INFO_V1
{
    NvU32   version;                //!< (IN)  structure version
    NvU8    isLicensed;             //!< (OUT) true if licensed, otherwise false.
    char    szSerialNumber[128];    //!< (OUT) Serial number if licensed, otherwise empty.
    NvU8    isTrialExpired;         //!< (OUT) true if trial expired, otherwise false; not valid if licensed.
    NvU8    trialDaysLeft;          //!< (OUT) The number of trial days left; not valid if licensed.
} NV_SS_MISC_LICENSE_INFO_V1;

typedef NV_SS_MISC_LICENSE_INFO_V1    NV_SS_MISC_LICENSE_INFO;
#define NV_SS_MISC_LICENSE_INFO_VER1  MAKE_NVAPI_VERSION(NV_SS_MISC_LICENSE_INFO_V1,1)
#define NV_SS_MISC_LICENSE_INFO_VER   NV_SS_MISC_LICENSE_INFO_VER1

//! @}

/////////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_SYS_GetMiscLicenseInfo
//
//! \code
//!   DESCRIPTION: This API gets the DR license info from the encrypted data saved in the kernel driver.
//!    PARAMETERS: mode(IN)                        - Feature license mode, must be NV_SS_FEATURE_LICENSE_MODE_*_END_USER.
//!                pMiscLicenseInfo [OUT]          - DR license info.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! RETURN STATUS: NVAPI_INVALID_ARGUMENT: invalid feature license mode, or NULL pointers.
//!                NVAPI_OK: Succeeded.
//!                NVAPI_ERROR: Call failed or no license data set before.
//!                             bIsLicensed set to false, szSerialNumber empty, bIsTrialExpired true, nTrialDaysLeft 0
//! \endcode
//! \ingroup sysgeneral
//////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_GetMiscLicenseInfo(NV_SS_FEATURE_LICENSE_MODE mode, NV_SS_MISC_LICENSE_INFO *pMiscLicenseInfo);







//! \ingroup sysgeneral
typedef struct _NVAPI_SYS_NBCI_PLATCAPS_PARAMS
{
    NvU32 version;                                    //!< Structure version

    NvU32 is3DEnableHotKeySupported:1;                //!< 1 :3D Stereo Enable-Disable Hotkey Supported.
                                                      //!< 0 :3D Stereo Enable-Disable Hotkey Not Supported.
    NvU32 is3DSeparationHotKeySupported:1;            //!< 1 :3D Stereo Separation.Hotkey Supported.
                                                      //!< 0 :3D Stereo Separation Hotkey Not Supported.
    NvU32 is3DActivateHotKeySupported:1;              //!< 1 :3D Stereo Activate-Deavtivate Hotkey Supported.
                                                      //!< 0 :3D Stereo Activate-Deavtivate Hotkey Not Supported.
    NvU32 reserved:29;
    
} NVAPI_SYS_NBCI_PLATCAPS_PARAMS_V1;

//! \ingroup sysgeneral
typedef NVAPI_SYS_NBCI_PLATCAPS_PARAMS_V1     NVAPI_SYS_NBCI_PLATCAPS_PARAMS;

//! \ingroup sysgeneral
#define NVAPI_SYS_NBCI_PLATCAPS_PARAMS_VER1   MAKE_NVAPI_VERSION(NVAPI_SYS_NBCI_PLATCAPS_PARAMS_V1,1)

//! \ingroup sysgeneral
#define NVAPI_SYS_NBCI_PLATCAPS_PARAMS_VER    NVAPI_SYS_NBCI_PLATCAPS_PARAMS_VER1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_SYS_GetNBCIPlatCaps
//
//! \param [out]    *pParams      Structure containing the out data. This data is 
//!                               the platcaps data returned by SBios.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! DESCRIPTION:     This API call is used to query for NBCI Platcaps. 
//!                  NVAPI_SYS_NBCI_PLATCAPS_PARAMS contains the out Data which is the platcaps..
//!
//! \retval ::NVAPI_OK - completed request
//! \retval ::NVAPI_ERROR - miscellaneous error occurred
//! \retval ::NVAPI_INVALID_POINTER - NULL argument passed
//! \retval ::NVAPI_NOT_SUPPORTED - call is not supported
//! \retval ::NVAPI_API_NOT_INTIALIZED - NvAPI not initialized
//! \retval ::NVAPI_INCOMPATIBLE_STRUCT_VERSION - Invalid Structure version.
//!
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_GetNBCIPlatCaps(NVAPI_SYS_NBCI_PLATCAPS_PARAMS *pParams);






//! \ingroup sysgeneral
#define NVAPI_OCA_FINGERPRINT_MAX_BUFFER_SIZE 128

////////////////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_SYS_SaveOCAFingerprint
//
//! DESCRIPTION: This API saves the fingerprint data passed in by user into the KMD OCA buffer,
//!              which is later saved in the mini-dump to be sent to OCA site in case of crash.
//!              The size of data, in bytes, present in buffer should not be more than NVAPI_OCA_FINGERPRINT_MAX_BUFFER_SIZE.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in]  pFingerprintBuffer   pointer to the buffer which contains the 
//!                                   fingerprint data to be saved
//! \param [in]  sizeOfBuffer         size, in Bytes, of the fingerprint data present in the buffer pointed by pFingerprintBuffer.
//!
//! \return      This API can return any of the error codes enumerated in #NvAPI_Status. 
//!              If there are return error codes with specific meaning for this API, they are listed below:
//! \retval ::NVAPI_INVALID_POINTER pFingerprintBuffer is NULL.
//! \retval ::NVAPI_ARGUMENT_EXCEED_MAX_SIZE sizeOfBuffer is greater than NVAPI_OCA_FINGERPRINT_MAX_BUFFER_SIZE
//!
//! \ingroup sysgeneral
////////////////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_SaveOCAFingerprint(__in_bcount(sizeOfBuffer) const NvU8 *pFingerprintBuffer, __in NvU32 sizeOfBuffer);


////////////////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_SYS_GetPipeServerInformation
//
//! DESCRIPTION: This API retrieves the name of the pipe server that our UMD driver are using to relay information.
//!              Besides the name, the API retrieves the version of the pipeServer which indicates how the messages are
//!              to be parsed. \n
//!              This is an internal API for usage only by our tools.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [out] pipeServerName     - pointer to the unicode string to receive the name of the pipe server
//! \param [out] pipeServerVersion  - Version of the pipeServer.
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!                If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup sysgeneral
////////////////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_GetPipeServerInformation(__out_bcount_full(sizeof(NvAPI_UnicodeString)) NvAPI_UnicodeString pipeServerName, __out NvU32 *pipeServerVersion);


////////////////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_SYS_SetScreenSaverState
//
//! DESCRIPTION: This API notifies the current state of screen saver to RM.
//!              Based on the screen saver state, RM will tune the performance.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in] bRunning  -  (Boolean) When set to true , this indicates that the screen saver is running.
//!
//! \return This API can return any of the error codes enumerated in #NvAPI_Status. 
//!                If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup sysgeneral
////////////////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_SetScreenSaverState(__in NvU8 bRunning);


//! \ingroup sysgeneral
typedef struct _NVAPI_SYS_ACPIID_MAP
{
    NvU32 version;                                       //!< Structure version

    NvU32 count;                                         //!< Count of valid mapping.
    NvU32 acpiIds[NVAPI_MAX_ACPI_IDS];                   //!< Output ACPI IDs
    NvU32 displayIds[NVAPI_MAX_ACPI_IDS];                //!< Output display ID
    
} NVAPI_SYS_ACPIID_MAP_V1;

//! \ingroup sysgeneral
typedef NVAPI_SYS_ACPIID_MAP_V1     NVAPI_SYS_ACPIID_MAP;

//! \ingroup sysgeneral
#define NVAPI_SYS_ACPIID_MAP_VER1   MAKE_NVAPI_VERSION(NVAPI_SYS_ACPIID_MAP_V1,1)

//! \ingroup sysgeneral
#define NVAPI_SYS_ACPIID_MAP_VER    NVAPI_SYS_ACPIID_MAP_VER1


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SYS_GetACPIIdMappings
//
//!   DESCRIPTION: This API returns ACPI IDs mapping to the corresponding display IDs.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in,out] pACPIIdMap            Pointer to NVAPI_SYS_ACPIID_MAP structure. 
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_GetACPIIdMappings( __inout NVAPI_SYS_ACPIID_MAP *pACPIIdMap);


//! \ingroup sysgeneral
typedef struct _NV_VGX_SYS_INFO
{
    NvU32               version;                    //!< Structure version

    NvAPI_LongString    hostDriverVersion;          //!< This field returns the host driver version (NV_VERSION_STRING)
    NvAPI_LongString    hostDriverBranchVersion;    //!< This field returns the host driver version (NV_BUILD_BRANCH_VERSION).
    NvAPI_LongString    hostDriverTitle;            //!< This field returns the host driver title (NV_DISPLAY_DRIVER_TITLE)
    NvAPI_LongString    hostOSVersion;              //!< This field returns the host OS version details
    NvAPI_LongString    pluginDriverTitle;          //!< This field returns the plug-in build title
    NvU32               pluginChangelistNumber;     //!< This field returns the change list value of the plug in 
    NvU32               hostOSChangelistNumber;     //!< This field returns the change list value of the host driver (NV_BUILD_CHANGELIST_NUM)
} NV_VGX_SYS_INFO_V1;

//! \ingroup sysgeneral
typedef NV_VGX_SYS_INFO_V1     NV_VGX_SYS_INFO;

//! \ingroup sysgeneral
#define NV_VGX_SYS_INFO_VER1   MAKE_NVAPI_VERSION(NV_VGX_SYS_INFO_V1,1)

//! \ingroup sysgeneral
#define NV_VGX_SYS_INFO_VER    NV_VGX_SYS_INFO_VER1


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SYS_GetVGXInfo
//
//!   DESCRIPTION: This API returns VGX system information
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [in,out] pVGXSysInfo         Pointer to NV_VGX_SYS_INFO structure. 
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_GetVGXInfo(__inout NV_VGX_SYS_INFO *pVGXSysInfo);


//! \ingroup sysgeneral 
//! @{
typedef enum _NVAPI_SYS_POWER_STATUS 
{ 
    NVAPI_SYS_EXTERNAL_POWER_STATUS_CONNECTED         = 0x00, 
    NVAPI_SYS_EXTERNAL_POWER_STATUS_NOT_CONNECTED     = 0x01,
} NVAPI_SYS_EXTERNAL_POWER_STATUS; 
 
typedef struct _NV_SYS_GPU_POWER_STATUS_V1
{ 
    NvU32                                   version;                     //! < structure version 
    NvU8                                    busNumber;                   //! < PCI bus number 
    NVAPI_SYS_EXTERNAL_POWER_STATUS         externalPowerStatus;         //! < External power Status 
} NV_SYS_GPU_POWER_STATUS_V1; 
typedef NV_SYS_GPU_POWER_STATUS_V1    NV_SYS_GPU_POWER_STATUS;
#define NV_SYS_GPU_POWER_STATUS_VER1  MAKE_NVAPI_VERSION(NV_SYS_GPU_POWER_STATUS_V1,1)
#define NV_SYS_GPU_POWER_STATUS_VER   NV_SYS_GPU_POWER_STATUS_VER1
 
typedef struct _NV_SYS_POWER_STATUS_V1
{ 
    NvU32                                   version;                     //! < structure version 
    NV_SYS_GPU_POWER_STATUS                *pGpuPowerStatus;             //! < power status for GPU list 
    NvU32                                   gpuCount;                    //! < number of GPUs 
} NV_SYS_POWER_STATUS_V1; 
typedef NV_SYS_POWER_STATUS_V1    NV_SYS_POWER_STATUS;
#define NV_SYS_POWER_STATUS_VER1  MAKE_NVAPI_VERSION(NV_SYS_POWER_STATUS_V1,1)
#define NV_SYS_POWER_STATUS_VER   NV_SYS_POWER_STATUS_VER1
//! @}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SYS_GetPowerStatus
//
//!   DESCRIPTION: This API returns the power status for each NVIDIA GPU in the system.
//!                The caller invokes this API with pGpuPowerStatus = NULL: only the gpuCount is returned, so 
//!                the caller can allocate pGpuPowerStatus and invoke the API again to have it filled.
//!
//! SUPPORTED OS:  Windows XP and higher
//!
//!
//! \param [in,out] pPowerStatus         Pointer to NV_SYS_POWER_STATUS structure. 
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_GetPowerStatus(__inout NV_SYS_POWER_STATUS *pPowerStatus); 



//! \ingroup sysgeneral
typedef struct _NV_SYS_JT_CAPS
{
    NvU32 version;                                    //!< Structure version

    NvU32 isJTEnabled:1;                              //!< 0   :JT Disabled (default).
                                                      //!< 1   :JT Enabled.
    NvU32 NVSREnabled:2;                              //!< 0   :NVSR Disabled (default).
                                                      //!< 1   :NVSR Enabled.
                                                      //!< 2~3 :Reserved
    NvU32 PanelPowerRail:2;                           //!< 0   :Panel & Backlight are powered independent of GPU Power, controlled by FB_CLAMP (default when GC6 is enabled).
                                                      //!< 1   :Same as 0 but with separate control independent of FB_CLAMP.
                                                      //!< 2   :Same as 0 but Panel & Backlight can remain powered in S1 & S3 System Suspend states.
    NvU32 SelfRefreshControllerPowerRail:1;           //!< 0 : SRC remains powered while Panel is powered (default)
                                                      //!< 1 : SRC is powered by Suspend power-rail. (required for S3-SR)
    NvU32 FBPowerRail:2;                              //!< 0   :Standard layout (default for GC6).
                                                      //!< 1   :Isolation and Split Power Rails (GC6-SplitRail).
                                                      //!< 2~3 :Reserved
    NvU32 GPUPowerRail:2;                             //!< 0   :Combined power rail for all GPU (default for single GPU).
                                                      //!< 1   :Separate power rail per-GPU (Required for SLI).
                                                      //!< 2~3 :Reserved
    NvU32 GC6ROM: 1;                                  //!< 0   :External SPI ROM (default)
                                                      //!< 1   :Integrated ROM
    NvU32 PanicTrapHandler: 1;                        //!< 0   :Has SMI handler to handle kernel panic exit while within GC6 (default)
                                                      //!< 1   :No SMI Handler
    NvU32 reserved:20;
} NV_SYS_JT_CAPS_V1;

//! \ingroup sysgeneral
typedef NV_SYS_JT_CAPS_V1     NV_SYS_JT_CAPS;

//! \ingroup sysgeneral
#define NV_SYS_JT_CAPS_VER1   MAKE_NVAPI_VERSION(NV_SYS_JT_CAPS_V1, 1)

//! \ingroup sysgeneral
#define NV_SYS_JT_CAPS_VER    NV_SYS_JT_CAPS_VER1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME:   NvAPI_SYS_GetJTCaps
//
//! DESCRIPTION:     This API call is used to query for JT(Jefferson Technology) capability of the system. 
//!                  
//! SUPPORTED OS:  Windows 7 and higher
//!
//!
//! \param [in,out]    *jtCaps   Structure containing the out data. This data is returned from SBIOS
//!                               by making an ACPI call to return the capabilities of the platform and status.
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_GetJTCaps(__inout NV_SYS_JT_CAPS *jtCaps);

#define NV_MAX_HW_CURSOR_BYTES 16384
//! This value should be in sync with NV_ESC_NVAPI_MAX_HW_CURSOR_BYTES.
//! This comment should not go in headers other than private.


//! \ingroup sysgeneral
typedef enum _NV_CURSOR_COLOR_FORMAT_FLAGS
{
    NV_CURSOR_COLOR_FORMAT_NONE          = 0, 
    NV_CURSOR_COLOR_FORMAT_MONOCHROME    = 1,
    NV_CURSOR_COLOR_FORMAT_COLOR         = 2,
    NV_CURSOR_COLOR_FORMAT_MASKED_COLOR  = 3,
} NV_CURSOR_COLOR_FORMAT_FLAGS;

//! \ingroup sysgeneral
typedef struct _NV_BIT_MAP_DATA
{
    NvU64   ulWidth;      
    NvU64   ulHeight;     
    NvU64   ulPitch;      
    NvU64   ulPlanes;     
    NvU64   ulDepth;      
    NvU8    pBits[NV_MAX_HW_CURSOR_BYTES]; 
} NV_BIT_MAP_DATA;

//! \ingroup sysgeneral
typedef struct _NV_CURSOR_INFO
{
    NvU32 version;                              //!< Structure version

    NvU8  isVisible;                            //!< OUT
    NvU32 xHot;                                 //!< OUT
    NvU32 yHot;                                 //!< OUT
    NV_CURSOR_COLOR_FORMAT_FLAGS formatFlag;    //!< OUT
    NV_BIT_MAP_DATA bitMapData;    
} NV_CURSOR_INFO_V1;

//! \ingroup sysgeneral
typedef NV_CURSOR_INFO_V1     NV_CURSOR_INFO;
#define NV_CURSOR_INFO_VER1   MAKE_NVAPI_VERSION(NV_CURSOR_INFO_V1,1)
#define NV_CURSOR_INFO_VER    NV_CURSOR_INFO_VER1

////////////////////////////////////////////////////////////////////////////////////////
// FUNCTION NAME: NvAPI_SYS_GetCursorInfo
//
//! DESCRIPTION: This API gets the cursor bit map information.
//!
//! SUPPORTED OS:  Windows Vista and higher
//!
//!
//! \param [inout] cursorBitMapInfo  -  Structure containing cursor bit map info.
//!
//! \return : This API can return any of the error codes enumerated in #NvAPI_Status. 
//!  If there are return error codes with specific meaning for this API, they are listed below.
//!
//! \ingroup sysgeneral
////////////////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_GetCursorInfo(NV_CURSOR_INFO *cursorBitMapInfo);




typedef enum _NV_SYS__MODULE
{
    NV_SYS_MODULE_Cache = 1,      //!< cache memory controller
    NV_SYS_MODULE_Vcp,            //!< vector co-processor
    NV_SYS_MODULE_Host1x,         //!< host1x clock domain
    NV_SYS_MODULE_Display,        //!< display clock domain for display controller
    NV_SYS_MODULE_Ide,            //!< IDE controller
    NV_SYS_MODULE_3d,             //!< 3D graphics clock domain
    NV_SYS_MODULE_Isp,            //!< image signal processor 
    NV_SYS_MODULE_Usb,            //!< USB2 OTG controller
    NV_SYS_MODULE_2d,             //!< 2D graphics clock domain
    NV_SYS_MODULE_Vi,             //!< video input
    NV_SYS_MODULE_Epp,            //!< encoder pre-processor 
    NV_SYS_MODULE_I2s,            //!< I2S controller
    NV_SYS_MODULE_Pwm,            //!< Pulse Width Modulator controller
    NV_SYS_MODULE_Twc,            //!< Three Wire controller
    NV_SYS_MODULE_Hsmmc,          //!< HSMMC controller
    NV_SYS_MODULE_Sdio,           //!< SDIO controller
    NV_SYS_MODULE_NandFlash,      //!< NAND controller
    NV_SYS_MODULE_NandSpeed,      //!< NAND Speed controller module
    NV_SYS_MODULE_I2c,            //!< I2C controller
    NV_SYS_MODULE_Spdif,          //!< Sony Phillips Digital Interface Format controller
    NV_SYS_MODULE_Gpio,           //!< GPIO controller
    NV_SYS_MODULE_Uart,           //!< UART controller
    NV_SYS_MODULE_Timer,          //!< timer controller
    NV_SYS_MODULE_Rtc,            //!< realtime clock controller
    NV_SYS_MODULE_Ac97,           //!< Audio Codec 97 controller
    NV_SYS_MODULE_Coprocessor,    //!< audio/video processor
    NV_SYS_MODULE_Cpu,            //!< application processor
    NV_SYS_MODULE_Bsev,           //!< 
    NV_SYS_MODULE_Bsea,           //!< Audio Bit Stream Engine
    NV_SYS_MODULE_Vde,            //!< video decoder
    NV_SYS_MODULE_Mpe,            //!< Motion Picture Encoder
    NV_SYS_MODULE_Emc,            //!< external memory
    NV_SYS_MODULE_Sprom,          //!< 
    NV_SYS_MODULE_Tvdac,          //!< TVO controller module - TVDAC clock
    NV_SYS_MODULE_Csi,            //!< Camera Serial Interface
    NV_SYS_MODULE_Hdmi,           //!< HDMI
    NV_SYS_MODULE_MipiBaseband,   //!< MIPI baseband controller 
    NV_SYS_MODULE_Tvo,            //!< 
    NV_SYS_MODULE_Dsi,            //!< serial display
    NV_SYS_MODULE_Dvc,            //!< Dynamic Voltage Controller
    NV_SYS_MODULE_Sbc,            //!< SBC controller module
    NV_SYS_MODULE_Xio,            //!< eXtended I/O controller
    NV_SYS_MODULE_Spi,            //!< SPI controller
    NV_SYS_MODULE_NorFlash,       //!< NOR controller
    NV_SYS_MODULE_Slc,            //!< SLink controller
    NV_SYS_MODULE_Fuse,           //!< FUSE controller
    NV_SYS_MODULE_Pmc,            //!< PMIF controller
    NV_SYS_MODULE_StatMon,        //!< system statistics monitor controller
    NV_SYS_MODULE_Kbc,            //!< keyboard controller
    NV_SYS_MODULE_Vg,             //!< VG graphics controller
    NV_SYS_MODULE_ApbDma,         //!< APB DMA controller
    NV_SYS_MODULE_Mc,             //!< memory controller (internal memory and memory arbitration)
    NV_SYS_MODULE_SpdifIn,        //!< S/PDIF controller module - S/PDIF IN clock
    NV_SYS_MODULE_Vfir,           //!< very fast infra-red controller
    NV_SYS_MODULE_Cve,            //!< TVO controller module - CVE clock
    NV_SYS_MODULE_ViSensor,       //!< VI controller module - VI sensor clock
    NV_SYS_MODULE_SystemReset,    //!< specifies entire system, not a valid clock module
    NV_SYS_MODULE_AvpUcq,         //!< AVP UCQ module
    NV_SYS_MODULE_KFuse,          //!< KFUSE controller
    NV_SYS_MODULE_OneWire,        //!< one-wire interface controller
    NV_SYS_MODULE_SyncNor,        //!< sync NOR controller
    NV_SYS_MODULE_Pcie,           //!< Pci express bridge
    NV_SYS_MODULE_Mselect,        //!< memory configuration
    NV_SYS_MODULE_Sata,           //!< sata
    NV_SYS_MODULE_SataOob,        //!< SATA OOB controller module
    NV_SYS_MODULE_HDA,            //!< HD-Audio
    NV_SYS_MODULE_HDA2CODEC,      //!< HDA to Codec X2 controller module
    NV_SYS_MODULE_Apbif,          //!< Advance Peripherial Bus
    NV_SYS_MODULE_MSENC,          //!< video encoder
    NV_SYS_MODULE_DTV,            //!< dtv
    NV_SYS_MODULE_Tsensor,        //!< tsensor
    NV_SYS_MODULE_Atomics,        //!< atomics
    NV_SYS_MODULE_Actmon,         //!< Activity Monitor
    NV_SYS_MODULE_Se,             //!< security engine 
    NV_SYS_MODULE_DAM,            //!< Digital Audio Mixer
    NV_SYS_MODULE_Audio,          //!< audio
    NV_SYS_MODULE_Num,
    NV_SYS_MODULE_UNDEFINED = 0xffffffff,
} NV_SYS_MODULE;


typedef struct 
{
    NvU32                  version;                     //!<  Structure version
    NV_SYS_MODULE          clkModule;    
    NvU32                  instance;                    //!< Instance of module example 0, 1,2 ...               
    NvU32                  frequency;                   //!< Clock frequency (KHz)
    NvU32                  reserved;   
        
} NV_SYS_CLOCK_INFO_V1;

typedef NV_SYS_CLOCK_INFO_V1    NV_SYS_CLOCK_INFO;

#define NV_SYS_CLOCK_INFO_VER1  MAKE_NVAPI_VERSION(NV_SYS_CLOCK_INFO_V1,1)
#define NV_SYS_CLOCK_INFO_VER   NV_SYS_CLOCK_INFO_VER1

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SYS_GetClockInfo
//
//! This API returns all clocks on ARM platform 
//!
//! HOW TO USE: 1) make a call to get the number of domains(numSupportedDomain)
//!                using NvAPI_SYS_GetAllClocks by passing the clockInfo as NULL
//!                On call success:
//!             2) Allocate memory (numSupportedDomain * sizeof(NV_SYS_CLOCK_INFO)) based on numSupportedDomain then make a call NvAPI_SYS_GetClockInfo to populate clockInfo
//!
//! SUPPORTED OS:  Windows 8 and higher
//!
//! PARAMETERS:     clockInfo(OUT)  - Pointer to an NV_SYS_CLOCK_INFO struct, each entry represents an instance of module and its attributes
//!                 numSupportedDomain(OUT)- Number of all instances of all modules.
//!                 flags (IN) - reserved(not used yet)
//! \since 
//!  Version: 295.00
//!
//! \return        This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
//! \retval        NVAPI_INSUFFICIENT_BUFFER  When the input buffer(clockInfo) is less than the actual number of domains, this API 
//!                                           will return NVAPI_INSUFFICIENT_BUFFER. 
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_GetClockInfo(__out_ecount_full_opt(*numSupportedDomain)NV_SYS_CLOCK_INFO* clockInfo, __inout NvU32* numSupportedDomain, __in NvU32 flags);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SYS_EnableDVFS
//
//! This API enables or disables DVFS. (Dynamic Voltage and Frequency Scaling)
//!
//! SUPPORTED OS:  Windows 8 and higher
//!
//!
//! \param [in] bEnable  -  (Boolean) Enable or disable DVFS.
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_EnableDVFS(__in NvU8 bEnable);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_SYS_SetLowestPowerState
//
//! This API sets the lowest power state
//!
//! SUPPORTED OS:  Windows 8 and higher
//!
//!
//! \param [in] lowestPowerState  -  New lowest power state.
//!
//! \return  This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!          specific meaning for this API, they are listed below.
//!
//! \ingroup sysgeneral
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_SYS_SetLowestPowerState(__in NvU32 lowestPowerState);


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION NAME: NvAPI_Power_Unload
//
//! This function unloads NVAPI library (nvPowerApi.dll)
//! 
//!
//! SUPPORTED OS:  Windows 8 and higher
//!
//!
//! \since 
//!  Version: 295.00
//!
//! \return        This API can return any of the error codes enumerated in #NvAPI_Status. If there are return error codes with 
//!                specific meaning for this API, they are listed below.
//! \ingroup nvapifunctions
///////////////////////////////////////////////////////////////////////////////
NVAPI_INTERFACE NvAPI_Power_Unload();


#if (((defined(WIN32) || defined(_WIN32)) && defined(_MSC_VER) && (_MSC_VER <= 1399) && !defined(NVAPI_INTERNAL)) || defined(NVAPI_DEPRECATED_OLD))
#pragma deprecated( NvAPI_SetView, NvAPI_SetViewEx, NvAPI_GetDisplayDriverVersion, NvAPI_GetDisplayDriverMemoryInfo, NvAPI_GetDriverMemoryInfo, NvAPI_EnumAppStatistics, NvAPI_GetPhysicalGPUsFromLogicalGPUInEngineOrder, NvAPI_GPU_GetAllOutputs, NvAPI_GPU_GetConnectedOutputs, NvAPI_GPU_GetConnectedSLIOutputs, NvAPI_GPU_GetConnectedOutputsEx, NvAPI_GPU_GetConnectedOutputsWithLidState, NvAPI_GPU_GetConnectedSLIOutputsWithLidState, NvAPI_GPU_GetConnectedOutputsWithLidStateEx, NvAPI_GPU_GetConnectedSLIOutputsWithLidStateEx, NvAPI_GPU_GetPstatesInfoEx, NvAPI_GPU_PowerLeakageGetStatus, NvAPI_GPU_QueryActiveApps, NvAPI_GPU_CudaEnumComputeCapableGpus, NvAPI_GetTiming, NvAPI_EnumCustomDisplay, NvAPI_TryCustomDisplay, NvAPI_RevertCustomDisplayTrial, NvAPI_DeleteCustomDisplay, NvAPI_SaveCustomDisplay, NvAPI_GetView, NvAPI_GetViewEx, NvAPI_SetViewExInternal, NvAPI_Diag_DPCD, NvAPI_Diag_DP_TestPattern, NvAPI_Diag_DP_LaneData, NvAPI_DISP_SetHyperSamplingSettings, NvAPI_DISP_GetHyperSamplingSettings, NvAPI_GSync_QueryTopology, NvAPI_GSync_EnableSync, NvAPI_GSync_DisableSync, NvAPI_GSync_SetSyncState, NvAPI_GSync_UpdateSyncPolarity, NvAPI_GSync_UpdateVideoMode, NvAPI_GSync_UpdateSyncInterval, NvAPI_GSync_UpdateSyncSkew, NvAPI_GSync_UpdateSyncStartDelay, NvAPI_GSync_UpdateSyncSource, NvAPI_GSync_QuerySyncParameters, NvAPI_GSync_QuerySyncStatus, NvAPI_GSync_UpdateInterlaceMode, NvAPI_GSync_QueryInterlaceMode, NvAPI_VIO_SetCSC, NvAPI_VIO_GetCSC, NvAPI_VIO_SetGamma, NvAPI_VIO_GetGamma, NvAPI_VIO_SetSyncDelay, NvAPI_VIO_GetSyncDelay, NvAPI_SecureAudio_GetSecureAudioAPIRevision )
#endif

#ifndef __NVAPI_EMPTY_SAL
#ifdef __nvapi_undef__ecount
    #undef __ecount
    #undef __nvapi_undef__ecount
#endif
#ifdef __nvapi_undef__bcount
    #undef __bcount
    #undef __nvapi_undef__bcount
#endif
#ifdef __nvapi_undef__in
    #undef __in
    #undef __nvapi_undef__in
#endif
#ifdef __nvapi_undef__in_ecount
    #undef __in_ecount
    #undef __nvapi_undef__in_ecount
#endif
#ifdef __nvapi_undef__in_bcount
    #undef __in_bcount
    #undef __nvapi_undef__in_bcount
#endif
#ifdef __nvapi_undef__in_z
    #undef __in_z
    #undef __nvapi_undef__in_z
#endif
#ifdef __nvapi_undef__in_ecount_z
    #undef __in_ecount_z
    #undef __nvapi_undef__in_ecount_z
#endif
#ifdef __nvapi_undef__in_bcount_z
    #undef __in_bcount_z
    #undef __nvapi_undef__in_bcount_z
#endif
#ifdef __nvapi_undef__in_nz
    #undef __in_nz
    #undef __nvapi_undef__in_nz
#endif
#ifdef __nvapi_undef__in_ecount_nz
    #undef __in_ecount_nz
    #undef __nvapi_undef__in_ecount_nz
#endif
#ifdef __nvapi_undef__in_bcount_nz
    #undef __in_bcount_nz
    #undef __nvapi_undef__in_bcount_nz
#endif
#ifdef __nvapi_undef__out
    #undef __out
    #undef __nvapi_undef__out
#endif
#ifdef __nvapi_undef__out_ecount
    #undef __out_ecount
    #undef __nvapi_undef__out_ecount
#endif
#ifdef __nvapi_undef__out_bcount
    #undef __out_bcount
    #undef __nvapi_undef__out_bcount
#endif
#ifdef __nvapi_undef__out_ecount_part
    #undef __out_ecount_part
    #undef __nvapi_undef__out_ecount_part
#endif
#ifdef __nvapi_undef__out_bcount_part
    #undef __out_bcount_part
    #undef __nvapi_undef__out_bcount_part
#endif
#ifdef __nvapi_undef__out_ecount_full
    #undef __out_ecount_full
    #undef __nvapi_undef__out_ecount_full
#endif
#ifdef __nvapi_undef__out_bcount_full
    #undef __out_bcount_full
    #undef __nvapi_undef__out_bcount_full
#endif
#ifdef __nvapi_undef__out_z
    #undef __out_z
    #undef __nvapi_undef__out_z
#endif
#ifdef __nvapi_undef__out_z_opt
    #undef __out_z_opt
    #undef __nvapi_undef__out_z_opt
#endif
#ifdef __nvapi_undef__out_ecount_z
    #undef __out_ecount_z
    #undef __nvapi_undef__out_ecount_z
#endif
#ifdef __nvapi_undef__out_bcount_z
    #undef __out_bcount_z
    #undef __nvapi_undef__out_bcount_z
#endif
#ifdef __nvapi_undef__out_ecount_part_z
    #undef __out_ecount_part_z
    #undef __nvapi_undef__out_ecount_part_z
#endif
#ifdef __nvapi_undef__out_bcount_part_z
    #undef __out_bcount_part_z
    #undef __nvapi_undef__out_bcount_part_z
#endif
#ifdef __nvapi_undef__out_ecount_full_z
    #undef __out_ecount_full_z
    #undef __nvapi_undef__out_ecount_full_z
#endif
#ifdef __nvapi_undef__out_bcount_full_z
    #undef __out_bcount_full_z
    #undef __nvapi_undef__out_bcount_full_z
#endif
#ifdef __nvapi_undef__out_nz
    #undef __out_nz
    #undef __nvapi_undef__out_nz
#endif
#ifdef __nvapi_undef__out_nz_opt
    #undef __out_nz_opt
    #undef __nvapi_undef__out_nz_opt
#endif
#ifdef __nvapi_undef__out_ecount_nz
    #undef __out_ecount_nz
    #undef __nvapi_undef__out_ecount_nz
#endif
#ifdef __nvapi_undef__out_bcount_nz
    #undef __out_bcount_nz
    #undef __nvapi_undef__out_bcount_nz
#endif
#ifdef __nvapi_undef__inout
    #undef __inout
    #undef __nvapi_undef__inout
#endif
#ifdef __nvapi_undef__inout_ecount
    #undef __inout_ecount
    #undef __nvapi_undef__inout_ecount
#endif
#ifdef __nvapi_undef__inout_bcount
    #undef __inout_bcount
    #undef __nvapi_undef__inout_bcount
#endif
#ifdef __nvapi_undef__inout_ecount_part
    #undef __inout_ecount_part
    #undef __nvapi_undef__inout_ecount_part
#endif
#ifdef __nvapi_undef__inout_bcount_part
    #undef __inout_bcount_part
    #undef __nvapi_undef__inout_bcount_part
#endif
#ifdef __nvapi_undef__inout_ecount_full
    #undef __inout_ecount_full
    #undef __nvapi_undef__inout_ecount_full
#endif
#ifdef __nvapi_undef__inout_bcount_full
    #undef __inout_bcount_full
    #undef __nvapi_undef__inout_bcount_full
#endif
#ifdef __nvapi_undef__inout_z
    #undef __inout_z
    #undef __nvapi_undef__inout_z
#endif
#ifdef __nvapi_undef__inout_ecount_z
    #undef __inout_ecount_z
    #undef __nvapi_undef__inout_ecount_z
#endif
#ifdef __nvapi_undef__inout_bcount_z
    #undef __inout_bcount_z
    #undef __nvapi_undef__inout_bcount_z
#endif
#ifdef __nvapi_undef__inout_nz
    #undef __inout_nz
    #undef __nvapi_undef__inout_nz
#endif
#ifdef __nvapi_undef__inout_ecount_nz
    #undef __inout_ecount_nz
    #undef __nvapi_undef__inout_ecount_nz
#endif
#ifdef __nvapi_undef__inout_bcount_nz
    #undef __inout_bcount_nz
    #undef __nvapi_undef__inout_bcount_nz
#endif
#ifdef __nvapi_undef__ecount_opt
    #undef __ecount_opt
    #undef __nvapi_undef__ecount_opt
#endif
#ifdef __nvapi_undef__bcount_opt
    #undef __bcount_opt
    #undef __nvapi_undef__bcount_opt
#endif
#ifdef __nvapi_undef__in_opt
    #undef __in_opt
    #undef __nvapi_undef__in_opt
#endif
#ifdef __nvapi_undef__in_ecount_opt
    #undef __in_ecount_opt
    #undef __nvapi_undef__in_ecount_opt
#endif
#ifdef __nvapi_undef__in_bcount_opt
    #undef __in_bcount_opt
    #undef __nvapi_undef__in_bcount_opt
#endif
#ifdef __nvapi_undef__in_z_opt
    #undef __in_z_opt
    #undef __nvapi_undef__in_z_opt
#endif
#ifdef __nvapi_undef__in_ecount_z_opt
    #undef __in_ecount_z_opt
    #undef __nvapi_undef__in_ecount_z_opt
#endif
#ifdef __nvapi_undef__in_bcount_z_opt
    #undef __in_bcount_z_opt
    #undef __nvapi_undef__in_bcount_z_opt
#endif
#ifdef __nvapi_undef__in_nz_opt
    #undef __in_nz_opt
    #undef __nvapi_undef__in_nz_opt
#endif
#ifdef __nvapi_undef__in_ecount_nz_opt
    #undef __in_ecount_nz_opt
    #undef __nvapi_undef__in_ecount_nz_opt
#endif
#ifdef __nvapi_undef__in_bcount_nz_opt
    #undef __in_bcount_nz_opt
    #undef __nvapi_undef__in_bcount_nz_opt
#endif
#ifdef __nvapi_undef__out_opt
    #undef __out_opt
    #undef __nvapi_undef__out_opt
#endif
#ifdef __nvapi_undef__out_ecount_opt
    #undef __out_ecount_opt
    #undef __nvapi_undef__out_ecount_opt
#endif
#ifdef __nvapi_undef__out_bcount_opt
    #undef __out_bcount_opt
    #undef __nvapi_undef__out_bcount_opt
#endif
#ifdef __nvapi_undef__out_ecount_part_opt
    #undef __out_ecount_part_opt
    #undef __nvapi_undef__out_ecount_part_opt
#endif
#ifdef __nvapi_undef__out_bcount_part_opt
    #undef __out_bcount_part_opt
    #undef __nvapi_undef__out_bcount_part_opt
#endif
#ifdef __nvapi_undef__out_ecount_full_opt
    #undef __out_ecount_full_opt
    #undef __nvapi_undef__out_ecount_full_opt
#endif
#ifdef __nvapi_undef__out_bcount_full_opt
    #undef __out_bcount_full_opt
    #undef __nvapi_undef__out_bcount_full_opt
#endif
#ifdef __nvapi_undef__out_ecount_z_opt
    #undef __out_ecount_z_opt
    #undef __nvapi_undef__out_ecount_z_opt
#endif
#ifdef __nvapi_undef__out_bcount_z_opt
    #undef __out_bcount_z_opt
    #undef __nvapi_undef__out_bcount_z_opt
#endif
#ifdef __nvapi_undef__out_ecount_part_z_opt
    #undef __out_ecount_part_z_opt
    #undef __nvapi_undef__out_ecount_part_z_opt
#endif
#ifdef __nvapi_undef__out_bcount_part_z_opt
    #undef __out_bcount_part_z_opt
    #undef __nvapi_undef__out_bcount_part_z_opt
#endif
#ifdef __nvapi_undef__out_ecount_full_z_opt
    #undef __out_ecount_full_z_opt
    #undef __nvapi_undef__out_ecount_full_z_opt
#endif
#ifdef __nvapi_undef__out_bcount_full_z_opt
    #undef __out_bcount_full_z_opt
    #undef __nvapi_undef__out_bcount_full_z_opt
#endif
#ifdef __nvapi_undef__out_ecount_nz_opt
    #undef __out_ecount_nz_opt
    #undef __nvapi_undef__out_ecount_nz_opt
#endif
#ifdef __nvapi_undef__out_bcount_nz_opt
    #undef __out_bcount_nz_opt
    #undef __nvapi_undef__out_bcount_nz_opt
#endif
#ifdef __nvapi_undef__inout_opt
    #undef __inout_opt
    #undef __nvapi_undef__inout_opt
#endif
#ifdef __nvapi_undef__inout_ecount_opt
    #undef __inout_ecount_opt
    #undef __nvapi_undef__inout_ecount_opt
#endif
#ifdef __nvapi_undef__inout_bcount_opt
    #undef __inout_bcount_opt
    #undef __nvapi_undef__inout_bcount_opt
#endif
#ifdef __nvapi_undef__inout_ecount_part_opt
    #undef __inout_ecount_part_opt
    #undef __nvapi_undef__inout_ecount_part_opt
#endif
#ifdef __nvapi_undef__inout_bcount_part_opt
    #undef __inout_bcount_part_opt
    #undef __nvapi_undef__inout_bcount_part_opt
#endif
#ifdef __nvapi_undef__inout_ecount_full_opt
    #undef __inout_ecount_full_opt
    #undef __nvapi_undef__inout_ecount_full_opt
#endif
#ifdef __nvapi_undef__inout_bcount_full_opt
    #undef __inout_bcount_full_opt
    #undef __nvapi_undef__inout_bcount_full_opt
#endif
#ifdef __nvapi_undef__inout_z_opt
    #undef __inout_z_opt
    #undef __nvapi_undef__inout_z_opt
#endif
#ifdef __nvapi_undef__inout_ecount_z_opt
    #undef __inout_ecount_z_opt
    #undef __nvapi_undef__inout_ecount_z_opt
#endif
#ifdef __nvapi_undef__inout_ecount_z_opt
    #undef __inout_ecount_z_opt
    #undef __nvapi_undef__inout_ecount_z_opt
#endif
#ifdef __nvapi_undef__inout_bcount_z_opt
    #undef __inout_bcount_z_opt
    #undef __nvapi_undef__inout_bcount_z_opt
#endif
#ifdef __nvapi_undef__inout_nz_opt
    #undef __inout_nz_opt
    #undef __nvapi_undef__inout_nz_opt
#endif
#ifdef __nvapi_undef__inout_ecount_nz_opt
    #undef __inout_ecount_nz_opt
    #undef __nvapi_undef__inout_ecount_nz_opt
#endif
#ifdef __nvapi_undef__inout_bcount_nz_opt
    #undef __inout_bcount_nz_opt
    #undef __nvapi_undef__inout_bcount_nz_opt
#endif
#ifdef __nvapi_undef__deref_ecount
    #undef __deref_ecount
    #undef __nvapi_undef__deref_ecount
#endif
#ifdef __nvapi_undef__deref_bcount
    #undef __deref_bcount
    #undef __nvapi_undef__deref_bcount
#endif
#ifdef __nvapi_undef__deref_out
    #undef __deref_out
    #undef __nvapi_undef__deref_out
#endif
#ifdef __nvapi_undef__deref_out_ecount
    #undef __deref_out_ecount
    #undef __nvapi_undef__deref_out_ecount
#endif
#ifdef __nvapi_undef__deref_out_bcount
    #undef __deref_out_bcount
    #undef __nvapi_undef__deref_out_bcount
#endif
#ifdef __nvapi_undef__deref_out_ecount_part
    #undef __deref_out_ecount_part
    #undef __nvapi_undef__deref_out_ecount_part
#endif
#ifdef __nvapi_undef__deref_out_bcount_part
    #undef __deref_out_bcount_part
    #undef __nvapi_undef__deref_out_bcount_part
#endif
#ifdef __nvapi_undef__deref_out_ecount_full
    #undef __deref_out_ecount_full
    #undef __nvapi_undef__deref_out_ecount_full
#endif
#ifdef __nvapi_undef__deref_out_bcount_full
    #undef __deref_out_bcount_full
    #undef __nvapi_undef__deref_out_bcount_full
#endif
#ifdef __nvapi_undef__deref_out_z
    #undef __deref_out_z
    #undef __nvapi_undef__deref_out_z
#endif
#ifdef __nvapi_undef__deref_out_ecount_z
    #undef __deref_out_ecount_z
    #undef __nvapi_undef__deref_out_ecount_z
#endif
#ifdef __nvapi_undef__deref_out_bcount_z
    #undef __deref_out_bcount_z
    #undef __nvapi_undef__deref_out_bcount_z
#endif
#ifdef __nvapi_undef__deref_out_nz
    #undef __deref_out_nz
    #undef __nvapi_undef__deref_out_nz
#endif
#ifdef __nvapi_undef__deref_out_ecount_nz
    #undef __deref_out_ecount_nz
    #undef __nvapi_undef__deref_out_ecount_nz
#endif
#ifdef __nvapi_undef__deref_out_bcount_nz
    #undef __deref_out_bcount_nz
    #undef __nvapi_undef__deref_out_bcount_nz
#endif
#ifdef __nvapi_undef__deref_inout
    #undef __deref_inout
    #undef __nvapi_undef__deref_inout
#endif
#ifdef __nvapi_undef__deref_inout_z
    #undef __deref_inout_z
    #undef __nvapi_undef__deref_inout_z
#endif
#ifdef __nvapi_undef__deref_inout_ecount
    #undef __deref_inout_ecount
    #undef __nvapi_undef__deref_inout_ecount
#endif
#ifdef __nvapi_undef__deref_inout_bcount
    #undef __deref_inout_bcount
    #undef __nvapi_undef__deref_inout_bcount
#endif
#ifdef __nvapi_undef__deref_inout_ecount_part
    #undef __deref_inout_ecount_part
    #undef __nvapi_undef__deref_inout_ecount_part
#endif
#ifdef __nvapi_undef__deref_inout_bcount_part
    #undef __deref_inout_bcount_part
    #undef __nvapi_undef__deref_inout_bcount_part
#endif
#ifdef __nvapi_undef__deref_inout_ecount_full
    #undef __deref_inout_ecount_full
    #undef __nvapi_undef__deref_inout_ecount_full
#endif
#ifdef __nvapi_undef__deref_inout_bcount_full
    #undef __deref_inout_bcount_full
    #undef __nvapi_undef__deref_inout_bcount_full
#endif
#ifdef __nvapi_undef__deref_inout_z
    #undef __deref_inout_z
    #undef __nvapi_undef__deref_inout_z
#endif
#ifdef __nvapi_undef__deref_inout_ecount_z
    #undef __deref_inout_ecount_z
    #undef __nvapi_undef__deref_inout_ecount_z
#endif
#ifdef __nvapi_undef__deref_inout_bcount_z
    #undef __deref_inout_bcount_z
    #undef __nvapi_undef__deref_inout_bcount_z
#endif
#ifdef __nvapi_undef__deref_inout_nz
    #undef __deref_inout_nz
    #undef __nvapi_undef__deref_inout_nz
#endif
#ifdef __nvapi_undef__deref_inout_ecount_nz
    #undef __deref_inout_ecount_nz
    #undef __nvapi_undef__deref_inout_ecount_nz
#endif
#ifdef __nvapi_undef__deref_inout_bcount_nz
    #undef __deref_inout_bcount_nz
    #undef __nvapi_undef__deref_inout_bcount_nz
#endif
#ifdef __nvapi_undef__deref_ecount_opt
    #undef __deref_ecount_opt
    #undef __nvapi_undef__deref_ecount_opt
#endif
#ifdef __nvapi_undef__deref_bcount_opt
    #undef __deref_bcount_opt
    #undef __nvapi_undef__deref_bcount_opt
#endif
#ifdef __nvapi_undef__deref_out_opt
    #undef __deref_out_opt
    #undef __nvapi_undef__deref_out_opt
#endif
#ifdef __nvapi_undef__deref_out_ecount_opt
    #undef __deref_out_ecount_opt
    #undef __nvapi_undef__deref_out_ecount_opt
#endif
#ifdef __nvapi_undef__deref_out_bcount_opt
    #undef __deref_out_bcount_opt
    #undef __nvapi_undef__deref_out_bcount_opt
#endif
#ifdef __nvapi_undef__deref_out_ecount_part_opt
    #undef __deref_out_ecount_part_opt
    #undef __nvapi_undef__deref_out_ecount_part_opt
#endif
#ifdef __nvapi_undef__deref_out_bcount_part_opt
    #undef __deref_out_bcount_part_opt
    #undef __nvapi_undef__deref_out_bcount_part_opt
#endif
#ifdef __nvapi_undef__deref_out_ecount_full_opt
    #undef __deref_out_ecount_full_opt
    #undef __nvapi_undef__deref_out_ecount_full_opt
#endif
#ifdef __nvapi_undef__deref_out_bcount_full_opt
    #undef __deref_out_bcount_full_opt
    #undef __nvapi_undef__deref_out_bcount_full_opt
#endif
#ifdef __nvapi_undef__deref_out_z_opt
    #undef __deref_out_z_opt
    #undef __nvapi_undef__deref_out_z_opt
#endif
#ifdef __nvapi_undef__deref_out_ecount_z_opt
    #undef __deref_out_ecount_z_opt
    #undef __nvapi_undef__deref_out_ecount_z_opt
#endif
#ifdef __nvapi_undef__deref_out_bcount_z_opt
    #undef __deref_out_bcount_z_opt
    #undef __nvapi_undef__deref_out_bcount_z_opt
#endif
#ifdef __nvapi_undef__deref_out_nz_opt
    #undef __deref_out_nz_opt
    #undef __nvapi_undef__deref_out_nz_opt
#endif
#ifdef __nvapi_undef__deref_out_ecount_nz_opt
    #undef __deref_out_ecount_nz_opt
    #undef __nvapi_undef__deref_out_ecount_nz_opt
#endif
#ifdef __nvapi_undef__deref_out_bcount_nz_opt
    #undef __deref_out_bcount_nz_opt
    #undef __nvapi_undef__deref_out_bcount_nz_opt
#endif
#ifdef __nvapi_undef__deref_inout_opt
    #undef __deref_inout_opt
    #undef __nvapi_undef__deref_inout_opt
#endif
#ifdef __nvapi_undef__deref_inout_ecount_opt
    #undef __deref_inout_ecount_opt
    #undef __nvapi_undef__deref_inout_ecount_opt
#endif
#ifdef __nvapi_undef__deref_inout_bcount_opt
    #undef __deref_inout_bcount_opt
    #undef __nvapi_undef__deref_inout_bcount_opt
#endif
#ifdef __nvapi_undef__deref_inout_ecount_part_opt
    #undef __deref_inout_ecount_part_opt
    #undef __nvapi_undef__deref_inout_ecount_part_opt
#endif
#ifdef __nvapi_undef__deref_inout_bcount_part_opt
    #undef __deref_inout_bcount_part_opt
    #undef __nvapi_undef__deref_inout_bcount_part_opt
#endif
#ifdef __nvapi_undef__deref_inout_ecount_full_opt
    #undef __deref_inout_ecount_full_opt
    #undef __nvapi_undef__deref_inout_ecount_full_opt
#endif
#ifdef __nvapi_undef__deref_inout_bcount_full_opt
    #undef __deref_inout_bcount_full_opt
    #undef __nvapi_undef__deref_inout_bcount_full_opt
#endif
#ifdef __nvapi_undef__deref_inout_z_opt
    #undef __deref_inout_z_opt
    #undef __nvapi_undef__deref_inout_z_opt
#endif
#ifdef __nvapi_undef__deref_inout_ecount_z_opt
    #undef __deref_inout_ecount_z_opt
    #undef __nvapi_undef__deref_inout_ecount_z_opt
#endif
#ifdef __nvapi_undef__deref_inout_bcount_z_opt
    #undef __deref_inout_bcount_z_opt
    #undef __nvapi_undef__deref_inout_bcount_z_opt
#endif
#ifdef __nvapi_undef__deref_inout_nz_opt
    #undef __deref_inout_nz_opt
    #undef __nvapi_undef__deref_inout_nz_opt
#endif
#ifdef __nvapi_undef__deref_inout_ecount_nz_opt
    #undef __deref_inout_ecount_nz_opt
    #undef __nvapi_undef__deref_inout_ecount_nz_opt
#endif
#ifdef __nvapi_undef__deref_inout_bcount_nz_opt
    #undef __deref_inout_bcount_nz_opt
    #undef __nvapi_undef__deref_inout_bcount_nz_opt
#endif
#ifdef __nvapi_undef__deref_opt_ecount
    #undef __deref_opt_ecount
    #undef __nvapi_undef__deref_opt_ecount
#endif
#ifdef __nvapi_undef__deref_opt_bcount
    #undef __deref_opt_bcount
    #undef __nvapi_undef__deref_opt_bcount
#endif
#ifdef __nvapi_undef__deref_opt_out
    #undef __deref_opt_out
    #undef __nvapi_undef__deref_opt_out
#endif
#ifdef __nvapi_undef__deref_opt_out_z
    #undef __deref_opt_out_z
    #undef __nvapi_undef__deref_opt_out_z
#endif
#ifdef __nvapi_undef__deref_opt_out_ecount
    #undef __deref_opt_out_ecount
    #undef __nvapi_undef__deref_opt_out_ecount
#endif
#ifdef __nvapi_undef__deref_opt_out_bcount
    #undef __deref_opt_out_bcount
    #undef __nvapi_undef__deref_opt_out_bcount
#endif
#ifdef __nvapi_undef__deref_opt_out_ecount_part
    #undef __deref_opt_out_ecount_part
    #undef __nvapi_undef__deref_opt_out_ecount_part
#endif
#ifdef __nvapi_undef__deref_opt_out_bcount_part
    #undef __deref_opt_out_bcount_part
    #undef __nvapi_undef__deref_opt_out_bcount_part
#endif
#ifdef __nvapi_undef__deref_opt_out_ecount_full
    #undef __deref_opt_out_ecount_full
    #undef __nvapi_undef__deref_opt_out_ecount_full
#endif
#ifdef __nvapi_undef__deref_opt_out_bcount_full
    #undef __deref_opt_out_bcount_full
    #undef __nvapi_undef__deref_opt_out_bcount_full
#endif
#ifdef __nvapi_undef__deref_opt_inout
    #undef __deref_opt_inout
    #undef __nvapi_undef__deref_opt_inout
#endif
#ifdef __nvapi_undef__deref_opt_inout_ecount
    #undef __deref_opt_inout_ecount
    #undef __nvapi_undef__deref_opt_inout_ecount
#endif
#ifdef __nvapi_undef__deref_opt_inout_bcount
    #undef __deref_opt_inout_bcount
    #undef __nvapi_undef__deref_opt_inout_bcount
#endif
#ifdef __nvapi_undef__deref_opt_inout_ecount_part
    #undef __deref_opt_inout_ecount_part
    #undef __nvapi_undef__deref_opt_inout_ecount_part
#endif
#ifdef __nvapi_undef__deref_opt_inout_bcount_part
    #undef __deref_opt_inout_bcount_part
    #undef __nvapi_undef__deref_opt_inout_bcount_part
#endif
#ifdef __nvapi_undef__deref_opt_inout_ecount_full
    #undef __deref_opt_inout_ecount_full
    #undef __nvapi_undef__deref_opt_inout_ecount_full
#endif
#ifdef __nvapi_undef__deref_opt_inout_bcount_full
    #undef __deref_opt_inout_bcount_full
    #undef __nvapi_undef__deref_opt_inout_bcount_full
#endif
#ifdef __nvapi_undef__deref_opt_inout_z
    #undef __deref_opt_inout_z
    #undef __nvapi_undef__deref_opt_inout_z
#endif
#ifdef __nvapi_undef__deref_opt_inout_ecount_z
    #undef __deref_opt_inout_ecount_z
    #undef __nvapi_undef__deref_opt_inout_ecount_z
#endif
#ifdef __nvapi_undef__deref_opt_inout_bcount_z
    #undef __deref_opt_inout_bcount_z
    #undef __nvapi_undef__deref_opt_inout_bcount_z
#endif
#ifdef __nvapi_undef__deref_opt_inout_nz
    #undef __deref_opt_inout_nz
    #undef __nvapi_undef__deref_opt_inout_nz
#endif
#ifdef __nvapi_undef__deref_opt_inout_ecount_nz
    #undef __deref_opt_inout_ecount_nz
    #undef __nvapi_undef__deref_opt_inout_ecount_nz
#endif
#ifdef __nvapi_undef__deref_opt_inout_bcount_nz
    #undef __deref_opt_inout_bcount_nz
    #undef __nvapi_undef__deref_opt_inout_bcount_nz
#endif
#ifdef __nvapi_undef__deref_opt_ecount_opt
    #undef __deref_opt_ecount_opt
    #undef __nvapi_undef__deref_opt_ecount_opt
#endif
#ifdef __nvapi_undef__deref_opt_bcount_opt
    #undef __deref_opt_bcount_opt
    #undef __nvapi_undef__deref_opt_bcount_opt
#endif
#ifdef __nvapi_undef__deref_opt_out_opt
    #undef __deref_opt_out_opt
    #undef __nvapi_undef__deref_opt_out_opt
#endif
#ifdef __nvapi_undef__deref_opt_out_ecount_opt
    #undef __deref_opt_out_ecount_opt
    #undef __nvapi_undef__deref_opt_out_ecount_opt
#endif
#ifdef __nvapi_undef__deref_opt_out_bcount_opt
    #undef __deref_opt_out_bcount_opt
    #undef __nvapi_undef__deref_opt_out_bcount_opt
#endif
#ifdef __nvapi_undef__deref_opt_out_ecount_part_opt
    #undef __deref_opt_out_ecount_part_opt
    #undef __nvapi_undef__deref_opt_out_ecount_part_opt
#endif
#ifdef __nvapi_undef__deref_opt_out_bcount_part_opt
    #undef __deref_opt_out_bcount_part_opt
    #undef __nvapi_undef__deref_opt_out_bcount_part_opt
#endif
#ifdef __nvapi_undef__deref_opt_out_ecount_full_opt
    #undef __deref_opt_out_ecount_full_opt
    #undef __nvapi_undef__deref_opt_out_ecount_full_opt
#endif
#ifdef __nvapi_undef__deref_opt_out_bcount_full_opt
    #undef __deref_opt_out_bcount_full_opt
    #undef __nvapi_undef__deref_opt_out_bcount_full_opt
#endif
#ifdef __nvapi_undef__deref_opt_out_z_opt
    #undef __deref_opt_out_z_opt
    #undef __nvapi_undef__deref_opt_out_z_opt
#endif
#ifdef __nvapi_undef__deref_opt_out_ecount_z_opt
    #undef __deref_opt_out_ecount_z_opt
    #undef __nvapi_undef__deref_opt_out_ecount_z_opt
#endif
#ifdef __nvapi_undef__deref_opt_out_bcount_z_opt
    #undef __deref_opt_out_bcount_z_opt
    #undef __nvapi_undef__deref_opt_out_bcount_z_opt
#endif
#ifdef __nvapi_undef__deref_opt_out_nz_opt
    #undef __deref_opt_out_nz_opt
    #undef __nvapi_undef__deref_opt_out_nz_opt
#endif
#ifdef __nvapi_undef__deref_opt_out_ecount_nz_opt
    #undef __deref_opt_out_ecount_nz_opt
    #undef __nvapi_undef__deref_opt_out_ecount_nz_opt
#endif
#ifdef __nvapi_undef__deref_opt_out_bcount_nz_opt
    #undef __deref_opt_out_bcount_nz_opt
    #undef __nvapi_undef__deref_opt_out_bcount_nz_opt
#endif
#ifdef __nvapi_undef__deref_opt_inout_opt
    #undef __deref_opt_inout_opt
    #undef __nvapi_undef__deref_opt_inout_opt
#endif
#ifdef __nvapi_undef__deref_opt_inout_ecount_opt
    #undef __deref_opt_inout_ecount_opt
    #undef __nvapi_undef__deref_opt_inout_ecount_opt
#endif
#ifdef __nvapi_undef__deref_opt_inout_bcount_opt
    #undef __deref_opt_inout_bcount_opt
    #undef __nvapi_undef__deref_opt_inout_bcount_opt
#endif
#ifdef __nvapi_undef__deref_opt_inout_ecount_part_opt
    #undef __deref_opt_inout_ecount_part_opt
    #undef __nvapi_undef__deref_opt_inout_ecount_part_opt
#endif
#ifdef __nvapi_undef__deref_opt_inout_bcount_part_opt
    #undef __deref_opt_inout_bcount_part_opt
    #undef __nvapi_undef__deref_opt_inout_bcount_part_opt
#endif
#ifdef __nvapi_undef__deref_opt_inout_ecount_full_opt
    #undef __deref_opt_inout_ecount_full_opt
    #undef __nvapi_undef__deref_opt_inout_ecount_full_opt
#endif
#ifdef __nvapi_undef__deref_opt_inout_bcount_full_opt
    #undef __deref_opt_inout_bcount_full_opt
    #undef __nvapi_undef__deref_opt_inout_bcount_full_opt
#endif
#ifdef __nvapi_undef__deref_opt_inout_z_opt
    #undef __deref_opt_inout_z_opt
    #undef __nvapi_undef__deref_opt_inout_z_opt
#endif
#ifdef __nvapi_undef__deref_opt_inout_ecount_z_opt
    #undef __deref_opt_inout_ecount_z_opt
    #undef __nvapi_undef__deref_opt_inout_ecount_z_opt
#endif
#ifdef __nvapi_undef__deref_opt_inout_bcount_z_opt
    #undef __deref_opt_inout_bcount_z_opt
    #undef __nvapi_undef__deref_opt_inout_bcount_z_opt
#endif
#ifdef __nvapi_undef__deref_opt_inout_nz_opt
    #undef __deref_opt_inout_nz_opt
    #undef __nvapi_undef__deref_opt_inout_nz_opt
#endif
#ifdef __nvapi_undef__deref_opt_inout_ecount_nz_opt
    #undef __deref_opt_inout_ecount_nz_opt
    #undef __nvapi_undef__deref_opt_inout_ecount_nz_opt
#endif
#ifdef __nvapi_undef__deref_opt_inout_bcount_nz_opt
    #undef __deref_opt_inout_bcount_nz_opt
    #undef __nvapi_undef__deref_opt_inout_bcount_nz_opt
#endif
#ifdef __nvapi_success
    #undef __success
    #undef __nvapi_success
#endif
#ifdef __nvapi__Ret_notnull_
    #undef __nvapi__Ret_notnull_
    #undef _Ret_notnull_
#endif
#ifdef __nvapi__Post_writable_byte_size_
    #undef __nvapi__Post_writable_byte_size_
    #undef _Post_writable_byte_size_
#endif
#ifdef __nvapi_Outptr_ 
    #undef __nvapi_Outptr_ 
    #undef _Outptr_ 
#endif

#endif // __NVAPI_EMPTY_SAL

#ifdef __cplusplus
}; //extern "C" {

#endif

#pragma pack(pop)

#endif // _NVAPI_H
